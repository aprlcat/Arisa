[
  {
    "url": "https://www.felixcloutier.com/x86/vgetexpsd",
    "category": "Core Instructions",
    "instructionName": "VGETEXPSD\n\t\t— Convert Exponents of Scalar Double Precision Floating-Point Value to DoublePrecision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert the biased exponent (bits 62:52) of the low double precision floating-point value in xmm3/m64 to a double precision floating-point value representing unbiased integer exponent. Stores the result to the low 64-bit of xmm1 under the writemask k1 and merge with the other elements of xmm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 43 /r VGETEXPSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtsh2ss",
    "category": "Core Instructions",
    "instructionName": "VCVTSH2SS\n\t\t— Convert Low FP16 Value to FP32 Value",
    "detailsTable": [
      {
        "Description": "Convert the low FP16 element in xmm3/m16 to an FP32 value and store in the low element of xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.NP.MAP6.W0 13 /r VCVTSH2SS xmm1{k1}{z}, xmm2, xmm3/m16 {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtpd2ph",
    "category": "Core Instructions",
    "instructionName": "VCVTPD2PH\n\t\t— Convert Packed Double Precision FP Values to Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert two packed double precision floating-point values in xmm2/m128/m64bcst to two packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.W1 5A /r VCVTPD2PH xmm1{k1}{z}, xmm2/m128/m64bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert four packed double precision floating-point values in ymm2/m256/m64bcst to four packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP5.W1 5A /r VCVTPD2PH xmm1{k1}{z}, ymm2/m256/m64bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed double precision floating-point values in zmm2/m512/m64bcst to eight packed FP16 values, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP5.W1 5A /r VCVTPD2PH xmm1{k1}{z}, zmm2/m512/m64bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xlat:xlatb",
    "category": "Core Instructions",
    "instructionName": "XLAT/XLATB\n\t\t— Table Look-up Translation",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set AL to memory byte DS:[(E)BX + unsigned AL].",
        "Instruction": "XLAT m8",
        "Op/En": "ZO",
        "Opcode": "D7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set AL to memory byte DS:[(E)BX + unsigned AL].",
        "Instruction": "XLATB",
        "Op/En": "ZO",
        "Opcode": "D7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set AL to memory byte [RBX + unsigned AL].",
        "Instruction": "XLATB",
        "Op/En": "ZO",
        "Opcode": "REX.W + D7"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer. The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.)\nAt the assembly-code level, two forms of this instruction are allowed: the “explicit-operand” form and the “no-operand” form. The explicit-operand form (specified with the XLAT mnemonic) allows the base address of the table to be specified explicitly with a symbol. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the symbol does not have to specify the correct base address. The base address is always specified by the DS:(E)BX registers, which must be loaded correctly before the XLAT instruction is executed.\nThe no-operands form (XLATB) provides a “short form” of the XLAT instructions. Here also the processor assumes that the DS:(E)BX registers contain the base address of the table.\nIn 64-bit mode, operation is similar to that in legacy or compatibility mode. AL is used to specify the table index (the operand size is fixed at 8 bits). RBX, however, is used to specify the table’s base address. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF AddressSize = 16\n    THEN\n        AL := (DS:BX + ZeroExtend(AL));\n    ELSE IF (AddressSize = 32)\n        AL := (DS:EBX + ZeroExtend(AL)); FI;\n    ELSE (AddressSize = 64)\n        AL := (RBX + ZeroExtend(AL));\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rcpss",
    "category": "Core Instructions",
    "instructionName": "RCPSS\n\t\t— Compute Reciprocal of Scalar Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Computes the approximate reciprocal of the scalar single precision floating-point value in xmm2/m32 and stores the result in xmm1.",
        "Op/En": "RM",
        "Opcode*/Instruction": "F3 0F 53 /r RCPSS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes the approximate reciprocal of the scalar single precision floating-point value in xmm3/m32 and stores the result in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].",
        "Op/En": "RVM",
        "Opcode*/Instruction": "VEX.LIG.F3.0F.WIG 53 /r VRCPSS xmm1, xmm2, xmm3/m32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Computes of an approximate reciprocal of the low single precision floating-point value in the source operand (second operand) and stores the single precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a scalar single precision floating-point operation.\nThe relative error for this approximation is:\n|Relative Error| ≤ 1.5 ∗ 2−12\nThe RCPSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results (see Section 4.9.1.5, “Numeric Underflow Exception (#U)” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1) are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B∗2125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
    "operationText": "DEST[31:0] := APPROXIMATE(1/SRC[31:0])\nDEST[MAXVL-1:32] (Unmodified)\nDEST[31:0] := APPROXIMATE(1/SRC2[31:0])\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-22, “Type 5 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vexpandpd",
    "category": "Core Instructions",
    "instructionName": "VEXPANDPD\n\t\t— Load Sparse Packed Double Precision Floating-Point Values From Dense Memory",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Expand packed double precision floating-point values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 88 /r VEXPANDPD xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Expand packed double precision floating-point values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 88 /r VEXPANDPD ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Expand packed double precision floating-point values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 88 /r VEXPANDPD zmm1 {k1}{z}, zmm2/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpdpbusds",
    "category": "Core Instructions",
    "instructionName": "VPDPBUSDS\n\t\t— Multiply and Add Unsigned and Signed Bytes With Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX-VNNI",
        "Description": "Multiply groups of 4 pairs signed bytes in xmm3/m128 with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result, with signed saturation in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 51 /r VPDPBUSDS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX-VNNI",
        "Description": "Multiply groups of 4 pairs signed bytes in ymm3/m256 with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result, with signed saturation in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 51 /r VPDPBUSDS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI AVX512VL",
        "Description": "Multiply groups of 4 pairs signed bytes in xmm3/m128/m32bcst with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result, with signed saturation in xmm1, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 51 /r VPDPBUSDS xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI AVX512VL",
        "Description": "Multiply groups of 4 pairs signed bytes in ymm3/m256/m32bcst with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result, with signed saturation in ymm1, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 51 /r VPDPBUSDS ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI",
        "Description": "Multiply groups of 4 pairs signed bytes in zmm3/m512/m32bcst with corresponding unsigned bytes of zmm2, summing those products and adding them to doubleword result, with signed saturation in zmm1, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 51 /r VPDPBUSDS zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/comiss",
    "category": "Core Instructions",
    "instructionName": "COMISS\n\t\t— Compare Scalar Ordered Single Precision Floating-Point Values and Set EFLAGS",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 2F /r COMISS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.0F.WIG 2F /r VCOMISS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.0F.W0 2F /r VCOMISS xmm1, xmm2/m32{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the single precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.\nThe COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid operation exception only if a source operand is an SNaN.\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "RESULT := OrderedCompare(DEST[31:0] <> SRC[31:0]) {\n(* Set EFLAGS *) CASE (RESULT) OF\n    UNORDERED: ZF,PF,CF := 111;\n    GREATER_THAN: ZF,PF,CF := 000;\n    LESS_THAN: ZF,PF,CF := 001;\n    EQUAL: ZF,PF,CF := 100;\nESAC;\nOF, AF, SF := 0; }",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid (if SNaN or QNaN operands), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pblendw",
    "category": "Core Instructions",
    "instructionName": "PBLENDW\n\t\t— Blend Packed Words",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A 0E /r ib PBLENDW xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 0E /r ib VPBLENDW xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.256.66.0F3A.WIG 0E /r ib VPBLENDW ymm1, ymm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Words from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is “1\", then the word is copied, else the word element in the destination operand is unchanged.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "IF (imm8[0] = 1) THEN DEST[15:0] := SRC[15:0]\nELSE DEST[15:0] := DEST[15:0]\nIF (imm8[1] = 1) THEN DEST[31:16] := SRC[31:16]\nELSE DEST[31:16] := DEST[31:16]\nIF (imm8[2] = 1) THEN DEST[47:32] := SRC[47:32]\nELSE DEST[47:32] := DEST[47:32]\nIF (imm8[3] = 1) THEN DEST[63:48] := SRC[63:48]\nELSE DEST[63:48] := DEST[63:48]\nIF (imm8[4] = 1) THEN DEST[79:64] := SRC[79:64]\nELSE DEST[79:64] := DEST[79:64]\nIF (imm8[5] = 1) THEN DEST[95:80] := SRC[95:80]\nELSE DEST[95:80] := DEST[95:80]\nIF (imm8[6] = 1) THEN DEST[111:96] := SRC[111:96]\nELSE DEST[111:96] := DEST[111:96]\nIF (imm8[7] = 1) THEN DEST[127:112] := SRC[127:112]\nELSE DEST[127:112] := DEST[127:112]\nIF (imm8[0] = 1) THEN DEST[15:0] := SRC2[15:0]\nELSE DEST[15:0] := SRC1[15:0]\nIF (imm8[1] = 1) THEN DEST[31:16] := SRC2[31:16]\nELSE DEST[31:16] := SRC1[31:16]\nIF (imm8[2] = 1) THEN DEST[47:32] := SRC2[47:32]\nELSE DEST[47:32] := SRC1[47:32]\nIF (imm8[3] = 1) THEN DEST[63:48] := SRC2[63:48]\nELSE DEST[63:48] := SRC1[63:48]\nIF (imm8[4] = 1) THEN DEST[79:64] := SRC2[79:64]\nELSE DEST[79:64] := SRC1[79:64]\nIF (imm8[5] = 1) THEN DEST[95:80] := SRC2[95:80]\nELSE DEST[95:80] := SRC1[95:80]\nIF (imm8[6] = 1) THEN DEST[111:96] := SRC2[111:96]\nELSE DEST[111:96] := SRC1[111:96]\nIF (imm8[7] = 1) THEN DEST[127:112] := SRC2[127:112]\nELSE DEST[127:112] := SRC1[127:112]\nDEST[MAXVL-1:128] := 0\nIF (imm8[0] == 1) THEN DEST[15:0] := SRC2[15:0]\nELSE DEST[15:0] := SRC1[15:0]\nIF (imm8[1] == 1) THEN DEST[31:16] := SRC2[31:16]\nELSE DEST[31:16] := SRC1[31:16]\nIF (imm8[2] == 1) THEN DEST[47:32] := SRC2[47:32]\nELSE DEST[47:32] := SRC1[47:32]\nIF (imm8[3] == 1) THEN DEST[63:48] := SRC2[63:48]\nELSE DEST[63:48] := SRC1[63:48]\nIF (imm8[4] == 1) THEN DEST[79:64] := SRC2[79:64]\nELSE DEST[79:64] := SRC1[79:64]\nIF (imm8[5] == 1) THEN DEST[95:80] := SRC2[95:80]\nELSE DEST[95:80] := SRC1[95:80]\nIF (imm8[6] == 1) THEN DEST[111:96] := SRC2[111:96]\nELSE DEST[111:96] := SRC1[111:96]\nIF (imm8[7] == 1) THEN DEST[127:112]\nELSE DEST[127:112] := SRC1[127:112]\nIF (imm8[0] == 1) THEN DEST[143:128]\nELSE DEST[143:128] := SRC1[143:128]\nIF (imm8[1] == 1) THEN DEST[159:144]\nELSE DEST[159:144] := SRC1[159:144]\nIF (imm8[2] == 1) THEN DEST[175:160]\nELSE DEST[175:160] := SRC1[175:160]\nIF (imm8[3] == 1) THEN DEST[191:176]\nELSE DEST[191:176] := SRC1[191:176]\nIF (imm8[4] == 1) THEN DEST[207:192]\nELSE DEST[207:192] := SRC1[207:192]\nIF (imm8[5] == 1) THEN DEST[223:208]\nELSE DEST[223:208] := SRC1[223:208]\nIF (imm8[6] == 1) THEN DEST[239:224]\nELSE DEST[239:224] := SRC1[239:224]\nIF (imm8[7] == 1) THEN DEST[255:240]\nELSE DEST[255:240] := SRC1[255:240]",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/bound",
    "category": "Core Instructions",
    "instructionName": "BOUND\n\t\t— Check Array Index Against Bounds",
    "detailsTable": [
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Check if r16 (array index) is within bounds specified by m16&16.",
        "Instruction": "BOUND r16, m16&16",
        "Op/En": "RM",
        "Opcode": "62 /r"
      },
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Check if r32 (array index) is within bounds specified by m32&32.",
        "Instruction": "BOUND r32, m32&32",
        "Op/En": "RM",
        "Opcode": "62 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "BOUND determines if the first operand (array index) is within the bounds of an array specified the second operand (bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory location that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index is not within bounds, a BOUND range exceeded exception (#BR) is signaled. When this exception is generated, the saved return instruction pointer points to the BOUND instruction.\nThe bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of the array. Because the address of the array already will be present in a register, this practice avoids extra bus cycles to obtain the effective address of the array bounds.\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.",
    "operationText": "IF 64bit Mode\n    THEN\n        #UD;\n    ELSE\n        IF (ArrayIndex < LowerBound OR ArrayIndex > UpperBound) THEN\n        (* Below lower bound or above upper bound *)\n            IF <equation for PL enabled> THEN BNDSTATUS := 0\n            #BR;\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_2: If second operand is not a memory location.; column_1: #UD; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If second operand is not a memory location.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #GP; column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS;"
      ],
      "virtual8086Mode": [
        "column_1: #UD; column_2: If second operand is not a memory location.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttph2dq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPH2DQ\n\t\t— Convert with Truncation Packed FP16 Values to Signed Doubleword Integers",
    "detailsTable": [
      {
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four signed doubleword integers, and store the result in xmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F3.MAP5.W0 5B /r VCVTTPH2DQ xmm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed doubleword integers, and store the result in ymm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F3.MAP5.W0 5B /r VCVTTPH2DQ ymm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen signed doubleword integers, and store the result in zmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F3.MAP5.W0 5B /r VCVTTPH2DQ zmm1{k1}{z}, ymm2/m256/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vsqrtsh",
    "category": "Core Instructions",
    "instructionName": "VSQRTSH\n\t\t— Compute Square Root of Scalar FP16 Value",
    "detailsTable": [
      {
        "Description": "Compute square root of the low FP16 value in xmm3/m16 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 51 /r VSQRTSH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/psignb:psignw:psignd",
    "category": "Core Instructions",
    "instructionName": "PSIGNB/PSIGNW/PSIGND\n\t\t— Packed SIGN",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 08 /r1 PSIGNB mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 08 /r PSIGNB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 09 /r1 PSIGNW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 09 /r PSIGNW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 0A /r1 PSIGND mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 0A /r PSIGND xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 08 /r VPSIGNB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 09 /r VPSIGNW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 0A /r VPSIGND xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Negate packed byte integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 08 /r VPSIGNB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Negate packed 16-bit integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 09 /r VPSIGNW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Negate packed doubleword integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 0A /r VPSIGND ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corresponding data element in the destination operand is set to zero.\n(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers.\nLegacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access additional registers.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location.",
    "operationText": "def byte_sign(control, input_val):\n    if control<0:\n        return negate(input_val)\n    elif control==0:\n        return 0\n    return input_val\ndef word_sign(control, input_val):\n    if control<0:\n        return negate(input_val)\n    elif control==0:\n        return 0\n    return input_val\ndef dword_sign(control, input_val):\n    if control<0:\n        return negate(input_val)\n    elif control==0:\n        return 0\n    return input_val\nVL=64\nKL := VL/8\nfor i in 0...KL-1:\n    srcdest.byte[i] := byte_sign(src.byte[i], srcdest.byte[i])\nVL=64\nKL := VL/16\nFOR i in 0...KL-1:\n    srcdest.word[i] := word_sign(src.word[i], srcdest.word[i])\nVL=64\nKL := VL/32\nFOR i in 0...KL-1:\n    srcdest.dword[i] := dword_sign(src.dword[i], srcdest.dword[i])\nVL=128\nKL := VL/8\nFOR i in 0...KL-1:\n    srcdest.byte[i] := byte_sign(src.byte[i], srcdest.byte[i])\nVL=128\nKL := VL/16\nFOR i in 0...KL-1:\n    srcdest.word[i] := word_sign(src.word[i], srcdest.word[i])\nVL=128\nKL := VL/32\nFOR i in 0...KL-1:\n    srcdest.dword[i] := dword_sign(src.dword[i], srcdest.dword[i])\nVL=(128,256)\nKL := VL/8\nFOR i in 0...KL-1:\n    dest.byte[i] := byte_sign(src2.byte[i], src1.byte[i])\nDEST[MAXVL-1:VL] := 0\nVL=(128,256)\nKL := VL/16\nFOR i in 0...KL-1:\n    dest.word[i] := word_sign(src2.word[i], src1.word[i])\nDEST[MAXVL-1:VL] := 0\nVL=(128,256)\nKL := VL/32\nFOR i in 0...KL-1:\n    dest.dword[i] := dword_sign(src2.dword[i], src1.dword[i])\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/dppd",
    "category": "Core Instructions",
    "instructionName": "DPPD\n\t\t— Dot Product of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Selectively multiply packed double precision floating-point values from xmm1 with packed double precision floating-point values from xmm2, add and selectively store the packed double precision floating-point values to xmm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A 41 /r ib DPPD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Selectively multiply packed double precision floating-point values from xmm2 with packed double precision floating-point values from xmm3, add and selectively store the packed double precision floating-point values to xmm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 41 /r ib VDPPD xmm1,xmm2, xmm3/m128, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Conditionally multiplies the packed double precision floating-point values in the destination operand (first operand) with the packed double precision floating-point values in the source (second operand) depending on a mask extracted from bits [5:4] of the immediate operand (third operand). If a condition mask bit is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nThe two resulting double precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.\nIf a broadcast mask bit is “1”, the intermediate result is copied to the corresponding qword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.\nDPPD follows the NaN forwarding rules stated in the Software Developer’s Manual, vol. 1, table 4-7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally generated NaNs will have at least one NaN propagated to the destination.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nIf VDPPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
    "operationText": "IF (imm8[4] = 1)\n    THEN Temp1[63:0] := DEST[63:0] * SRC[63:0]; // update SIMD exception flags\n    ELSE Temp1[63:0] := +0.0; FI;\nIF (imm8[5] = 1)\n    THEN Temp1[127:64] := DEST[127:64] * SRC[127:64]; // update SIMD exception flags\n    ELSE Temp1[127:64] := +0.0; FI;\n/* if unmasked exception reported, execute exception handler*/\nTemp2[63:0] := Temp1[63:0] + Temp1[127:64]; // update SIMD exception flags\n/* if unmasked exception reported, execute exception handler*/\nIF (imm8[0] = 1)\n    THEN DEST[63:0] := Temp2[63:0];\n    ELSE DEST[63:0] := +0.0; FI;\nIF (imm8[1] = 1)\n    THEN DEST[127:64] := Temp2[63:0];\n    ELSE DEST[127:64] := +0.0; FI;\nDEST[127:0] := DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal.",
        "Exceptions are determined separately for each add and multiply operation. Unmasked exceptions will leave the destination untouched."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ret",
    "category": "Core Instructions",
    "instructionName": "RET\n\t\t— Return From Procedure",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Near return to calling procedure.",
        "Instruction": "RET",
        "Op/En": "ZO",
        "Opcode*": "C3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Far return to calling procedure.",
        "Instruction": "RET",
        "Op/En": "ZO",
        "Opcode*": "CB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Near return to calling procedure and pop imm16 bytes from stack.",
        "Instruction": "RET imm16",
        "Op/En": "I",
        "Opcode*": "C2 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Far return to calling procedure and pop imm16 bytes from stack.",
        "Instruction": "RET imm16",
        "Op/En": "I",
        "Opcode*": "CA iw"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "I",
        "Operand 1": "imm16",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.\nThe optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.\nThe RET instruction can be used to execute three different types of returns:\nThe inter-privilege-level return type can only be executed in protected mode. See the section titled “Calling Procedures Using Call and RET” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for detailed information on near, far, and inter-privilege-level returns.\nWhen executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.\nWhen executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP register, then pops the segment selector from the top of the stack into the CS register. The processor then begins program execution in the new code segment at the new instruction pointer.\nThe mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the processor examines the privilege levels and access rights of the code and stack segments being returned to determine if the control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the new privilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are loaded from the stack.\nIf parameters are passed to the called procedure during an inter-privilege level call, the optional source operand must be used with the RET instruction to release the parameters on the return. Here, the parameters are released both from the called procedure’s stack and the calling procedure’s stack (that is, the stack being returned to).\nIn 64-bit mode, the default operation size of this instruction is the stack-address size, i.e., 64 bits. This applies to near returns, not far returns; the default operation size of far returns is 32 bits.\nRefer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions‚” and Chapter 17, “Control-flow Enforcement Technology (CET)‚” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for CET details.\nInstruction ordering. Instructions following a far return may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far return have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).\nUnlike near indirect CALL and near indirect JMP, the processor will not speculatively execute the next sequential instruction after a near RET unless that instruction is also the target of a jump or is a target in a branch predictor.",
    "operationText": "(* Near return *)\nIF instruction = near return\n    THEN;\n            IF OperandSize = 32\n                    THEN\n                        IF top 4 bytes of stack not within stack limits\n                            THEN #SS(0); FI;\n                        EIP := Pop();\n                        IF ShadowStackEnabled(CPL)\n                            tempSsEIP = ShadowStackPop4B();\n                            IF EIP != TempSsEIP\n                                THEN #CP(NEAR_RET); FI;\n                        FI;\n                    ELSE\n                        IF OperandSize = 64\n                            THEN\n                                IF top 8 bytes of stack not within stack limits\n                                    THEN #SS(0); FI;\n                                RIP := Pop();\n                                IF ShadowStackEnabled(CPL)\n                                    tempSsEIP = ShadowStackPop8B();\n                                    IF RIP != tempSsEIP\n                                        THEN #CP(NEAR_RET); FI;\n                                FI;\n                            ELSE (* OperandSize = 16 *)\n                                IF top 2 bytes of stack not within stack limits\n                                    THEN #SS(0); FI;\n                                tempEIP := Pop();\n                                tempEIP := tempEIP AND 0000FFFFH;\n                                IF tempEIP not within code segment limits\n                                    THEN #GP(0); FI;\n                                EIP := tempEIP;\n                                IF ShadowStackEnabled(CPL)\n                                    tempSsEip = ShadowStackPop4B();\n                                    IF EIP != tempSsEIP\n                                        THEN #CP(NEAR_RET); FI;\n                                FI;\n                        FI;\n            FI;\n    IF instruction has immediate operand\n            THEN (* Release parameters from stack *)\n                    IF StackAddressSize = 32\n                        THEN\n                            ESP := ESP + SRC;\n                        ELSE\n                            IF StackAddressSize = 64\n                                THEN\n                                    RSP := RSP + SRC;\n                                ELSE (* StackAddressSize = 16 *)\n                                    SP := SP + SRC;\n                            FI;\n                    FI;\n    FI;\nFI;\n(* Real-address mode or virtual-8086 mode *)\nIF ((PE = 0) or (PE = 1 AND VM = 1)) and instruction = far return\n    THEN\n            IF OperandSize = 32\n                    THEN\n                        IF top 8 bytes of stack not within stack limits\n                            THEN #SS(0); FI;\n                        EIP := Pop();\n                        CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n                    ELSE (* OperandSize = 16 *)\n                        IF top 4 bytes of stack not within stack limits\n                            THEN #SS(0); FI;\n                        tempEIP := Pop();\n                        tempEIP := tempEIP AND 0000FFFFH;\n                        IF tempEIP not within code segment limits\n                            THEN #GP(0); FI;\n                        EIP := tempEIP;\n                        CS := Pop(); (* 16-bit pop *)\n            FI;\n    IF instruction has immediate operand\n            THEN (* Release parameters from stack *)\n                    SP := SP + (SRC AND FFFFH);\n    FI;\nFI;\n(* Protected mode, not virtual-8086 mode *)\nIF (PE = 1 and VM = 0 and IA32_EFER.LMA = 0) and instruction = far return\n    THEN\n            IF OperandSize = 32\n                    THEN\n                        IF second doubleword on stack is not within stack limits\n                            THEN #SS(0); FI;\n                    ELSE (* OperandSize = 16 *)\n                        IF second word on stack is not within stack limits\n                            THEN #SS(0); FI;\n            FI;\n    IF return code segment selector is NULL\n            THEN #GP(0); FI;\n    IF return code segment selector addresses descriptor beyond descriptor table limit\n            THEN #GP(selector); FI;\n    Obtain descriptor to which return code segment selector points from descriptor table;\n    IF return code segment descriptor is not a code segment\n            THEN #GP(selector); FI;\n    IF return code segment selector RPL < CPL\n            THEN #GP(selector); FI;\n    IF return code segment descriptor is conforming\n    and return code segment DPL > return code segment selector RPL\n            THEN #GP(selector); FI;\n    IF return code segment descriptor is non-conforming and return code\n    segment DPL ≠ return code segment selector RPL\n            THEN #GP(selector); FI;\n    IF return code segment descriptor is not present\n            THEN #NP(selector); FI:\n    IF return code segment selector RPL > CPL\n            THEN GOTO RETURN-TO-OUTER-PRIVILEGE-LEVEL;\n            ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL;\n    FI;\nFI;\nRETURN-TO-SAME-PRIVILEGE-LEVEL:\n    IF the return instruction pointer is not within the return code segment limit\n            THEN #GP(0); FI;\n    IF OperandSize = 32\n            THEN\n                    EIP := Pop();\n                    CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n            ELSE (* OperandSize = 16 *)\n                    EIP := Pop();\n                    EIP := EIP AND 0000FFFFH;\n                    CS := Pop(); (* 16-bit pop *)\n    FI;\n    IF instruction has immediate operand\n            THEN (* Release parameters from stack *)\n                    IF StackAddressSize = 32\n                        THEN\n                            ESP := ESP + SRC;\n                        ELSE (* StackAddressSize = 16 *)\n                            SP := SP + SRC;\n                    FI;\n    FI;\n    IF ShadowStackEnabled(CPL)\n            (* SSP must be 8 byte aligned *)\n            IF SSP AND 0x7 != 0\n                    THEN #CP(FAR-RET/IRET); FI;\n            tempSsCS = shadow_stack_load 8 bytes from SSP+16;\n            tempSsLIP = shadow_stack_load 8 bytes from SSP+8;\n            prevSSP = shadow_stack_load 8 bytes from SSP;\n            SSP = SSP + 24;\n            (* do a 64 bit-compare to check if any bits beyond bit 15 are set *)\n            tempCS = CS; (* zero pad to 64 bit *)\n            IF tempCS != tempSsCS\n                    THEN #CP(FAR-RET/IRET); FI;\n            (* do a 64 bit-compare; pad CSBASE+RIP with 0 for 32 bit LIP*)\n            IF CSBASE + RIP != tempSsLIP\n                    THEN #CP(FAR-RET/IRET); FI;\n            (* prevSSP must be 4 byte aligned *)\n            IF prevSSP AND 0x3 != 0\n                    THEN #CP(FAR-RET/IRET); FI;\n            (* In legacy mode SSP must be in low 4GB *)\n            IF prevSSP[63:32] != 0\n                    THEN #GP(0); FI;\n            SSP := prevSSP\n    FI;\nRETURN-TO-OUTER-PRIVILEGE-LEVEL:\n    IF top (16 + SRC) bytes of stack are not within stack limits (OperandSize = 32)\n    or top (8 + SRC) bytes of stack are not within stack limits (OperandSize = 16)\n                    THEN #SS(0); FI;\n    Read return segment selector;\n    IF stack segment selector is NULL\n            THEN #GP(0); FI;\n    IF return stack segment selector index is not within its descriptor table limits\n            THEN #GP(selector); FI;\n    Read segment descriptor pointed to by return segment selector;\n    IF stack segment selector RPL ≠ RPL of the return code segment selector\n    or stack segment is not a writable data segment\n    or stack segment descriptor DPL ≠ RPL of the return code segment selector\n                    THEN #GP(selector); FI;\n    IF stack segment not present\n            THEN #SS(StackSegmentSelector); FI;\n    IF the return instruction pointer is not within the return code segment limit\n            THEN #GP(0); FI;\n    IF OperandSize = 32\n            THEN\n                    EIP := Pop();\n                    CS := Pop(); (* 32-bit pop, high-order 16 bits discarded; segment descriptor loaded *)\n                    CS(RPL) := ReturnCodeSegmentSelector(RPL);\n                    IF instruction has immediate operand\n                        THEN (* Release parameters from called procedure’s stack *)\n                            IF StackAddressSize = 32\n                                THEN\n                                    ESP := ESP + SRC;\n                                ELSE (* StackAddressSize = 16 *)\n                                    SP := SP + SRC;\n                            FI;\n                    FI;\n                    tempESP := Pop();\n                    tempSS := Pop(); (* 32-bit pop, high-order 16 bits discarded; seg. descriptor loaded *)\n            ELSE (* OperandSize = 16 *)\n                    EIP := Pop();\n                    EIP := EIP AND 0000FFFFH;\n                    CS := Pop(); (* 16-bit pop; segment descriptor loaded *)\n                    CS(RPL) := ReturnCodeSegmentSelector(RPL);\n                    IF instruction has immediate operand\n                        THEN (* Release parameters from called procedure’s stack *)\n                            IF StackAddressSize = 32\n                                THEN\n                                    ESP := ESP + SRC;\n                                ELSE (* StackAddressSize = 16 *)\n                                    SP := SP + SRC;\n                            FI;\n                    FI;\n                    tempESP := Pop();\n                    tempSS := Pop(); (* 16-bit pop; segment descriptor loaded *)\n            FI;\n    IF ShadowStackEnabled(CPL)\n            (* check if 8 byte aligned *)\n            IF SSP AND 0x7 != 0\n                    THEN #CP(FAR-RET/IRET); FI;\n            IF ReturnCodeSegmentSelector(RPL) !=3\n                    THEN\n                        tempSsCS = shadow_stack_load 8 bytes from SSP+16;\n                        tempSsLIP = shadow_stack_load 8 bytes from SSP+8;\n                        tempSSP = shadow_stack_load 8 bytes from SSP;\n                        SSP = SSP + 24;\n                        (* Do 64 bit compare to detect bits beyond 15 being set *)\n                        tempCS = CS; (* zero extended to 64 bit *)\n                        IF tempCS != tempSsCS\n                            THEN #CP(FAR-RET/IRET); FI;\n                        (* Do 64 bit compare; pad CSBASE+RIP with 0 for 32 bit LA *)\n                        IF CSBASE + RIP != tempSsLIP\n                            THEN #CP(FAR-RET/IRET); FI;\n                        (* check if 4 byte aligned *)\n                        IF tempSSP AND 0x3 != 0\n                            THEN #CP(FAR-RET/IRET); FI;\n            FI;\n    FI;\n            tempOldCPL = CPL;\n            CPL := ReturnCodeSegmentSelector(RPL);\n            ESP := tempESP;\n            SS := tempSS;\n            tempOldSSP = SSP;\n            IF ShadowStackEnabled(CPL)\n                    IF CPL = 3\n                        THEN tempSSP := IA32_PL3_SSP; FI;\n                    IF tempSSP[63:32] != 0\n                        THEN #GP(0); FI;\n                    SSP := tempSSP\n            FI;\n            (* Now past all faulting points; safe to free the token. The token free is done using the old SSP\n                * and using a supervisor override as old CPL was a supervisor privilege level *)\n            IF ShadowStackEnabled(tempOldCPL)\n                    expected_token_value = tempOldSSP | BUSY_BIT (* busy bit - bit position 0 - must be set *)\n                    new_token_value = tempOldSSP (* clear the busy bit *)\n                    shadow_stack_lock_cmpxchg8b(tempOldSSP, new_token_value, expected_token_value)\n            FI;\n    FI;\n    FOR each SegReg in (ES, FS, GS, and DS)\n            DO\n                    tempDesc := descriptor cache for SegReg (* hidden part of segment register *)\n                    IF (SegmentSelector == NULL) OR (tempDesc(DPL) < CPL AND tempDesc(Type) is (data or non-conforming code)))\n                        THEN (* Segment register invalid *)\n                            SegmentSelector := 0; (*Segment selector becomes null*)\n                    FI;\n            OD;\n    IF instruction has immediate operand\n            THEN (* Release parameters from calling procedure’s stack *)\n                    IF StackAddressSize = 32\n                        THEN\n                            ESP := ESP + SRC;\n                        ELSE (* StackAddressSize = 16 *)\n                            SP := SP + SRC;\n                    FI;\n    FI;\n(* IA-32e Mode *)\n    IF (PE = 1 and VM = 0 and IA32_EFER.LMA = 1) and instruction = far return\n            THEN\n                    IF OperandSize = 32\n                        THEN\n                            IF second doubleword on stack is not within stack limits\n                                THEN #SS(0); FI;\n                            IF first or second doubleword on stack is not in canonical space\n                                THEN #SS(0); FI;\n                        ELSE\n                            IF OperandSize = 16\n                                THEN\n                                    IF second word on stack is not within stack limits\n                                        THEN #SS(0); FI;\n                                    IF first or second word on stack is not in canonical space\n                                        THEN #SS(0); FI;\n                                ELSE (* OperandSize = 64 *)\n                                    IF first or second quadword on stack is not in canonical space\n                                        THEN #SS(0); FI;\n                            FI\n                    FI;\n            IF return code segment selector is NULL\n                    THEN GP(0); FI;\n            IF return code segment selector addresses descriptor beyond descriptor table limit\n                    THEN GP(selector); FI;\n            IF return code segment selector addresses descriptor in non-canonical space\n                    THEN GP(selector); FI;\n            Obtain descriptor to which return code segment selector points from descriptor table;\n            IF return code segment descriptor is not a code segment\n                    THEN #GP(selector); FI;\n            IF return code segment descriptor has L-bit = 1 and D-bit = 1\n                    THEN #GP(selector); FI;\n            IF return code segment selector RPL < CPL\n                    THEN #GP(selector); FI;\n            IF return code segment descriptor is conforming\n            and return code segment DPL > return code segment selector RPL\n                    THEN #GP(selector); FI;\n            IF return code segment descriptor is non-conforming\n            and return code segment DPL ≠ return code segment selector RPL\n                    THEN #GP(selector); FI;\n            IF return code segment descriptor is not present\n                    THEN #NP(selector); FI:\n            IF return code segment selector RPL > CPL\n                    THEN GOTO IA-32E-MODE-RETURN-TO-OUTER-PRIVILEGE-LEVEL;\n                    ELSE GOTO IA-32E-MODE-RETURN-TO-SAME-PRIVILEGE-LEVEL;\n            FI;\n    FI;\nIA-32E-MODE-RETURN-TO-SAME-PRIVILEGE-LEVEL:\nIF the return instruction pointer is not within the return code segment limit\n    THEN #GP(0); FI;\nIF the return instruction pointer is not within canonical address space\n    THEN #GP(0); FI;\nIF OperandSize = 32\n    THEN\n            EIP := Pop();\n            CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n    ELSE\n            IF OperandSize = 16\n                    THEN\n                        EIP := Pop();\n                        EIP := EIP AND 0000FFFFH;\n                        CS := Pop(); (* 16-bit pop *)\n                    ELSE (* OperandSize = 64 *)\n                        RIP := Pop();\n                        CS := Pop(); (* 64-bit pop, high-order 48 bits discarded *)\n            FI;\nFI;\nIF instruction has immediate operand\n    THEN (* Release parameters from stack *)\n            IF StackAddressSize = 32\n                    THEN\n                        ESP := ESP + SRC;\n                    ELSE\n                        IF StackAddressSize = 16\n                            THEN\n                                SP := SP + SRC;\n                            ELSE (* StackAddressSize = 64 *)\n                                RSP := RSP + SRC;\n                        FI;\n            FI;\nFI;\nIF ShadowStackEnabled(CPL)\n    IF SSP AND 0x7 != 0 (* check if aligned to 8 bytes *)\n            THEN #CP(FAR-RET/IRET); FI;\n    tempSsCS = shadow_stack_load 8 bytes from SSP+16;\n    tempSsLIP = shadow_stack_load 8 bytes from SSP+8;\n    tempSSP = shadow_stack_load 8 bytes from SSP;\n    SSP = SSP + 24;\n    tempCS = CS; (* zero padded to 64 bit *)\n    IF tempCS != tempSsCS (* 64 bit compare; CS zero padded to 64 bits *)\n            THEN #CP(FAR-RET/IRET); FI;\n    IF CSBASE + RIP != tempSsLIP (* 64 bit compare *)\n            THEN #CP(FAR-RET/IRET); FI;\n    IF tempSSP AND 0x3 != 0 (* check if aligned to 4 bytes *)\n            THEN #CP(FAR-RET/IRET); FI;\n    IF (CS.L = 0 AND tempSSP[63:32] != 0) OR\n        (CS.L = 1 AND tempSSP is not canonical relative to the current paging mode)\n            THEN #GP(0); FI;\n    SSP := tempSSP\nFI;\nIA-32E-MODE-RETURN-TO-OUTER-PRIVILEGE-LEVEL:\nIF top (16 + SRC) bytes of stack are not within stack limits (OperandSize = 32)\nor top (8 + SRC) bytes of stack are not within stack limits (OperandSize = 16)\n    THEN #SS(0); FI;\nIF top (16 + SRC) bytes of stack are not in canonical address space (OperandSize =32)\nor top (8 + SRC) bytes of stack are not in canonical address space (OperandSize = 16)\nor top (32 + SRC) bytes of stack are not in canonical address space (OperandSize = 64)\n    THEN #SS(0); FI;\nRead return stack segment selector;\nIF stack segment selector is NULL\n    THEN\n            IF new CS descriptor L-bit = 0\n                    THEN #GP(selector);\n            IF stack segment selector RPL = 3\n                    THEN #GP(selector);\nFI;\nIF return stack segment descriptor is not within descriptor table limits\n            THEN #GP(selector); FI;\nIF return stack segment descriptor is in non-canonical address space\n            THEN #GP(selector); FI;\nRead segment descriptor pointed to by return segment selector;\nIF stack segment selector RPL ≠ RPL of the return code segment selector\nor stack segment is not a writable data segment\nor stack segment descriptor DPL ≠ RPL of the return code segment selector\n    THEN #GP(selector); FI;\nIF stack segment not present\n    THEN #SS(StackSegmentSelector); FI;\nIF the return instruction pointer is not within the return code segment limit\n    THEN #GP(0); FI:\nIF the return instruction pointer is not within canonical address space\n    THEN #GP(0); FI;\nIF OperandSize = 32\n    THEN\n            EIP := Pop();\n            CS := Pop(); (* 32-bit pop, high-order 16 bits discarded, segment descriptor loaded *)\n            CS(RPL) := ReturnCodeSegmentSelector(RPL);\n            IF instruction has immediate operand\n                    THEN (* Release parameters from called procedure’s stack *)\n                        IF StackAddressSize = 32\n                            THEN\n                                ESP := ESP + SRC;\n                            ELSE\n                                IF StackAddressSize = 16\n                                    THEN\n                                        SP := SP + SRC;\n                                    ELSE (* StackAddressSize = 64 *)\n                                        RSP := RSP + SRC;\n                                FI;\n                        FI;\n            FI;\n            tempESP := Pop();\n            tempSS := Pop(); (* 32-bit pop, high-order 16 bits discarded, segment descriptor loaded *)\n    ELSE\n            IF OperandSize = 16\n                    THEN\n                        EIP := Pop();\n                        EIP := EIP AND 0000FFFFH;\n                        CS := Pop(); (* 16-bit pop; segment descriptor loaded *)\n                        CS(RPL) := ReturnCodeSegmentSelector(RPL);\n                        IF instruction has immediate operand\n                            THEN (* Release parameters from called procedure’s stack *)\n                                IF StackAddressSize = 32\n                                    THEN\n                                        ESP := ESP + SRC;\n                                    ELSE\n                                        IF StackAddressSize = 16\n                                            THEN\n                                                SP := SP + SRC;\n                                            ELSE (* StackAddressSize = 64 *)\n                                                RSP := RSP + SRC;\n                                        FI;\n                                FI;\n                        FI;\n                        tempESP := Pop();\n                        tempSS := Pop(); (* 16-bit pop; segment descriptor loaded *)\n                    ELSE (* OperandSize = 64 *)\n                        RIP := Pop();\n                        CS := Pop(); (* 64-bit pop; high-order 48 bits discarded; seg. descriptor loaded *)\n                        CS(RPL) := ReturnCodeSegmentSelector(RPL);\n                        IF instruction has immediate operand\n                            THEN (* Release parameters from called procedure’s stack *)\n                                RSP := RSP + SRC;\n                        FI;\n                        tempESP := Pop();\n                        tempSS := Pop(); (* 64-bit pop; high-order 48 bits discarded; seg. desc. loaded *)\n            FI;\nFI;\nIF ShadowStackEnabled(CPL)\n    (* check if 8 byte aligned *)\n    IF SSP AND 0x7 != 0\n            THEN #CP(FAR-RET/IRET); FI;\n    IF ReturnCodeSegmentSelector(RPL) !=3\n            THEN\n                    tempSsCS = shadow_stack_load 8 bytes from SSP+16;\n                    tempSsLIP = shadow_stack_load 8 bytes from SSP+8;\n                    tempSSP = shadow_stack_load 8 bytes from SSP;\n                    SSP = SSP + 24;\n                    (* Do 64 bit compare to detect bits beyond 15 being set *)\n                    tempCS = CS; (* zero padded to 64 bit *)\n                    IF tempCS != tempSsCS\n                        THEN #CP(FAR-RET/IRET); FI;\n                    (* Do 64 bit compare; pad CSBASE+RIP with 0 for 32 bit LIP *)\n                    IF CSBASE + RIP != tempSsLIP\n                        THEN #CP(FAR-RET/IRET); FI;\n                    (* check if 4 byte aligned *)\n                    IF tempSSP AND 0x3 != 0\n                        THEN #CP(FAR-RET/IRET); FI;\n    FI;\nFI;\ntempOldCPL = CPL;\nCPL := ReturnCodeSegmentSelector(RPL);\nESP := tempESP;\nSS := tempSS;\ntempOldSSP = SSP;\nIF ShadowStackEnabled(CPL)\n    IF CPL = 3\n            THEN tempSSP := IA32_PL3_SSP; FI;\n    IF (CS.L = 0 AND tempSSP[63:32] != 0) OR\n        (CS.L = 1 AND tempSSP is not canonical relative to the current paging mode)\n            THEN #GP(0); FI;\n    SSP := tempSSP\nFI;\n(* Now past all faulting points; safe to free the token. The token free is done using the old SSP\n* and using a supervisor override as old CPL was a supervisor privilege level *)\nIF ShadowStackEnabled(tempOldCPL)\n    expected_token_value = tempOldSSP | BUSY_BIT (* busy bit - bit position 0 - must be set *)\n    new_token_value = tempOldSSP (* clear the busy bit *)\n    shadow_stack_lock_cmpxchg8b(tempOldSSP, new_token_value, expected_token_value)\nFI;\nFOR each of segment register (ES, FS, GS, and DS)\n    DO\n            IF segment register points to data or non-conforming code segment\n            and CPL > segment descriptor DPL; (* DPL in hidden part of segment register *)\n                    THEN SegmentSelector := 0; (* SegmentSelector invalid *)\n            FI;\n    OD;\nIF instruction has immediate operand\n    THEN (* Release parameters from calling procedure’s stack *)\n            IF StackAddressSize = 32\n                    THEN\n                        ESP := ESP + SRC;\n                    ELSE\n                        IF StackAddressSize = 16\n                            THEN\n                                SP := SP + SRC;\n                            ELSE (* StackAddressSize = 64 *)\n                                RSP := RSP + SRC;\n                        FI;\n            FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the return instruction pointer is not within the return code segment limit.; \ncolumn_1: If the stack segment selector is NULL going back to compatibility mode.; \ncolumn_1: If the stack segment selector is NULL going back to CPL3 64-bit mode.; \ncolumn_1: If a NULL stack segment selector RPL is not equal to CPL going back to non-CPL3 64-bit mode.; \ncolumn_1: If the return code segment selector is NULL.; \ncolumn_1: If returning to 32-bit or compatibility mode and the previous SSP from shadow stack (when returning to CPL <3) or from IA32_PL3_SSP (returning to CPL 3) is beyond 4GB.; \ncolumn_1: #GP(selector); column_2: If the proposed segment descriptor for a code segment does not indicate it is a code segment.; \ncolumn_1: If the proposed new code segment descriptor has both the D-bit and L-bit set.; \ncolumn_1: If the DPL for a nonconforming-code segment is not equal to the RPL of the code segment selector.; \ncolumn_1: If CPL is greater than the RPL of the code segment selector.; \ncolumn_1: If the DPL of a conforming-code segment is greater than the return code segment selector RPL.; \ncolumn_1: If a segment selector index is outside its descriptor table limits.; \ncolumn_1: If a segment descriptor memory address is non-canonical.; \ncolumn_1: If the stack segment is not a writable data segment.; \ncolumn_1: If the stack segment descriptor DPL is not equal to the RPL of the return code segment selector.; \ncolumn_1: If the stack segment selector RPL is not equal to the RPL of the return code segment selector.; \ncolumn_1: #SS(0); column_2: If an attempt to pop a value off the stack violates the SS limit.; \ncolumn_1: If an attempt to pop a value off the stack causes a non-canonical address to be referenced.; \ncolumn_1: #NP(selector); column_2: If the return code or stack segment is not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #CP(Far-RET/IRET); column_2: If the previous SSP from shadow stack (when returning to CPL <3) or from IA32_PL3_SSP (returning to CPL 3) is not 4 byte aligned.; \ncolumn_1: If return instruction pointer from stack and shadow stack do not match.;"
      ],
      "compatibilityMode": [
        "Same as 64-bit mode exceptions."
      ],
      "protectedMode": [
        "column_1: If the return instruction pointer is not within the return code segment limit.; \ncolumn_1: If returning to 32-bit or compatibility mode and the previous SSP from shadow stack (when returning to CPL <3) or from IA32_PL3_SSP (returning to CPL 3) is beyond 4GB.; \ncolumn_1: #GP(selector); column_2: If the RPL of the return code segment selector is less then the CPL.; \ncolumn_1: If the return code or stack segment selector index is not within its descriptor table limits.; \ncolumn_1: If the return code segment descriptor does not indicate a code segment.; \ncolumn_1: If the return code segment is non-conforming and the segment selector’s DPL is not equal to the RPL of the code segment’s segment selector; \ncolumn_1: If the return code segment is conforming and the segment selector’s DPL greater than the RPL of the code segment’s segment selector; \ncolumn_1: If the stack segment is not a writable data segment.; \ncolumn_1: If the stack segment selector RPL is not equal to the RPL of the return code segment selector.; \ncolumn_1: If the stack segment descriptor DPL is not equal to the RPL of the return code segment selector.; \ncolumn_1: #SS(0); column_2: If the top bytes of stack are not within stack limits.; \ncolumn_1: If the return stack segment is not present.; \ncolumn_1: #NP(selector); column_2: If the return code segment is not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory access occurs when the CPL is 3 and alignment checking is enabled.; \ncolumn_1: #CP(Far-RET/IRET); column_2: If the previous SSP from shadow stack (when returning to CPL <3) or from IA32_PL3_SSP (returning to CPL 3) is not 4 byte aligned.; \ncolumn_1: If return instruction pointer from stack and shadow stack do not match.;"
      ],
      "realAddressMode": [
        "column_2: If the top bytes of stack are not within stack limits.; column_1: #SS;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If the top bytes of stack are not within stack limits.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory access occurs when alignment checking is enabled.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/intn:into:int3:int1",
    "category": "Core Instructions",
    "instructionName": "INT n/INTO/INT3/INT1\n\t\t— Call to Interrupt Procedure",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Generate breakpoint trap.",
        "Instruction": "INT3",
        "Op/En": "ZO",
        "Opcode": "CC"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Generate software interrupt with vector specified by immediate byte.",
        "Instruction": "INT imm8",
        "Op/En": "I",
        "Opcode": "CD ib"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Generate overflow trap if overflow flag is 1.",
        "Instruction": "INTO",
        "Op/En": "ZO",
        "Opcode": "CE"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Generate debug trap.",
        "Instruction": "INT1",
        "Op/En": "ZO",
        "Opcode": "F1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "I",
        "Operand 1": "imm8",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand (see the section titled “Interrupts and Exceptions” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.\nThe INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)\nThe INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP). (This one-byte form is useful because it can replace the first byte of any instruction at which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.)\nThe INT1 instruction also uses a one-byte opcode (F1) and generates a debug exception (#DB) without setting any bits in DR6.1 Hardware vendors may use the INT1 instruction for hardware debug. For that reason, Intel recommends software vendors instead use the INT3 instruction for software breakpoints.\nAn interrupt generated by the INTO, INT3, or INT1 instruction differs from one generated by INT n in the following ways:\n(These features do not pertain to CD03, the “normal” 2-byte opcode for INT 3. Intel and Microsoft assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct numeric code definition or by self-modifying code.)\nThe action of the INT n instruction (including the INTO, INT3, and INT1 instructions) is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed onto the stack before the return address. (The return address is a far address consisting of the current values of the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.\nEach of the INT n, INTO, and INT3 instructions generates a general-protection exception (#GP) if the CPL is greater than the DPL value in the selected gate descriptor in the IDT. In contrast, the INT1 instruction can deliver a #DB\neven if the CPL is greater than the DPL of descriptor 1 in the IDT. (This behavior supports the use of INT1 by hardware vendors performing hardware debug.)\nThe vector specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure. In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in real-address mode, the IDT is called the interrupt vector table, and its pointers are called interrupt vectors.)\nThe following decision table indicates which action in the lower portion of the table is taken given the conditions in the upper portion of the table. Each Y in the lower section of the decision table represents a procedure defined in the “Operation” section for this instruction (except #GP).\nWhen the processor is executing in virtual-8086 mode, the IOPL determines the action of the INT n instruction. If the IOPL is less than 3, the processor generates a #GP(selector) exception; if the IOPL is 3, the processor executes a protected mode interrupt to privilege level 0. The interrupt gate's DPL must be set to 3 and the target CPL of the interrupt handler procedure must be 0 to execute the protected mode interrupt to privilege level 0.\nThe interrupt descriptor table register (IDTR) specifies the base linear address and limit of the IDT. The initial base address value of the IDTR after the processor is powered up or reset is 0.\nRefer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions” and Chapter 17, “Control-flow Enforcement Technology (CET)” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for CET details.\nInstruction ordering. Instructions following an INT n may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the INT n have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible). This applies also to the INTO, INT3, and INT1 instructions, but not to executions of INTO when EFLAGS.OF = 0.",
    "operationText": "The following operational description applies not only to the INT n, INTO, INT3, or INT1 instructions, but also to\nexternal interrupts, nonmaskable interrupts (NMIs), and exceptions. Some of these events push onto the stack an\nerror code.\nThe operational description specifies numerous checks whose failure may result in delivery of a nested exception.\nIn these cases, the original event is not delivered.\nThe operational description specifies the error code delivered by any nested exception. In some cases, the error\ncode is specified with a pseudofunction error_code(num,idt,ext), where idt and ext are bit values. The pseudofunc-\ntion produces an error code as follows: (1) if idt is 0, the error code is (num & FCH) | ext; (2) if idt is 1, the error\ncode is (num « 3) | 2 | ext.\nIn many cases, the pseudofunction error_code is invoked with a pseudovariable EXT. The value of EXT depends on\nthe nature of the event whose delivery encountered a nested exception: if that event is a software interrupt (INT n,\nINT3, or INTO), EXT is 0; otherwise (including INT1), EXT is 1.\nIF PE = 0\n    THEN\n        GOTO REAL-ADDRESS-MODE;\n    ELSE (* PE = 1 *)\n        IF (EFLAGS.VM = 1 AND CR4.VME = 0 AND IOPL < 3 AND INT n)\n            THEN\n                    #GP(0); (* Bit 0 of error code is 0 because INT n *)\n            ELSE\n                IF (EFLAGS.VM = 1 AND CR4.VME = 1 AND INT n)\n                        THEN\n                            Consult bit n of the software interrupt redirection bit map in the TSS;\n                            IF bit n is clear\n                                THEN (* redirect interrupt to 8086 program interrupt handler *)\n                                    Push EFLAGS[15:0]; (* if IOPL < 3, save VIF in IF position and save IOPL position as 3 *)\n                                    Push CS;\n                                    Push IP;\n                                    IF IOPL = 3\n                                        THEN IF := 0; (* Clear interrupt flag *)\n                                        ELSE VIF := 0; (* Clear virtual interrupt flag *)\n                                    FI;\n                                    TF := 0; (* Clear trap flag *)\n                                    load CS and EIP (lower 16 bits only) from entry n in interrupt vector table referenced from TSS;\n                                ELSE\n                                    IF IOPL = 3\n                                        THEN GOTO PROTECTED-MODE;\n                                        ELSE #GP(0); (* Bit 0 of error code is 0 because INT n *)\n                                    FI;\n                            FI;\n                        ELSE (* Protected mode, IA-32e mode, or virtual-8086 mode interrupt *)\n                            IF (IA32_EFER.LMA = 0)\n                                THEN (* Protected mode, or virtual-8086 mode interrupt *)\n                                    GOTO PROTECTED-MODE;\n                                ELSE (* IA-32e mode interrupt *)\n                                GOTO IA-32e-MODE;\n                            FI;\n                FI;\n        FI;\nFI;\nREAL-ADDRESS-MODE:\n    IF ((vector_number « 2) + 3) is not within IDT limit\n        THEN #GP; FI;\n    IF stack not large enough for a 6-byte return information\n        THEN #SS; FI;\n    Push (EFLAGS[15:0]);\n    IF := 0; (* Clear interrupt flag *)\n    TF := 0; (* Clear trap flag *)\n    AC := 0; (* Clear AC flag *)\n    Push(CS);\n    Push(IP);\n    (* No error codes are pushed in real-address mode*)\n    CS := IDT(Descriptor (vector_number « 2), selector));\n    EIP := IDT(Descriptor (vector_number « 2), offset)); (* 16 bit offset AND 0000FFFFH *)\nEND;\nPROTECTED-MODE:\n    IF ((vector_number « 3) + 7) is not within IDT limits\n    or selected IDT descriptor is not an interrupt-, trap-, or task-gate type\n        THEN #GP(error_code(vector_number,1,EXT)); FI;\n        (* idt operand to error_code set because vector is used *)\n    IF software interrupt (* Generated by INT n, INT3, or INTO; does not apply to INT1 *)\n        THEN\n            IF gate DPL < CPL (* PE = 1, DPL < CPL, software interrupt *)\n                THEN #GP(error_code(vector_number,1,0)); FI;\n                (* idt operand to error_code set because vector is used *)\n                (* ext operand to error_code is 0 because INT n, INT3, or INTO*)\n    FI;\n    IF gate not present\n        THEN #NP(error_code(vector_number,1,EXT)); FI;\n        (* idt operand to error_code set because vector is used *)\n    IF task gate (* Specified in the selected interrupt table descriptor *)\n        THEN GOTO TASK-GATE;\n        ELSE GOTO TRAP-OR-INTERRUPT-GATE; (* PE = 1, trap/interrupt gate *)\n    FI;\nEND;\nIA-32e-MODE:\n    IF INTO and CS.L = 1 (64-bit mode)\n        THEN #UD;\n    FI;\n    IF ((vector_number « 4) + 15) is not in IDT limits\n    or selected IDT descriptor is not an interrupt-, or trap-gate type\n        THEN #GP(error_code(vector_number,1,EXT));\n        (* idt operand to error_code set because vector is used *)\n    FI;\n    IF software interrupt (* Generated by INT n, INT3, or INTO; does not apply to INT1 *)\n        THEN\n            IF gate DPL < CPL (* PE = 1, DPL < CPL, software interrupt *)\n                THEN #GP(error_code(vector_number,1,0));\n                (* idt operand to error_code set because vector is used *)\n                (* ext operand to error_code is 0 because INT n, INT3, or INTO*)\n            FI;\n    FI;\n    IF gate not present\n        THEN #NP(error_code(vector_number,1,EXT));\n        (* idt operand to error_code set because vector is used *)\n    FI;\n    GOTO TRAP-OR-INTERRUPT-GATE; (* Trap/interrupt gate *)\nEND;\nTASK-GATE: (* PE = 1, task gate *)\n    Read TSS selector in task gate (IDT descriptor);\n        IF local/global bit is set to local or index not within GDT limits\n            THEN #GP(error_code(TSS selector,0,EXT)); FI;\n            (* idt operand to error_code is 0 because selector is used *)\n        Access TSS descriptor in GDT;\n        IF TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)\n            THEN #GP(error_code(TSS selector,0,EXT)); FI;\n            (* idt operand to error_code is 0 because selector is used *)\n        IF TSS not present\n            THEN #NP(error_code(TSS selector,0,EXT)); FI;\n            (* idt operand to error_code is 0 because selector is used *)\n    SWITCH-TASKS (with nesting) to TSS;\n    IF interrupt caused by fault with error code\n        THEN\n            IF stack limit does not allow push of error code\n                THEN #SS(EXT); FI;\n            Push(error code);\n    FI;\n    IF EIP not within code segment limit\n        THEN #GP(EXT); FI;\nEND;\nTRAP-OR-INTERRUPT-GATE:\n    Read new code-segment selector for trap or interrupt gate (IDT descriptor);\n    IF new code-segment selector is NULL\n        THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n    IF new code-segment selector is not within its descriptor table limits\n        THEN #GP(error_code(new code-segment selector,0,EXT)); FI;\n        (* idt operand to error_code is 0 because selector is used *)\n    Read descriptor referenced by new code-segment selector;\n    IF descriptor does not indicate a code segment or new code-segment DPL > CPL\n        THEN #GP(error_code(new code-segment selector,0,EXT)); FI;\n        (* idt operand to error_code is 0 because selector is used *)\n    IF new code-segment descriptor is not present,\n        THEN #NP(error_code(new code-segment selector,0,EXT)); FI;\n        (* idt operand to error_code is 0 because selector is used *)\n    IF new code segment is non-conforming with DPL < CPL\n        THEN\n            IF VM = 0\n                THEN\n                        GOTO INTER-PRIVILEGE-LEVEL-INTERRUPT;\n                        (* PE = 1, VM = 0, interrupt or trap gate, nonconforming code segment,\n                        DPL < CPL *)\n                ELSE (* VM = 1 *)\n                        IF new code-segment DPL ≠ 0\n                            THEN #GP(error_code(new code-segment selector,0,EXT));\n                            (* idt operand to error_code is 0 because selector is used *)\n                        GOTO INTERRUPT-FROM-VIRTUAL-8086-MODE; FI;\n                        (* PE = 1, interrupt or trap gate, DPL < CPL, VM = 1 *)\n            FI;\n        ELSE (* PE = 1, interrupt or trap gate, DPL ≥ CPL *)\n            IF VM = 1\n                THEN #GP(error_code(new code-segment selector,0,EXT));\n                (* idt operand to error_code is 0 because selector is used *)\n            IF new code segment is conforming or new code-segment DPL = CPL\n                THEN\n                        GOTO INTRA-PRIVILEGE-LEVEL-INTERRUPT;\n                ELSE (* PE = 1, interrupt or trap gate, nonconforming code segment, DPL > CPL *)\n                        #GP(error_code(new code-segment selector,0,EXT));\n                        (* idt operand to error_code is 0 because selector is used *)\n            FI;\n    FI;\nEND;\nINTER-PRIVILEGE-LEVEL-INTERRUPT:\n    (* PE = 1, interrupt or trap gate, non-conforming code segment, DPL < CPL *)\n    IF (IA32_EFER.LMA = 0) (* Not IA-32e mode *)\n        THEN\n        (* Identify stack-segment selector for new privilege level in current TSS *)\n            IF current TSS is 32-bit\n                THEN\n                        TSSstackAddress := (new code-segment DPL « 3) + 4;\n                        IF (TSSstackAddress + 5) > current TSS limit\n                            THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n                            (* idt operand to error_code is 0 because selector is used *)\n                        NewSS := 2 bytes loaded from (TSS base + TSSstackAddress + 4);\n                        NewESP := 4 bytes loaded from (TSS base + TSSstackAddress);\n                ELSE (* current TSS is 16-bit *)\n                        TSSstackAddress := (new code-segment DPL « 2) + 2\n                        IF (TSSstackAddress + 3) > current TSS limit\n                            THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n                            (* idt operand to error_code is 0 because selector is used *)\n                        NewSS := 2 bytes loaded from (TSS base + TSSstackAddress + 2);\n                        NewESP := 2 bytes loaded from (TSS base + TSSstackAddress);\n            FI;\n            IF NewSS is NULL\n                THEN #TS(EXT); FI;\n            IF NewSS index is not within its descriptor-table limits\n            or NewSS RPL ≠ new code-segment DPL\n                THEN #TS(error_code(NewSS,0,EXT)); FI;\n                (* idt operand to error_code is 0 because selector is used *)\n            Read new stack-segment descriptor for NewSS in GDT or LDT;\n            IF new stack-segment DPL ≠ new code-segment DPL\n            or new stack-segment Type does not indicate writable data segment\n                THEN #TS(error_code(NewSS,0,EXT)); FI;\n                (* idt operand to error_code is 0 because selector is used *)\n            IF NewSS is not present\n                THEN #SS(error_code(NewSS,0,EXT)); FI;\n                (* idt operand to error_code is 0 because selector is used *)\n                NewSSP := IA32_PLi_SSP (* where i = new code-segment DPL *)\n        ELSE (* IA-32e mode *)\n            IF IDT-gate IST = 0\n                THEN TSSstackAddress := (new code-segment DPL « 3) + 4;\n                ELSE TSSstackAddress := (IDT gate IST « 3) + 28;\n            FI;\n            IF (TSSstackAddress + 7) > current TSS limit\n                THEN #TS(error_code(current TSS selector,0,EXT); FI;\n                (* idt operand to error_code is 0 because selector is used *)\n            NewRSP := 8 bytes loaded from (current TSS base + TSSstackAddress);\n            NewSS := new code-segment DPL; (* NULL selector with RPL = new CPL *)\n            IF IDT-gate IST = 0\n                THEN\n                        NewSSP := IA32_PLi_SSP (* where i = new code-segment DPL *)\n                ELSE\n                        NewSSPAddress = IA32_INTERRUPT_SSP_TABLE_ADDR + (IDT-gate IST « 3)\n                        (* Check if shadow stacks are enabled at CPL 0 *)\n                        IF ShadowStackEnabled(CPL 0)\n                            THEN NewSSP := 8 bytes loaded from NewSSPAddress; FI;\n            FI;\n    FI;\n    IF IDT gate is 32-bit\n            THEN\n                IF new stack does not have room for 24 bytes (error code pushed)\n                or 20 bytes (no error code pushed)\n                        THEN #SS(error_code(NewSS,0,EXT)); FI;\n                        (* idt operand to error_code is 0 because selector is used *)\n            FI\n        ELSE\n            IF IDT gate is 16-bit\n                THEN\n                        IF new stack does not have room for 12 bytes (error code pushed)\n                        or 10 bytes (no error code pushed);\n                            THEN #SS(error_code(NewSS,0,EXT)); FI;\n                            (* idt operand to error_code is 0 because selector is used *)\n            ELSE (* 64-bit IDT gate*)\n                IF StackAddress is non-canonical\n                        THEN #SS(EXT); FI; (* Error code contains NULL selector *)\n        FI;\n    FI;\n    IF (IA32_EFER.LMA = 0) (* Not IA-32e mode *)\n        THEN\n            IF instruction pointer from IDT gate is not within new code-segment limits\n                THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n            ESP := NewESP;\n            SS := NewSS; (* Segment descriptor information also loaded *)\n        ELSE (* IA-32e mode *)\n            IF instruction pointer from IDT gate contains a non-canonical address\n                THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n            RSP := NewRSP & FFFFFFFFFFFFFFF0H;\n            SS := NewSS;\n    FI;\n    IF IDT gate is 32-bit\n        THEN\n            CS:EIP := Gate(CS:EIP); (* Segment descriptor information also loaded *)\n        ELSE\n            IF IDT gate 16-bit\n                THEN\n                        CS:IP := Gate(CS:IP);\n                        (* Segment descriptor information also loaded *)\n                ELSE (* 64-bit IDT gate *)\n                        CS:RIP := Gate(CS:RIP);\n                        (* Segment descriptor information also loaded *)\n            FI;\n    FI;\n    IF IDT gate is 32-bit\n            THEN\n                Push(far pointer to old stack);\n                (* Old SS and ESP, 3 words padded to 4 *)\n                Push(EFLAGS);\n                Push(far pointer to return instruction);\n                (* Old CS and EIP, 3 words padded to 4 *)\n                Push(ErrorCode); (* If needed, 4 bytes *)\n            ELSE\n                IF IDT gate 16-bit\n                        THEN\n                            Push(far pointer to old stack);\n                            (* Old SS and SP, 2 words *)\n                            Push(EFLAGS(15:0]);\n                            Push(far pointer to return instruction);\n                            (* Old CS and IP, 2 words *)\n                            Push(ErrorCode); (* If needed, 2 bytes *)\n                        ELSE (* 64-bit IDT gate *)\n                            Push(far pointer to old stack);\n                            (* Old SS and SP, each an 8-byte push *)\n                            Push(RFLAGS); (* 8-byte push *)\n                            Push(far pointer to return instruction);\n                            (* Old CS and RIP, each an 8-byte push *)\n                            Push(ErrorCode); (* If needed, 8-bytes *)\n            FI;\n    FI;\n    IF ShadowStackEnabled(CPL) AND CPL = 3\n        THEN\n            IF IA32_EFER.LMA = 0\n                THEN IA32_PL3_SSP := SSP;\n                ELSE (* adjust so bits 63:N get the value of bit N–1, where N is the CPU’s maximum linear-address width *)\n                        IA32_PL3_SSP := LA_adjust(SSP);\n            FI;\n    FI;\n    CPL := new code-segment DPL;\n    CS(RPL) := CPL;\n    IF ShadowStackEnabled(CPL)\n        oldSSP := SSP\n        SSP := NewSSP\n        IF SSP & 0x07 != 0\n            THEN #GP(0); FI;\n        (* Token and CS:LIP:oldSSP pushed on shadow stack must be contained in a naturally aligned 32-byte region *)\n        IF (SSP & ~0x1F) != ((SSP – 24) & ~0x1F)\n            #GP(0); FI;\n        IF ((IA32_EFER.LMA and CS.L) = 0 AND SSP[63:32] != 0)\n            THEN #GP(0); FI;\n        expected_token_value = SSP (* busy bit - bit position 0 - must be clear *)\n        new_token_value = SSP | BUSY_BIT (* Set the busy bit *)\n        IF shadow_stack_lock_cmpxchg8b(SSP, new_token_value, expected_token_value) != expected_token_value\n            THEN #GP(0); FI;\n        IF oldSS.DPL != 3\n            ShadowStackPush8B(oldCS); (* Padded with 48 high-order bits of 0 *)\n            ShadowStackPush8B(oldCSBASE + oldRIP); (* Padded with 32 high-order bits of 0 for 32 bit LIP*)\n            ShadowStackPush8B(oldSSP);\n        FI;\n    FI;\n    IF EndbranchEnabled (CPL)\n        IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;\n        IA32_S_CET.SUPPRESS = 0\n    FI;\n    IF IDT gate is interrupt gate\n        THEN IF := 0 (* Interrupt flag set to 0, interrupts disabled *); FI;\n    TF := 0;\n    VM := 0;\n    RF := 0;\n    NT := 0;\nEND;\nINTERRUPT-FROM-VIRTUAL-8086-MODE:\n    (* Identify stack-segment selector for privilege level 0 in current TSS *)\n    IF current TSS is 32-bit\n        THEN\n            IF TSS limit < 9\n                THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n                (* idt operand to error_code is 0 because selector is used *)\n            NewSS := 2 bytes loaded from (current TSS base + 8);\n            NewESP := 4 bytes loaded from (current TSS base + 4);\n        ELSE (* current TSS is 16-bit *)\n            IF TSS limit < 5\n                THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n                (* idt operand to error_code is 0 because selector is used *)\n            NewSS := 2 bytes loaded from (current TSS base + 4);\n            NewESP := 2 bytes loaded from (current TSS base + 2);\n    FI;\n    IF NewSS is NULL\n        THEN #TS(EXT); FI; (* Error code contains NULL selector *)\n    IF NewSS index is not within its descriptor table limits\n    or NewSS RPL ≠ 0\n        THEN #TS(error_code(NewSS,0,EXT)); FI;\n        (* idt operand to error_code is 0 because selector is used *)\n    Read new stack-segment descriptor for NewSS in GDT or LDT;\n    IF new stack-segment DPL ≠ 0 or stack segment does not indicate writable data segment\n        THEN #TS(error_code(NewSS,0,EXT)); FI;\n        (* idt operand to error_code is 0 because selector is used *)\n    IF new stack segment not present\n        THEN #SS(error_code(NewSS,0,EXT)); FI;\n        (* idt operand to error_code is 0 because selector is used *)\n    NewSSP := IA32_PL0_SSP (* the new code-segment DPL must be 0 *)\n    IF IDT gate is 32-bit\n        THEN\n            IF new stack does not have room for 40 bytes (error code pushed)\n            or 36 bytes (no error code pushed)\n                THEN #SS(error_code(NewSS,0,EXT)); FI;\n                (* idt operand to error_code is 0 because selector is used *)\n        ELSE (* IDT gate is 16-bit)\n            IF new stack does not have room for 20 bytes (error code pushed)\n            or 18 bytes (no error code pushed)\n                THEN #SS(error_code(NewSS,0,EXT)); FI;\n                (* idt operand to error_code is 0 because selector is used *)\n    FI;\n    IF instruction pointer from IDT gate is not within new code-segment limits\n        THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n    tempEFLAGS := EFLAGS;\n    VM := 0;\n    TF := 0;\n    RF := 0;\n    NT := 0;\n    IF service through interrupt gate\n        THEN IF = 0; FI;\n    TempSS := SS;\n    TempESP := ESP;\n    SS := NewSS;\n    ESP := NewESP;\n    (* Following pushes are 16 bits for 16-bit IDT gates and 32 bits for 32-bit IDT gates;\n    Segment selector pushes in 32-bit mode are padded to two words *)\n    Push(GS);\n    Push(FS);\n    Push(DS);\n    Push(ES);\n    Push(TempSS);\n    Push(TempESP);\n    Push(TempEFlags);\n    Push(CS);\n    Push(EIP);\n    GS := 0; (* Segment registers made NULL, invalid for use in protected mode *)\n    FS := 0;\n    DS := 0;\n    ES := 0;\n    CS := Gate(CS); (* Segment descriptor information also loaded *)\n    CS(RPL) := 0;\n    CPL := 0;\n    IF IDT gate is 32-bit\n        THEN\n            EIP := Gate(instruction pointer);\n        ELSE (* IDT gate is 16-bit *)\n            EIP := Gate(instruction pointer) AND 0000FFFFH;\n    FI;\n    IF ShadowStackEnabled(0)\n        oldSSP := SSP\n        SSP := NewSSP\n        IF SSP & 0x07 != 0\n            THEN #GP(0); FI;\n        (* Token and CS:LIP:oldSSP pushed on shadow stack must be contained in a naturally aligned 32-byte region *)\n        IF (SSP & ~0x1F) != ((SSP – 24) & ~0x1F)\n            #GP(0); FI;\n    IF ((IA32_EFER.LMA and CS.L) = 0 AND SSP[63:32] != 0)\n        THEN #GP(0); FI;\n    expected_token_value = SSP (* busy bit - bit position 0 - must be clear *)\n    new_token_value = SSP | BUSY_BIT (* Set the busy bit *)\n    IF shadow_stack_lock_cmpxchg8b(SSP, new_token_value, expected_token_value) != expected_token_value\n        THEN #GP(0); FI;\n    FI;\n    IF EndbranchEnabled (CPL)\n        IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;\n        IA32_S_CET.SUPPRESS = 0\n    FI;\n(* Start execution of new routine in Protected Mode *)\nEND;\nINTRA-PRIVILEGE-LEVEL-INTERRUPT:\n    NewSSP = SSP;\n    CHECK_SS_TOKEN = 0\n    (* PE = 1, DPL = CPL or conforming segment *)\n    IF IA32_EFER.LMA = 1 (* IA-32e mode *)\n        IF IDT-descriptor IST ≠ 0\n            THEN\n                TSSstackAddress := (IDT-descriptor IST « 3) + 28;\n                IF (TSSstackAddress + 7) > TSS limit\n                        THEN #TS(error_code(current TSS selector,0,EXT)); FI;\n                        (* idt operand to error_code is 0 because selector is used *)\n                NewRSP := 8 bytes loaded from (current TSS base + TSSstackAddress);\n            ELSE NewRSP := RSP;\n        FI;\n        IF IDT-descriptor IST ≠ 0\n            IF ShadowStackEnabled(CPL)\n                THEN\n                        NewSSPAddress = IA32_INTERRUPT_SSP_TABLE_ADDR + (IDT gate IST « 3)\n                        NewSSP := 8 bytes loaded from NewSSPAddress\n                        CHECK_SS_TOKEN = 1\n            FI;\n        FI;\n    FI;\n    IF 32-bit gate (* implies IA32_EFER.LMA = 0 *)\n        THEN\n            IF current stack does not have room for 16 bytes (error code pushed)\n            or 12 bytes (no error code pushed)\n                THEN #SS(EXT); FI; (* Error code contains NULL selector *)\n        ELSE IF 16-bit gate (* implies IA32_EFER.LMA = 0 *)\n            IF current stack does not have room for 8 bytes (error code pushed)\n            or 6 bytes (no error code pushed)\n                THEN #SS(EXT); FI; (* Error code contains NULL selector *)\n        ELSE (* IA32_EFER.LMA = 1, 64-bit gate*)\n                IF NewRSP contains a non-canonical address\n                        THEN #SS(EXT); (* Error code contains NULL selector *)\n        FI;\n    FI;\n    IF (IA32_EFER.LMA = 0) (* Not IA-32e mode *)\n        THEN\n            IF instruction pointer from IDT gate is not within new code-segment limit\n                THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n        ELSE\n            IF instruction pointer from IDT gate contains a non-canonical address\n                THEN #GP(EXT); FI; (* Error code contains NULL selector *)\n            RSP := NewRSP & FFFFFFFFFFFFFFF0H;\n    FI;\n    IF IDT gate is 32-bit (* implies IA32_EFER.LMA = 0 *)\n        THEN\n            Push (EFLAGS);\n            Push (far pointer to return instruction); (* 3 words padded to 4 *)\n            CS:EIP := Gate(CS:EIP); (* Segment descriptor information also loaded *)\n            Push (ErrorCode); (* If any *)\n        ELSE\n            IF IDT gate is 16-bit (* implies IA32_EFER.LMA = 0 *)\n                THEN\n                        Push (FLAGS);\n                        Push (far pointer to return location); (* 2 words *)\n                        CS:IP := Gate(CS:IP);\n                        (* Segment descriptor information also loaded *)\n                        Push (ErrorCode); (* If any *)\n                ELSE (* IA32_EFER.LMA = 1, 64-bit gate*)\n                        Push(far pointer to old stack);\n                        (* Old SS and SP, each an 8-byte push *)\n                        Push(RFLAGS); (* 8-byte push *)\n                        Push(far pointer to return instruction);\n                        (* Old CS and RIP, each an 8-byte push *)\n                        Push(ErrorCode); (* If needed, 8 bytes *)\n                        CS:RIP := GATE(CS:RIP);\n                        (* Segment descriptor information also loaded *)\n            FI;\n    FI;\n    CS(RPL) := CPL;\n    IF ShadowStackEnabled(CPL)\n        IF CHECK_SS_TOKEN == 1\n            THEN\n                IF NewSSP & 0x07 != 0\n                        THEN #GP(0); FI;\n        (* Token and CS:LIP:oldSSP pushed on shadow stack must be contained in a naturally aligned 32-byte region *)\n        IF (NewSSP & ~0x1F) != ((NewSSP – 24) & ~0x1F)\n            #GP(0); FI;\n                IF ((IA32_EFER.LMA and CS.L) = 0 AND NewSSP[63:32] != 0)\n                        THEN #GP(0); FI;\n                expected_token_value = NewSSP (* busy bit - bit position 0 - must be clear *)\n                new_token_value = NewSSP | BUSY_BIT (* Set the busy bit *)\n                IF shadow_stack_lock_cmpxchg8b(NewSSP, new_token_value, expected_token_value) != expected_token_value\n                        THEN #GP(0); FI;\n        FI;\n        (* Align to next 8 byte boundary *)\n        tempSSP = SSP;\n        Shadow_stack_store 4 bytes of 0 to (NewSSP − 4)\n        SSP = newSSP & 0xFFFFFFFFFFFFFFF8H;\n        (* push cs:lip:ssp on shadow stack *)\n        ShadowStackPush8B(oldCS); (* Padded with 48 high-order bits of 0 *)\n        ShadowStackPush8B(oldCSBASE + oldRIP); (* Padded with 32 high-order bits of 0 for 32 bit LIP*)\n        ShadowStackPush8B(tempSSP);\n    FI;\n    IF EndbranchEnabled (CPL)\n        IF CPL = 3\n            THEN\n                IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                IA32_U_CET.SUPPRESS = 0\n            ELSE\n                IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                IA32_S_CET.SUPPRESS = 0\n        FI;\n    FI;\n    IF IDT gate is interrupt gate\n        THEN IF := 0; FI; (* Interrupt flag set to 0; interrupts disabled *)\n    TF := 0;\n    NT := 0;\n    VM := 0;\n    RF := 0;\nEND;",
    "flagsAffectedText": "The EFLAGS register is pushed onto the stack. The IF, TF, NT, AC, RF, and VM flags may be cleared, depending on the mode of operation of the processor when the INT instruction is executed (see the “Operation” section). If the interrupt uses a task gate, any flags may be set or cleared, controlled by the EFLAGS image in the new task’s TSS.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the segment selector in the 64-bit interrupt or trap gate is NULL.; \ncolumn_1: If the vector selects a descriptor outside the IDT limits.; \ncolumn_1: If the vector points to a gate which is in non-canonical space.; \ncolumn_1: If the vector points to a descriptor which is not a 64-bit interrupt gate or a 64-bit trap gate.; \ncolumn_1: If the descriptor pointed to by the gate selector is outside the descriptor table limit.; \ncolumn_1: If the descriptor pointed to by the gate selector is in non-canonical space.; \ncolumn_1: If the descriptor pointed to by the gate selector is not a code segment.; \ncolumn_1: If the descriptor pointed to by the gate selector doesn’t have the L-bit set, or has both the L-bit and D-bit set.; \ncolumn_1: If the descriptor pointed to by the gate selector has DPL > CPL.; \ncolumn_1: If SSP in IA32_PLi_SSP (where i is the new CPL) is not 8 byte aligned.; \ncolumn_1: If the token and the stack frame to be pushed on shadow stack are not contained in a naturally aligned 32-byte region of the shadow stack.; \ncolumn_1: If “supervisor shadow stack” token on new shadow stack is marked busy.; \ncolumn_1: If destination mode is 32-bit or compatibility mode, but SSP address in “supervisor shadow stack” token is beyond 4GB.; \ncolumn_1: If SSP address in “supervisor shadow stack” token does not match SSP address in IA32_PLi_SSP (where i is the new CPL).; \ncolumn_1: #SS(error_code); column_2: If a push of the old EFLAGS, CS selector, EIP, or error code is in non-canonical space with no stack switch.; \ncolumn_1: If a push of the old SS selector, ESP, EFLAGS, CS selector, EIP, or error code is in non-canonical space on a stack switch (either CPL change or no-CPL with IST).; \ncolumn_1: #NP(error_code); column_2: If the 64-bit interrupt-gate, 64-bit trap-gate, or code segment is not present.; \ncolumn_2: If an attempt to load RSP from the TSS causes an access to non-canonical space.; column_1: #TS(error_code); \ncolumn_1: If the RSP from the TSS is outside descriptor table limits.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: #AC(EXT); column_2: If alignment checking is enabled, the gate DPL is 3, and a stack push is unaligned.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the segment selector in the interrupt, trap, or task gate is NULL.; \ncolumn_1: If an interrupt, trap, or task gate, code segment, or TSS segment selector index is outside its descriptor table limits.; \ncolumn_1: If the vector selects a descriptor outside the IDT limits.; \ncolumn_1: If an IDT descriptor is not an interrupt, trap, or task gate.; \ncolumn_1: If an interrupt is generated by the INT n, INT3, or INTO instruction and the DPL of an interrupt, trap, or task gate is less than the CPL.; \ncolumn_1: If the segment selector in an interrupt or trap gate does not point to a segment descriptor for a code segment.; \ncolumn_1: If the segment selector for a TSS has its local/global bit set for local.; \ncolumn_1: If a TSS segment descriptor specifies that the TSS is busy or not available.; \ncolumn_1: If SSP in IA32_PLi_SSP (where i is the new CPL) is not 8 byte aligned.; \ncolumn_1: If the token and the stack frame to be pushed on shadow stack are not contained in a naturally aligned 32-byte region of the shadow stack.; \ncolumn_1: If “supervisor Shadow Stack” token on new shadow stack is marked busy.; \ncolumn_1: If destination mode is 32-bit or compatibility mode, but SSP address in “supervisor shadow stack” token is beyond 4GB.; \ncolumn_1: If SSP address in “supervisor shadow stack” token does not match SSP address in IA32_PLi_SSP (where i is the new CPL).; \ncolumn_1: #SS(error_code); column_2: If pushing the return address, flags, or error code onto the stack exceeds the bounds of the stack segment and no stack switch occurs.; \ncolumn_1: If the SS register is being loaded and the segment pointed to is marked not present.; \ncolumn_1: If pushing the return address, flags, error code, or stack segment pointer exceeds the bounds of the new stack segment when a stack switch occurs.; \ncolumn_2: If code segment, interrupt gate, trap gate, task gate, or TSS is not present.; column_1: #NP(error_code); \ncolumn_1: #TS(error_code); column_2: If the RPL of the stack segment selector in the TSS is not equal to the DPL of the code segment being accessed by the interrupt or trap gate.; \ncolumn_1: If DPL of the stack segment descriptor pointed to by the stack segment selector in the TSS is not equal to the DPL of the code segment descriptor for the interrupt or trap gate.; \ncolumn_1: If the stack segment selector in the TSS is NULL.; \ncolumn_1: If the stack segment for the TSS is not a writable data segment.; \ncolumn_1: If segment-selector index for stack segment is outside descriptor table limits.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: #AC(EXT); column_2: If alignment checking is enabled, the gate DPL is 3, and a stack push is unaligned.;"
      ],
      "realAddressMode": [
        "column_1: If the interrupt vector number is outside the IDT limits.; \ncolumn_1: #SS; column_2: If stack limit violation on push.; \ncolumn_1: If pushing the return address, flags, or error code onto the stack exceeds the bounds of the stack segment.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If the instruction pointer in the IDT or in the interrupt, trap, or task gate is beyond the code segment limits.; \ncolumn_1: If the segment selector in the interrupt, trap, or task gate is NULL.; \ncolumn_1: If a interrupt gate, trap gate, task gate, code segment, or TSS segment selector index is outside its descriptor table limits.; \ncolumn_1: If the vector selects a descriptor outside the IDT limits.; \ncolumn_1: If an IDT descriptor is not an interrupt, trap, or task gate.; \ncolumn_1: If an interrupt is generated by INT n, INT3, or INTO and the DPL of an interrupt, trap, or task gate is less than the CPL.; \ncolumn_1: If the segment selector in an interrupt or trap gate does not point to a segment descriptor for a code segment.; \ncolumn_1: If the segment selector for a TSS has its local/global bit set for local.; \ncolumn_1: #SS(error_code); column_2: If the SS register is being loaded and the segment pointed to is marked not present.; \ncolumn_1: If pushing the return address, flags, error code, stack segment pointer, or data segments exceeds the bounds of the stack segment.; \ncolumn_1: #NP(error_code); column_2: If code segment, interrupt gate, trap gate, task gate, or TSS is not present.; \ncolumn_1: #TS(error_code); column_2: If the RPL of the stack segment selector in the TSS is not equal to the DPL of the code segment being accessed by the interrupt or trap gate.; \ncolumn_1: If DPL of the stack segment descriptor for the TSS’s stack segment is not equal to the DPL of the code segment descriptor for the interrupt or trap gate.; \ncolumn_1: If the stack segment selector in the TSS is NULL.; \ncolumn_1: If the stack segment for the TSS is not a writable data segment.; \ncolumn_1: If segment-selector index for stack segment is outside descriptor table limits.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #OF; column_2: If the INTO instruction is executed and the OF flag is set.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_2: If alignment checking is enabled, the gate DPL is 3, and a stack push is unaligned.; column_1: #AC(EXT);"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fstcw:fnstcw",
    "category": "Core Instructions",
    "instructionName": "FSTCW/FNSTCW\n\t\t— Store x87 FPU Control Word",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.",
        "Instruction": "FSTCW m2byte",
        "Opcode": "9B D9 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions.",
        "Instruction": "FNSTCW1 m2byte",
        "Opcode": "D9 /7"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.\nThe assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "DEST := FPUControlWord;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_2: If there is a pending x87 FPU exception.; column_1: #MF; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/wrssd:wrssq",
    "category": "Core Instructions",
    "instructionName": "WRSSD/WRSSQ\n\t\t— Write to Shadow Stack",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Write 4 bytes to shadow stack.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F 38 F6 !(11):rrr:bbb WRSSD m32, r32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Write 8 bytes to shadow stack.",
        "Op/En": "MR",
        "Opcode/Instruction": "REX.W 0F 38 F6 !(11):rrr:bbb WRSSQ m64, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Writes bytes in register source to the shadow stack.",
    "operationText": "IF CPL = 3\n    IF (CR4.CET & IA32_U_CET.SH_STK_EN) = 0\n        THEN #UD; FI;\n    IF (IA32_U_CET.WR_SHSTK_EN) = 0\n        THEN #UD; FI;\nELSE\n    IF (CR4.CET & IA32_S_CET.SH_STK_EN) = 0\n        THEN #UD; FI;\n    IF (IA32_S_CET.WR_SHSTK_EN) = 0\n        THEN #UD; FI;\nFI;\nDEST_LA = Linear_Address(mem operand)\nIF (operand size is 64 bit)\n    THEN\n        (* Destination not 8B aligned *)\n        IF DEST_LA[2:0]\n            THEN GP(0); FI;\n        Shadow_stack_store 8 bytes of SRC to DEST_LA;\n    ELSE\n        (* Destination not 4B aligned *)\n        IF DEST_LA[1:0]\n            THEN GP(0); FI;\n        Shadow_stack_store 4 bytes of SRC[31:0] to DEST_LA;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: If CPL = 3 and IA32_U_CET.SH_STK_EN = 0.; \ncolumn_1: If CPL < 3 and IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: If CPL = 3 and IA32_U_CET.WR_SHSTK_EN = 0.; \ncolumn_1: If CPL < 3 and IA32_S_CET.WR_SHSTK_EN = 0.; \ncolumn_1: #GP(0); column_2: If a memory address is in a non-canonical form.; \ncolumn_1: If linear address of destination is not 4 byte aligned.; \ncolumn_2: If a page fault occurs if destination is not a user shadow stack when CPL3 and not a supervisor shadow stack when CPL < 3.; column_1: #PF(fault-code); \ncolumn_1: Other terminal and non-terminal faults.;"
      ],
      "compatibilityMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: If CPL = 3 and IA32_U_CET.SH_STK_EN = 0.; \ncolumn_1: If CPL < 3 and IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: If CPL = 3 and IA32_U_CET.WR_SHSTK_EN = 0.; \ncolumn_1: If CPL < 3 and IA32_S_CET.WR_SHSTK_EN = 0.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs if destination is not a user shadow stack when CPL3 and not a supervisor shadow stack when CPL < 3.; \ncolumn_1: Other terminal and non-terminal faults.;"
      ],
      "protectedMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: If CPL = 3 and IA32_U_CET.SH_STK_EN = 0.; \ncolumn_1: If CPL < 3 and IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: If CPL = 3 and IA32_U_CET.WR_SHSTK_EN = 0.; \ncolumn_1: If CPL < 3 and IA32_S_CET.WR_SHSTK_EN = 0.; \ncolumn_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If destination is located in a non-writeable segment.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If linear address of destination is not 4 byte aligned.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs if destination is not a user shadow stack when CPL3 and not a supervisor shadow stack when CPL < 3.; column_1: #PF(fault-code); \ncolumn_1: Other terminal and non-terminal faults.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/phminposuw",
    "category": "Core Instructions",
    "instructionName": "PHMINPOSUW\n\t\t— Packed Horizontal Word Minimum",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 41 /r PHMINPOSUW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 41 /r VPHMINPOSUW xmm1, xmm2/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Determine the minimum unsigned word value in the source operand (second operand) and place the unsigned word in the low word (bits 0-15) of the destination operand (first operand). The word index of the minimum value is stored in bits 16-18 of the destination operand. The remaining upper bits of the destination are set to zero.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding XMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination XMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.",
    "operationText": "INDEX := 0;\nMIN := SRC[15:0]\nIF (SRC[31:16] < MIN)\n    THEN INDEX := 1; MIN := SRC[31:16]; FI;\nIF (SRC[47:32] < MIN)\n    THEN INDEX := 2; MIN := SRC[47:32]; FI;\n* Repeat operation for words 3 through 6\nIF (SRC[127:112] < MIN)\n    THEN INDEX := 7; MIN := SRC[127:112]; FI;\nDEST[15:0] := MIN;\nDEST[18:16] := INDEX;\nDEST[127:19] := 0000000000000000000000000000H;\nINDEX := 0\nMIN := SRC[15:0]\nIF (SRC[31:16] < MIN) THEN INDEX := 1; MIN := SRC[31:16]\nIF (SRC[47:32] < MIN) THEN INDEX := 2; MIN := SRC[47:32]\n* Repeat operation for words 3 through 6\nIF (SRC[127:112] < MIN) THEN INDEX := 7; MIN := SRC[127:112]\nDEST[15:0] := MIN\nDEST[18:16] := INDEX\nDEST[127:19] := 0000000000000000000000000000H\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        "column_1: If VEX.vvvv ≠ 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/kandnw:kandnb:kandnq:kandnd",
    "category": "Core Instructions",
    "instructionName": "KANDNW/KANDNB/KANDNQ/KANDND\n\t\t— Bitwise Logical AND NOT Masks",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise AND NOT 16 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W0 42 /r KANDNW k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Bitwise AND NOT 8 bits masks k1 and k2 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W0 42 /r KANDNB k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise AND NOT 64 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W1 42 /r KANDNQ k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise AND NOT 32 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W1 42 /r KANDND k1, k2, k3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.1vvv (r)",
        "Operand 3": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
    "operationText": "DEST[15:0] := (BITWISE NOT SRC1[15:0]) BITWISE AND SRC2[15:0]\nDEST[MAX_KL-1:16] := 0\nDEST[7:0] := (BITWISE NOT SRC1[7:0]) BITWISE AND SRC2[7:0]\nDEST[MAX_KL-1:8] := 0\nDEST[63:0] := (BITWISE NOT SRC1[63:0]) BITWISE AND SRC2[63:0]\nDEST[MAX_KL-1:64] := 0\nDEST[31:0] := (BITWISE NOT SRC1[31:0]) BITWISE AND SRC2[31:0]\nDEST[MAX_KL-1:32] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/dpps",
    "category": "Core Instructions",
    "instructionName": "DPPS\n\t\t— Dot Product of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Selectively multiply packed single precision floating-point values from xmm1 with packed single precision floating-point values from xmm2, add and selectively store the packed single precision floating-point values or zero values to xmm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A 40 /r ib DPPS xmm1, xmm2/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply packed single precision floating-point values from xmm1 with packed single precision floating-point values from xmm2/mem selectively add and store to xmm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 40 /r ib VDPPS xmm1,xmm2, xmm3/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply packed single precision floating-point values from ymm2 with packed single precision floating-point values from ymm3/mem, selectively add pairs of elements and store to ymm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.256.66.0F3A.WIG 40 /r ib VDPPS ymm1, ymm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand) with the packed single precision floats in the source (second operand) depending on a mask extracted from the high 4 bits of the immediate byte (third operand). If a condition mask bit in imm8[7:4] is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nThe four resulting single precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the immediate byte.\nIf a broadcast mask bit is “1”, the intermediate result is copied to the corresponding dword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.\nDPPS follows the NaN forwarding rules stated in the Software Developer’s Manual, vol. 1, table 4-7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally generated NaNs will have at least one NaN propagated to the destination.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "IF (imm8[4] = 1)\n    THEN Temp1[31:0] := DEST[31:0] * SRC[31:0]; // update SIMD exception flags\n    ELSE Temp1[31:0] := +0.0; FI;\nIF (imm8[5] = 1)\n    THEN Temp1[63:32] := DEST[63:32] * SRC[63:32]; // update SIMD exception flags\n    ELSE Temp1[63:32] := +0.0; FI;\nIF (imm8[6] = 1)\n    THEN Temp1[95:64] := DEST[95:64] * SRC[95:64]; // update SIMD exception flags\n    ELSE Temp1[95:64] := +0.0; FI;\nIF (imm8[7] = 1)\n    THEN Temp1[127:96] := DEST[127:96] * SRC[127:96]; // update SIMD exception flags\n    ELSE Temp1[127:96] := +0.0; FI;\nTemp2[31:0] := Temp1[31:0] + Temp1[63:32]; // update SIMD exception flags\n/* if unmasked exception reported, execute exception handler*/\nTemp3[31:0] := Temp1[95:64] + Temp1[127:96]; // update SIMD exception flags\n/* if unmasked exception reported, execute exception handler*/\nTemp4[31:0] := Temp2[31:0] + Temp3[31:0]; // update SIMD exception flags\n/* if unmasked exception reported, execute exception handler*/\nIF (imm8[0] = 1)\n    THEN DEST[31:0] := Temp4[31:0];\n    ELSE DEST[31:0] := +0.0; FI;\nIF (imm8[1] = 1)\n    THEN DEST[63:32] := Temp4[31:0];\n    ELSE DEST[63:32] := +0.0; FI;\nIF (imm8[2] = 1)\n    THEN DEST[95:64] := Temp4[31:0];\n    ELSE DEST[95:64] := +0.0; FI;\nIF (imm8[3] = 1)\n    THEN DEST[127:96] := Temp4[31:0];\n    ELSE DEST[127:96] := +0.0; FI;\nDEST[127:0] := DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := DP_Primitive(SRC1[127:0], SRC2[127:0]);\nDEST[255:128] := DP_Primitive(SRC1[255:128], SRC2[255:128]);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal.",
        "Exceptions are determined separately for each add and multiply operation, in the order of their execution. Unmasked exceptions will leave the destination operands unchanged."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmovm2b:vpmovm2w:vpmovm2d:vpmovm2q",
    "category": "Core Instructions",
    "instructionName": "VPMOVM2B/VPMOVM2W/VPMOVM2D/VPMOVM2Q\n\t\t— Convert a Mask Register to a VectorRegister",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sets each byte in XMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 28 /r VPMOVM2B xmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sets each byte in YMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 28 /r VPMOVM2B ymm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Sets each byte in ZMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 28 /r VPMOVM2B zmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sets each word in XMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W1 28 /r VPMOVM2W xmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sets each word in YMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W1 28 /r VPMOVM2W ymm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Sets each word in ZMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W1 28 /r VPMOVM2W zmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Sets each doubleword in XMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 38 /r VPMOVM2D xmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Sets each doubleword in YMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 38 /r VPMOVM2D ymm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Sets each doubleword in ZMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 38 /r VPMOVM2D zmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Sets each quadword in XMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W1 38 /r VPMOVM2Q xmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Sets each quadword in YMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W1 38 /r VPMOVM2Q ymm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Sets each quadword in ZMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W1 38 /r VPMOVM2Q zmm1, k1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetmantss",
    "category": "Core Instructions",
    "instructionName": "VGETMANTSS\n\t\t— Extract Float32 Vector of Normalized Mantissa From Float32 Scalar",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Extract the normalized mantissa from the low float32 element of xmm3/m32 using imm8 for sign control and mantissa interval normalization, store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W0 27 /r ib VGETMANTSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/wbinvd",
    "category": "Core Instructions",
    "instructionName": "WBINVD\n\t\t— Write Back and Invalidate Cache",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Write back and flush Internal caches; initiate writing-back and flushing of external caches.",
        "Instruction": "WBINVD",
        "Op/En": "ZO",
        "Opcode": "0F 09"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Writes back all modified cache lines in the processor’s internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated.\nAfter executing this instruction, the processor does not wait for the external caches to complete their write-back and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back and flush signals. The amount of time or cycles for WBINVD to complete will vary due to size and other factors of different cache hierarchies. As a consequence, the use of the WBINVD instruction can have an impact on logical processor interrupt/event response time. Additional information of WBINVD behavior in a cache hierarchy with hierarchical sharing topology can be found in Chapter 2 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\nThe WBINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see “Serializing Instructions” in Chapter 9 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A).\nIn situations where cache coherency with main memory is not a concern, software can use the INVD instruction.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "WriteBack(InternalCaches);\nFlush(InternalCaches);\nSignalWriteBack(ExternalCaches);\nSignalFlush(ExternalCaches);\nContinue; (* Continue execution *)\nWBINVD void _wbinvd(void);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fxsave",
    "category": "Core Instructions",
    "instructionName": "FXSAVE\n\t\t— Save x87 FPU, MMX Technology, and SSE State",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.",
        "Op/En": "M",
        "Opcode/Instruction": "NP 0F AE /0 FXSAVE m512byte"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.",
        "Op/En": "M",
        "Opcode/Instruction": "NP REX.W + 0F AE /0 FXSAVE64 m512byte"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location specified in the destination operand. The content layout of the 512 byte region depends on whether the processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.\nBytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.\nThe operation of FXSAVE in non-64-bit modes is described first.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        IF REX.W = 1\n            THEN\n                DEST := Save64BitPromotedFxsave(x87 FPU, MMX, XMM15-XMM0,\n                MXCSR);\n            ELSE\n                DEST := Save64BitDefaultFxsave(x87 FPU, MMX, XMM15-XMM0, MXCSR);\n        FI;\n    ELSE\n        DEST := SaveLegacyFxsave(x87 FPU, MMX, XMM7-XMM0, MXCSR);\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: If memory operand is not aligned on a 16-byte boundary, regardless of segment.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: If CR0.EM[bit 2] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:EDX.FXSR[bit 24] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 16-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).; column_1: #AC;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand is not aligned on a 16-byte boundary, regardless of segment. (See the description of the alignment check exception [#AC] below.); \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: If CR0.EM[bit 2] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:EDX.FXSR[bit 24] = 0.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 16-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).; column_1: #AC;"
      ],
      "realAddressMode": [
        "column_1: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: If CR0.EM[bit 2] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:EDX.FXSR[bit 24] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode.",
        "column_1: #AC; column_2: For unaligned memory reference.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ltr",
    "category": "Core Instructions",
    "instructionName": "LTR\n\t\t— Load Task Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load r/m16 into task register.",
        "Instruction": "LTR r/m16",
        "Op/En": "M",
        "Opcode": "0F 00 /3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the source operand into the segment selector field of the task register. The source operand (a general-purpose register or a memory location) contains a segment selector that points to a task state segment (TSS). After the segment selector is loaded in the task register, the processor uses the segment selector to locate the segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is marked busy, but a switch to the task does not occur.\nThe LTR instruction is provided for use in operating-system software; it should not be used in application programs. It can only be executed in protected mode when the CPL is 0. It is commonly used in initialization code to establish the first task to be executed.\nThe operand-size attribute has no effect on this instruction.\nIn 64-bit mode, the operand size is still fixed at 16 bits. The instruction references a 16-byte descriptor to load the 64-bit base.",
    "operationText": "IF SRC is a NULL selector\n    THEN #GP(0);\nIF SRC(Offset) > descriptor table limit OR IF SRC(type) ≠ global\n    THEN #GP(segment selector); FI;\nRead segment descriptor;\nIF segment descriptor is not for an available TSS\n    THEN #GP(segment selector); FI;\nIF segment descriptor is not present\n    THEN #NP(segment selector); FI;\nTSSsegmentDescriptor(busy) := 1;\n(* Locked read-modify-write operation on the entire descriptor when setting busy flag *)\nTaskRegister(SegmentSelector) := SRC;\nTaskRegister(SegmentDescriptor) := TSSSegmentDescriptor;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the current privilege level is not 0.; \ncolumn_1: If the memory address is in a non-canonical form.; \ncolumn_1: If the source operand contains a NULL segment selector.; \ncolumn_1: #GP(selector); column_2: If the source selector points to a segment that is not a TSS, to a 16-bit TSS, or to a TSS for a task that is already busy.; \ncolumn_1: If the selector points to LDT or is beyond the GDT limit.; \ncolumn_1: If the descriptor type of the upper 8-byte of the 16-byte descriptor is non-zero.; \ncolumn_1: #NP(selector); column_2: If the TSS descriptor is marked not present.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode, as well as the following:",
        ""
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the source operand contains a NULL segment selector.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #GP(selector); column_2: If the source selector points to a segment that is not a TSS or to one for a task that is already busy.; \ncolumn_1: If the selector points to LDT or is beyond the GDT limit.; \ncolumn_1: #NP(selector); column_2: If the TSS descriptor is marked not present.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtph2w",
    "category": "Core Instructions",
    "instructionName": "VCVTPH2W\n\t\t— Convert Packed FP16 Values to Signed Word Integers",
    "detailsTable": [
      {
        "Description": "Convert packed FP16 values in xmm2/m128/m16bcst to signed word integers, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.W0 7D /r VCVTPH2W xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert packed FP16 values in ymm2/m256/m16bcst to signed word integers, and store the result in ymm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP5.W0 7D /r VCVTPH2W ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert packed FP16 values in zmm2/m512/m16bcst to signed word integers, and store the result in zmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP5.W0 7D /r VCVTPH2W zmm1{k1}{z}, zmm2/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xrstor",
    "category": "Core Instructions",
    "instructionName": "XRSTOR\n\t\t— Restore Processor Extended States",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "XSAVE",
        "Description": "Restore state components specified by EDX:EAX from mem.",
        "Op/En": "M",
        "Opcode / Instruction": "NP 0F AE /5 XRSTOR mem"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "XSAVE",
        "Description": "Restore state components specified by EDX:EAX from mem.",
        "Op/En": "M",
        "Opcode / Instruction": "NP REX.W + 0F AE /5 XRSTOR64 mem"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\nThe format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nSection 13.8, “Operation of XRSTOR,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a highlevel outline:\nUse of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\nSee Section 13.6, “Processor Tracking of XSAVE-Managed State,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for discussion of the bitmaps XINUSE and XMODIFIED and of the quantity XRSTOR_INFO.",
    "operationText": "RFBM := XCR0 AND EDX:EAX; /* bitwise logical AND */\nCOMPMASK := XCOMP_BV field from XSAVE header;\nRSTORMASK := XSTATE_BV field from XSAVE header;\nIF COMPMASK[63] = 0\n    THEN\n        /* Standard form of XRSTOR */\n        TO_BE_RESTORED := RFBM AND RSTORMASK;\n        TO_BE_INITIALIZED := RFBM AND NOT RSTORMASK;\n        IF TO_BE_RESTORED[0] = 1\n            THEN\n                XINUSE[0] := 1;\n                load x87 state from legacy region of XSAVE area;\n        ELSIF TO_BE_INITIALIZED[0] = 1\n            THEN\n                XINUSE[0] := 0;\n                initialize x87 state;\n        FI;\n        IF RFBM[1] = 1 OR RFBM[2] = 1\n            THEN load MXCSR from legacy region of XSAVE area;\n        FI;\n        IF TO_BE_RESTORED[1] = 1\n            THEN\n                XINUSE[1] := 1;\n                load XMM registers from legacy region of XSAVE area; // this step does not load MXCSR\n        ELSIF TO_BE_INITIALIZED[1] = 1\n            THEN\n                XINUSE[1] := 0;\n                set all XMM registers to 0; // this step does not initialize MXCSR\n        FI;\n        FOR i := 2 TO 62\n            IF TO_BE_RESTORED[i] = 1\n                THEN\n                    XINUSE[i] := 1;\n                    load XSAVE state component i at offset n from base of XSAVE area;\n                        // n enumerated by CPUID(EAX=0DH,ECX=i):EBX)\n            ELSIF TO_BE_INITIALIZED[i] = 1\n                THEN\n                    XINUSE[i] := 0;\n                    initialize XSAVE state component i;\n            FI;\n        ENDFOR;\n    ELSE\n        /* Compacted form of XRSTOR */\n        IF CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit 1] = 0\n            THEN /* compacted form not supported */\n                #GP(0);\n        FI;\n        FORMAT = COMPMASK AND 7FFFFFFF_FFFFFFFFH;\n        RESTORE_FEATURES = FORMAT AND RFBM;\n        TO_BE_RESTORED := RESTORE_FEATURES AND RSTORMASK;\n        FORCE_INIT := RFBM AND NOT FORMAT;\n        TO_BE_INITIALIZED = (RFBM AND NOT RSTORMASK) OR FORCE_INIT;\n        IF TO_BE_RESTORED[0] = 1\n            THEN\n                XINUSE[0] := 1;\n                load x87 state from legacy region of XSAVE area;\n        ELSIF TO_BE_INITIALIZED[0] = 1\n            THEN\n                XINUSE[0] := 0;\n                initialize x87 state;\n        FI;\n        IF TO_BE_RESTORED[1] = 1\n            THEN\n                XINUSE[1] := 1;\n                load SSE state from legacy region of XSAVE area; // this step loads the XMM registers and MXCSR\n        ELSIF TO_BE_INITIALIZED[1] = 1\n            THEN\n                set all XMM registers to 0;\n                XINUSE[1] := 0;\n                MXCSR := 1F80H;\n        FI;\n        NEXT_FEATURE_OFFSET = 576;\n                                // Legacy area and XSAVE header consume 576 bytes\n        FOR i := 2 TO 62\n            IF FORMAT[i] = 1\n                THEN\n                    IF TO_BE_RESTORED[i] = 1\n                        THEN\n                            XINUSE[i] := 1;\n                            load XSAVE state component i at offset NEXT_FEATURE_OFFSET from base of XSAVE area;\n                    FI;\n                    NEXT_FEATURE_OFFSET = NEXT_FEATURE_OFFSET + n (n enumerated by CPUID(EAX=0DH,ECX=i):EAX);\n            FI;\n            IF TO_BE_INITIALIZED[i] = 1\n                THEN\n                    XINUSE[i] := 0;\n                    initialize XSAVE state component i;\n            FI;\n        ENDFOR;\nFI;\nXMODIFIED := NOT RFBM;\nIF in VMX non-root operation\n    THEN VMXNR := 1;\n    ELSE VMXNR := 0;\nFI;\nLAXA := linear address of XSAVE area;\nXRSTOR_INFO := CPL,VMXNR,LAXA,COMPMASK;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: If bit 63 of the XCOMP_BV field of the XSAVE header is 1 and CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit 1] = 0.; \ncolumn_1: If the standard form is executed and a bit in XCR0 is 0 and the corresponding bit in the XSTATE_BV field of the XSAVE header is 1.; \ncolumn_1: If the standard form is executed and bytes 23:8 of the XSAVE header are not all zero.; \ncolumn_1: If the compacted form is executed and a bit in XCR0 is 0 and the corresponding bit in the XCOMP_BV field of the XSAVE header is 1.; \ncolumn_1: If the compacted form is executed and a bit in the XCOMP_BV field in the XSAVE header is 0 and the corresponding bit in the XSTATE_BV field is 1.; \ncolumn_1: If the compacted form is executed and bytes 63:16 of the XSAVE header are not all zero.; \ncolumn_1: If attempting to write any reserved bits of the MXCSR register with 1.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #AC; column_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 64-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: If bit 63 of the XCOMP_BV field of the XSAVE header is 1 and CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit 1] = 0.; \ncolumn_1: If the standard form is executed and a bit in XCR0 is 0 and the corresponding bit in the XSTATE_BV field of the XSAVE header is 1.; \ncolumn_1: If the standard form is executed and bytes 23:8 of the XSAVE header are not all zero.; \ncolumn_1: If the compacted form is executed and a bit in XCR0 is 0 and the corresponding bit in the XCOMP_BV field of the XSAVE header is 1.; \ncolumn_1: If the compacted form is executed and a bit in the XCOMP_BV field in the XSAVE header is 0 and the corresponding bit in the XSTATE_BV field is 1.; \ncolumn_1: If the compacted form is executed and bytes 63:16 of the XSAVE header are not all zero.; \ncolumn_1: If attempting to write any reserved bits of the MXCSR register with 1.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #AC; column_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 64-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).;"
      ],
      "realAddressMode": [
        "column_1: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: If bit 63 of the XCOMP_BV field of the XSAVE header is 1 and CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit 1] = 0.; \ncolumn_1: If the standard form is executed and a bit in XCR0 is 0 and the corresponding bit in the XSTATE_BV field of the XSAVE header is 1.; \ncolumn_1: If the standard form is executed and bytes 23:8 of the XSAVE header are not all zero.; \ncolumn_1: If the compacted form is executed and a bit in XCR0 is 0 and the corresponding bit in the XCOMP_BV field of the XSAVE header is 1.; \ncolumn_1: If the compacted form is executed and a bit in the XCOMP_BV field in the XSAVE header is 0 and the corresponding bit in the XSTATE_BV field is 1.; \ncolumn_1: If the compacted form is executed and bytes 63:16 of the XSAVE header are not all zero.; \ncolumn_1: If attempting to write any reserved bits of the MXCSR register with 1.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movhlps",
    "category": "Core Instructions",
    "instructionName": "MOVHLPS\n\t\t— Move Packed Single Precision Floating-Point Values High to Low",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move two packed single precision floating-point values from high quadword of xmm2 to low quadword of xmm1.",
        "Op / En": "RM",
        "Opcode/Instruction": "NP 0F 12 /r MOVHLPS xmm1, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge two packed single precision floating-point values from high quadword of xmm3 and low quadword of xmm2.",
        "Op / En": "RVM",
        "Opcode/Instruction": "VEX.128.0F.WIG 12 /r VMOVHLPS xmm1, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Merge two packed single precision floating-point values from high quadword of xmm3 and low quadword of xmm2.",
        "Op / En": "RVM",
        "Opcode/Instruction": "EVEX.128.0F.W0 12 /r VMOVHLPS xmm1, xmm2, xmm3"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "This instruction cannot be used for memory to register moves.\n128-bit two-argument form:\nMoves two packed single precision floating-point values from the high quadword of the second XMM argument (second operand) to the low quadword of the first XMM register (first argument). The quadword at bits 127:64 of the destination operand is left unchanged. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\n128-bit and EVEX three-argument form:\nMoves two packed single precision floating-point values from the high quadword of the third XMM argument (third operand) to the low quadword of the destination (first operand). Copies the high quadword from the second XMM argument (second operand) to the high quadword of the destination (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nIf VMOVHLPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception.",
    "operationText": "DEST[63:0] := SRC[127:64]\nDEST[MAXVL-1:64] (Unmodified)\nDEST[63:0] := SRC2[127:64]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-24, “Type 7 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Exceptions Type E7NM.128 in Table 2-55, “Type E7NM Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpshldv",
    "category": "Core Instructions",
    "instructionName": "VPSHLDV\n\t\t— Concatenate and Variable Shift Packed Data Left Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 70 /r VPSHLDVW xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 70 /r VPSHLDVW ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 70 /r VPSHLDVW zmm1{k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 71 /r VPSHLDVD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 71 /r VPSHLDVD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 71 /r VPSHLDVD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate xmm1 and xmm2, extract result shifted to the left by value in xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 71 /r VPSHLDVQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate ymm1 and ymm2, extract result shifted to the left by value in xmm3/m256 into ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 71 /r VPSHLDVQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate zmm1 and zmm2, extract result shifted to the left by value in zmm3/m512 into zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 71 /r VPSHLDVQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/psubusb:psubusw",
    "category": "Core Instructions",
    "instructionName": "PSUBUSB/PSUBUSW\n\t\t— Subtract Packed Unsigned Integers With Unsigned Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F D8 /r1 PSUBUSB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F D8 /r PSUBUSB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F D9 /r1 PSUBUSW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F D9 /r PSUBUSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D8 /r VPSUBUSB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D9 /r VPSUBUSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D8 /r VPSUBUSB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D9 /r VPSUBUSW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2, saturate results and store in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG D8 /r VPSUBUSB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2, saturate results and store in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG D8 /r VPSUBUSB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Subtract packed unsigned byte integers in zmm3/m512 from packed unsigned byte integers in zmm2, saturate results and store in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG D8 /r VPSUBUSB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate results and store in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG D9 /r VPSUBUSW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2, saturate results and store in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG D9 /r VPSUBUSW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Subtract packed unsigned word integers in zmm3/m512 from packed unsigned word integers in zmm2, saturate results and store in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG D9 /r VPSUBUSW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.\nThese instructions can operate on either 64-bit or 128-bit operands.\nThe (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.\nThe (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
    "operationText": "DEST[7:0] := SaturateToUnsignedByte (DEST[7:0] − SRC (7:0] );\n(* Repeat add operation for 2nd through 7th bytes *)\nDEST[63:56] := SaturateToUnsignedByte (DEST[63:56] − SRC[63:56];\nDEST[15:0] := SaturateToUnsignedWord (DEST[15:0] − SRC[15:0] );\n(* Repeat add operation for 2nd and 3rd words *)\nDEST[63:48] := SaturateToUnsignedWord (DEST[63:48] − SRC[63:48] );\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8;\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := SaturateToUnsignedByte (SRC1[i+7:i] - SRC2[i+7:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] := 0;\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0;\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16;\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SaturateToUnsignedWord (SRC1[i+15:i] - SRC2[i+15:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0;\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0;\nDEST[7:0] := SaturateToUnsignedByte (SRC1[7:0] - SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 31st bytes *)\nDEST[255:148] := SaturateToUnsignedByte (SRC1[255:248] - SRC2[255:248]);\nDEST[MAXVL-1:256] := 0;\nDEST[7:0] := SaturateToUnsignedByte (SRC1[7:0] - SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 14th bytes *)\nDEST[127:120] := SaturateToUnsignedByte (SRC1[127:120] - SRC2[127:120]);\nDEST[MAXVL-1:128] := 0\nDEST[7:0] := SaturateToUnsignedByte (DEST[7:0] - SRC[7:0]);\n(* Repeat subtract operation for 2nd through 14th bytes *)\nDEST[127:120] := SaturateToUnsignedByte (DEST[127:120] - SRC[127:120]);\nDEST[MAXVL-1:128] (Unmodified)\nDEST[15:0] := SaturateToUnsignedWord (SRC1[15:0] - SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 15th words *)\nDEST[255:240] := SaturateToUnsignedWord (SRC1[255:240] - SRC2[255:240]);\nDEST[MAXVL-1:256] := 0;\nDEST[15:0] := SaturateToUnsignedWord (SRC1[15:0] - SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 7th words *)\nDEST[127:112] := SaturateToUnsignedWord (SRC1[127:112] - SRC2[127:112]);\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := SaturateToUnsignedWord (DEST[15:0] - SRC[15:0]);\n(* Repeat subtract operation for 2nd through 7th words *)\nDEST[127:112] := SaturateToUnsignedWord (DEST[127:112] - SRC[127:112]);\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpconflictd:vpconflictq",
    "category": "Core Instructions",
    "instructionName": "VPCONFLICTD/VPCONFLICTQ\n\t\t— Detect Conflicts Within a Vector of Packed Dword/Qword Values Into DenseMemory/ Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Detect duplicate double-word values in xmm2/m128/m32bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 C4 /r VPCONFLICTD xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Detect duplicate double-word values in ymm2/m256/m32bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 C4 /r VPCONFLICTD ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512CD",
        "Description": "Detect duplicate double-word values in zmm2/m512/m32bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C4 /r VPCONFLICTD zmm1 {k1}{z}, zmm2/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Detect duplicate quad-word values in xmm2/m128/m64bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 C4 /r VPCONFLICTQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Detect duplicate quad-word values in ymm2/m256/m64bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 C4 /r VPCONFLICTQ ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512CD",
        "Description": "Detect duplicate quad-word values in zmm2/m512/m64bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C4 /r VPCONFLICTQ zmm1 {k1}{z}, zmm2/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cbw:cwde:cdqe",
    "category": "Core Instructions",
    "instructionName": "CBW/CWDE/CDQE\n\t\t— Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword toQuadword",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AX := sign-extend of AL.",
        "Instruction": "CBW",
        "Op/En": "ZO",
        "Opcode": "98"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "EAX := sign-extend of AX.",
        "Instruction": "CWDE",
        "Op/En": "ZO",
        "Opcode": "98"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "RAX := sign-extend of EAX.",
        "Instruction": "CDQE",
        "Op/En": "ZO",
        "Opcode": "REX.W + 98"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.\nCBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.\nIn 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX.",
    "operationText": "IF OperandSize = 16 (* Instruction = CBW *)\n    THEN\n        AX := SignExtend(AL);\n    ELSE IF (OperandSize = 32, Instruction = CWDE)\n        EAX := SignExtend(AX); FI;\n    ELSE (* 64-Bit Mode, OperandSize = 64, Instruction = CDQE*)\n        RAX := SignExtend(EAX);\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsub132sd:vfmsub213sd:vfmsub231sd",
    "category": "Core Instructions",
    "instructionName": "VFMSUB132SD/VFMSUB213SD/VFMSUB231SD\n\t\t— Fused Multiply-Subtract of Scalar DoublePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 9B /r VFMSUB132SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 AB /r VFMSUB213SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 BB /r VFMSUB231SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 9B /r VFMSUB132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 AB /r VFMSUB213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 BB /r VFMSUB231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/etrack",
    "category": "SGX Instructions",
    "instructionName": "ETRACK\n\t\t— Activates EBLOCK Checks",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function activates EBLOCK checks.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 0CH ENCLS[ETRACK]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "ETRACK (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Pointer to the SECS of the EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmclear",
    "category": "VMX Instructions",
    "instructionName": "VMCLEAR\n\t\t— Clear Virtual-Machine Control Structure",
    "detailsTable": [
      {
        "Description": "Copy VMCS data to VMCS region in memory.",
        "Op/En": "M",
        "Opcode/Instruction": "66 0F C7 /6 VMCLEAR m64"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "M",
        "column_2": "ModRM:r/m (r)",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "This instruction applies to the VMCS whose VMCS region resides at the physical address contained in the instruction operand. The instruction ensures that VMCS data for that VMCS (some of these data may be currently maintained on the processor) are copied to the VMCS region in memory. It also initializes parts of the VMCS region (for example, it sets the launch state of that VMCS to clear). See Chapter 25, “Virtual Machine Control Structures.”\nThe operand of this instruction is always 64 bits and is always in memory. If the operand is the current-VMCS pointer, then that pointer is made invalid (set to FFFFFFFF_FFFFFFFFH).\nNote that the VMCLEAR instruction might not explicitly write any VMCS data to memory; the data may be already resident in memory before the VMCLEAR is executed.",
    "operationText": "IF (register operand) or (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation\n    THEN VM exit;\nELSIF CPL > 0\n    THEN #GP(0);\n    ELSE\n        addr := contents of 64-bit in-memory operand;\n        IF addr is not 4KB-aligned OR\n        addr sets any bits beyond the physical-address width1\n            THEN VMfail(VMCLEAR with invalid physical address);\n        ELSIF addr = VMXON pointer\n            THEN VMfail(VMCLEAR with VMXON pointer);\n            ELSE\n                ensure that data for VMCS referenced by the operand is in memory;\n                initialize implementation-specific data in VMCS region;\n                launch state of VMCS referenced by the operand := “clear”\n                IF operand addr = current-VMCS pointer\n                    THEN current-VMCS pointer := FFFFFFFF_FFFFFFFFH;\n                FI;\n                VMsucceed;\n        FI;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the source operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory operand.; \ncolumn_1: #SS(0); column_2: If the source operand is in the SS segment and the memory address is in a non-canonical form.; \ncolumn_1: #UD; column_2: If operand is a register.; \ncolumn_1: If not in VMX operation.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the operand is located in an execute-only code segment.; \ncolumn_2: If a page fault occurs in accessing the memory operand.; column_1: #PF(fault-code); \ncolumn_1: #SS(0); column_2: If the memory operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_1: #UD; column_2: If operand is a register.; \ncolumn_1: If not in VMX operation.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/wrussd:wrussq",
    "category": "Core Instructions",
    "instructionName": "WRUSSD/WRUSSQ\n\t\t— Write to User Shadow Stack",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Write 4 bytes to shadow stack.",
        "Op/En": "MR",
        "Opcode/Instruction": "66 0F 38 F5 !(11):rrr:bbb WRUSSD m32, r32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Write 8 bytes to shadow stack.",
        "Op/En": "MR",
        "Opcode/Instruction": "66 REX.W 0F 38 F5 !(11):rrr:bbb WRUSSQ m64, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Writes bytes in register source to a user shadow stack page. The WRUSS instruction can be executed only if CPL = 0, however the processor treats its shadow-stack accesses as user accesses.",
    "operationText": "IF CR4.CET = 0\n    THEN #UD; FI;\nIF CPL > 0\n    THEN #GP(0); FI;\nDEST_LA = Linear_Address(mem operand)\nIF (operand size is 64 bit)\n    THEN\n        (* Destination not 8B aligned *)\n        IF DEST_LA[2:0]\n            THEN GP(0); FI;\n        Shadow_stack_store 8 bytes of SRC to DEST_LA as user-mode access;\n    ELSE\n        (* Destination not 4B aligned *)\n        IF DEST_LA[1:0]\n            THEN GP(0); FI;\n        Shadow_stack_store 4 bytes of SRC[31:0] to DEST_LA as user-mode access;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: #GP(0); column_2: If a memory address is in a non-canonical form.; \ncolumn_1: If linear address of destination is not 4 byte aligned.; \ncolumn_1: If CPL is not 0.; \ncolumn_1: #PF(fault-code); column_2: If destination is not a user shadow stack.; \ncolumn_1: Other terminal and non-terminal faults.;"
      ],
      "compatibilityMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: #GP(0); column_2: If a memory address is in a non-canonical form.; \ncolumn_1: If linear address of destination is not 4 byte aligned.; \ncolumn_1: If CPL is not 0.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If destination is not a user shadow stack.; \ncolumn_1: Other terminal and non-terminal faults.;"
      ],
      "protectedMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; column_1: #GP(0); \ncolumn_1: If destination is located in a non-writeable segment.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If linear address of destination is not 4 byte aligned.; \ncolumn_1: If CPL is not 0.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If destination is not a user shadow stack.; \ncolumn_1: Other terminal and non-terminal faults.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtps2uqq",
    "category": "Core Instructions",
    "instructionName": "VCVTPS2UQQ\n\t\t— Convert Packed Single Precision Floating-Point Values to Packed UnsignedQuadword Integer Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed single precision floating-point values from zmm2/m64/m32bcst to two packed unsigned quadword values in zmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 79 /r VCVTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 79 /r VCVTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 79 /r VCVTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vshuff32x4:vshuff64x2:vshufi32x4:vshufi64x2",
    "category": "Core Instructions",
    "instructionName": "VSHUFF32x4/VSHUFF64x2/VSHUFI32x4/VSHUFI64x2\n\t\t— Shuffle Packed Values at 128-BitGranularity",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shuffle 128-bit packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/m256/m32bcst and place results in ymm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 23 /r ib VSHUFF32X4 ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shuffle 128-bit packed single-precision floating-point values selected by imm8 from zmm2 and zmm3/m512/m32bcst and place results in zmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 23 /r ib VSHUFF32x4 zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shuffle 128-bit packed double precision floating-point values selected by imm8 from ymm2 and ymm3/m256/m64bcst and place results in ymm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 23 /r ib VSHUFF64X2 ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shuffle 128-bit packed double precision floating-point values selected by imm8 from zmm2 and zmm3/m512/m64bcst and place results in zmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 23 /r ib VSHUFF64x2 zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shuffle 128-bit packed double-word values selected by imm8 from ymm2 and ymm3/m256/m32bcst and place results in ymm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 43 /r ib VSHUFI32X4 ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shuffle 128-bit packed double-word values selected by imm8 from zmm2 and zmm3/m512/m32bcst and place results in zmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 43 /r ib VSHUFI32x4 zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shuffle 128-bit packed quad-word values selected by imm8 from ymm2 and ymm3/m256/m64bcst and place results in ymm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 43 /r ib VSHUFI64X2 ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shuffle 128-bit packed quad-word values selected by imm8 from zmm2 and zmm3/m512/m64bcst and place results in zmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 43 /r ib VSHUFI64x2 zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fcos",
    "category": "Core Instructions",
    "instructionName": "FCOS\n\t\t— Cosine",
    "detailsTable": [
      {
        "Description": "Replace ST(0) with its approximate cosine.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 FF",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes the approximate cosine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −263 to +263. The following table shows the results obtained when taking the cosine of various classes of numbers.\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range − 263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π. However, even within the range -263 to +263, inaccurate results can occur because the finite approximation of π used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply FCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3π/8. See the sections titled “Approximation of Pi” and “Transcendental Instruction Accuracy” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a discussion of the proper value to use for π in performing such reductions.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF |ST(0)| < 263\nTHEN\n    C2 := 0;\n    ST(0) := FCOS(ST(0)); // approximation of cosine\nELSE (* Source operand is out-of-range *)\n    C2 := 1;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value, ∞, or unsupported format.; \ncolumn_1: #D; column_2: Source is a denormal value.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/prefetchwt1",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "PREFETCHWT1\n\t\t— Prefetch Vector Data Into Caches With Intent to Write and T1 Hint",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "PREFETCHWT1",
        "Description": "Move data from m8 closer to the processor using T1 hint with intent to write.",
        "Op/En": "M",
        "Opcode/Instruction": "0F 0D /2 PREFETCHWT1 m8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Operand 1 Operand 2 Operand 3 Operand 4": "M ModRM:r/m (r) N/A N/A N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": ""
      }
    ],
    "descriptionText": "Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by an intent to write hint (so that data is brought into ‘Exclusive’ state via a request for ownership) and a locality hint:\nThe source operand is a byte memory location. (The locality hints are encoded into the machine level instruction using bits 3 through 5 of the ModR/M byte. Use of any ModR/M value other than the specified ones will lead to unpredictable behavior.)\nIf the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\nThe PREFETCHWT1 instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor in anticipation of future use.\nThe implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes. Additional details of the implementation-dependent locality hints are described in Section 9.5, “Memory Optimization Using Prefetch” of the Intel® 64 and IA-32 Architectures Optimization Reference Manual.\nIt should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A PREFETCHWT1 instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHWT1 instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHWT1 instruction is also unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHWT1 instructions, or any other general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "PREFETCH(mem, Level, State) Prefetches a byte memory location pointed by ‘mem’ into the cache level specified by ‘Level’; a request\nfor exclusive/ownership is done if ‘State’ is 1. Note that the memory location ignore cache line splits. This operation is considered a\nhint for the processor and may be skipped depending on implementation.\nPrefetch (m8, Level = 1, EXCLUSIVE=1);",
    "flagsAffectedText": "All flags are affected.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sttilecfg",
    "category": "Core Instructions",
    "instructionName": "STTILECFG\n\t\t— Store Tile Configuration",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-TILE",
        "Description": "Store tile configuration in m512.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 49 !(11):000:bbb STTILECFG m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The STTILECFG instruction takes a pointer to a 64-byte memory location (described in Table 3-10 in the “LDTILECFG—Load Tile Configuration” entry) that will, after successful execution of this instruction, contain the description of the tiles that were configured. In order to configure tiles, the AMX-TILE bit in CPUID must be set and the operating system has to have enabled the tiles architecture.\nIf the tiles are not configured, then STTILECFG stores 64B of zeros to the indicated memory location.\nAny attempt to execute the STTILECFG instruction inside an Intel TSX transaction will result in a transaction abort.",
    "operationText": "if TILES_CONFIGURED == 0:\n    //write 64 bytes of zeros at mem pointer\n    buf[0..63] := 0\n    write_memory(mem, 64, buf)\nelse:\n    buf.byte[0] := tilecfg.palette_id\n    buf.byte[1] := tilecfg.start_row\n    buf.byte[2..15] := 0\n    p := 16\n    for n in 0 ... palette_table[tilecfg.palette_id].max_names-1:\n        buf.word[p/2] := tilecfg.t[n].colsb\n        p := p + 2\n    if p < 47:\n        buf.byte[p..47] := 0\n    p := 48\n    for n in 0 ... palette_table[tilecfg.palette_id].max_names-1:\n        buf.byte[p++] := tilecfg.t[n].rows\n    if p < 63:\n        buf.byte[p..63] := 0\n    write_memory(mem, 64, buf)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "AMX-E2; see Section 2.10, “Intel® AMX Instruction Exception Classes,” for details."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ucomisd",
    "category": "Core Instructions",
    "instructionName": "UCOMISD\n\t\t— Unordered Compare Scalar Double Precision Floating-Point Values and Set EFLAGS",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 2E /r UCOMISD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F.WIG 2E /r VUCOMISD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare low double precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS flags accordingly.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F.W1 2E /r VUCOMISD xmm1, xmm2/m64{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Performs an unordered compare of the double precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory\nlocation.\nThe UCOMISD instruction differs from the COMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) only when a source operand is an SNaN. The COMISD instruction signals an invalid operation exception only if a source operand is either an SNaN or a QNaN.\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "RESULT := UnorderedCompare(DEST[63:0] <> SRC[63:0]) {\n(* Set EFLAGS *) CASE (RESULT) OF\n    UNORDERED: ZF,PF,CF := 111;\n    GREATER_THAN: ZF,PF,CF := 000;\n    LESS_THAN: ZF,PF,CF := 001;\n    EQUAL: ZF,PF,CF := 100;\nESAC;\nOF, AF, SF := 0; }",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (if SNaN operands), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/frndint",
    "category": "Core Instructions",
    "instructionName": "FRNDINT\n\t\t— Round to Integer",
    "detailsTable": [
      {
        "Description": "Round ST(0) to an integer.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 FC",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding mode (setting of the RC field of the FPU control word), and stores the result in ST(0).\nIf the source value is ∞, the value is not changed. If the source value is not an integral value, the floating-point inexact-result exception (#P) is generated.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "ST(0) := RoundToIntegralValue(ST(0));",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value or unsupported format.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_1: #P; column_2: Source operand is not an integral value.;"
      ],
      "protectedMode": [
        "column_2: If there is a pending x87 FPU exception.; column_1: #MF; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtdq2pd",
    "category": "Core Instructions",
    "instructionName": "CVTDQ2PD\n\t\t— Convert Packed Doubleword Integers to Packed Double Precision Floating-PointValues",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert two packed signed doubleword integers from xmm2/mem to two packed double precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F E6 /r CVTDQ2PD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert two packed signed doubleword integers from xmm2/mem to two packed double precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F.WIG E6 /r VCVTDQ2PD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert four packed signed doubleword integers from xmm2/mem to four packed double precision floating-point values in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.F3.0F.WIG E6 /r VCVTDQ2PD ymm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert 2 packed signed doubleword integers from xmm2/m64/m32bcst to eight packed double precision floating-point values in xmm1 with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.F3.0F.W0 E6 /r VCVTDQ2PD xmm1 {k1}{z}, xmm2/m64/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert 4 packed signed doubleword integers from xmm2/m128/m32bcst to 4 packed double precision floating-point values in ymm1 with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.F3.0F.W0 E6 /r VCVTDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed double precision floating-point values in zmm1 with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.F3.0F.W0 E6 /r VCVTDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half"
      }
    ],
    "descriptionText": "Converts two, four or eight packed signed doubleword integers in the source operand (the second operand) to two, four or eight packed double precision floating-point values in the destination operand (the first operand).\nEVEX encoded versions: The source operand can be a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. Attempt to encode this instruction with EVEX embedded rounding is ignored.\nVEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a YMM register.\nVEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    k := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] :=\n            Convert_Integer_To_Double_Precision_Floating_Point(SRC[k+31:k])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    k := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+63:i] :=\n            Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0])\n                ELSE\n                    DEST[i+63:i] :=\n            Convert_Integer_To_Double_Precision_Floating_Point(SRC[k+31:k])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[191:128] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[95:64])\nDEST[255:192] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[127:96)\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[MAXVL-1:128] (unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-51, “Type E5 Class Exception Conditions.”",
        "Additionally:",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/bsf",
    "category": "Core Instructions",
    "instructionName": "BSF\n\t\t— Bit Scan Forward",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Bit scan forward on r/m16.",
        "Instruction": "BSF r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F BC /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Bit scan forward on r/m32.",
        "Instruction": "BSF r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F BC /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Bit scan forward on r/m64.",
        "Instruction": "BSF r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F BC /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content of the source operand is 0, the content of the destination operand is undefined.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF SRC = 0\n    THEN\n        ZF := 1;\n        DEST is undefined;\n    ELSE\n        ZF := 0;\n        temp := 0;\n        WHILE Bit(SRC, temp) = 0\n        DO\n            temp := temp + 1;\n        OD;\n        DEST := temp;\nFI;",
    "flagsAffectedText": "The ZF flag is set to 1 if the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/kxnorw:kxnorb:kxnorq:kxnord",
    "category": "Core Instructions",
    "instructionName": "KXNORW/KXNORB/KXNORQ/KXNORD\n\t\t— Bitwise Logical XNOR Masks",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise XNOR 16-bit masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W0 46 /r KXNORW k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Bitwise XNOR 8-bit masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W0 46 /r KXNORB k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise XNOR 64-bit masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W1 46 /r KXNORQ k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise XNOR 32-bit masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W1 46 /r KXNORD k1, k2, k3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.1vvv (r)",
        "Operand 3": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
    "operationText": "DEST[15:0] := NOT (SRC1[15:0] BITWISE XOR SRC2[15:0])\nDEST[MAX_KL-1:16] := 0\nDEST[7:0] := NOT (SRC1[7:0] BITWISE XOR SRC2[7:0])\nDEST[MAX_KL-1:8] := 0\nDEST[63:0] := NOT (SRC1[63:0] BITWISE XOR SRC2[63:0])\nDEST[MAX_KL-1:64] := 0\nDEST[31:0] := NOT (SRC1[31:0] BITWISE XOR SRC2[31:0])\nDEST[MAX_KL-1:32] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/encls",
    "category": "SGX Instructions",
    "instructionName": "ENCLS\n\t\t— Execute an Enclave System Function of Specified Leaf Number",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "NA",
        "Description": "This instruction is used to execute privileged Intel SGX leaf functions that are used for managing and debugging the enclaves.",
        "Op/En": "ZO",
        "Opcode/Instruction": "NP 0F 01 CF ENCLS"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "ZO",
        "column_2": "NA",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "See Section 38.3"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pcmpeqq",
    "category": "Core Instructions",
    "instructionName": "PCMPEQQ\n\t\t— Compare Packed Qword Data for Equal",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed qwords in xmm2/m128 and xmm1 for equality.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 29 /r PCMPEQQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed quadwords in xmm3/m128 and xmm2 for equality.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 29 /r VPCMPEQQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed quadwords in ymm3/m256 and ymm2 for equality.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 29 /r VPCMPEQQ ymm1, ymm2, ymm3 /m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare Equal between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 29 /r VPCMPEQQ k1 {k2}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare Equal between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 29 /r VPCMPEQQ k1 {k2}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare Equal between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 29 /r VPCMPEQQ k1 {k2}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX encoded VPCMPEQQ: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
    "operationText": "IF (DEST[63:0] = SRC[63:0])\n    THEN DEST[63:0] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[63:0] := 0; FI;\nIF (DEST[127:64] = SRC[127:64])\n    THEN DEST[127:64] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[127:64] := 0; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[63:0] = SRC2[63:0]\nTHEN DEST[63:0] := FFFFFFFFFFFFFFFFH;\nELSE DEST[63:0] := 0; FI;\nIF SRC1[127:64] = SRC2[127:64]\nTHEN DEST[127:64] := FFFFFFFFFFFFFFFFH;\nELSE DEST[127:64] := 0; FI;\nDEST[127:0] := COMPARE_QWORDS_EQUAL(SRC1,SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := COMPARE_QWORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[255:128] := COMPARE_QWORDS_EQUAL(SRC1[255:128],SRC2[255:128])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k2[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN CMP := SRC1[i+63:i] = SRC2[63:0];\n                ELSE CMP := SRC1[i+63:i] = SRC2[i+63:i];\n            FI;\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                    ; zeroing-masking only\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPCMPEQQ, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cldemote",
    "category": "Core Instructions",
    "instructionName": "CLDEMOTE\n\t\t— Cache Line Demote",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CLDEMOTE",
        "Description": "Hint to hardware to move the cache line containing m8 to a more distant level of the cache without writing back to memory.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 1C /0 CLDEMOTE m8"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Hints to hardware that the cache line that contains the linear address specified with the memory operand should be moved (“demoted”) from the cache(s) closest to the processor core to a level more distant from the processor core. This may accelerate subsequent accesses to the line by other cores in the same coherence domain, especially if the line was written by the core that demotes the line. Moving the line in such a manner is a performance optimization, i.e., it is a hint which does not modify architectural state. Hardware may choose which level in the cache hierarchy to retain the line (e.g., L3 in typical server designs). The source operand is a byte memory location.\nThe availability of the CLDEMOTE instruction is indicated by the presence of the CPUID feature flag CLDEMOTE (bit 25 of the ECX register in sub-leaf 07H, see “CPUID—CPU Identification”). On processors which do not support the CLDEMOTE instruction (including legacy hardware) the instruction will be treated as a NOP.\nA CLDEMOTE instruction is ordered with respect to stores to the same cache line, but unordered with respect to other instructions including memory fences, CLDEMOTE, CLWB or CLFLUSHOPT instructions to a different cache line. Since CLDEMOTE will retire in order with respect to stores to the same cache line, software should ensure that after issuing CLDEMOTE the line is not accessed again immediately by the same core to avoid cache data movement penalties.\nThe effective memory type of the page containing the affected line determines the effect; cacheable types are likely to generate a data movement operation, while uncacheable types may cause the instruction to be ignored.\nSpeculative fetching can occur at any time and is not tied to instruction execution. The CLDEMOTE instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms. That is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLDEMOTE instruction that references the cache line.\nUnlike CLFLUSH, CLFLUSHOPT, and CLWB instructions, CLDEMOTE is not guaranteed to write back modified data to memory.\nThe CLDEMOTE instruction may be ignored by hardware in certain cases and is not a guarantee.\nThe CLDEMOTE instruction can be used at all privilege levels. In certain processor implementations the CLDEMOTE instruction may set the A bit but not the D bit in the page tables.\nIf the line is not found in the cache, the instruction will be treated as a NOP.\nIn some implementations, the CLDEMOTE instruction may always cause a transactional abort with Transactional Synchronization Extensions (TSX). However, programmers must not rely on CLDEMOTE instruction to force a transactional abort.",
    "operationText": "Cache_Line_Demote(m8);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfpclassph",
    "category": "Core Instructions",
    "instructionName": "VFPCLASSPH\n\t\t— Test Types of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bitforeachofthesecategorytests. Themasked test results are OR-ed together to form a mask result.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.0F3A.W0 66 /r /ib VFPCLASSPH k1{k2}, xmm1/m128/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bitforeachofthesecategorytests. Themasked test results are OR-ed together to form a mask result.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.0F3A.W0 66 /r /ib VFPCLASSPH k1{k2}, ymm1/m256/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bitforeachofthesecategorytests. Themasked test results are OR-ed together to form a mask result.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.0F3A.W0 66 /r /ib VFPCLASSPH k1{k2}, zmm1/m512/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8 (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpbroadcast",
    "category": "Core Instructions",
    "instructionName": "VPBROADCAST\n\t\t— Load Integer and Broadcast",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast a byte integer in the source operand to sixteen locations in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 78 /r VPBROADCASTB xmm1, xmm2/m8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast a byte integer in the source operand to thirty-two locations in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 78 /r VPBROADCASTB ymm1, xmm2/m8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Broadcast a byte integer in the source operand to locations in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 78 /r VPBROADCASTB xmm1{k1}{z}, xmm2/m8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Broadcast a byte integer in the source operand to locations in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 78 /r VPBROADCASTB ymm1{k1}{z}, xmm2/m8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Broadcast a byte integer in the source operand to 64 locations in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 78 /r VPBROADCASTB zmm1{k1}{z}, xmm2/m8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast a word integer in the source operand to eight locations in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 79 /r VPBROADCASTW xmm1, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast a word integer in the source operand to sixteen locations in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 79 /r VPBROADCASTW ymm1, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Broadcast a word integer in the source operand to locations in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 79 /r VPBROADCASTW xmm1{k1}{z}, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Broadcast a word integer in the source operand to locations in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 79 /r VPBROADCASTW ymm1{k1}{z}, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Broadcast a word integer in the source operand to 32 locations in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 79 /r VPBROADCASTW zmm1{k1}{z}, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast a dword integer in the source operand to four locations in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 58 /r VPBROADCASTD xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast a dword integer in the source operand to eight locations in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 58 /r VPBROADCASTD ymm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast a dword integer in the source operand to locations in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 58 /r VPBROADCASTD xmm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast a dword integer in the source operand to locations in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 58 /r VPBROADCASTD ymm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast a dword integer in the source operand to locations in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 58 /r VPBROADCASTD zmm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast a qword element in source operand to two locations in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 59 /r VPBROADCASTQ xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast a qword element in source operand to four locations in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 59 /r VPBROADCASTQ ymm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast a qword element in source operand to locations in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 59 /r VPBROADCASTQ xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast a qword element in source operand to locations in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 59 /r VPBROADCASTQ ymm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast a qword element in source operand to locations in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 59 /r VPBROADCASTQ zmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Broadcast two dword elements in source operand to locations in xmm1 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 59 /r VBROADCASTI32x2 xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Broadcast two dword elements in source operand to locations in ymm1 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 59 /r VBROADCASTI32x2 ymm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Broadcast two dword elements in source operand to locations in zmm1 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 59 /r VBROADCASTI32x2 zmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast 128 bits of integer data in mem to low and high 128-bits in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 5A /r VBROADCASTI128 ymm1, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast 128 bits of 4 doubleword integer data in mem to locations in ymm1 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 5A /r VBROADCASTI32X4 ymm1 {k1}{z}, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast 128 bits of 4 doubleword integer data in mem to locations in zmm1 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 5A /r VBROADCASTI32X4 zmm1 {k1}{z}, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Broadcast 128 bits of 2 quadword integer data in mem to locations in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 5A /r VBROADCASTI64X2 ymm1 {k1}{z}, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Broadcast 128 bits of 2 quadword integer data in mem to locations in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 5A /r VBROADCASTI64X2 zmm1 {k1}{z}, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Broadcast 256 bits of 8 doubleword integer data in mem to locations in zmm1 using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 5B /r VBROADCASTI32X8 zmm1 {k1}{z}, m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast 256 bits of 4 quadword integer data in mem to locations in zmm1 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 5B /r VBROADCASTI64X4 zmm1 {k1}{z}, m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple2"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple4"
      },
      {
        "Op/En": "E",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple8"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/eaccept",
    "category": "SGX Instructions",
    "instructionName": "EACCEPT\n\t\t— Accept Changes to an EPC Page",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX2",
        "Description": "This leaf function accepts changes made by system software to an EPC page in the running enclave.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 05H ENCLU[EACCEPT]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EACCEPT (In)",
        "column_3": "Return Error Code (Out)",
        "column_4": "Address of a SECINFO (In)",
        "column_5": "Address of the destination EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/maxpd",
    "category": "Core Instructions",
    "instructionName": "MAXPD\n\t\t— Maximum of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Return the maximum double precision floating-point values between xmm1 and xmm2/m128.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 5F /r MAXPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the maximum double precision floating-point values between xmm2 and xmm3/m128.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 5F /r VMAXPD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the maximum packed double precision floating-point values between ymm2 and ymm3/m256.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 5F /r VMAXPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Return the maximum packed double precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 5F /r VMAXPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Return the maximum packed double precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 5F /r VMAXPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Return the maximum packed double precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 5F /r VMAXPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed double precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPD can be emulated using a sequence of instructions, such as a comparison followed by AND, ANDN, and OR.\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "MAX(SRC1, SRC2)\n{\n    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;\n        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC1 > SRC2) THEN DEST := SRC1;\n        ELSE DEST := SRC2;\n    FI;\n}\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := MAX(SRC1[i+63:i], SRC2[63:0])\n                ELSE\n                    DEST[i+63:i] := MAX(SRC1[i+63:i], SRC2[i+63:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0\n                        ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := MAX(SRC1[63:0], SRC2[63:0])\nDEST[127:64] := MAX(SRC1[127:64], SRC2[127:64])\nDEST[191:128] := MAX(SRC1[191:128], SRC2[191:128])\nDEST[255:192] := MAX(SRC1[255:192], SRC2[255:192])\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := MAX(SRC1[63:0], SRC2[63:0])\nDEST[127:64] := MAX(SRC1[127:64], SRC2[127:64])\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := MAX(DEST[63:0], SRC[63:0])\nDEST[127:64] := MAX(DEST[127:64], SRC[127:64])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (including QNaN Source Operand), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xend",
    "category": "Core Instructions",
    "instructionName": "XEND\n\t\t— Transactional End",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "RTM",
        "Description": "Specifies the end of an RTM code region.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 01 D5 XEND"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "N/A",
        "Operand2": "N/A",
        "Operand3": "N/A",
        "Operand4": "N/A"
      }
    ],
    "descriptionText": "The instruction marks the end of an RTM code region. If this corresponds to the outermost scope (that is, including this XEND instruction, the number of XBEGIN instructions is the same as number of XEND instructions), the logical processor will attempt to commit the logical processor state atomically. If the commit fails, the logical processor will rollback all architectural register and memory updates performed during the RTM execution. The logical processor will resume execution at the fallback address computed from the outermost XBEGIN instruction. The EAX register is updated to reflect RTM abort information.\nExecution of XEND outside a transactional region causes a general-protection exception (#GP). Execution of XEND while in a suspend read address tracking region causes a transactional abort.",
    "operationText": "IF (RTM_ACTIVE = 0) THEN\n    SIGNAL #GP\nELSE\n    IF SUSLDTRK_ACTIVE = 1\n        THEN GOTO RTM_ABORT_PROCESSING;\n    FI;\n    RTM_NEST_COUNT--\n    IF (RTM_NEST_COUNT = 0) THEN\n        Try to commit transaction\n        IF fail to commit transactional execution\n            THEN\n                GOTO RTM_ABORT_PROCESSING;\n            ELSE (* commit success *)\n                RTM_ACTIVE := 0\n        FI;\n    FI;\nFI;\n(* For any RTM abort condition encountered during RTM execution *)\nRTM_ABORT_PROCESSING:\n    Restore architectural register state\n    Discard memory updates performed in transaction\n    Update EAX with status\n    RTM_NEST_COUNT := 0\n    RTM_ACTIVE := 0\n    SUSLDTRK_ACTIVE := 0\n    IF 64-bit Mode\n        THEN\n            RIP := fallbackRIP\n        ELSE\n            EIP := fallbackEIP\n    FI;\nEND",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "column_1: If LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If RTM_ACTIVE = 0.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/andnps",
    "category": "Core Instructions",
    "instructionName": "ANDNPS\n\t\t— Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Return the bitwise logical AND NOT of packed single precision floating-point values in xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 55 /r ANDNPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical AND NOT of packed single precision floating-point values in xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F 55 /r VANDNPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical AND NOT of packed single precision floating-point values in ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F 55 /r VANDNPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 55 /r VANDNPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 55 /r VANDNPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 55 /r VANDNPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical AND NOT of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+31:i] := (NOT(SRC1[i+31:i])) BITWISE AND SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] := (NOT(SRC1[i+31:i])) BITWISE AND SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] = 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := (NOT(SRC1[31:0])) BITWISE AND SRC2[31:0]\nDEST[63:32] := (NOT(SRC1[63:32])) BITWISE AND SRC2[63:32]\nDEST[95:64] := (NOT(SRC1[95:64])) BITWISE AND SRC2[95:64]\nDEST[127:96] := (NOT(SRC1[127:96])) BITWISE AND SRC2[127:96]\nDEST[159:128] := (NOT(SRC1[159:128])) BITWISE AND SRC2[159:128]\nDEST[191:160] := (NOT(SRC1[191:160])) BITWISE AND SRC2[191:160]\nDEST[223:192] := (NOT(SRC1[223:192])) BITWISE AND SRC2[223:192]\nDEST[255:224] := (NOT(SRC1[255:224])) BITWISE AND SRC2[255:224].\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := (NOT(SRC1[31:0])) BITWISE AND SRC2[31:0]\nDEST[63:32] := (NOT(SRC1[63:32])) BITWISE AND SRC2[63:32]\nDEST[95:64] := (NOT(SRC1[95:64])) BITWISE AND SRC2[95:64]\nDEST[127:96] := (NOT(SRC1[127:96])) BITWISE AND SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := (NOT(DEST[31:0])) BITWISE AND SRC[31:0]\nDEST[63:32] := (NOT(DEST[63:32])) BITWISE AND SRC[63:32]\nDEST[95:64] := (NOT(DEST[95:64])) BITWISE AND SRC[95:64]\nDEST[127:96] := (NOT(DEST[127:96])) BITWISE AND SRC[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pavgb:pavgw",
    "category": "Core Instructions",
    "instructionName": "PAVGB/PAVGW\n\t\t— Average Packed Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F E0 /r1 PAVGB mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F E0, /r PAVGB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Average packed unsigned word integers from mm2/m64 and mm1 with rounding.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F E3 /r1 PAVGW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F E3 /r PAVGW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E0 /r VPAVGB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E3 /r VPAVGW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E0 /r VPAVGB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E3 /r VPAVGW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Average packed unsigned byte integers from xmm2, and xmm3/m128 with rounding and store to xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG E0 /r VPAVGB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG E0 /r VPAVGB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Average packed unsigned byte integers from zmm2, and zmm3/m512 with rounding and store to zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG E0 /r VPAVGB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Average packed unsigned word integers from xmm2, xmm3/m128 with rounding to xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG E3 /r VPAVGW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG E3 /r VPAVGW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Average packed unsigned word integers from zmm2, zmm3/m512 with rounding to zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG E3 /r VPAVGW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.\nThe (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.\nVEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nVEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
    "operationText": "DEST[7:0] := (SRC[7:0] + DEST[7:0] + 1) >> 1; (* Temp sum before shifting is 9 bits *)\n(* Repeat operation performed for bytes 2 through 6 *)\nDEST[63:56] := (SRC[63:56] + DEST[63:56] + 1) >> 1;\nDEST[15:0] := (SRC[15:0] + DEST[15:0] + 1) >> 1; (* Temp sum before shifting is 17 bits *)\n(* Repeat operation performed for words 2 and 3 *)\nDEST[63:48] := (SRC[63:48] + DEST[63:48] + 1) >> 1;\nDEST[7:0] := (SRC[7:0] + DEST[7:0] + 1) >> 1; (* Temp sum before shifting is 9 bits *)\n(* Repeat operation performed for bytes 2 through 14 *)\nDEST[127:120] := (SRC[127:120] + DEST[127:120] + 1) >> 1;\nDEST[15:0] := (SRC[15:0] + DEST[15:0] + 1) >> 1; (* Temp sum before shifting is 17 bits *)\n(* Repeat operation performed for words 2 through 6 *)\nDEST[127:112] := (SRC[127:112] + DEST[127:112] + 1) >> 1;\nDEST[7:0] := (SRC1[7:0] + SRC2[7:0] + 1) >> 1;\n(* Repeat operation performed for bytes 2 through 15 *)\nDEST[127:120] := (SRC1[127:120] + SRC2[127:120] + 1) >> 1\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := (SRC1[15:0] + SRC2[15:0] + 1) >> 1;\n(* Repeat operation performed for 16-bit words 2 through 7 *)\nDEST[127:112] := (SRC1[127:112] + SRC2[127:112] + 1) >> 1\nDEST[MAXVL-1:128] := 0\nDEST[7:0] := (SRC1[7:0] + SRC2[7:0] + 1) >> 1; (* Temp sum before shifting is 9 bits *)\n(* Repeat operation performed for bytes 2 through 31)\nDEST[255:248] := (SRC1[255:248] + SRC2[255:248] + 1) >> 1;\nDEST[15:0] := (SRC1[15:0] + SRC2[15:0] + 1) >> 1; (* Temp sum before shifting is 17 bits *)\n    (* Repeat operation performed for words 2 through 15)\n    DEST[255:14]) := (SRC1[255:240] + SRC2[255:240] + 1) >> 1;\nVPAVGB (EVEX encoded versions)\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := (SRC1[i+7:i] + SRC2[i+7:i] + 1) >> 1; (* Temp sum before shifting is 9 bits *)\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := (SRC1[i+15:i] + SRC2[i+15:i] + 1) >> 1\n                        ; (* Temp sum before shifting is 17 bits *)\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfixupimmpd",
    "category": "Core Instructions",
    "instructionName": "VFIXUPIMMPD\n\t\t— Fix Up Special Packed Float64 Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Fix up special numbers in float64 vector xmm1, float64 vector xmm2 and int64 vector xmm3/m128/m64bcst and store the result in xmm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 54 /r ib VFIXUPIMMPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Fix up special numbers in float64 vector ymm1, float64 vector ymm2 and int64 vector ymm3/m256/m64bcst and store the result in ymm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 54 /r ib VFIXUPIMMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Fix up elements of float64 vector in zmm2 using int64 vector table in zmm3/m512/m64bcst, combine with preserved elements from zmm1, and store the result in zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 54 /r ib VFIXUPIMMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcp14sd",
    "category": "Core Instructions",
    "instructionName": "VRCP14SD\n\t\t— Compute Approximate Reciprocal of Scalar Float64 Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes the approximate reciprocal of the scalar double precision floating-point value in xmm3/m64 and stores the result in xmm1 using writemask k1. Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 4D /r VRCP14SD xmm1 {k1}{z}, xmm2, xmm3/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/incsspd:incsspq",
    "category": "Core Instructions",
    "instructionName": "INCSSPD/INCSSPQ\n\t\t— Increment Shadow Stack Pointer",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Increment SSP by 4 * r32[7:0].",
        "Op / En": "R",
        "Opcode/Instruction": "F3 0F AE /05 INCSSPD r32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Increment SSP by 8 * r64[7:0].",
        "Op / En": "R",
        "Opcode/Instruction": "F3 REX.W 0F AE /05 INCSSPQ r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "R",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      }
    ],
    "descriptionText": "This instruction can be used to increment the current shadow stack pointer by the operand size of the instruction times the unsigned 8-bit value specified by bits 7:0 in the source operand. The instruction performs a pop and discard of the first and last element on the shadow stack in the range specified by the unsigned 8-bit value in bits 7:0 of the source operand.",
    "operationText": "IF CPL = 3\n    IF (CR4.CET & IA32_U_CET.SH_STK_EN) = 0\n        THEN #UD; FI;\nELSE\n    IF (CR4.CET & IA32_S_CET.SH_STK_EN) = 0\n        THEN #UD; FI;\nFI;\nIF (operand size is 64-bit)\n    THEN\n        Range := R64[7:0];\n        shadow_stack_load 8 bytes from SSP;\n        IF Range > 0\n            THEN shadow_stack_load 8 bytes from SSP + 8 * (Range - 1);\n        FI;\n        SSP := SSP + Range * 8;\n    ELSE\n        Range := R32[7:0];\n        shadow_stack_load 4 bytes from SSP;\n        IF Range > 0\n            THEN shadow_stack_load 4 bytes from SSP + 4 * (Range - 1);\n        FI;\n        SSP := SSP + Range * 4;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: IF CPL = 3 and IA32_U_CET.SH_STK_EN = 0.; \ncolumn_1: IF CPL < 3 and IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fld1:fldl2t:fldl2e:fldpi:fldlg2:fldln2:fldz",
    "category": "Core Instructions",
    "instructionName": "FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ\n\t\t— Load Constant",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push +1.0 onto the FPU register stack.",
        "Instruction": "FLD1",
        "Opcode*": "D9 E8"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push log210 onto the FPU register stack.",
        "Instruction": "FLDL2T",
        "Opcode*": "D9 E9"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push log2e onto the FPU register stack.",
        "Instruction": "FLDL2E",
        "Opcode*": "D9 EA"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push π onto the FPU register stack.",
        "Instruction": "FLDPI",
        "Opcode*": "D9 EB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push log102 onto the FPU register stack.",
        "Instruction": "FLDLG2",
        "Opcode*": "D9 EC"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push loge2 onto the FPU register stack.",
        "Instruction": "FLDLN2",
        "Opcode*": "D9 ED"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push +0.0 onto the FPU register stack.",
        "Instruction": "FLDZ",
        "Opcode*": "D9 EE"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, π, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.\nSee the section titled “Approximation of Pi” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the π constant.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "TOP := TOP − 1;\nST(0) := CONSTANT;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        ""
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetexppd",
    "category": "Core Instructions",
    "instructionName": "VGETEXPPD\n\t\t— Convert Exponents of Packed Double Precision Floating-Point Values to DoublePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert the exponent of packed double precision floating-point values in the source operand to double precision floating-point results representing unbiased integer exponents and stores the results in the destination register.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 42 /r VGETEXPPD xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert the exponent of packed double precision floating-point values in the source operand to double precision floating-point results representing unbiased integer exponents and stores the results in the destination register.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 42 /r VGETEXPPD ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert the exponent of packed double precision floating-point values in the source operand to double precision floating-point results representing unbiased integer exponents and stores the results in the destination under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 42 /r VGETEXPPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/bsr",
    "category": "Core Instructions",
    "instructionName": "BSR\n\t\t— Bit Scan Reverse",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Bit scan reverse on r/m16.",
        "Instruction": "BSR r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F BD /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Bit scan reverse on r/m32.",
        "Instruction": "BSR r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F BD /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Bit scan reverse on r/m64.",
        "Instruction": "BSR r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F BD /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF SRC = 0\n    THEN\n        ZF := 1;\n        DEST is undefined;\n    ELSE\n        ZF := 0;\n        temp := OperandSize – 1;\n        WHILE Bit(SRC, temp) = 0\n        DO\n            temp := temp - 1;\n        OD;\n        DEST := temp;\nFI;",
    "flagsAffectedText": "The ZF flag is set to 1 if the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/smctrl",
    "category": "SMX Instructions",
    "instructionName": "GETSEC[SMCTRL]\n\t\t— SMX Mode Control",
    "detailsTable": [
      {
        "Description": "Perform specified SMX mode control as selected with the input EBX.",
        "Instruction": "GETSEC[SMCTRL]",
        "Opcode": "NP 0F 37 (EAX = 7)"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The GETSEC[SMCTRL] instruction is available for performing certain SMX specific mode control operations. The operation to be performed is selected through the input register EBX. Currently only an input value in EBX of 0 is supported. All other EBX settings will result in the signaling of a general protection violation.\nIf EBX is set to 0, then the SMCTRL leaf is used to re-enable SMI events. SMI is masked by the ILP executing the GETSEC[SENTER] instruction (SMI is also masked in the responding logical processors in response to SENTER rendezvous messages.). The determination of when this instruction is allowed and the events that are unmasked is dependent on the processor context (See Table 7-11). For brevity, the usage of SMCTRL where EBX=0 will be referred to as GETSEC[SMCTRL(0)].\nAs part of support for launching a measured environment, the SMI, NMI, and INIT events are masked after GETSEC[SENTER], and remain masked after exiting authenticated execution mode. Unmasking these events should be accompanied by securely enabling these event handlers. These security concerns can be addressed in VMX operation by a MVMM.\nThe VM monitor can choose two approaches:\nTable 7-11 defines the processor context in which GETSEC[SMCTRL(0)] can be used and which events will be unmasked. Note that the events that are unmasked are dependent upon the currently operating processor context.",
    "operationText": "(* The state of the internal flag ACMODEFLAG and SENTERFLAG persist across instruction boundary *)\nIF (CR4.SMXE=0)\n    THEN #UD;\nELSE IF (in VMX non-root operation)\n    THEN VM Exit (reason=”GETSEC instruction”);\nELSE IF (GETSEC leaf unsupported)\n    THEN #UD;\nELSE IF ((CR0.PE=0) or (CPL>0) OR (EFLAGS.VM=1))\n    THEN #GP(0);\nELSE IF((EBX=0) and (SENTERFLAG=1) and (ACMODEFLAG=0) and (IN_SMM=0) and\n        (((in VMX root operation) and (SMM monitor not configured)) or (not in VMX operation)) )\n    THEN unmask SMI;\nELSE\n    #GP(0);\nEND",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "All protected mode exceptions apply."
      ],
      "compatibilityMode": [
        "All protected mode exceptions apply."
      ],
      "protectedMode": [
        "column_1: If GETSEC[SMCTRL] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: IfCR0.PE=0orCPL>0orEFLAGS.VM=1.; \ncolumn_1: If in VMX root operation.; \ncolumn_1: If a protected partition is not already active or the processor is currently in authenticated code mode.; \ncolumn_1: If the processor is in SMM.; \ncolumn_1: If the SMM monitor is not configured.;"
      ],
      "realAddressMode": [
        "column_1: If GETSEC[SMCTRL] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[SMCTRL] is not recognized in real-address mode.;"
      ],
      "virtual8086Mode": [
        "column_1: If GETSEC[SMCTRL] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[SMCTRL] is not recognized in virtual-8086 mode.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtne2ps2bf16",
    "category": "Core Instructions",
    "instructionName": "VCVTNE2PS2BF16\n\t\t— Convert Two Packed Single Data to One Packed BF16 Data",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_BF16",
        "Description": "Convert packed single data from xmm2 and xmm3/m128/m32bcst to packed BF16 data in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F2.0F38.W0 72 /r VCVTNE2PS2BF16 xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_BF16",
        "Description": "Convert packed single data from ymm2 and ymm3/m256/m32bcst to packed BF16 data in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F2.0F38.W0 72 /r VCVTNE2PS2BF16 ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F AVX512_BF16",
        "Description": "Convert packed single data from zmm2 and zmm3/m512/m32bcst to packed BF16 data in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F2.0F38.W0 72 /r VCVTNE2PS2BF16 zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/rsm",
    "category": "Core Instructions",
    "instructionName": "RSM\n\t\t— Resume From System Management Mode",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Resume operation of interrupted program.",
        "Instruction": "RSM",
        "Op/En": "ZO",
        "Opcode*": "0F AA"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Returns program control from system management mode (SMM) to the application program or operating-system procedure that was interrupted when the processor received an SMM interrupt. The processor’s state is restored from the dump created upon entering SMM. If the processor detects invalid state information during state restoration, it enters the shutdown state. The following invalid information can cause a shutdown:\nThe contents of the model-specific registers are not affected by a return from SMM.\nThe SMM state map used by RSM supports resuming processor context for non-64-bit modes and 64-bit mode.\nSee Chapter 32, “System Management Mode,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about SMM and the behavior of the RSM instruction.",
    "operationText": "ReturnFromSMM;\nIF (IA-32e mode supported) or (CPUID DisplayFamily_DisplayModel = 06H_0CH )\n    THEN\n        ProcessorState := Restore(SMMDump(IA-32e SMM STATE MAP));\n    Else\n        ProcessorState := Restore(SMMDump(Non-32-Bit-Mode SMM STATE MAP));\nFI",
    "flagsAffectedText": "All.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/gf2p8mulb",
    "category": "Core Instructions",
    "instructionName": "GF2P8MULB\n\t\t— Galois Field Multiply Bytes",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "GFNI",
        "Description": "Multiplies elements in the finite field GF(2^8).",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F38 CF /r GF2P8MULB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX GFNI",
        "Description": "Multiplies elements in the finite field GF(2^8).",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 CF /r VGF2P8MULB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX GFNI",
        "Description": "Multiplies elements in the finite field GF(2^8).",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 CF /r VGF2P8MULB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL GFNI",
        "Description": "Multiplies elements in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 CF /r VGF2P8MULB xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL GFNI",
        "Description": "Multiplies elements in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 CF /r VGF2P8MULB ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F GFNI",
        "Description": "Multiplies elements in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 CF /r VGF2P8MULB zmm1{k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetmantph",
    "category": "Core Instructions",
    "instructionName": "VGETMANTPH\n\t\t— Extract FP16 Vector of Normalized Mantissas from FP16 Vector",
    "detailsTable": [
      {
        "Description": "Get normalized mantissa from FP16 vector xmm2/m128/m16bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.0F3A.W0 26 /r /ib VGETMANTPH xmm1{k1}{z}, xmm2/m128/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Get normalized mantissa from FP16 vector ymm2/m256/m16bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.0F3A.W0 26 /r /ib VGETMANTPH ymm1{k1}{z}, ymm2/m256/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Get normalized mantissa from FP16 vector zmm2/m512/m16bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.0F3A.W0 26 /r /ib VGETMANTPH zmm1{k1}{z}, zmm2/m512/m16bcst {sae}, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8 (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xsetbv",
    "category": "Core Instructions",
    "instructionName": "XSETBV\n\t\t— Set Extended Control Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Write the value in EDX:EAX to the XCR specified by ECX.",
        "Instruction": "XSETBV",
        "Op/En": "ZO",
        "Opcode": "NP 0F 01 D1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Writes the contents of registers EDX:EAX into the 64-bit extended control register (XCR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected XCR and the contents of the EAX register are copied to low-order 32 bits of the XCR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an XCR should be set to values previously read.\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented XCR in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to reserved bits in an XCR.\nCurrently, only XCR0 is supported. Thus, all other values of ECX are reserved and will cause a #GP(0). Note that bit 0 of XCR0 (corresponding to x87 state) must be set to 1; the instruction will cause a #GP(0) if an attempt is made to clear this bit. In addition, the instruction causes a #GP(0) if an attempt is made to set XCR0[2] (AVX state) while clearing XCR0[1] (SSE state); it is necessary to set both bits to use AVX instructions; Section 13.3, “Enabling the XSAVE Feature Set and XSAVE-Enabled Features,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
    "operationText": "XCR[ECX] := EDX:EAX;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If an invalid XCR is specified in ECX.; \ncolumn_1: If the value in EDX:EAX sets bits that are reserved in the XCR specified by ECX.; \ncolumn_1: If an attempt is made to clear bit 0 of XCR0.; \ncolumn_1: If an attempt is made to set XCR0[2:1] to 10b.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If the value in EDX:EAX sets bits that are reserved in the XCR specified by ECX.; \ncolumn_1: If an attempt is made to clear bit 0 of XCR0.; \ncolumn_1: If an attempt is made to set XCR0[2:1] to 10b.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/emodpe",
    "category": "SGX Instructions",
    "instructionName": "EMODPE\n\t\t— Extend an EPC Page Permissions",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX2",
        "Description": "This leaf function extends the access rights of an existing EPC page.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 06H ENCLU[EMODPE]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EMODPE (In)",
        "column_3": "Address of a SECINFO (In)",
        "column_4": "Address of the destination EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/ffree",
    "category": "Core Instructions",
    "instructionName": "FFREE\n\t\t— Free Floating-Point Register",
    "detailsTable": [
      {
        "Description": "Sets tag for ST(i) to empty.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "DD C0+i",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "TAG(i) := 11B;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/hsubps",
    "category": "Core Instructions",
    "instructionName": "HSUBPS\n\t\t— Packed Single Precision Floating-Point Horizontal Subtract",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Horizontal subtract packed single precision floating-point values from xmm2/m128 to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 7D /r HSUBPS xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Horizontal subtract packed single precision floating-point values from xmm2 and xmm3/mem.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.F2.0F.WIG 7D /r VHSUBPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Horizontal subtract packed single precision floating-point values from ymm2 and ymm3/mem.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.F2.0F.WIG 7D /r VHSUBPS ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Subtracts the single precision floating-point value in the second dword of the destination operand from the first dword of the destination operand and stores the result in the first dword of the destination operand.\nSubtracts the single precision floating-point value in the fourth dword of the destination operand from the third dword of the destination operand and stores the result in the second dword of the destination operand.\nSubtracts the single precision floating-point value in the second dword of the source operand from the first dword of the source operand and stores the result in the third dword of the destination operand.\nSubtracts the single precision floating-point value in the fourth dword of the source operand from the third dword of the source operand and stores the result in the fourth dword of the destination operand.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nSee Figure 3-23 for HSUBPS; see Figure 3-24 for VHSUBPS.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "DEST[31:0] := SRC1[31:0] - SRC1[63:32]\nDEST[63:32] := SRC1[95:64] - SRC1[127:96]\nDEST[95:64] := SRC2[31:0] - SRC2[63:32]\nDEST[127:96] := SRC2[95:64] - SRC2[127:96]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := SRC1[31:0] - SRC1[63:32]\nDEST[63:32] := SRC1[95:64] - SRC1[127:96]\nDEST[95:64] := SRC2[31:0] - SRC2[63:32]\nDEST[127:96] := SRC2[95:64] - SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] - SRC1[63:32]\nDEST[63:32] := SRC1[95:64] - SRC1[127:96]\nDEST[95:64] := SRC2[31:0] - SRC2[63:32]\nDEST[127:96] := SRC2[95:64] - SRC2[127:96]\nDEST[159:128] := SRC1[159:128] - SRC1[191:160]\nDEST[191:160] := SRC1[223:192] - SRC1[255:224]\nDEST[223:192] := SRC2[159:128] - SRC2[191:160]\nDEST[255:224] := SRC2[223:192] - SRC2[255:224]",
    "flagsAffectedText": "",
    "exceptions": {
      "exceptions¶": [
        "When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."
      ],
      "numeric¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ],
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fpatan",
    "category": "Core Instructions",
    "instructionName": "FPATAN\n\t\t— Partial Arctangent",
    "detailsTable": [
      {
        "64-Bit Mode": "",
        "Compat/Leg Mode": "Valid",
        "Description": "Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack.",
        "Instruction": "",
        "column_1": "D9 F3"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0), stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the source operand ST(1) and a magnitude less than +π.\nThe FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently, not just on the sign of the ratio Y/X. This is because a point (−X,Y) is in the second quadrant, resulting in an angle between π/2 and π, while a point (X,−Y) is in the fourth quadrant, resulting in an angle between 0 and −π/2. A point (−X,−Y) is in the third quadrant, giving an angle between −π/2 and −π.\nThe following table shows the results obtained when computing the arctangent of various classes of numbers, assuming that underflow does not occur.\nThere is no restriction on the range of source operands that FPATAN can accept.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "ST(1) := arctan(ST(1) / ST(0));\nPopRegisterStack;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value or unsupported format.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_2: Result is too small for destination format.; column_1: #U; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtsd2usi",
    "category": "Core Instructions",
    "instructionName": "VCVTSD2USI\n\t\t— Convert Scalar Double Precision Floating-Point Value to Unsigned DoublewordInteger",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one unsigned doubleword integer r32.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W0 79 /r VCVTSD2USI r32, xmm1/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one unsigned quadword integer zero-extended into r64.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 79 /r VCVTSD2USI r64, xmm1/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Fixed"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/ldmxcsr",
    "category": "Core Instructions",
    "instructionName": "LDMXCSR\n\t\t— Load MXCSR Register",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Load MXCSR register from m32.",
        "Op/En": "M",
        "Opcode/Instruction": "NP 0F AE /2 LDMXCSR m32"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Load MXCSR register from m32.",
        "Op/En": "M",
        "Opcode/Instruction": "VEX.LZ.0F.WIG AE /2 VLDMXCSR m32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location. See “MXCSR Control and Status Register” in Chapter 10, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the MXCSR register and its contents.\nThe LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.\nThe default MXCSR value at reset is 1F80H.\nIf a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only upon the execution of the next instruction that meets both conditions below:\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.\nIf VLDMXCSR is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "MXCSR := m32;",
    "flagsAffectedText": "",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "See Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "column_2: If VEX.vvvv ≠ 1111B.; column_1: #UD;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/parameters",
    "category": "SMX Instructions",
    "instructionName": "GETSEC[PARAMETERS]\n\t\t— Report the SMX Parameters",
    "detailsTable": [
      {
        "Description": "Report the SMX parameters. The parameters index is input in EBX with the result returned in EAX, EBX, and ECX.",
        "Instruction": "GETSEC[PARAMETERS]",
        "Opcode": "NP 0F 37 (EAX=6)"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The GETSEC[PARAMETERS] instruction returns specific parameter information for SMX features supported by the processor. Parameter information is returned in EAX, EBX, and ECX, with the input parameter selected using EBX.\nSoftware retrieves parameter information by searching with an input index for EBX starting at 0, and then reading the returned results in EAX, EBX, and ECX. EAX[4:0] is designated to return a parameter type field indicating if a parameter is available and what type it is. If EAX[4:0] is returned with 0, this designates a null parameter and indicates no more parameters are available.\nTable 7-7 defines the parameter types supported in current and future implementations.\nSupported AC module versions (as defined by the AC module HeaderVersion field) can be determined for a particular SMX capable processor by the type 1 parameter. Using EBX to index through the available parameters reported by GETSEC[PARAMETERS] for each unique parameter set returned for type 1, software can determine the complete list of AC module version(s) supported.\nFor each parameter set, EBX returns the comparison mask and ECX returns the available HeaderVersion field values supported, after AND'ing the target HeaderVersion with the comparison mask. Software can then determine if a particular AC module version is supported by following the pseudo-code search routine given below:\nparameter_search_index= 0 do { EBX= parameter_search_index++ EAX= 6 GETSEC if (EAX[4:0] = 1) { if ((version_query & EBX) = ECX) { version_is_supported= 1 break } }\n} while (EAX[4:0] ≠ 0)\nIf only AC modules with a HeaderVersion of 0 are supported by the processor, then only one parameter set of type 1 will be returned, as follows: EAX = 00000001H,\nEBX = FFFFFFFFH and ECX = 00000000H.\nThe maximum capacity for an authenticated code execution area supported by the processor is reported with the parameter type of 2. The maximum supported size in bytes is determined by multiplying the returned size in EAX[31:5] by 32. Thus, for a maximum supported authenticated RAM size of 32KBytes, EAX returns with 00008002H.\nSupportable memory types for memory mapped outside of the authenticated code execution area are reported with the parameter type of 3. While is active, as initiated by the GETSEC functions SENTER and ENTERACCS and terminated by EXITAC, there are restrictions on what memory types are allowed for the rest of system memory. It is the responsibility of the system software to initialize the memory type range register (MTRR) MSRs and/or the page attribute table (PAT) to only map memory types consistent with the reporting of this parameter. The reporting of supportable memory types of external memory is indicated using a bit map returned in EAX[31:8]. These bit positions correspond to the memory type encodings defined for the MTRR MSR and PAT programming. See Table 7-9.\nThe parameter type of 4 is used for enumerating the availability of selective GETSEC[SENTER] function disable controls. If a 1 is reported in bits 14:8 of the returned parameter EAX, then this indicates a disable control capability exists with SENTER for a particular function. The enumerated field in bits 14:8 corresponds to use of the EDX input parameter bits 6:0 for SENTER. If an enumerated field bit is set to 1, then the corresponding EDX input parameter bit of EDX may be set to 1 to disable that designated function. If the enumerated field bit is 0 or this parameter is not reported, then no disable capability exists with the corresponding EDX input parameter for SENTER, and EDX bit(s) must be cleared to 0 to enable execution of SENTER. If no selective disable capability for SENTER exists as enumerated, then the corresponding bits in the IA32_FEATURE_CONTROL MSR bits 14:8 must also be programmed to 1 if the SENTER global enable bit 15 of the MSR is set. This is required to enable future extensibility of SENTER selective disable capability with respect to potentially separate software initialization of the MSR.\nIf the GETSEC[PARAMETERS] leaf or specific parameter is not present for a given SMX capable processor, then default parameter values should be assumed. These are defined in Table 7-10.",
    "operationText": "(* example of a processor supporting only a 0.0 HeaderVersion, 32K ACRAM size, memory types UC and WC *)\nIF (CR4.SMXE=0)\n    THEN #UD;\nELSE IF (in VMX non-root operation)\n    THEN VM Exit (reason=”GETSEC instruction”);\nELSE IF (GETSEC leaf unsupported)\n    THEN #UD;\n    (* example of a processor supporting a 0.0 HeaderVersion *)\nIF (EBX=0) THEN\n    EAX := 00000001h;\n    EBX := FFFFFFFFh;\n    ECX := 00000000h;\nELSE IF (EBX=1)\n    (* example of a processor supporting a 32K ACRAM size *)\n    THEN EAX := 00008002h;\nESE IF (EBX= 2)\n    (* example of a processor supporting external memory types of UC and WC *)\n    THEN EAX := 00000303h;\nESE IF (EBX= other value(s) less than unsupported index value)\n    (* EAX value varies. Consult Table 7-7 and Table *)\nELSE (* unsupported index*)\n    EAX := 00000000h;\nEND;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "All protected mode exceptions apply."
      ],
      "compatibilityMode": [
        "All protected mode exceptions apply."
      ],
      "protectedMode": [
        "column_1: If GETSEC[PARAMETERS] is not reported as supported by GETSEC[CAPABILITIES].;"
      ],
      "realAddressMode": [
        "column_1: If GETSEC[PARAMETERS] is not reported as supported by GETSEC[CAPABILITIES].;"
      ],
      "virtual8086Mode": [
        "column_1: If GETSEC[PARAMETERS] is not reported as supported by GETSEC[CAPABILITIES].;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fcomi:fcomip:fucomi:fucomip",
    "category": "Core Instructions",
    "instructionName": "FCOMI/FCOMIP/FUCOMI/FUCOMIP\n\t\t— Compare Floating-Point Values and Set EFLAGS",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(i) and set status flags accordingly.",
        "Instruction": "FCOMI ST, ST(i)",
        "Opcode": "DB F0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.",
        "Instruction": "FCOMIP ST, ST(i)",
        "Opcode": "DF F0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly.",
        "Instruction": "FUCOMI ST, ST(i)",
        "Opcode": "DB E8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack.",
        "Instruction": "FUCOMIP ST, ST(i)",
        "Opcode": "DF E8+i"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.\nAn unordered comparison checks the class of the numbers being compared (see “FXAM—Examine Floating-Point” in this chapter). The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions. The only difference is that the FUCOMI/FUCOMIP instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The FCOMI/FCOMIP instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.\nIf the operation results in an invalid-arithmetic-operand exception being raised, the status flags in the EFLAGS register are set only if the exception is masked.\nThe FCOMI/FCOMIP and FUCOMI/FUCOMIP instructions set the OF, SF, and AF flags to zero in the EFLAGS register (regardless of whether an invalid-operation exception is detected).\nThe FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "CASE (relation of operands) OF\n    ST(0) > ST(i):\n                        ZF, PF, CF := 000;\n    ST(0) < ST(i):\n                        ZF, PF, CF := 001;\n    ST(0) = ST(i):\n                        ZF, PF, CF := 100;\nESAC;\nIF Instruction is FCOMI or FCOMIP\n    THEN\n        IF ST(0) or ST(i) = NaN or unsupported format\n            THEN\n                #IA\n                IF FPUControlWord.IM = 1\n                        THEN\n                            ZF, PF, CF := 111;\n                FI;\n        FI;\nFI;\nIF Instruction is FUCOMI or FUCOMIP\n    THEN\n        IF ST(0) or ST(i) = QNaN, but not SNaN or unsupported format\n            THEN\n                ZF, PF, CF := 111;\n            ELSE (* ST(0) or ST(i) is SNaN or unsupported format *)\n                    #IA;\n                IF FPUControlWord.IM = 1\n                        THEN\n                            ZF, PF, CF := 111;\n                FI;\n        FI;\nFI;\nIF Instruction is FCOMIP or FUCOMIP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: (FCOMI or FCOMIP instruction) One or both operands are NaN values or have unsupported formats.; \ncolumn_1: (FUCOMI or FUCOMIP instruction) One or both operands are SNaN values (but not QNaNs) or have undefined formats. Detection of a QNaN value does not raise an invalid-operand exception.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtusi2sd",
    "category": "Core Instructions",
    "instructionName": "VCVTUSI2SD\n\t\t— Convert Unsigned Integer to Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one unsigned doubleword integer from r/m32 to one double precision floating-point value in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W0 7B /r VCVTUSI2SD xmm1, xmm2, r/m32"
      },
      {
        "64/32 Bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one unsigned quadword integer from r/m64 to one double precision floating-point value in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 7B /r VCVTUSI2SD xmm1, xmm2, r/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/mul",
    "category": "Core Instructions",
    "instructionName": "MUL\n\t\t— Unsigned Multiply",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Unsigned multiply (AX := AL ∗ r/m8).",
        "Instruction": "MUL r/m8",
        "Op/En": "M",
        "Opcode": "F6 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Unsigned multiply (AX := AL ∗ r/m8).",
        "Instruction": "MUL r/m81",
        "Op/En": "M",
        "Opcode": "REX + F6 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Unsigned multiply (DX:AX := AX ∗ r/m16).",
        "Instruction": "MUL r/m16",
        "Op/En": "M",
        "Opcode": "F7 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Unsigned multiply (EDX:EAX := EAX ∗ r/m32).",
        "Instruction": "MUL r/m32",
        "Op/En": "M",
        "Opcode": "F7 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Unsigned multiply (RDX:RAX := RAX ∗ r/m64).",
        "Instruction": "MUL r/m64",
        "Op/En": "M",
        "Opcode": "REX.W + F7 /4"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location. The action of this instruction and the location of the result depends on the opcode and the operand size as shown in Table 4-9.\nThe result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size), with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\nSee the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF (Byte operation)\n    THEN\n        AX := AL ∗ SRC;\n    ELSE (* Word or doubleword operation *)\n        IF OperandSize = 16\n            THEN\n                DX:AX := AX ∗ SRC;\n            ELSE IF OperandSize = 32\n                THEN EDX:EAX := EAX ∗ SRC; FI;\n            ELSE (* OperandSize = 64 *)\n                RDX:RAX := RAX ∗ SRC;\n        FI;\nFI;",
    "flagsAffectedText": "The OF and CF flags are set to 0 if the upper half of the result is 0; otherwise, they are set to 1. The SF, ZF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vdpbf16ps",
    "category": "Core Instructions",
    "instructionName": "VDPBF16PS\n\t\t— Dot Product of BF16 Pairs Accumulated Into Packed Single Precision",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_BF16",
        "Description": "Multiply BF16 pairs from xmm2 and xmm3/m128, and accumulate the resulting packed single precision results in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 52 /r VDPBF16PS xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_BF16",
        "Description": "Multiply BF16 pairs from ymm2 and ymm3/m256, and accumulate the resulting packed single precision results in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 52 /r VDPBF16PS ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F AVX512_BF16",
        "Description": "Multiply BF16 pairs from zmm2 and zmm3/m512, and accumulate the resulting packed single precision results in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 52 /r VDPBF16PS zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/bndcl",
    "category": "Core Instructions",
    "instructionName": "BNDCL\n\t\t— Check Lower Bound",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "N.E./V",
        "CPUID Feature Flag": "MPX",
        "Description": "Generate a #BR if the address in r/m32 is lower than the lower bound in bnd.LB.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 0F 1A /r BNDCL bnd, r/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MPX",
        "Description": "Generate a #BR if the address in r/m64 is lower than the lower bound in bnd.LB.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 0F 1A /r BNDCL bnd, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "Compare the address in the second operand with the lower bound in bnd. The second operand can be either a register or memory operand. If the address is lower than the lower bound in bnd.LB, it will set BNDSTATUS to 01H and signal a #BR exception.\nThis instruction does not cause any memory access, and does not read or write any flags.",
    "operationText": "IF reg < BND.LB Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\nTEMP := LEA(mem);\nIF TEMP < BND.LB Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;",
    "flagsAffectedText": "None",
    "exceptions": {
      "64BitMode": [
        "",
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 67H prefix is not used and CS.D=0.; \ncolumn_1: If 67H prefix is used and CS.D=1.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpsrlvw:vpsrlvd:vpsrlvq",
    "category": "Core Instructions",
    "instructionName": "VPSRLVW/VPSRLVD/VPSRLVQ\n\t\t— Variable Bit Shift Right Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 45 /r VPSRLVD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 45 /r VPSRLVQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 45 /r VPSRLVD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 45 /r VPSRLVQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 10 /r VPSRLVW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 10 /r VPSRLVW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 10 /r VPSRLVW zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 45 /r VPSRLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 45 /r VPSRLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 45 /r VPSRLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 45 /r VPSRLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 45 /r VPSRLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 45 /r VPSRLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrt14sd",
    "category": "Core Instructions",
    "instructionName": "VRSQRT14SD\n\t\t— Compute Approximate Reciprocal of Square Root of Scalar Float64 Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes the approximate reciprocal square root of the scalar double precision floating-point value in xmm3/m64 and stores the result in the low quadword element of xmm1 using writemask k1. Bits[127:64] of xmm2 is copied to xmm1[127:64].",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 4F /r VRSQRT14SD xmm1 {k1}{z}, xmm2, xmm3/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/tpause",
    "category": "Core Instructions",
    "instructionName": "TPAUSE\n\t\t— Timed PAUSE",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "WAITPKG",
        "Description": "Directs the processor to enter an implementation-dependent optimized state until the TSC reaches the value in EDX:EAX.",
        "Op/En": "A",
        "Opcode / Instruction": "66 0F AE /6 TPAUSE r32, <edx>, <eax>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "TPAUSE instructs the processor to enter an implementation-dependent optimized state. There are two such optimized states to choose from: light-weight power/performance optimized state, and improved power/performance optimized state. The selection between the two is governed by the explicit input register bit[0] source operand.\nTPAUSE is available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. TPAUSE may be executed at any privilege level. This instruction’s operation is the same in non-64-bit modes and in 64-bit mode.\nUnlike PAUSE, the TPAUSE instruction will not cause an abort when used inside a transactional region, described in the chapter Chapter 16, “Programming with Intel® Transactional Synchronization Extensions,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nThe input register contains information such as the preferred optimized state the processor should enter as described in the following table. Bits other than bit 0 are reserved and will result in #GP if non-zero.\nThe instruction execution wakes up when the time-stamp counter reaches or exceeds the implicit EDX:EAX 64-bit input value.\nPrior to executing the TPAUSE instruction, an operating system may specify the maximum delay it allows the processor to suspend its operation. It can do so by writing TSC-quanta value to the following 32-bit MSR (IA32_UMWAIT_CONTROL at MSR index E1H):\nIf the processor that executed a TPAUSE instruction wakes due to the expiration of the operating system time-limit, the instructions sets RFLAGS.CF; otherwise, that flag is cleared.\nThe following additional events cause the processor to exit the implementation-dependent optimized state: a store to the read-set range within the transactional region, an NMI or SMI, a debug exception, a machine check exception, the BINIT# signal, the INIT# signal, and the RESET# signal.\nOther implementation-dependent events may cause the processor to exit the implementation-dependent optimized state proceeding to the instruction following TPAUSE. In addition, an external interrupt causes the processor to exit the implementation-dependent optimized state regardless of whether maskable-interrupts are inhibited (EFLAGS.IF =0). It should be noted that if maskable-interrupts are inhibited execution will proceed to the instruction following TPAUSE.",
    "operationText": "os_deadline := TSC+(IA32_UMWAIT_CONTROL[31:2]<<2)\ninstr_deadline := UINT64(EDX:EAX)\nIF os_deadline < instr_deadline:\n    deadline := os_deadline\n    using_os_deadline := 1\nELSE:\n    deadline := instr_deadline\n    using_os_deadline := 0\nWHILE TSC < deadline:\n    implementation_dependent_optimized_state(Source register, deadline, IA32_UMWAIT_CONTROL[0])\nIF using_os_deadline AND TSC ≥ deadline:\n    RFLAGS.CF := 1\nELSE:\n    RFLAGS.CF := 0\nRFLAGS.AF,PF,SF,ZF,OF := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "numeric¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fcmovcc",
    "category": "Core Instructions",
    "instructionName": "FCMOVcc\n\t\t— Floating-Point Conditional Move",
    "detailsTable": [
      {
        "column_1": "DA C0+i",
        "column_2": "FCMOVB ST(0), ST(i)",
        "column_3": "Valid",
        "column_4": "Valid",
        "column_5": "Move if below (CF=1)."
      },
      {
        "column_1": "DA C8+i",
        "column_2": "FCMOVE ST(0), ST(i)",
        "column_3": "Valid",
        "column_4": "Valid",
        "column_5": "Move if equal (ZF=1)."
      },
      {
        "column_1": "DA D0+i",
        "column_2": "FCMOVBE ST(0), ST(i)",
        "column_3": "Valid",
        "column_4": "Valid",
        "column_5": "Move if below or equal (CF=1 or ZF=1)."
      },
      {
        "column_1": "DA D8+i",
        "column_2": "FCMOVU ST(0), ST(i)",
        "column_3": "Valid",
        "column_4": "Valid",
        "column_5": "Move if unordered (PF=1)."
      },
      {
        "column_1": "DB C0+i",
        "column_2": "FCMOVNB ST(0), ST(i)",
        "column_3": "Valid",
        "column_4": "Valid",
        "column_5": "Move if not below (CF=0)."
      },
      {
        "column_1": "DB C8+i",
        "column_2": "FCMOVNE ST(0), ST(i)",
        "column_3": "Valid",
        "column_4": "Valid",
        "column_5": "Move if not equal (ZF=0)."
      },
      {
        "column_1": "DB D0+i",
        "column_2": "FCMOVNBE ST(0), ST(i)",
        "column_3": "Valid",
        "column_4": "Valid",
        "column_5": "Move if not below or equal (CF=0 and ZF=0)."
      },
      {
        "column_1": "DB D8+i",
        "column_2": "FCMOVNU ST(0), ST(i)",
        "column_3": "Valid",
        "column_4": "Valid",
        "column_5": "Move if not unordered (PF=0)."
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).\nThe FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.\nA processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF condition TRUE\n    THEN ST(0) := ST(i);\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        ""
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fdiv:fdivp:fidiv",
    "category": "Core Instructions",
    "instructionName": "FDIV/FDIVP/FIDIV\n\t\t— Divide",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(0) by m32fp and store result in ST(0).",
        "Instruction": "FDIV m32fp",
        "Opcode": "D8 /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(0) by m64fp and store result in ST(0).",
        "Instruction": "FDIV m64fp",
        "Opcode": "DC /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(0) by ST(i) and store result in ST(0).",
        "Instruction": "FDIV ST(0), ST(i)",
        "Opcode": "D8 F0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(i) by ST(0) and store result in ST(i).",
        "Instruction": "FDIV ST(i), ST(0)",
        "Opcode": "DC F8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(i) by ST(0), store result in ST(i), and pop the register stack.",
        "Instruction": "FDIVP ST(i), ST(0)",
        "Opcode": "DE F8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(1) by ST(0), store result in ST(1), and pop the register stack.",
        "Instruction": "FDIVP",
        "Opcode": "DE F9"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(0) by m32int and store result in ST(0).",
        "Instruction": "FIDIV m32int",
        "Opcode": "DA /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(0) by m16int and store result in ST(0).",
        "Instruction": "FIDIV m16int",
        "Opcode": "DE /6"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Divides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format, word or doubleword integer format.\nThe no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.\nThe FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.\nThe FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.\nThe following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF SRC = 0\n    THEN\n        #Z;\n    ELSE\n        IF Instruction is FIDIV\n            THEN\n                DEST := DEST / ConvertToDoubleExtendedPrecisionFP(SRC);\n            ELSE (* Source operand is floating-point value *)\n                DEST := DEST / SRC;\n        FI;\nFI;\nIF Instruction = FDIVP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Operand is an SNaN value or unsupported format.; \ncolumn_1: ±∞ / ±∞; ±0 / ±0; \ncolumn_1: #D; column_2: Source is a denormal value.; \ncolumn_2: DEST / ±0, where DEST is not equal to ±0.; column_1: #Z; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/shld",
    "category": "Core Instructions",
    "instructionName": "SHLD\n\t\t— Double Precision Shift Left",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.",
        "Instruction": "SHLD r/m16, r16, imm8",
        "Op/En": "MRI",
        "Opcode*": "0F A4 /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shift r/m16 to left CL places while shifting bits from r16 in from the right.",
        "Instruction": "SHLD r/m16, r16, CL",
        "Op/En": "MRC",
        "Opcode*": "0F A5 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.",
        "Instruction": "SHLD r/m32, r32, imm8",
        "Op/En": "MRI",
        "Opcode*": "0F A4 /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.",
        "Instruction": "SHLD r/m64, r64, imm8",
        "Op/En": "MRI",
        "Opcode*": "REX.W + 0F A4 /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shift r/m32 to left CL places while shifting bits from r32 in from the right.",
        "Instruction": "SHLD r/m32, r32, CL",
        "Op/En": "MRC",
        "Opcode*": "0F A5 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Shift r/m64 to left CL places while shifting bits from r64 in from the right.",
        "Instruction": "SHLD r/m64, r64, CL",
        "Op/En": "MRC",
        "Opcode*": "REX.W + 0F A5 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MRI",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MRC",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "CL",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The SHLD instruction is used for multi-precision shifts of 64 bits or more.\nThe instruction shifts the first operand (destination operand) to the left the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting with bit 0 of the destination operand).\nThe destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an immediate byte or in the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode; only bits 0 through 4 of the count are used. This masks the count to a value between 0 and 31. If a count is greater than the operand size, the result is undefined.\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits). See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF (In 64-Bit Mode and REX.W = 1)\n    THEN COUNT := COUNT MOD 64;\n    ELSE COUNT := COUNT MOD 32;\nFI\nSIZE := OperandSize;\nIF COUNT = 0\n    THEN\n        No operation;\n    ELSE\n        IF COUNT > SIZE\n            THEN (* Bad parameters *)\n                DEST is undefined;\n                CF, OF, SF, ZF, AF, PF are undefined;\n            ELSE (* Perform the shift *)\n                CF := BIT[DEST, SIZE – COUNT];\n                (* Last bit shifted out on exit *)\n                FOR i := SIZE – 1 DOWN TO COUNT\n                    DO\n                        Bit(DEST, i) := Bit(DEST, i – COUNT);\n                    OD;\n                FOR i := COUNT – 1 DOWN TO 0\n                    DO\n                        BIT[DEST, i] := BIT[SRC, i – COUNT + SIZE];\n                    OD;\n        FI;\nFI;",
    "flagsAffectedText": "If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcp14pd",
    "category": "Core Instructions",
    "instructionName": "VRCP14PD\n\t\t— Compute Approximate Reciprocals of Packed Float64 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes the approximate reciprocals of the packed double precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 4C /r VRCP14PD xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes the approximate reciprocals of the packed double precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 4C /r VRCP14PD ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes the approximate reciprocals of the packed double precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 4C /r VRCP14PD zmm1 {k1}{z}, zmm2/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pinsrb:pinsrd:pinsrq",
    "category": "Core Instructions",
    "instructionName": "PINSRB/PINSRD/PINSRQ\n\t\t— Insert Byte/Dword/Qword",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F 3A 20 /r ib PINSRB xmm1, r32/m8, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F 3A 22 /r ib PINSRD xmm1, r/m32, imm8"
      },
      {
        "64/32 bit Mode Support": "V/N. E.",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by imm8.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 REX.W 0F 3A 22 /r ib PINSRQ xmm1, r/m64, imm8"
      },
      {
        "64/32 bit Mode Support": "V1/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 20 /r ib VPINSRB xmm1, xmm2, r32/m8, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 22 /r ib VPINSRD xmm1, xmm2, r/m32, imm8"
      },
      {
        "64/32 bit Mode Support": "V/I2",
        "CPUID Feature Flag": "AVX",
        "Description": "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.W1 22 /r ib VPINSRQ xmm1, xmm2, r/m64, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.WIG 20 /r ib VPINSRB xmm1, xmm2, r32/m8, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 22 /r ib VPINSRD xmm1, xmm2, r32/m32, imm8"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 22 /r ib VPINSRQ xmm1, xmm2, r64/m64, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. VEX.L must be 0, otherwise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.\nEVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
    "operationText": "CASE OF\n    PINSRB: SEL:=COUNT[3:0];\n            MASK := (0FFH << (SEL * 8));\n            TEMP := (((SRC[7:0] << (SEL *8)) AND MASK);\n    PINSRD: SEL := COUNT[1:0];\n            MASK := (0FFFFFFFFH << (SEL * 32));\n            TEMP := (((SRC << (SEL *32)) AND MASK) ;\n    PINSRQ: SEL:=COUNT[0]\n            MASK := (0FFFFFFFFFFFFFFFFH << (SEL * 64));\n            TEMP := (((SRC << (SEL *64)) AND MASK) ;\nESAC;\n        DEST := ((DEST AND NOT MASK) OR TEMP);\nSEL := imm8[3:0]\nDEST[127:0] := write_b_element(SEL, SRC2, SRC1)\nDEST[MAXVL-1:128] := 0\nSEL := imm8[1:0]\nDEST[127:0] := write_d_element(SEL, SRC2, SRC1)\nDEST[MAXVL-1:128] := 0\nSEL := imm8[0]\nDEST[127:0] := write_q_element(SEL, SRC2, SRC1)\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movs:movsb:movsw:movsd:movsq",
    "category": "Core Instructions",
    "instructionName": "MOVS/MOVSB/MOVSW/MOVSD/MOVSQ\n\t\t— Move Data From String to String",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.",
        "Instruction": "MOVS m8, m8",
        "Op/En": "ZO",
        "Opcode": "A4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.",
        "Instruction": "MOVS m16, m16",
        "Op/En": "ZO",
        "Opcode": "A5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.",
        "Instruction": "MOVS m32, m32",
        "Op/En": "ZO",
        "Opcode": "A5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move qword from address (R|E)SI to (R|E)DI.",
        "Instruction": "MOVS m64, m64",
        "Op/En": "ZO",
        "Opcode": "REX.W + A5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.",
        "Instruction": "MOVSB",
        "Op/En": "ZO",
        "Opcode": "A4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.",
        "Instruction": "MOVSW",
        "Op/En": "ZO",
        "Opcode": "A5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.",
        "Instruction": "MOVSD",
        "Op/En": "ZO",
        "Opcode": "A5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move qword from address (R|E)SI to (R|E)DI.",
        "Instruction": "MOVSQ",
        "Op/En": "ZO",
        "Opcode": "REX.W + A5"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\nAt the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location. The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed.\nThe no-operands form provides “short forms” of the byte, word, and doubleword versions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move).\nAfter the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-\nmented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
    "operationText": "DEST := SRC;\nNon-64-bit Mode:\nIF (Byte move)\n    THEN IF DF = 0\n        THEN\n            (E)SI := (E)SI + 1;\n            (E)DI := (E)DI + 1;\n        ELSE\n            (E)SI := (E)SI – 1;\n            (E)DI := (E)DI – 1;\n        FI;\n    ELSE IF (Word move)\n        THEN IF DF = 0\n            (E)SI := (E)SI + 2;\n            (E)DI := (E)DI + 2;\n            FI;\n        ELSE\n            (E)SI := (E)SI – 2;\n            (E)DI := (E)DI – 2;\n        FI;\n    ELSE IF (Doubleword move)\n        THEN IF DF = 0\n            (E)SI := (E)SI + 4;\n            (E)DI := (E)DI + 4;\n            FI;\n        ELSE\n            (E)SI := (E)SI – 4;\n            (E)DI := (E)DI – 4;\n        FI;\nFI;\n64-bit Mode:\nIF (Byte move)\n    THEN IF DF = 0\n        THEN\n            (R|E)SI := (R|E)SI + 1;\n            (R|E)DI := (R|E)DI + 1;\n        ELSE\n            (R|E)SI := (R|E)SI – 1;\n            (R|E)DI := (R|E)DI – 1;\n        FI;\n    ELSE IF (Word move)\n        THEN IF DF = 0\n            (R|E)SI := (R|E)SI + 2;\n            (R|E)DI := (R|E)DI + 2;\n            FI;\n        ELSE\n            (R|E)SI := (R|E)SI – 2;\n            (R|E)DI := (R|E)DI – 2;\n        FI;\n    ELSE IF (Doubleword move)\n        THEN IF DF = 0\n            (R|E)SI := (R|E)SI + 4;\n            (R|E)DI := (R|E)DI + 4;\n            FI;\n        ELSE\n            (R|E)SI := (R|E)SI – 4;\n            (R|E)DI := (R|E)DI – 4;\n        FI;\n    ELSE IF (Quadword move)\n        THEN IF DF = 0\n            (R|E)SI := (R|E)SI + 8;\n            (R|E)DI := (R|E)DI + 8;\n            FI;\n        ELSE\n            (R|E)SI := (R|E)SI – 8;\n            (R|E)DI := (R|E)DI – 8;\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrndscalepd",
    "category": "Core Instructions",
    "instructionName": "VRNDSCALEPD\n\t\t— Round Packed Float64 Values to Include a Given Number of Fraction Bits",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rounds packed double precision floating-point values in xmm2/m128/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 09 /r ib VRNDSCALEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rounds packed double precision floating-point values in ymm2/m256/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 09 /r ib VRNDSCALEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rounds packed double precision floating-point values in zmm2/m512/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 09 /r ib VRNDSCALEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movq2dq",
    "category": "Core Instructions",
    "instructionName": "MOVQ2DQ\n\t\t— Move Quadword from MMX Technology to XMM Register",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move quadword from mmx to low quadword of xmm.",
        "Op/En": "RM",
        "Opcode / Instruction": "F3 0F D6 /r MOVQ2DQ xmm, mm"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Moves the quadword from the source operand (second operand) to the low quadword of the destination operand (first operand). The source operand is an MMX technology register and the destination operand is an XMM register.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVQ2DQ instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST[63:0] := SRC[63:0];\nDEST[127:64] := 00000000000000000H;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If CR0.EM[bit 2] = 1.; \ncolumn_1: If CR4.OSFXSR[bit 9] = 0.; \ncolumn_1: If CPUID.01H:EDX.SSE2[bit 26] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_2: If there is a pending x87 FPU exception.; column_1: #MF;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "simdFloating-Point¶": [
        "None."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pabsb:pabsw:pabsd:pabsq",
    "category": "Core Instructions",
    "instructionName": "PABSB/PABSW/PABSD/PABSQ\n\t\t— Packed Absolute Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 38 1C /r1 PABSB mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 1C /r PABSB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 38 1D /r1 PABSW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 1D /r PABSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 38 1E /r1 PABSD mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 1E /r PABSD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 1C /r VPABSB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 1D /r VPABSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 1E /r VPABSD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 1C /r VPABSB ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 1D /r VPABSW ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 1E /r VPABSD ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 1C /r VPABSB xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 1C /r VPABSB ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compute the absolute value of bytes in zmm2/m512 and store UNSIGNED result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 1C /r VPABSB zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 1D /r VPABSW xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 1D /r VPABSW ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compute the absolute value of 16-bit integers in zmm2/m512 and store UNSIGNED result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 1D /r VPABSW zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compute the absolute value of 32-bit integers in xmm2/m128/m32bcst and store UNSIGNED result in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 1E /r VPABSD xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compute the absolute value of 32-bit integers in ymm2/m256/m32bcst and store UNSIGNED result in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 1E /r VPABSD ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compute the absolute value of 32-bit integers in zmm2/m512/m32bcst and store UNSIGNED result in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 1E /r VPABSD zmm1 {k1}{z}, zmm2/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compute the absolute value of 64-bit integers in xmm2/m128/m64bcst and store UNSIGNED result in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 1F /r VPABSQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compute the absolute value of 64-bit integers in ymm2/m256/m64bcst and store UNSIGNED result in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 1F /r VPABSQ ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compute the absolute value of 64-bit integers in zmm2/m512/m64bcst and store UNSIGNED result in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 1F /r VPABSQ zmm1 {k1}{z}, zmm2/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.\nEVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nEVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nVEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.\nVEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\n128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "Unsigned DEST[7:0] := ABS(SRC[7: 0])\nRepeat operation for 2nd through 15th bytes\nUnsigned DEST[127:120] := ABS(SRC[127:120])\nUnsigned DEST[7:0] := ABS(SRC[7: 0])\nRepeat operation for 2nd through 15th bytes\nUnsigned DEST[127:120] := ABS(SRC[127:120])\nUnsigned DEST[7:0] := ABS(SRC[7: 0])\nRepeat operation for 2nd through 31st bytes\nUnsigned DEST[255:248] := ABS(SRC[255:248])\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN\n            Unsigned DEST[i+7:i] := ABS(SRC[i+7:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nUnsigned DEST[15:0] := ABS(SRC[15:0])\nRepeat operation for 2nd through 7th 16-bit words\nUnsigned DEST[127:112] := ABS(SRC[127:112])\nUnsigned DEST[15:0] := ABS(SRC[15:0])\nRepeat operation for 2nd through 7th 16-bit words\nUnsigned DEST[127:112] := ABS(SRC[127:112])\nUnsigned DEST[15:0] := ABS(SRC[15:0])\nRepeat operation for 2nd through 15th 16-bit words\nUnsigned DEST[255:240] := ABS(SRC[255:240])\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN\n            Unsigned DEST[i+15:i] := ABS(SRC[i+15:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nUnsigned DEST[31:0] := ABS(SRC[31:0])\nRepeat operation for 2nd through 3rd 32-bit double words\nUnsigned DEST[127:96] := ABS(SRC[127:96])\nUnsigned DEST[31:0] := ABS(SRC[31:0])\nRepeat operation for 2nd through 3rd 32-bit double words\nUnsigned DEST[127:96] := ABS(SRC[127:96])\nUnsigned DEST[31:0] := ABS(SRC[31:0])\nRepeat operation for 2nd through 7th 32-bit double words\nUnsigned DEST[255:224] := ABS(SRC[255:224])\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC *is memory*)\n                THEN\n                    Unsigned DEST[i+31:i] := ABS(SRC[31:0])\n                ELSE\n                    Unsigned DEST[i+31:i] := ABS(SRC[i+31:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC *is memory*)\n                THEN\n                    Unsigned DEST[i+63:i] := ABS(SRC[63:0])\n                ELSE\n                    Unsigned DEST[i+63:i] := ABS(SRC[i+63:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPABSD/Q, see Table 2-49, “Type E4 Class Exception Conditions.”",
        "EVEX-encoded VPABSB/W, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/mfence",
    "category": "Core Instructions",
    "instructionName": "MFENCE\n\t\t— Memory Fence",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Serializes load and store operations.",
        "Op/En": "ZO",
        "Opcode / Instruction": "NP 0F AE F0 MFENCE"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.1 The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream.\nWeakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, speculative reads, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The MFENCE instruction provides a performance-efficient way of ensuring load and store ordering between routines that produce weakly-ordered results and routines that consume that data.\nProcessors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it is not ordered with respect to executions of the MFENCE instruction; data can be brought into the caches speculatively just before, during, or after the execution of an MFENCE instruction.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.\nSpecification of the instruction's opcode above indicates a ModR/M byte of F0. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, MFENCE is encoded by any opcode of the form 0F AE Fx, where x is in the range 0-7.",
    "operationText": "Wait_On_Following_Loads_And_Stores_Until(preceding_loads_and_stores_globally_visible);",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmpxchg8b:cmpxchg16b",
    "category": "Core Instructions",
    "instructionName": "CMPXCHG8B/CMPXCHG16B\n\t\t— Compare and Exchange Bytes",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid*",
        "Description": "Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX.",
        "Op/En": "M",
        "Opcode/Instruction": "0F C7 /1 CMPXCHG8B m64"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX.",
        "Op/En": "M",
        "Opcode/Instruction": "REX.W + 0F C7 /1 CMPXCHG16B m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX). The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)\nIn 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the beginning of this section for encoding data and limits. For information on the CPUID flag that indicates CMPX-CHG16B, see page 3-243.",
    "operationText": "IF (64-Bit Mode and OperandSize = 64)\n    THEN\n        TEMP128 := DEST\n        IF (RDX:RAX = TEMP128)\n            THEN\n                ZF := 1;\n                DEST := RCX:RBX;\n            ELSE\n                ZF := 0;\n                RDX:RAX := TEMP128;\n                DEST := TEMP128;\n                FI;\n        FI\n    ELSE\n        TEMP64 := DEST;\n        IF (EDX:EAX = TEMP64)\n            THEN\n                ZF := 1;\n                DEST := ECX:EBX;\n            ELSE\n                ZF := 0;\n                EDX:EAX := TEMP64;\n                DEST := TEMP64;\n                FI;\n        FI;\nFI;",
    "flagsAffectedText": "The ZF flag is set if the destination operand and EDX:EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are unaffected.",
    "exceptions": {
      "64BitMode": [
        "column_2: If the memory address is in a non-canonical form.; column_1: #GP(0); \ncolumn_1: If memory operand for CMPXCHG16B is not aligned on a 16-byte boundary.; \ncolumn_1: If CPUID.01H:ECX.CMPXCHG16B[bit 13] = 0.; \ncolumn_2: If the destination operand is not a memory location.; column_1: #UD; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #GP(0); column_2: If the destination is located in a non-writable segment.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "realAddressMode": [
        "column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; column_1: #GP; \ncolumn_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.;"
      ],
      "virtual8086Mode": [
        "column_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfnmsub132ss:vfnmsub213ss:vfnmsub231ss",
    "category": "Core Instructions",
    "instructionName": "VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS\n\t\t— Fused Negative Multiply-Subtract ofScalar Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 9F /r VFNMSUB132SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 AF /r VFNMSUB213SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 BF /r VFNMSUB231SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 9F /r VFNMSUB132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 AF /r VFNMSUB213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 BF /r VFNMSUB231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/ins:insb:insw:insd",
    "category": "Core Instructions",
    "instructionName": "INS/INSB/INSW/INSD\n\t\t— Input from Port to String",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1",
        "Instruction": "INS m8, DX",
        "Op/En": "ZO",
        "Opcode": "6C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1",
        "Instruction": "INS m16, DX",
        "Op/En": "ZO",
        "Opcode": "6D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1",
        "Instruction": "INS m32, DX",
        "Op/En": "ZO",
        "Opcode": "6D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1",
        "Instruction": "INSB",
        "Op/En": "ZO",
        "Opcode": "6C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1",
        "Instruction": "INSW",
        "Op/En": "ZO",
        "Opcode": "6D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1",
        "Instruction": "INSD",
        "Op/En": "ZO",
        "Opcode": "6D"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\nAt the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand must be “DX,” and the destination operand should be a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the INS instruction is executed.\nThe no-operands form provides “short forms” of the byte, word, and doubleword versions of the INS instructions. Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).\nAfter the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\nThe INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.\nThese instructions are only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 19, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.\nIn 64-bit mode, default address size is 64 bits, 32 bit address size is supported using the prefix 67H. The address of the memory destination is specified by RDI or EDI. 16-bit address size is not supported in 64-bit mode. The operand size is not promoted.\nThese instructions may read from the I/O port without writing to the memory location if an exception or VM exit occurs due to the write (e.g. #PF). If this would be problematic, for example because the I/O port read has side-effects, software should ensure the write to the memory location does not cause an exception or VM exit.",
    "operationText": "IF ((PE = 1) and ((CPL > IOPL) or (VM = 1)))\n    THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)\n        IF (Any I/O Permission Bit for I/O port being accessed = 1)\n            THEN (* I/O operation is not allowed *)\n                #GP(0);\n            ELSE (* I/O operation is allowed *)\n                DEST := SRC; (* Read from I/O port *)\n        FI;\n    ELSE (Real Mode or Protected Mode with CPL IOPL *)\n        DEST := SRC; (* Read from I/O port *)\nFI;\nNon-64-bit Mode:\nIF (Byte transfer)\n    THEN IF DF = 0\n        THEN (E)DI := (E)DI + 1;\n        ELSE (E)DI := (E)DI – 1; FI;\n    ELSE IF (Word transfer)\n        THENIFDF =0\n            THEN (E)DI := (E)DI + 2;\n            ELSE (E)DI := (E)DI – 2; FI;\n        ELSE (* Doubleword transfer *)\n            THEN IF DF = 0\n                THEN (E)DI := (E)DI + 4;\n                ELSE (E)DI := (E)DI – 4; FI;\n        FI;\nFI;\nFI64-bit Mode:\nIF (Byte transfer)\n    THEN IF DF = 0\n        THEN (E|R)DI := (E|R)DI + 1;\n        ELSE (E|R)DI := (E|R)DI – 1; FI;\n    ELSE IF (Word transfer)\n        THENIFDF =0\n            THEN (E)DI := (E)DI + 2;\n            ELSE (E)DI := (E)DI – 2; FI;\n        ELSE (* Doubleword transfer *)\n            THEN IF DF = 0\n                THEN (E|R)DI := (E|R)DI + 4;\n                ELSE (E|R)DI := (E|R)DI – 4; FI;\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the CPL is greater than (has less privilege) the I/O privilege level (IOPL) and any of the corresponding I/O permission bits in TSS for the I/O port being accessed is 1.; \ncolumn_1: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the destination is located in a non-writable segment.; \ncolumn_1: If an illegal memory operand effective address in the ES segments is given.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtsh2usi",
    "category": "Core Instructions",
    "instructionName": "VCVTSH2USI\n\t\t— Convert Low FP16 Value to Unsigned Integer",
    "detailsTable": [
      {
        "Description": "Convert the low FP16 element in xmm1/m16 to an unsigned integer and store the result in r32.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 79 /r VCVTSH2USI r32, xmm1/m16 {er}",
        "Support": "V/V1",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Convert the low FP16 element in xmm1/m16 to an unsigned integer and store the result in r64.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W1 79 /r VCVTSH2USI r64, xmm1/m16 {er}",
        "Support": "V/N.E.",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pcmpgtb:pcmpgtw:pcmpgtd",
    "category": "Core Instructions",
    "instructionName": "PCMPGTB/PCMPGTW/PCMPGTD\n\t\t— Compare Packed Signed Integers for Greater Than",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Compare packed signed byte integers in mm and mm/m64 for greater than.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 64 /r1 PCMPGTB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 64 /r PCMPGTB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Compare packed signed word integers in mm and mm/m64 for greater than.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 65 /r1 PCMPGTW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 65 /r PCMPGTW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Compare packed signed doubleword integers in mm and mm/m64 for greater than.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 66 /r1 PCMPGTD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 66 /r PCMPGTD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 64 /r VPCMPGTB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed word integers in xmm2 and xmm3/m128 for greater than.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 65 /r VPCMPGTW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 66 /r VPCMPGTD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 64 /r VPCMPGTB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed word integers in ymm2 and ymm3/m256 for greater than.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 65 /r VPCMPGTW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 66 /r VPCMPGTD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare Greater between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 66 /r VPCMPGTD k1 {k2}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare Greater between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 66 /r VPCMPGTD k1 {k2}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare Greater between int32 elements in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask. k2.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 66 /r VPCMPGTD k1 {k2}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 64 /r VPCMPGTB k1 {k2}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 64 /r VPCMPGTB k1 {k2}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed signed byte integers in zmm2 and zmm3/m512 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 64 /r VPCMPGTB k1 {k2}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed word integers in xmm2 and xmm3/m128 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 65 /r VPCMPGTW k1 {k2}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed word integers in ymm2 and ymm3/m256 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 65 /r VPCMPGTW k1 {k2}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed signed word integers in zmm2 and zmm3/m512 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 65 /r VPCMPGTW k1 {k2}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\nThe PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.\nEVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
    "operationText": "IF DEST[7:0] > SRC[7:0]\n    THEN DEST[7:0) := FFH;\n    ELSE DEST[7:0] := 0; FI;\n(* Continue comparison of 2nd through 7th bytes in DEST and SRC *)\nIF DEST[63:56] > SRC[63:56]\n    THEN DEST[63:56] := FFH;\n    ELSE DEST[63:56] := 0; FI;\nIF SRC1[7:0] > SRC2[7:0]\n    THEN DEST[7:0] := FFH;\n    ELSE DEST[7:0] := 0; FI;\n(* Continue comparison of 2nd through 15th bytes in SRC1 and SRC2 *)\n    IF SRC1[127:120] > SRC2[127:120]\n    THEN DEST[127:120] := FFH;\n    ELSE DEST[127:120] := 0; FI;\nIF SRC1[15:0] > SRC2[15:0]\n    THEN DEST[15:0] := FFFFH;\n    ELSE DEST[15:0] := 0; FI;\n(* Continue comparison of 2nd through 7th 16-bit words in SRC1 and SRC2 *)\n    IF SRC1[127:112] > SRC2[127:112]\n    THEN DEST[127:112] := FFFFH;\n    ELSE DEST[127:112] := 0; FI;\nIF SRC1[31:0] > SRC2[31:0]\n    THEN DEST[31:0] := FFFFFFFFH;\n    ELSE DEST[31:0] := 0; FI;\n(* Continue comparison of 2nd through 3rd 32-bit dwords in SRC1 and SRC2 *)\n    IF SRC1[127:96] > SRC2[127:96]\n    THEN DEST[127:96] := FFFFFFFFH;\n    ELSE DEST[127:96] := 0; FI;\nDEST[127:0] := COMPARE_BYTES_GREATER(DEST[127:0],SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := COMPARE_BYTES_GREATER(SRC1,SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := COMPARE_BYTES_GREATER(SRC1[127:0],SRC2[127:0])\nDEST[255:128] := COMPARE_BYTES_GREATER(SRC1[255:128],SRC2[255:128])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k2[j] OR *no writemask*\n        THEN\n            /* signed comparison */\n            CMP := SRC1[i+7:i] > SRC2[i+7:i];\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                    ; zeroing-masking onlyFI;\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0\nIF DEST[15:0] > SRC[15:0]\n    THEN DEST[15:0] := FFFFH;\n    ELSE DEST[15:0] := 0; FI;\n(* Continue comparison of 2nd and 3rd words in DEST and SRC *)\nIF DEST[63:48] > SRC[63:48]\n    THEN DEST[63:48] := FFFFH;\n    ELSE DEST[63:48] := 0; FI;\nDEST[127:0] := COMPARE_WORDS_GREATER(DEST[127:0],SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := COMPARE_WORDS_GREATER(SRC1,SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := COMPARE_WORDS_GREATER(SRC1[127:0],SRC2[127:0])\nDEST[255:128] := COMPARE_WORDS_GREATER(SRC1[255:128],SRC2[255:128])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k2[j] OR *no writemask*\n        THEN\n            /* signed comparison */\n            CMP := SRC1[i+15:i] > SRC2[i+15:i];\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                    ; zeroing-masking onlyFI;\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0\nIF DEST[31:0] > SRC[31:0]\n    THEN DEST[31:0] := FFFFFFFFH;\n    ELSE DEST[31:0] := 0; FI;\nIF DEST[63:32] > SRC[63:32]\n    THEN DEST[63:32] := FFFFFFFFH;\n    ELSE DEST[63:32] := 0; FI;\nDEST[127:0] := COMPARE_DWORDS_GREATER(DEST[127:0],SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := COMPARE_DWORDS_GREATER(SRC1,SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := COMPARE_DWORDS_GREATER(SRC1[127:0],SRC2[127:0])\nDEST[255:128] := COMPARE_DWORDS_GREATER(SRC1[255:128],SRC2[255:128])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k2[j] OR *no writemask*\n                THEN\n                    /* signed comparison */\n                    IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                        THEN CMP := SRC1[i+31:i] > SRC2[31:0];\n                        ELSE CMP := SRC1[i+31:i] > SRC2[i+31:i];\n                    FI;\n                    IF CMP = TRUE\n                        THEN DEST[j] := 1;\n                        ELSE DEST[j] := 0; FI;\n                ELSE\n                        DEST[j] := 0\n                            ; zeroing-masking only\n        I\n            ;\nENDFOR\nDEST[MAX_KL-1:KL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPCMPGTD, see Table 2-49, “Type E4 Class Exception Conditions.”",
        "EVEX-encoded VPCMPGTB/W, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movmskpd",
    "category": "Core Instructions",
    "instructionName": "MOVMSKPD\n\t\t— Extract Packed Double Precision Floating-Point Sign Mask",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 50 /r MOVMSKPD reg, xmm"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract 2-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 50 /r VMOVMSKPD reg, xmm2"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract 4-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 50 /r VMOVMSKPD reg, ymm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Extracts the sign bits from the packed double precision floating-point values in the source operand (second operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored in the 2 low-order bits of the destination operand. Zero-extend the upper bits of the destination.\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\n128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.\nVEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "DEST[0] := SRC[63]\nDEST[1] := SRC[127]\nIF DEST = r32\n    THEN DEST[31:2] := 0;\n    ELSE DEST[63:2] := 0;\nFI\nDEST[0] := SRC[63]\nDEST[1] := SRC[127]\nDEST[2] := SRC[191]\nDEST[3] := SRC[255]\nIF DEST = r32\n    THEN DEST[31:4] := 0;\n    ELSE DEST[63:4] := 0;\nFI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-24, “Type 7 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgatherdps:vgatherqps",
    "category": "Core Instructions",
    "instructionName": "VGATHERDPS/VGATHERQPS\n\t\t— Gather Packed Single Precision Floating-Point Values UsingSigned Dword/Qword Indices",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using dword indices specified in vm32x, gather single-precision floating-point values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 92 /r VGATHERDPS xmm1, vm32x, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using qword indices specified in vm64x, gather single-precision floating-point values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 93 /r VGATHERQPS xmm1, vm64x, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using dword indices specified in vm32y, gather single-precision floating-point values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 92 /r VGATHERDPS ymm1, vm32y, ymm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using qword indices specified in vm64y, gather single-precision floating-point values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 93 /r VGATHERQPS xmm1, vm64y, xmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r,w)",
        "Operand 2": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 3": "VEX.vvvv (r, w)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction conditionally loads up to 4 or 8 single-precision floating-point values from memory addresses specified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\nThe mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is specified by the most significant bit of each data element of the mask register. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.\nUsing qword indices, the instruction conditionally loads up to 2 or 4 single-precision floating-point values from the VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destination register are zero’ed with qword indices.\nThis instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.\nIf the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.\nVEX.128 version: For dword indices, the instruction will gather four single-precision floating-point values. For qword indices, the instruction will gather two values and zero the upper 64 bits of the destination.\nVEX.256 version: For dword indices, the instruction will gather eight single-precision floating-point values. For qword indices, the instruction will gather four values and zero the upper 128 bits of the destination.\nNote that:",
    "operationText": "DEST := SRC1;\nBASE_ADDR: base register encoded in VSIB addressing;\nVINDEX: the vector index register encoded by VSIB addressing;\nSCALE: scale factor encoded by SIB:[7:6];\nDISP: optional 1, 4 byte displacement;\nMASK := SRC3;\nMASK[MAXVL-1:128] := 0;\nFOR j := 0 to 3\n    i := j * 32;\n    IF MASK[31+i] THEN\n        MASK[i +31:i] := FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +31:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 3\n    i := j * 32;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX[i+31:i])*SCALE + DISP;\n    IF MASK[31+i] THEN\n        DEST[i +31:i] := FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +31:i] := 0;\nENDFOR\nDEST[MAXVL-1:128] := 0;\nMASK[MAXVL-1:64] := 0;\nFOR j := 0 to 3\n    i := j * 32;\n    IF MASK[31+i] THEN\n        MASK[i +31:i] := FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +31:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 1\n    k := j * 64;\n    i := j * 32;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[k+63:k])*SCALE + DISP;\n    IF MASK[31+i] THEN\n        DEST[i +31:i] := FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +31:i] := 0;\nENDFOR\nDEST[MAXVL-1:64] := 0;\nMASK[MAXVL-1:256] := 0;\nFOR j := 0 to 7\n    i := j * 32;\n    IF MASK[31+i] THEN\n        MASK[i +31:i] := FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +31:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 7\n    i := j * 32;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[i+31:i])*SCALE + DISP;\n    IF MASK[31+i] THEN\n        DEST[i +31:i] := FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +31:i] := 0;\nENDFOR\nDEST[MAXVL-1:256] := 0;\nMASK[MAXVL-1:128] := 0;\nFOR j := 0 to 7\n    i := j * 32;\n    IF MASK[31+i] THEN\n        MASK[i +31:i] := FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +31:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 3\n    k := j * 64;\n    i := j * 32;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[k+63:k])*SCALE + DISP;\n    IF MASK[31+i] THEN\n        DEST[i +31:i] := FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +31:i] := 0;\nENDFOR\nDEST[MAXVL-1:128] := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-27, “Type 12 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sha256msg1",
    "category": "Core Instructions",
    "instructionName": "SHA256MSG1\n\t\t— Perform an Intermediate Calculation for the Next Four SHA256 MessageDwords",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SHA",
        "Description": "Performs an intermediate calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 CC /r SHA256MSG1 xmm1, xmm2/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "The SHA256MSG1 instruction is one of two SHA256 message scheduling instructions. The instruction performs an intermediate calculation for the next four SHA256 message dwords.",
    "operationText": "W4 := SRC2[31: 0] ;\nW3 := SRC1[127:96] ;\nW2 := SRC1[95:64] ;\nW1 := SRC1[63: 32] ;\nW0 := SRC1[31: 0] ;\nDEST[127:96] := W3 + σ0( W4);\nDEST[95:64] := W2 + σ0( W3);\nDEST[63:32] := W1 + σ0( W2);\nDEST[31:0] := W0 + σ0( W1);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vextracti128:vextracti32x4:vextracti64x2:vextracti32x8:vextracti64x4",
    "category": "Core Instructions",
    "instructionName": "VEXTRACTI128/VEXTRACTI32x4/VEXTRACTI64x2/VEXTRACTI32x8/VEXTRACTI64x4\n\t\t— ExtractPacked Integer Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Extract 128 bits of integer data from ymm2 and store results in xmm1/m128.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 39 /r ib VEXTRACTI128 xmm1/m128, ymm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Extract 128 bits of double-word integer values from ymm2 and store results in xmm1/m128 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 39 /r ib VEXTRACTI32X4 xmm1/m128 {k1}{z}, ymm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Extract 128 bits of double-word integer values from zmm2 and store results in xmm1/m128 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 39 /r ib VEXTRACTI32x4 xmm1/m128 {k1}{z}, zmm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Extract 128 bits of quad-word integer values from ymm2 and store results in xmm1/m128 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 39 /r ib VEXTRACTI64X2 xmm1/m128 {k1}{z}, ymm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Extract 128 bits of quad-word integer values from zmm2 and store results in xmm1/m128 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 39 /r ib VEXTRACTI64X2 xmm1/m128 {k1}{z}, zmm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Extract 256 bits of double-word integer values from zmm2 and store results in ymm1/m256 subject to writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 3B /r ib VEXTRACTI32X8 ymm1/m256 {k1}{z}, zmm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Extract 256 bits of quad-word integer values from zmm2 and store results in ymm1/m256 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 3B /r ib VEXTRACTI64x4 ymm1/m256 {k1}{z}, zmm2, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple2"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple4"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple8"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fincstp",
    "category": "Core Instructions",
    "instructionName": "FINCSTP\n\t\t— Increment Stack-Top Pointer",
    "detailsTable": [
      {
        "Description": "Increment the TOP field in the FPU status register.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 F7",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a 7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag for the previous top-of-stack register is not marked empty.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF TOP = 7\n    THEN TOP := 0;\n    ELSE TOP := TOP + 1;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_2: If there is a pending x87 FPU exception.; column_1: #MF; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdtscp",
    "category": "Core Instructions",
    "instructionName": "RDTSCP\n\t\t— Read Time-Stamp Counter and Processor ID",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Read 64-bit time-stamp counter and IA32_TSC_AUX value into EDX:EAX and ECX.",
        "Instruction": "RDTSCP",
        "Op/En": "ZO",
        "Opcode*": "0F 01 F9"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Reads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers and also reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the ECX register. The EDX register is loaded with the high-order 32 bits of the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of the IA32_TSC MSR; and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR. On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.\nThe processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See “Time Stamp Counter” in Chapter 18 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, for specific details of the time stamp counter behavior.\nThe time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSCP instruction as follows. When the flag is clear, the RDTSCP instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0.\nThe RDTSCP instruction is not a serializing instruction, but it does wait until all previous instructions have executed and all previous loads are globally visible.1 But it does not wait for previous stores to be globally visible, and subsequent instructions may begin execution before the read operation is performed. The following items may guide software seeking to order executions of RDTSCP:\nSee “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 26 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
    "operationText": "IF (CR4.TSD = 0) or (CPL = 0) or (CR0.PE = 0)\n    THEN\n        EDX:EAX := TimeStampCounter;\n        ECX := IA32_TSC_AUX[31:0];\n    ELSE (* CR4.TSD = 1 and (CPL = 1, 2, or 3) and CR0.PE = 1 *)\n        #GP(0);\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_2: If the LOCK prefix is used.; column_1: #UD; \ncolumn_1: If CPUID.80000001H:EDX.RDTSCP[bit 27] = 0.;"
      ],
      "realAddressMode": [
        "column_1: If CPUID.80000001H:EDX.RDTSCP[bit 27] = 0.;"
      ],
      "virtual8086Mode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If CPUID.80000001H:EDX.RDTSCP[bit 27] = 0.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fstenv:fnstenv",
    "category": "Core Instructions",
    "instructionName": "FSTENV/FNSTENV\n\t\t— Store x87 FPU Environment",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.",
        "Instruction": "FSTENV m14/28byte",
        "Opcode": "9B D9 /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.",
        "Instruction": "FNSTENV1 m14/28byte",
        "Opcode": "D9 /6"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Saves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.\nThe FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been executed.\nThese instructions are often used by exception handlers because they provide access to the FPU instruction and data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment prevents floating-point exceptions from interrupting the exception handler.\nThe assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "DEST[FPUControlWord] := FPUControlWord;\nDEST[FPUStatusWord] := FPUStatusWord;\nDEST[FPUTagWord] := FPUTagWord;\nDEST[FPUDataPointer] := FPUDataPointer;\nDEST[FPUInstructionPointer] := FPUInstructionPointer;\nDEST[FPULastInstructionOpcode] := FPULastInstructionOpcode;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/emodpr",
    "category": "SGX Instructions",
    "instructionName": "EMODPR\n\t\t— Restrict the Permissions of an EPC Page",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX2",
        "Description": "This leaf function restricts the access rights associated with a EPC page in an initialized enclave.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 0EH ENCLS[EMODPR]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EMODPR (In)",
        "column_3": "Return Error Code (Out)",
        "column_4": "Address of a SECINFO (In)",
        "column_5": "Address of the destination EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/hlt",
    "category": "Core Instructions",
    "instructionName": "HLT\n\t\t— Halt",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Halt",
        "Instruction": "HLT",
        "Op/En": "ZO",
        "Opcode": "F4"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer (CS:EIP) points to the instruction following the HLT instruction.\nWhen a HLT instruction is executed on an Intel 64 or IA-32 processor supporting Intel Hyper-Threading Technology, only the logical processor that executes the instruction is halted. The other logical processors in the physical processor remain active, unless they are each individually halted by executing a HLT instruction.\nThe HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode, the privilege level of a program or procedure must be 0 to execute the HLT instruction.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "Enter Halt state;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "None."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movlps",
    "category": "Core Instructions",
    "instructionName": "MOVLPS\n\t\t— Move Low Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move two packed single precision floating-point values from m64 to low quadword of xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 12 /r MOVLPS xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge two packed single precision floating-point values from m64 and the high quadword of xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 12 /r VMOVLPS xmm2, xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Merge two packed single precision floating-point values from m64 and the high quadword of xmm1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.0F.W0 12 /r VMOVLPS xmm2, xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move two packed single precision floating-point values from low quadword of xmm1 to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "0F 13/r MOVLPS m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move two packed single precision floating-point values from low quadword of xmm1 to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "VEX.128.0F.WIG 13/r VMOVLPS m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move two packed single precision floating-point values from low quadword of xmm1 to m64.",
        "Op / En": "E",
        "Opcode/Instruction": "EVEX.128.0F.W0 13/r VMOVLPS m64, xmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple2"
      },
      {
        "Op/En": "E",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple2"
      }
    ],
    "descriptionText": "This instruction cannot be used for register to register or memory to memory moves.\n128-bit Legacy SSE load:\nMoves two packed single precision floating-point values from the source 64-bit memory operand and stores them in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.\nVEX.128 & EVEX encoded load:\nLoads two packed single precision floating-point values from the source 64-bit memory operand (the third operand), merges them with the upper 64-bits of the first source operand (the second operand), and stores them in the low 128-bits of the destination register (the first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n128-bit store:\nLoads two packed single precision floating-point values from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).\nNote: VMOVLPS (store) (VEX.128.0F 13 /r) is legal and has the same behavior as the existing 0F 13 store. For VMOVLPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.\nIf VMOVLPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception.",
    "operationText": "DEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] (Unmodified)\nDEST[63:0] := SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC[63:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movntps",
    "category": "Core Instructions",
    "instructionName": "MOVNTPS\n\t\t— Store Packed Single Precision Floating-Point Values Using Non-Temporal Hint",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move packed single precision values xmm1 to mem using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 2B /r MOVNTPS m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move packed single precision values xmm1 to mem using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.0F.WIG 2B /r VMOVNTPS m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move packed single precision values ymm1 to mem using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.0F.WIG 2B /r VMOVNTPS m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move packed single precision values in xmm1 to m128 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.0F.W0 2B /r VMOVNTPS m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move packed single precision values in ymm1 to m256 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.0F.W0 2B /r VMOVNTPS m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move packed single precision values in zmm1 to m512 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.0F.W0 2B /r VMOVNTPS m512, zmm1"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Moves the packed single precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed single precision, floating-pointing. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple processors might use different memory types to read/write the destination memory locations.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "VL = 128, 256, 512\nDEST[VL-1:0] := SRC[VL-1:0]\nDEST[MAXVL-1:VL] := 0\nDEST := SRC",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Exceptions Type1.SSE in Table 2-18, “Type 1 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-45, “Type E1NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movdiri",
    "category": "Core Instructions",
    "instructionName": "MOVDIRI\n\t\t— Move Doubleword as Direct Store",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MOVDIRI",
        "Description": "Move doubleword from r32 to m32 using direct store.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 38 F9 /r MOVDIRI m32, r32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MOVDIRI",
        "Description": "Move quadword from r64 to m64 using direct store.",
        "Op/En": "A",
        "Opcode/Instruction": "NP REX.W + 0F 38 F9 /r MOVDIRI m64, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a direct-store operation. The source operand is a general purpose register. The destination operand is a 32-bit memory location. In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See summary chart at the beginning of this section for encoding data and limits.\nThe direct-store is implemented by using write combining (WC) memory type protocol for writing data. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. If the destination address is cached, the line is written-back (if modified) and invalidated from the cache, before the direct-store. Unlike stores with non-temporal hint that allow uncached (UC) and write-protected (WP) memory-type for the destination to override the non-temporal hint, direct-stores always follow WC memory type protocol irrespective of the destination address memory type (including UC and WP types).\nUnlike WC stores and stores with non-temporal hint, direct-stores are eligible for immediate eviction from the write-combining buffer, and thus not combined with younger stores (including direct-stores) to the same address. Older WC and non-temporal stores held in the write-combing buffer may be combined with younger direct stores to the same address. Direct stores are weakly ordered relative to other stores. Software that desires stronger ordering should use a fencing instruction (MFENCE or SFENCE) before or after a direct store to enforce the ordering desired.\nDirect-stores issued by MOVDIRI to a destination aligned to a 4-byte boundary (8-byte boundary if used with REX.W prefix) guarantee 4-byte (8-byte with REX.W prefix) write-completion atomicity. This means that the data arrives at the destination in a single undivided 4-byte (or 8-byte) write transaction. If the destination is not aligned for the write size, the direct-stores issued by MOVDIRI are split and arrive at the destination in two parts. Each part of such split direct-store will not merge with younger stores but can arrive at the destination in either order. Availability of the MOVDIRI instruction is indicated by the presence of the CPUID feature flag MOVDIRI (bit 27 of the ECX register in leaf 07H, see “CPUID—CPU Identification” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A).",
    "operationText": "DEST := SRC;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in non-canonical form.; \ncolumn_2: (fault-code) For a page fault.; column_1: #PF; \ncolumn_1: #UD; column_2: If CPUID.07H.0H:ECX.MOVDIRI[bit 27] = 0.; \ncolumn_1: If LOCK prefix or operand-size (66H) prefix is used.; \ncolumn_1: #AC; column_2: If alignment checking is enabled and an unaligned memory reference made while in current privilege level 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.07H.0H:ECX.MOVDIRI[bit 27] = 0.; \ncolumn_1: If LOCK prefix or operand-size (66H) prefix is used.; \ncolumn_1: #AC; column_2: If alignment checking is enabled and an unaligned memory reference made while in current privilege level 3.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If CPUID.07H.0H:ECX.MOVDIRI[bit 27] = 0.; \ncolumn_1: If LOCK prefix or operand-size (66H) prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode.",
        "column_2: If alignment checking is enabled and an unaligned memory reference made while in current privilege level 3.; column_1: #AC;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvttsd2si",
    "category": "Core Instructions",
    "instructionName": "CVTTSD2SI\n\t\t— Convert With Truncation Scalar Double Precision Floating-Point Value to SignedInteger",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 2C /r CVTTSD2SI r32, xmm1/m64"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 REX.W 0F 2C /r CVTTSD2SI r64, xmm1/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.F2.0F.W0 2C /r 1 VCVTTSD2SI r32, xmm1/m64"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.W1 2C /r 1 VCVTTSD2SI r64, xmm1/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W0 2C /r VCVTTSD2SI r32, xmm1/m64{sae}"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 2C /r VCVTTSD2SI r64, xmm1/m64{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Fixed"
      }
    ],
    "descriptionText": "Converts a double precision floating-point value in the source operand (the second operand) to a signed double-word integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the double precision floating-point value is contained in the low quadword of the register.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\nIf a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nIf a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.\nLegacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.\nVEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCVTTSD2SI is encoded with VEX.L=0. Encoding VCVTTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF 64-Bit Mode and OperandSize = 64\nTHEN\n    DEST[63:0] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0]);\nELSE\n    DEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0]);\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/capabilities",
    "category": "SMX Instructions",
    "instructionName": "GETSEC[CAPABILITIES]\n\t\t— Report the SMX Capabilities",
    "detailsTable": [
      {
        "Description": "Report the SMX capabilities. The capabilities index is input in EBX with the result returned in EAX.",
        "Instruction": "GETSEC[CAPABILITIES]",
        "Opcode": "NP 0F 37 (EAX = 0)"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The GETSEC[CAPABILITIES] function returns a bit vector of supported GETSEC leaf functions. The CAPABILITIES leaf of GETSEC is selected with EAX set to 0 at entry. EBX is used as the selector for returning the bit vector field in EAX. GETSEC[CAPABILITIES] may be executed at all privilege levels, but the CR4.SMXE bit must be set or an undefined opcode exception (#UD) is returned.\nWith EBX = 0 upon execution of GETSEC[CAPABILITIES], EAX returns the a bit vector representing status on the presence of a Intel® TXT-capable chipset and the first 30 available GETSEC leaf functions. The format of the returned bit vector is provided in Table 7-3.\nIf bit 0 is set to 1, then an Intel® TXT-capable chipset has been sampled present by the processor. If bits in the range of 1-30 are set, then the corresponding GETSEC leaf function is available. If the bit value at a given bit index is 0, then the GETSEC leaf function corresponding to that index is unsupported and attempted execution results in a #UD.\nBit 31 of EAX indicates if further leaf indexes are supported. If the Extended Leafs bit 31 is set, then additional leaf functions are accessed by repeating GETSEC[CAPABILITIES] with EBX incremented by one. When the most significant bit of EAX is not set, then additional GETSEC leaf functions are not supported; indexing EBX to a higher value results in EAX returning zero.",
    "operationText": "IF (CR4.SMXE=0)\n    THEN #UD;\nELSIF (in VMX non-root operation)\n    THEN VM Exit (reason=”GETSEC instruction”);\nIF (EBX=0) THEN\n        BitVector := 0;\n        IF (TXT chipset present)\n            BitVector[Chipset present] := 1;\n        IF (ENTERACCS Available)\n            THEN BitVector[ENTERACCS] := 1;\n        IF (EXITAC Available)\n            THEN BitVector[EXITAC] := 1;\n        IF (SENTER Available)\n            THEN BitVector[SENTER] := 1;\n        IF (SEXIT Available)\n            THEN BitVector[SEXIT] := 1;\n        IF (PARAMETERS Available)\n            THEN BitVector[PARAMETERS] := 1;\n        IF (SMCTRL Available)\n            THEN BitVector[SMCTRL] := 1;\n        IF (WAKEUP Available)\n            THEN BitVector[WAKEUP] := 1;\n        EAX := BitVector;\nELSE\n    EAX := 0;\nEND;;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/prefetchh",
    "category": "Core Instructions",
    "instructionName": "PREFETCHh\n\t\t— Prefetch Data Into Caches",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move data from m8 closer to the processor using T0 hint.",
        "Instruction": "PREFETCHT0 m8",
        "Op/En": "M",
        "Opcode": "0F 18 /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move data from m8 closer to the processor using T1 hint.",
        "Instruction": "PREFETCHT1 m8",
        "Op/En": "M",
        "Opcode": "0F 18 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move data from m8 closer to the processor using T2 hint.",
        "Instruction": "PREFETCHT2 m8",
        "Op/En": "M",
        "Opcode": "0F 18 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move data from m8 closer to the processor using NTA hint.",
        "Instruction": "PREFETCHNTA m8",
        "Op/En": "M",
        "Opcode": "0F 18 /0"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by a locality hint:\nThe source operand is a byte memory location. (The locality hints are encoded into the machine level instruction using bits 3 through 5 of the ModR/M byte.)\nIf the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.\nThe PREFETCHh instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor in anticipation of future use.\nThe implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes. Additional details of the implementation-dependent locality hints are described in Section 7.4 of Intel® 64 and IA-32 Architectures Optimization Reference Manual.\nIt should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHh instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHh instruction is also unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHh instructions, or any other general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "FETCH (m8);",
    "flagsAffectedText": "",
    "exceptions": {
      "numeric¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmulph",
    "category": "Core Instructions",
    "instructionName": "VMULPH\n\t\t— Multiply Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Multiply packed FP16 values from xmm3/m128/m16bcst to xmm2 and store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 59 /r VMULPH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm3/m256/m16bcst to ymm2 and store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 59 /r VMULPH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values in zmm3/m512/m16bcst with zmm2 and store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 59 /r VMULPH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/out",
    "category": "Core Instructions",
    "instructionName": "OUT\n\t\t— Output to Port",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output byte in AL to I/O port address imm8.",
        "Instruction": "OUT imm8, AL",
        "Op/En": "I",
        "column_1": "E6 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output word in AX to I/O port address imm8.",
        "Instruction": "OUT imm8, AX",
        "Op/En": "I",
        "column_1": "E7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output doubleword in EAX to I/O port address imm8.",
        "Instruction": "OUT imm8, EAX",
        "Op/En": "I",
        "column_1": "E7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output byte in AL to I/O port address in DX.",
        "Instruction": "OUT DX, AL",
        "Op/En": "ZO",
        "column_1": "EE"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output word in AX to I/O port address in DX.",
        "Instruction": "OUT DX, AX",
        "Op/En": "ZO",
        "column_1": "EF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output doubleword in EAX to I/O port address in DX.",
        "Instruction": "OUT DX, EAX",
        "Op/En": "ZO",
        "column_1": "EF"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "I",
        "Operand 1": "imm8",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies the value from the second operand (source operand) to the I/O port specified with the destination operand (first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-immediate or the DX register. Using a byte immediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source operand allows I/O ports from 0 to 65,535 to be accessed.\nThe size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\nAt the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.\nThis instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 19, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF ((PE = 1) and ((CPL > IOPL) or (VM = 1)))\n    THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)\n        IF (Any I/O Permission Bit for I/O port being accessed = 1)\n            THEN (* I/O operation is not allowed *)\n                #GP(0);\n            ELSE ( * I/O operation is allowed *)\n                DEST := SRC; (* Writes to selected I/O port *)\n        FI;\n    ELSE (Real Mode or Protected Mode with CPL ≤ IOPL *)\n        DEST := SRC; (* Writes to selected I/O port *)\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same as protected mode exceptions."
      ],
      "compatibilityMode": [
        "Same as protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmovsh",
    "category": "Core Instructions",
    "instructionName": "VMOVSH\n\t\t— Move Scalar FP16 Value",
    "detailsTable": [
      {
        "Description": "Move FP16 value from m16 to xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 10 /r VMOVSH xmm1{k1}{z}, m16",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Move low FP16 value from xmm1 to m16 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 11 /r VMOVSH m16{k1}, xmm1",
        "Support": "V/V",
        "column_2": "B",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Move low FP16 values from xmm3 to xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 10 /r VMOVSH xmm1{k1}{z}, xmm2, xmm3",
        "Support": "V/V",
        "column_2": "C",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Move low FP16 values from xmm3 to xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 11 /r VMOVSH xmm1{k1}{z}, xmm2, xmm3",
        "Support": "V/V",
        "column_2": "D",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:reg (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttph2udq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPH2UDQ\n\t\t— Convert with Truncation Packed FP16 Values to Unsigned DoublewordIntegers",
    "detailsTable": [
      {
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four unsigned doubleword integers, and store the result in xmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 78 /r VCVTTPH2UDQ xmm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned doubleword integers, and store the result in ymm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 78 /r VCVTTPH2UDQ ymm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen unsigned doubleword integers, and store the result in zmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 78 /r VCVTTPH2UDQ zmm1{k1}{z}, ymm2/m256/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movdqa:vmovdqa32:vmovdqa64",
    "category": "Core Instructions",
    "instructionName": "MOVDQA/VMOVDQA32/VMOVDQA64\n\t\t— Move Aligned Packed Integer Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move aligned packed integer values from xmm2/mem to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 6F /r MOVDQA xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move aligned packed integer values from xmm1 to xmm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 7F /r MOVDQA xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed integer values from xmm2/mem to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 6F /r VMOVDQA xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed integer values from xmm1 to xmm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 7F /r VMOVDQA xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed integer values from ymm2/mem to ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 6F /r VMOVDQA ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed integer values from ymm1 to ymm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 7F /r VMOVDQA ymm2/m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 6F /r VMOVDQA32 xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 6F /r VMOVDQA32 ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move aligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 6F /r VMOVDQA32 zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 7F /r VMOVDQA32 xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 7F /r VMOVDQA32 ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move aligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 7F /r VMOVDQA32 zmm2/m512 {k1}{z}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed quadword integer values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 6F /r VMOVDQA64 xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed quadword integer values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 6F /r VMOVDQA64 ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move aligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 6F /r VMOVDQA64 zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 7F /r VMOVDQA64 xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 7F /r VMOVDQA64 ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move aligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 7F /r VMOVDQA64 zmm2/m512 {k1}{z}, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nEVEX encoded versions:\nMoves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second operand) to the destination operand (the first operand). This instruction can be used to load a vector register from an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.\nThe destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the writemask.\nVEX.256 encoded version:\nMoves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.\nWhen the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction. Bits (MAXVL-1:256) of the destination register are zeroed.\n128-bit versions:\nMoves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.\nWhen the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                    ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0\n                    ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE *DEST[i+31:i] remains unchanged*\n            ; merging-masking\n    FI;\nENDFOR;\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE *DEST[i+63:i] remains unchanged*\n            ; merging-masking\n    FI;\nENDFOR;\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := SRC[255:0]\nDEST[MAXVL-1:256] := 0\nDEST[255:0] := SRC[255:0]\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := SRC[127:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Exceptions Type1.SSE2 in Table 2-18, “Type 1 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-44, “Type E1 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fchs",
    "category": "Core Instructions",
    "instructionName": "FCHS\n\t\t— Change Sign",
    "detailsTable": [
      {
        "Description": "Complements sign of ST(0).",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 E0",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magnitude or vice versa. The following table shows the results obtained when changing the sign of various classes of numbers.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "SignBit(ST(0)) := NOT (SignBit(ST(0)));",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        ""
      ],
      "protectedMode": [
        "column_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/subsd",
    "category": "Core Instructions",
    "instructionName": "SUBSD\n\t\t— Subtract Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract the low double precision floating-point value in xmm2/m64 from xmm1 and store the result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 5C /r SUBSD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract the low double precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 5C /r VSUBSD xmm1,xmm2, xmm3/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Subtract the low double precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 5C /r VSUBSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Subtract the low double precision floating-point value in the second source operand from the first source operand and stores the double precision floating-point result in the low quadword of the destination operand.\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded versions: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: The low quadword element of the destination operand is updated according to the write-mask.\nSoftware should ensure VSUBSD is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (SRC2 *is register*) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := SRC1[63:0] - SRC2[63:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0] - SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] - SRC[63:0]\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aas",
    "category": "Core Instructions",
    "instructionName": "AAS\n\t\t— ASCII Adjust AL After Subtraction",
    "detailsTable": [
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "ASCII adjust AL after subtraction.",
        "Instruction": "AAS",
        "Op/En": "ZO",
        "Opcode": "3F"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.\nIf the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL register is left with its top four bits set to 0.\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.",
    "operationText": "IF 64-bit mode\n    THEN\n        #UD;\n    ELSE\n        IF ((AL AND 0FH) > 9) or (AF = 1)\n            THEN\n                AX := AX – 6;\n                AH := AH – 1;\n                AF := 1;\n                CF := 1;\n                AL := AL AND 0FH;\n            ELSE\n                CF := 0;\n                AF := 0;\n                AL := AL AND 0FH;\n        FI;\nFI;",
    "flagsAffectedText": "The AF and CF flags are set to 1 if there is a decimal borrow; otherwise, they are cleared to 0. The OF, SF, ZF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        "Same exceptions as protected mode."
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        "Same exceptions as protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/kmovw:kmovb:kmovq:kmovd",
    "category": "Core Instructions",
    "instructionName": "KMOVW/KMOVB/KMOVQ/KMOVD\n\t\t— Move From and to Mask Registers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move 16 bits mask from k2/m16 and store the result in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.L0.0F.W0 90 /r KMOVW k1, k2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Move 8 bits mask from k2/m8 and store the result in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.L0.66.0F.W0 90 /r KMOVB k1, k2/m8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move 64 bits mask from k2/m64 and store the result in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.L0.0F.W1 90 /r KMOVQ k1, k2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move 32 bits mask from k2/m32 and store the result in k1.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.L0.66.0F.W1 90 /r KMOVD k1, k2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move 16 bits mask from k1 and store the result in m16.",
        "Op/En": "MR",
        "Opcode/Instruction": "VEX.L0.0F.W0 91 /r KMOVW m16, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Move 8 bits mask from k1 and store the result in m8.",
        "Op/En": "MR",
        "Opcode/Instruction": "VEX.L0.66.0F.W0 91 /r KMOVB m8, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move 64 bits mask from k1 and store the result in m64.",
        "Op/En": "MR",
        "Opcode/Instruction": "VEX.L0.0F.W1 91 /r KMOVQ m64, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move 32 bits mask from k1 and store the result in m32.",
        "Op/En": "MR",
        "Opcode/Instruction": "VEX.L0.66.0F.W1 91 /r KMOVD m32, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move 16 bits mask from r32 to k1.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.0F.W0 92 /r KMOVW k1, r32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Move 8 bits mask from r32 to k1.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.66.0F.W0 92 /r KMOVB k1, r32"
      },
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move 64 bits mask from r64 to k1.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.F2.0F.W1 92 /r KMOVQ k1, r64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move 32 bits mask from r32 to k1.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.F2.0F.W0 92 /r KMOVD k1, r32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move 16 bits mask from k1 to r32.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.0F.W0 93 /r KMOVW r32, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Move 8 bits mask from k1 to r32.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.66.0F.W0 93 /r KMOVB r32, k1"
      },
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move 64 bits mask from k1 to r64.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.F2.0F.W1 93 /r KMOVQ r64, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move 32 bits mask from k1 to r32.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.F2.0F.W0 93 /r KMOVD r32, k1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w, ModRM:[7:6] must not be 11b)",
        "Operand 2": "ModRM:reg (r)"
      },
      {
        "Op/En": "RR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Copies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.\nWhen moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination’s size is 32 bits. In 64-bit mode, the default GPR destination’s size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.",
    "operationText": "IF *destination is a memory location*\n    DEST[15:0] := SRC[15:0]\nIF *destination is a mask register or a GPR *\n    DEST := ZeroExtension(SRC[15:0])\nIF *destination is a memory location*\n    DEST[7:0] := SRC[7:0]\nIF *destination is a mask register or a GPR *\n    DEST := ZeroExtension(SRC[7:0])\nIF *destination is a memory location or a GPR*\n    DEST[63:0] := SRC[63:0]\nIF *destination is a mask register*\n    DEST := ZeroExtension(SRC[63:0])\nIF *destination is a memory location*\n    DEST[31:0] := SRC[31:0]\nIF *destination is a mask register or a GPR *\n    DEST := ZeroExtension(SRC[31:0])",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Instructions with RR operand encoding, see Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”",
        "Instructions with RM or MR operand encoding, see Table 2-64, “TYPE K21 Exception Definition (VEX-Encoded OpMask Instructions Addressing Memory).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sti",
    "category": "Core Instructions",
    "instructionName": "STI\n\t\t— Set Interrupt Flag",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.",
        "Instruction": "STI",
        "Op/En": "ZO",
        "Opcode": "FB"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "In most cases, STI sets the interrupt flag (IF) in the EFLAGS register. This allows the processor to respond to maskable hardware interrupts.\nIf IF = 0, maskable hardware interrupts remain inhibited on the instruction boundary following an execution of STI. (The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning from a procedure or subroutine. For instance, if an STI instruction is followed by an RET instruction, the RET instruction is allowed to execute before external interrupts are recognized. No interrupts can be recognized if an execution of CLI immediately follow such an execution of STI.) The inhibition ends after delivery of another event (e.g., exception) or the execution of the next instruction.\nThe IF flag and the STI and CLI instructions do not prohibit the generation of exceptions and nonmaskable interrupts (NMIs). However, NMIs (and system-management interrupts) may be inhibited on the instruction boundary following an execution of STI that begins with IF = 0.\nOperation is different in two modes defined as follows:\nIf IOPL < 3, EFLAGS.VIP = 1, and either VME mode or PVI mode is active, STI sets the VIF flag in the EFLAGS register, leaving IF unaffected.\nTable 4-19 indicates the action of the STI instruction depending on the processor operating mode, IOPL, CPL, and EFLAGS.VIP.\n2. For this table, “protected mode” applies whenever CR0.PE = 1 and EFLAGS.VM = 0; it includes compatibility mode and 64-bit mode.\n3. PVI mode and virtual-8086 mode each imply CPL = 3.",
    "operationText": "IF CR0.PE = 0 (* Executing in real-address mode *)\n    THEN IF := 1; (* Set Interrupt Flag *)\n    ELSE\n        IF IOPL ≥ CPL (* CPL = 3 if EFLAGS.VM = 1 *)\n            THEN IF := 1; (* Set Interrupt Flag *)\n            ELSE\n                IF VME mode OR PVI mode\n                    THEN\n                        IF EFLAGS.VIP = 0\n                            THEN VIF := 1; (* Set Virtual Interrupt Flag *)\n                            ELSE #GP(0);\n                        FI;\n                    ELSE #GP(0);\n                FI;\n        FI;\nFI;",
    "flagsAffectedText": "Either the IF flag or the VIF flag is set to 1. Other flags are unaffected.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CPL is greater than IOPL and EFLAGS.VIP = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        "column_1: If IOPL is less than 3 and EFLAGS.VIP = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtudq2ps",
    "category": "Core Instructions",
    "instructionName": "VCVTUDQ2PS\n\t\t— Convert Packed Unsigned Doubleword Integers to Packed Single PrecisionFloating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed single precision floating-point values in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F2.0F.W0 7A /r VCVTUDQ2PS xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to packed single precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F2.0F.W0 7A /r VCVTUDQ2PS ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert sixteen packed unsigned doubleword integers from zmm2/m512/m32bcst to sixteen packed single precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F2.0F.W0 7A /r VCVTUDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtph2uw",
    "category": "Core Instructions",
    "instructionName": "VCVTPH2UW\n\t\t— Convert Packed FP16 Values to Unsigned Word Integers",
    "detailsTable": [
      {
        "Description": "Convert packed FP16 values in xmm2/m128/m16bcst to unsigned word integers, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 7D /r VCVTPH2UW xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert packed FP16 values in ymm2/m256/m16bcst to unsigned word integers, and store the result in ymm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 7D /r VCVTPH2UW ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert packed FP16 values in zmm2/m512/m16bcst to unsigned word integers, and store the result in zmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 7D /r VCVTPH2UW zmm1{k1}{z}, zmm2/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpdpbusd",
    "category": "Core Instructions",
    "instructionName": "VPDPBUSD\n\t\t— Multiply and Add Unsigned and Signed Bytes",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX-VNNI",
        "Description": "Multiply groups of 4 pairs of signed bytes in xmm3/m128 with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 50 /r VPDPBUSD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX-VNNI",
        "Description": "Multiply groups of 4 pairs of signed bytes in ymm3/m256 with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 50 /r VPDPBUSD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI AVX512VL",
        "Description": "Multiply groups of 4 pairs of signed bytes in xmm3/m128/m32bcst with corresponding unsigned bytes of xmm2, summing those products and adding them to doubleword result in xmm1 under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 50 /r VPDPBUSD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI AVX512VL",
        "Description": "Multiply groups of 4 pairs of signed bytes in ymm3/m256/m32bcst with corresponding unsigned bytes of ymm2, summing those products and adding them to doubleword result in ymm1 under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 50 /r VPDPBUSD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI",
        "Description": "Multiply groups of 4 pairs of signed bytes in zmm3/m512/m32bcst with corresponding unsigned bytes of zmm2, summing those products and adding them to doubleword result in zmm1 under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 50 /r VPDPBUSD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsub132pd:vfmsub213pd:vfmsub231pd",
    "category": "Core Instructions",
    "instructionName": "VFMSUB132PD/VFMSUB213PD/VFMSUB231PD\n\t\t— Fused Multiply-Subtract of Packed DoublePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 9A /r VFMSUB132PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 AA /r VFMSUB213PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 BA /r VFMSUB231PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 9A /r VFMSUB132PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 AA /r VFMSUB213PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1.S",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 BA /r VFMSUB231PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract xmm2 and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 9A /r VFMSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 AA /r VFMSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract xmm1 and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 BA /r VFMSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract ymm2 and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 9A /r VFMSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 AA /r VFMSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract ymm1 and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 BA /r VFMSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract zmm2 and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 9A /r VFMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 AA /r VFMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract zmm1 and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 BA /r VFMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/rsqrtps",
    "category": "Core Instructions",
    "instructionName": "RSQRTPS\n\t\t— Compute Reciprocals of Square Roots of Packed Single Precision Floating-PointValues",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Computes the approximate reciprocals of the square roots of the packed single precision floating-point values in xmm2/m128 and stores the results in xmm1.",
        "Op/En": "RM",
        "Opcode*/Instruction": "NP 0F 52 /r RSQRTPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes the approximate reciprocals of the square roots of packed single precision values in xmm2/mem and stores the results in xmm1.",
        "Op/En": "RM",
        "Opcode*/Instruction": "VEX.128.0F.WIG 52 /r VRSQRTPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes the approximate reciprocals of the square roots of packed single precision values in ymm2/mem and stores the results in ymm1.",
        "Op/En": "RM",
        "Opcode*/Instruction": "VEX.256.0F.WIG 52 /r VRSQRTPS ymm1, ymm2/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a SIMD computation of the approximate reciprocals of the square roots of the four packed single precision floating-point values in the source operand (second operand) and stores the packed single precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD single precision floating-point operation.\nThe relative error for this approximation is:\n|Relative Error| ≤ 1.5 ∗ 2−12\nThe RSQRTPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than −0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "DEST[31:0] := APPROXIMATE(1/SQRT(SRC[31:0]))\nDEST[63:32] := APPROXIMATE(1/SQRT(SRC1[63:32]))\nDEST[95:64] := APPROXIMATE(1/SQRT(SRC1[95:64]))\nDEST[127:96] := APPROXIMATE(1/SQRT(SRC2[127:96]))\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := APPROXIMATE(1/SQRT(SRC[31:0]))\nDEST[63:32] := APPROXIMATE(1/SQRT(SRC1[63:32]))\nDEST[95:64] := APPROXIMATE(1/SQRT(SRC1[95:64]))\nDEST[127:96] := APPROXIMATE(1/SQRT(SRC2[127:96]))\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := APPROXIMATE(1/SQRT(SRC[31:0]))\nDEST[63:32] := APPROXIMATE(1/SQRT(SRC1[63:32]))\nDEST[95:64] := APPROXIMATE(1/SQRT(SRC1[95:64]))\nDEST[127:96] := APPROXIMATE(1/SQRT(SRC2[127:96]))\nDEST[159:128] := APPROXIMATE(1/SQRT(SRC2[159:128]))\nDEST[191:160] := APPROXIMATE(1/SQRT(SRC2[191:160]))\nDEST[223:192] := APPROXIMATE(1/SQRT(SRC2[223:192]))\nDEST[255:224] := APPROXIMATE(1/SQRT(SRC2[255:224]))",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movntpd",
    "category": "Core Instructions",
    "instructionName": "MOVNTPD\n\t\t— Store Packed Double Precision Floating-Point Values Using Non-Temporal Hint",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move packed double precision values in xmm1 to m128 using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 2B /r MOVNTPD m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move packed double precision values in xmm1 to m128 using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 2B /r VMOVNTPD m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move packed double precision values in ymm1 to m256 using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 2B /r VMOVNTPD m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move packed double precision values in xmm1 to m128 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 2B /r VMOVNTPD m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move packed double precision values in ymm1 to m256 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 2B /r VMOVNTPD m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move packed double precision values in zmm1 to m512 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 2B /r VMOVNTPD m512, zmm1"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Moves the packed double precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed double precision, floating-pointing data. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPD instructions if multiple processors might use different memory types to read/write the destination memory locations.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD.",
    "operationText": "VL = 128, 256, 512\nDEST[VL-1:0] := SRC[VL-1:0]\nDEST[MAXVL-1:VL] := 0\nDEST := SRC",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Exceptions Type1.SSE2 in Table 2-18, “Type 1 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-45, “Type E1NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmaddsub132pd:vfmaddsub213pd:vfmaddsub231pd",
    "category": "Core Instructions",
    "instructionName": "VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD\n\t\t— Fused Multiply-AlternatingAdd/Subtract of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 96 /r VFMADDSUB132PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 A6 /r VFMADDSUB213PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 B6 /r VFMADDSUB231PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 96 /r VFMADDSUB132PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 A6 /r VFMADDSUB213PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 B6 /r VFMADDSUB231PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 A6 /r VFMADDSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/m128/m64bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 B6 /r VFMADDSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/m128/m64bcst, add/subtract elements in xmm2 and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 96 /r VFMADDSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 A6 /r VFMADDSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/m256/m64bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 B6 /r VFMADDSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/m256/m64bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 96 /r VFMADDSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1and zmm2, add/subtract elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 A6 /r VFMADDSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm2 and zmm3/m512/m64bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 B6 /r VFMADDSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm3/m512/m64bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 96 /r VFMADDSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/divss",
    "category": "Core Instructions",
    "instructionName": "DIVSS\n\t\t— Divide Scalar Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Divide low single precision floating-point value in xmm1 by low single precision floating-point value in xmm2/m32.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 5E /r DIVSS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Divide low single precision floating-point value in xmm2 by low single precision floating-point value in xmm3/m32.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 5E /r VDIVSS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Divide low single precision floating-point value in xmm2 by low single precision floating-point value in xmm3/m32.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 5E /r VDIVSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Divides the low single precision floating-point value in the first source operand by the low single precision floating-point value in the second source operand, and stores the single precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The doubleword elements of the destination operand at bits 127:32 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX version: The low doubleword element of the destination is updated according to the writemask.\nSoftware should ensure VDIVSS is encoded with VEX.L=0. Encoding VDIVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := SRC1[31:0] / SRC2[31:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] / SRC2[31:0]\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := DEST[31:0] / SRC[31:0]\nDEST[MAXVL-1:32] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pinsrw",
    "category": "Core Instructions",
    "instructionName": "PINSRW\n\t\t— Insert Word",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Insert the low word from r32 or from m16 into mm at the word position specified by imm8.",
        "Op/ En": "A",
        "Opcode/Instruction": "NP 0F C4 /r ib1 PINSRW mm, r32/m16, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move the low word of r32 or from m16 into xmm at the word position specified by imm8.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F C4 /r ib PINSRW xmm, r32/m16, imm8"
      },
      {
        "64/32 bit Mode Support": "V2/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Insert the word from r32/m16 at the offset indicated by imm8 into the value from xmm2 and store result in xmm1.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.W0 C4 /r ib VPINSRW xmm1, xmm2, r32/m16, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Insert the word from r32/m16 at the offset indicated by imm8 into the value from xmm2 and store result in xmm1.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG C4 /r ib VPINSRW xmm1, xmm2, r32/m16, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Three operand MMX and SSE instructions:\nCopies a word from the source operand and inserts it in the destination operand at the location specified with the count operand. (The other words in the destination register are left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The destination operand can be an MMX technology register or an XMM register. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location.\nBits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nFour operand AVX and AVX-512 instructions:\nCombines a word from the first source operand with the second source operand, and inserts it in the destination operand at the location specified with the count operand. The second source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The first source and destination operands are XMM registers. The count operand is an 8-bit immediate. When specifying a word location, the 3 least-significant bits specify the location.\nBits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L/EVEX.L’L must be 0, otherwise the instruction will #UD.",
    "operationText": "SEL := imm8[1:0]\nDEST.word[SEL] := src.word[0]\nSEL := imm8[2:0]\nDEST.word[SEL] := src.word[0]\nSEL := imm8[2:0]\nDEST := src1\nDEST.word[SEL] := src2.word[0]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ktestw:ktestb:ktestq:ktestd",
    "category": "Core Instructions",
    "instructionName": "KTESTW/KTESTB/KTESTQ/KTESTD\n\t\t— Packed Bit Test Masks and Set Flags",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Set ZF and CF depending on sign bit AND and ANDN of 16 bits mask register sources.",
        "Op En": "RR",
        "Opcode/Instruction": "VEX.L0.0F.W0 99 /r KTESTW k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Set ZF and CF depending on sign bit AND and ANDN of 8 bits mask register sources.",
        "Op En": "RR",
        "Opcode/Instruction": "VEX.L0.66.0F.W0 99 /r KTESTB k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Set ZF and CF depending on sign bit AND and ANDN of 64 bits mask register sources.",
        "Op En": "RR",
        "Opcode/Instruction": "VEX.L0.0F.W1 99 /r KTESTQ k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Set ZF and CF depending on sign bit AND and ANDN of 32 bits mask register sources.",
        "Op En": "RR",
        "Opcode/Instruction": "VEX.L0.66.0F.W1 99 /r KTESTD k1, k2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RR",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is clear. Only the EFLAGS register is updated.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "TEMP[15:0] := SRC2[15:0] AND SRC1[15:0]\nIF (TEMP[15:0] = = 0)\n    THEN ZF :=1;\n    ELSE ZF := 0;\nFI;\nTEMP[15:0] := SRC2[15:0] AND NOT SRC1[15:0]\nIF (TEMP[15:0] = = 0)\n    THEN CF :=1;\n    ELSE CF := 0;\nFI;\nAF := OF := PF := SF := 0;\nTEMP[7:0] := SRC2[7:0] AND SRC1[7:0]\nIF (TEMP[7:0] = = 0)\n    THEN ZF :=1;\n    ELSE ZF := 0;\nFI;\nTEMP[7:0] := SRC2[7:0] AND NOT SRC1[7:0]\nIF (TEMP[7:0] = = 0)\n    THEN CF :=1;\n    ELSE CF := 0;\nFI;\nAF := OF := PF := SF := 0;\nTEMP[63:0] := SRC2[63:0] AND SRC1[63:0]\nIF (TEMP[63:0] = = 0)\n    THEN ZF :=1;\n    ELSE ZF := 0;\nFI;\nTEMP[63:0] := SRC2[63:0] AND NOT SRC1[63:0]\nIF (TEMP[63:0] = = 0)\n    THEN CF :=1;\n    ELSE CF := 0;\nFI;\nAF := OF := PF := SF := 0;\nTEMP[31:0] := SRC2[31:0] AND SRC1[31:0]\nIF (TEMP[31:0] = = 0)\n    THEN ZF :=1;\n    ELSE ZF := 0;\nFI;\nTEMP[31:0] := SRC2[31:0] AND NOT SRC1[31:0]\nIF (TEMP[31:0] = = 0)\n    THEN CF :=1;\n    ELSE CF := 0;\nFI;\nAF := OF := PF := SF := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpcmpw:vpcmpuw",
    "category": "Core Instructions",
    "instructionName": "VPCMPW/VPCMPUW\n\t\t— Compare Packed Word Values Into Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed word integers in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 3F /r ib VPCMPW k1 {k2}, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed word integers in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 3F /r ib VPCMPW k1 {k2}, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed signed word integers in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 3F /r ib VPCMPW k1 {k2}, zmm2, zmm3/m512, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned word integers in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 3E /r ib VPCMPUW k1 {k2}, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned word integers in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 3E /r ib VPCMPUW k1 {k2}, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed unsigned word integers in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 3E /r ib VPCMPUW k1 {k2}, zmm2, zmm3/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/lddqu",
    "category": "Core Instructions",
    "instructionName": "LDDQU\n\t\t— Load Unaligned Integer 128 Bits",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Load unaligned data from mem and return double quadword in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F F0 /r LDDQU xmm1, mem"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Load unaligned packed integer values from mem to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.F2.0F.WIG F0 /r VLDDQU xmm1, m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Load unaligned packed integer values from mem to ymm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.256.F2.0F.WIG F0 /r VLDDQU ymm1, m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is: 32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.\nThis instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use (V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction.",
    "operationText": "DEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] := 0\nDEST[255:0] := SRC[255:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”",
        "Note treatment of #AC varies."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/valignd:valignq",
    "category": "Core Instructions",
    "instructionName": "VALIGND/VALIGNQ\n\t\t— Align Doubleword/Quadword Vectors",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift right and merge vectors xmm2 and xmm3/m128/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in xmm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 03 /r ib VALIGND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift right and merge vectors xmm2 and xmm3/m128/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in xmm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 03 /r ib VALIGNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift right and merge vectors ymm2 and ymm3/m256/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in ymm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 03 /r ib VALIGND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift right and merge vectors ymm2 and ymm3/m256/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in ymm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 03 /r ib VALIGNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift right and merge vectors zmm2 and zmm3/m512/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in zmm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 03 /r ib VALIGND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift right and merge vectors zmm2 and zmm3/m512/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in zmm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 03 /r ib VALIGNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttpd2udq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPD2UDQ\n\t\t— Convert With Truncation Packed Double Precision Floating-Point Values toPacked Unsigned Doubleword Integers",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert two packed double precision floating-point values in xmm2/m128/m64bcst to two unsigned doubleword integers in xmm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode Instruction": "EVEX.128.0F.W1 78 /r VCVTTPD2UDQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed double precision floating-point values in ymm2/m256/m64bcst to four unsigned doubleword integers in xmm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode Instruction": "EVEX.256.0F.W1 78 02 /r VCVTTPD2UDQ xmm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert eight packed double precision floating-point values in zmm2/m512/m64bcst to eight unsigned doubleword integers in ymm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode Instruction": "EVEX.512.0F.W1 78 /r VCVTTPD2UDQ ymm1 {k1}{z}, zmm2/m512/m64bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetexpph",
    "category": "Core Instructions",
    "instructionName": "VGETEXPPH\n\t\t— Convert Exponents of Packed FP16 Values to FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert the exponent of FP16 values in the source operand to FP16 results representing unbiased integer exponents and stores the results in the destination register subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 42 /r VGETEXPPH xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert the exponent of FP16 values in the source operand to FP16 results representing unbiased integer exponents and stores the results in the destination register subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 42 /r VGETEXPPH ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert the exponent of FP16 values in the source operand to FP16 results representing unbiased integer exponents and stores the results in the destination register subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 42 /r VGETEXPPH zmm1{k1}{z}, zmm2/m512/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/stc",
    "category": "Core Instructions",
    "instructionName": "STC\n\t\t— Set Carry Flag",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set CF flag.",
        "Instruction": "STC",
        "Op/En": "ZO",
        "Opcode": "F9"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Sets the CF flag in the EFLAGS register. Operation is the same in all modes.",
    "operationText": "CF := 1;",
    "flagsAffectedText": "The CF flag is set. The OF, ZF, SF, AF, and PF flags are unaffected.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/bndmk",
    "category": "Core Instructions",
    "instructionName": "BNDMK\n\t\t— Make Bounds",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "N.E./V",
        "CPUID Feature Flag": "MPX",
        "Description": "Make lower and upper bounds from m32 and store them in bnd.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 0F 1B /r BNDMK bnd, m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MPX",
        "Description": "Make lower and upper bounds from m64 and store them in bnd.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 0F 1B /r BNDMK bnd, m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "Makes bounds from the second operand and stores the lower and upper bounds in the bound register bnd. The second operand must be a memory operand. The content of the base register from the memory operand is stored in the lower bound bnd.LB. The 1's complement of the effective address of m32/m64 is stored in the upper bound b.UB. Computation of m32/m64 has identical behavior to LEA.\nThis instruction does not cause any memory access, and does not read or write any flags.\nIf the instruction did not specify base register, the lower bound will be zero. The reg-reg form of this instruction retains legacy behavior (NOP).\nThe instruction causes an invalid-opcode exception (#UD) if executed in 64-bit mode with RIP-relative addressing.",
    "operationText": "BND.LB := SRCMEM.base;\nIF 64-bit mode Then\n    BND.UB := NOT(LEA.64_bits(SRCMEM));\nELSE\n    BND.UB := Zero_Extend.64_bits(NOT(LEA.32_bits(SRCMEM)));\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If ModRM.r/m and REX encodes BND4-BND15 when Intel MPX is enabled.; \ncolumn_1: If RIP-relative addressing is used.; \ncolumn_1: #SS(0); column_2: If the memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #GP(0); column_2: If the memory address is in a non-canonical form.;",
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 67H prefix is not used and CS.D=0.; \ncolumn_1: If 67H prefix is used and CS.D=1.;"
      ],
      "realAddressMode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesdec256kl",
    "category": "Core Instructions",
    "instructionName": "AESDEC256KL\n\t\t— Perform 14 Rounds of AES Decryption Flow With Key Locker Using 256-Bit Key",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLE",
        "Description": "Decrypt xmm using 256-bit AES key indicated by handle at m512 and store result in xmm.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 DF !(11):rrr:bbb AESDEC256KL xmm, m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The AESDEC256KL1 instruction performs 14 rounds of AES to decrypt the first operand using the 256-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).",
    "operationText": "Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL > 0)) ||\n                Handle [2] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256);\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    DEST := AES256Decrypt (DEST, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/lfence",
    "category": "Core Instructions",
    "instructionName": "LFENCE\n\t\t— Load Fence",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Serializes load operations.",
        "Op/En": "ZO",
        "Opcode / Instruction": "NP 0F AE E8 LFENCE"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute (even speculatively) until the LFENCE completes.\nWeakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE instruction provides a performance-efficient way of ensuring load ordering between routines that produce weakly-ordered results and routines that consume that data.\nProcessors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it is not ordered with respect to executions of the LFENCE instruction; data can be brought into the caches speculatively just before, during, or after the execution of an LFENCE instruction.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.\nSpecification of the instruction's opcode above indicates a ModR/M byte of E8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, LFENCE is encoded by any opcode of the form 0F AE Ex, where x is in the range 8-F.",
    "operationText": "Wait_On_Following_Instructions_Until(preceding_instructions_complete);",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/bndldx",
    "category": "Core Instructions",
    "instructionName": "BNDLDX\n\t\t— Load Extended Bounds Using Address Translation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MPX",
        "Description": "Load the bounds stored in a bound table entry (BTE) into bnd with address translation using the base of mib and conditional on the index of mib matching the pointer value in the BTE.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 1A /r BNDLDX bnd, mib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "SIB.base (r): Address of pointer SIB.index(r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "BNDLDX uses the linear address constructed from the base register and displacement of the SIB-addressing form of the memory operand (mib) to perform address translation to access a bound table entry and conditionally load the bounds in the BTE to the destination. The destination register is updated with the bounds in the BTE, if the content of the index register of mib matches the pointer value stored in the BTE.\nIf the pointer value comparison fails, the destination is updated with INIT bounds (lb = 0x0, ub = 0x0) (note: as articulated earlier, the upper bound is represented using 1's complement, therefore, the 0x0 value of upper bound allows for access to full memory).\nThis instruction does not cause memory access to the linear address of mib nor the effective address referenced by the base, and does not read or write any flags.\nSegment overrides apply to the linear address computation with the base of mib, and are used during address translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be linear address. There are no segmentation checks performed on the base of mib.\nThe base of mib will not be checked for canonical address violation as it does not access memory.\nAny encoding of this instruction that does not specify base or index register will treat those registers as zero (constant). The reg-reg form of this instruction will remain a NOP.\nThe scale field of the SIB byte has no effect on these instructions and is ignored.\nThe bound register may be partially updated on memory faults. The order in which memory operands are loaded is implementation specific.",
    "operationText": "base := mib.SIB.base ? mib.SIB.base + Disp: 0;\nptr_value := mib.SIB.index ? mib.SIB.index : 0;\nA_BDE[31:0] := (Zero_extend32(base[31:12] « 2) + (BNDCFG[31:12] «12 );\nA_BT[31:0] := LoadFrom(A_BDE );\nIF A_BT[0] equal 0 Then\n    BNDSTATUS := A_BDE | 02H;\n    #BR;\nFI;\nA_BTE[31:0] := (Zero_extend32(base[11:2] « 4) + (A_BT[31:2] « 2 );\nTemp_lb[31:0] := LoadFrom(A_BTE);\nTemp_ub[31:0] := LoadFrom(A_BTE + 4);\nTemp_ptr[31:0] := LoadFrom(A_BTE + 8);\nIF Temp_ptr equal ptr_value Then\n    BND.LB := Temp_lb;\n    BND.UB := Temp_ub;\nELSE\n    BND.LB := 0;\n    BND.UB := 0;\nFI;\nA_BDE[63:0] := (Zero_extend64(base[47+MAWA:20] « 3) + (BNDCFG[63:12] «12 );1\nA_BT[63:0] := LoadFrom(A_BDE);\nIF A_BT[0] equal 0 Then\n    BNDSTATUS := A_BDE | 02H;\n    #BR;\nFI;\nA_BTE[63:0] := (Zero_extend64(base[19:3] « 5) + (A_BT[63:3] « 3 );\nTemp_lb[63:0] := LoadFrom(A_BTE);\nTemp_ub[63:0] := LoadFrom(A_BTE + 8);\nTemp_ptr[63:0] := LoadFrom(A_BTE + 16);\nIF Temp_ptr equal ptr_value Then\n    BND.LB := Temp_lb;\n    BND.UB := Temp_ub;\nELSE\n    BND.LB := 0;\n    BND.UB := 0;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If ModRM is RIP relative.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m and REX encodes BND4-BND15 when Intel MPX is enabled.; \ncolumn_1: #GP(0); column_2: If the memory address (A_BDE or A_BTE) is in a non-canonical form.; \ncolumn_2: code) If a page fault occurs.; column_1: #PF(fault;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 67H prefix is not used and CS.D=0.; \ncolumn_1: If 67H prefix is used and CS.D=1.; \ncolumn_1: #GP(0); column_2: If a destination effective address of the Bound Table entry is outside the DS segment limit.; \ncolumn_1: If DS register contains a NULL segment selector.; \ncolumn_1: #PF(fault; column_2: code) If a page fault occurs.;"
      ],
      "realAddressMode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.; \ncolumn_1: #GP(0); column_2: If a destination effective address of the Bound Table entry is outside the DS segment limit.;"
      ],
      "virtual8086Mode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.; \ncolumn_1: #GP(0); column_2: If a destination effective address of the Bound Table entry is outside the DS segment limit.; \ncolumn_1: #PF(fault; column_2: code) If a page fault occurs.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/phaddw:phaddd",
    "category": "Core Instructions",
    "instructionName": "PHADDW/PHADDD\n\t\t— Packed Horizontal Add",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Add 16-bit integers horizontally, pack to mm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 01 /r1 PHADDW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Add 16-bit integers horizontally, pack to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 01 /r PHADDW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Add 32-bit integers horizontally, pack to mm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 02 /r PHADDD mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Add 32-bit integers horizontally, pack to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 02 /r PHADDD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add 16-bit integers horizontally, pack to xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 01 /r VPHADDW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add 32-bit integers horizontally, pack to xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 02 /r VPHADDD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add 16-bit signed integers horizontally, pack to ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 01 /r VPHADDW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add 32-bit signed integers horizontally, pack to ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 02 /r VPHADDD ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nNote that these instructions can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.\nLegacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nIn 64-bit mode, use the REX prefix to access additional registers.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16-bytes of the destination operand. The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.\nS7 S3 S3 S4 S3 S2 S1 S0",
    "operationText": "mm1[15-0] = mm1[31-16] + mm1[15-0];\nmm1[31-16] = mm1[63-48] + mm1[47-32];\nmm1[47-32] = mm2/m64[31-16] + mm2/m64[15-0];\nmm1[63-48] = mm2/m64[63-48] + mm2/m64[47-32];\nxmm1[15-0] = xmm1[31-16] + xmm1[15-0];\nxmm1[31-16] = xmm1[63-48] + xmm1[47-32];\nxmm1[47-32] = xmm1[95-80] + xmm1[79-64];\nxmm1[63-48] = xmm1[127-112] + xmm1[111-96];\nxmm1[79-64] = xmm2/m128[31-16] + xmm2/m128[15-0];\nxmm1[95-80] = xmm2/m128[63-48] + xmm2/m128[47-32];\nxmm1[111-96] = xmm2/m128[95-80] + xmm2/m128[79-64];\nxmm1[127-112] = xmm2/m128[127-112] + xmm2/m128[111-96];\nDEST[15:0] := SRC1[31:16] + SRC1[15:0]\nDEST[31:16] := SRC1[63:48] + SRC1[47:32]\nDEST[47:32] := SRC1[95:80] + SRC1[79:64]\nDEST[63:48] := SRC1[127:112] + SRC1[111:96]\nDEST[79:64] := SRC2[31:16] + SRC2[15:0]\nDEST[95:80] := SRC2[63:48] + SRC2[47:32]\nDEST[111:96] := SRC2[95:80] + SRC2[79:64]\nDEST[127:112] := SRC2[127:112] + SRC2[111:96]\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := SRC1[31:16] + SRC1[15:0]\nDEST[31:16] := SRC1[63:48] + SRC1[47:32]\nDEST[47:32] := SRC1[95:80] + SRC1[79:64]\nDEST[63:48] := SRC1[127:112] + SRC1[111:96]\nDEST[79:64] := SRC2[31:16] + SRC2[15:0]\nDEST[95:80] := SRC2[63:48] + SRC2[47:32]\nDEST[111:96] := SRC2[95:80] + SRC2[79:64]\nDEST[127:112] := SRC2[127:112] + SRC2[111:96]\nDEST[143:128] := SRC1[159:144] + SRC1[143:128]\nDEST[159:144] := SRC1[191:176] + SRC1[175:160]\nDEST[175:160] := SRC1[223:208] + SRC1[207:192]\nDEST[191:176] := SRC1[255:240] + SRC1[239:224]\nDEST[207:192] := SRC2[127:112] + SRC2[143:128]\nDEST[223:208] := SRC2[159:144] + SRC2[175:160]\nDEST[239:224] := SRC2[191:176] + SRC2[207:192]\nDEST[255:240] := SRC2[223:208] + SRC2[239:224]\nmm1[31-0] = mm1[63-32] + mm1[31-0];\nmm1[63-32] = mm2/m64[63-32] + mm2/m64[31-0];\nxmm1[31-0] = xmm1[63-32] + xmm1[31-0];\nxmm1[63-32] = xmm1[127-96] + xmm1[95-64];\nxmm1[95-64] = xmm2/m128[63-32] + xmm2/m128[31-0];\nxmm1[127-96] = xmm2/m128[127-96] + xmm2/m128[95-64];\nDEST[31-0] := SRC1[63-32] + SRC1[31-0]\nDEST[63-32] := SRC1[127-96] + SRC1[95-64]\nDEST[95-64] := SRC2[63-32] + SRC2[31-0]\nDEST[127-96] := SRC2[127-96] + SRC2[95-64]\nDEST[MAXVL-1:128] := 0\nDEST[31-0] := SRC1[63-32] + SRC1[31-0]\nDEST[63-32] := SRC1[127-96] + SRC1[95-64]\nDEST[95-64] := SRC2[63-32] + SRC2[31-0]\nDEST[127-96] := SRC2[127-96] + SRC2[95-64]\nDEST[159-128] := SRC1[191-160] + SRC1[159-128]\nDEST[191-160] := SRC1[255-224] + SRC1[223-192]\nDEST[223-192] := SRC2[191-160] + SRC2[159-128]\nDEST[255-224] := SRC2[255-224] + SRC2[223-192]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtdq2ph",
    "category": "Core Instructions",
    "instructionName": "VCVTDQ2PH\n\t\t— Convert Packed Signed Doubleword Integers to Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert four packed signed doubleword integers from xmm2/m128/m32bcst to four packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 5B /r VCVTDQ2PH xmm1{k1}{z}, xmm2/m128/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 5B /r VCVTDQ2PH xmm1{k1}{z}, ymm2/m256/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed signed doubleword integers from zmm2/m512/m32bcst to sixteen packed FP16 values, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 5B /r VCVTDQ2PH ymm1{k1}{z}, zmm2/m512/m32bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttps2qq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPS2QQ\n\t\t— Convert With Truncation Packed Single Precision Floating-Point Values toPacked Signed Quadword Integer Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 7A /r VCVTTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 7A /r VCVTTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 7A /r VCVTTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fmul:fmulp:fimul",
    "category": "Core Instructions",
    "instructionName": "FMUL/FMULP/FIMUL\n\t\t— Multiply",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply ST(0) by m32fp and store result in ST(0).",
        "Instruction": "FMUL m32fp",
        "Opcode": "D8 /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply ST(0) by m64fp and store result in ST(0).",
        "Instruction": "FMUL m64fp",
        "Opcode": "DC /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply ST(0) by ST(i) and store result in ST(0).",
        "Instruction": "FMUL ST(0), ST(i)",
        "Opcode": "D8 C8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply ST(i) by ST(0) and store result in ST(i).",
        "Instruction": "FMUL ST(i), ST(0)",
        "Opcode": "DC C8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack.",
        "Instruction": "FMULP ST(i), ST(0)",
        "Opcode": "DE C8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack.",
        "Instruction": "FMULP",
        "Opcode": "DE C9"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply ST(0) by m32int and store result in ST(0).",
        "Instruction": "FIMUL m32int",
        "Opcode": "DA /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply ST(0) by m16int and store result in ST(0).",
        "Instruction": "FIMUL m16int",
        "Opcode": "DE /1"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Multiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\nThe no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value) and stores the product in the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).\nThe FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.\nThe FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.\nThe sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or ∞. When the source operand is an integer 0, it is treated as a +0.\nThe following table shows the results obtained when multiplying various classes of numbers, assuming that neither overflow nor underflow occurs.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF Instruction = FIMUL\n    THEN\n        DEST := DEST ∗ ConvertToDoubleExtendedPrecisionFP(SRC);\n    ELSE (* Source operand is floating-point value *)\n        DEST := DEST ∗ SRC;\nFI;\nIF Instruction = FMULP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Operand is an SNaN value or unsupported format.; \ncolumn_1: One operand is ±0 and the other is ±∞.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_2: Result is too small for destination format.; column_1: #U; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; column_1: #NM; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmovwb:vpmovswb:vpmovuswb",
    "category": "Core Instructions",
    "instructionName": "VPMOVWB/VPMOVSWB/VPMOVUSWB\n\t\t— Down Convert Word to Byte",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts 8 packed word integers from xmm2 into 8 packed bytes in xmm1/m64 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 30 /r VPMOVWB xmm1/m64 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts 8 packed signed word integers from xmm2 into 8 packed signed bytes in xmm1/m64 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 20 /r VPMOVSWB xmm1/m64 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts 8 packed unsigned word integers from xmm2 into 8 packed unsigned bytes in 8mm1/m64 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 10 /r VPMOVUSWB xmm1/m64 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts 16 packed word integers from ymm2 into 16 packed bytes in xmm1/m128 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 30 /r VPMOVWB xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts 16 packed signed word integers from ymm2 into 16 packed signed bytes in xmm1/m128 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 20 /r VPMOVSWB xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts 16 packed unsigned word integers from ymm2 into 16 packed unsigned bytes in xmm1/m128 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 10 /r VPMOVUSWB xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Converts 32 packed word integers from zmm2 into 32 packed bytes in ymm1/m256 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 30 /r VPMOVWB ymm1/m256 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Converts 32 packed signed word integers from zmm2 into 32 packed signed bytes in ymm1/m256 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 20 /r VPMOVSWB ymm1/m256 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Converts 32 packed unsigned word integers from zmm2 into 32 packed unsigned bytes in ymm1/m256 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 10 /r VPMOVUSWB ymm1/m256 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesenc128kl",
    "category": "Core Instructions",
    "instructionName": "AESENC128KL\n\t\t— Perform Ten Rounds of AES Encryption Flow With Key Locker Using 128-Bit Key",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLE",
        "Description": "Encrypt xmm using 128-bit AES key indicated by handle at m384 and store result in xmm.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 DC !(11):rrr:bbb AESENC128KL xmm, m384"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The AESENC128KL1 instruction performs ten rounds of AES to encrypt the first operand using the 128-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).",
    "operationText": "Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (\n                HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL > 0)) ||\n                Handle [1] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128\n                );\nIF (Illegal Handle) {\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);\n        IF (Authentic == 0)\n        THEN RFLAGS.ZF := 1;\n        ELSE\n            DEST := AES128Encrypt (DEST, UnwrappedKey) ;\n            RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/kunpckbw:kunpckwd:kunpckdq",
    "category": "Core Instructions",
    "instructionName": "KUNPCKBW/KUNPCKWD/KUNPCKDQ\n\t\t— Unpack for Mask Registers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Unpack 8-bit masks in k2 and k3 and write word result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W0 4B /r KUNPCKBW k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Unpack 16-bit masks in k2 and k3 and write doubleword result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W0 4B /r KUNPCKWD k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Unpack 32-bit masks in k2 and k3 and write quadword result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W1 4B /r KUNPCKDQ k1, k2, k3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.1vvv (r)",
        "Operand 3": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Unpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.",
    "operationText": "DEST[7:0] := SRC2[7:0]\nDEST[15:8] := SRC1[7:0]\nDEST[MAX_KL-1:16] := 0\nDEST[15:0] := SRC2[15:0]\nDEST[31:16] := SRC1[15:0]\nDEST[MAX_KL-1:32] := 0\nDEST[31:0] := SRC2[31:0]\nDEST[63:32] := SRC1[31:0]\nDEST[MAX_KL-1:64] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfixupimmsd",
    "category": "Core Instructions",
    "instructionName": "VFIXUPIMMSD\n\t\t— Fix Up Special Scalar Float64 Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Fix up a float64 number in the low quadword element of xmm2 using scalar int32 table in xmm3/m64 and store the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W1 55 /r ib VFIXUPIMMSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesencwide128kl",
    "category": "Core Instructions",
    "instructionName": "AESENCWIDE128KL\n\t\t— Perform Ten Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLE WIDE_KL",
        "Description": "Encrypt XMM0-7 using 128-bit AES key indicated by handle at m384 and store each resultant block back to its corresponding register.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 D8 !(11):000:bbb AESENCWIDE128KL m384, <XMM0-7>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r)",
        "Operands 2—9": "Implicit XMM0-7 (r, w)",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The AESENCWIDE128KL1 instruction performs ten rounds of AES to encrypt each of the eight blocks in XMM0-7 using the 128-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding encrypted block if the operation succeeds (e.g., does not run into a handle violation failure).",
    "operationText": "Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (\n                HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL > 0)) ||\n                Handle [1] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128\n                );\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);\n        IF Authentic == 0\n            THEN RFLAGS.ZF := 1;\n            ELSE\n            XMM0 := AES128Encrypt (XMM0, UnwrappedKey) ;\n                    XMM1 := AES128Encrypt (XMM1, UnwrappedKey) ;\n                    XMM2 := AES128Encrypt (XMM2, UnwrappedKey) ;\n                    XMM3 := AES128Encrypt (XMM3, UnwrappedKey) ;\n                    XMM4 := AES128Encrypt (XMM4, UnwrappedKey) ;\n                    XMM5 := AES128Encrypt (XMM5, UnwrappedKey) ;\n                    XMM6 := AES128Encrypt (XMM6, UnwrappedKey) ;\n                    XMM7 := AES128Encrypt (XMM7, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n1. Further details on Key Locker and usage of this instruction can be found here:",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/mov-2",
    "category": "Core Instructions",
    "instructionName": "MOV\n\t\t— Move to/from Debug Registers",
    "detailsTable": [
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Move debug register to r32.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F 21/r MOV r32, DR0–DR7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move extended debug register to r64.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F 21/r MOV r64, DR0–DR7"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r32 to debug register.",
        "Op/En": "RM",
        "Opcode/Instruction": "0F 23 /r MOV DR0–DR7, r32"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move r64 to extended debug register.",
        "Op/En": "RM",
        "Opcode/Instruction": "0F 23 /r MOV DR0–DR7, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or DR7) to a general-purpose register or vice versa. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. (See Section 18.2, “Debug Registers”, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for a detailed description of the flags and fields in the debug registers.)\nThe instructions must be executed at privilege level 0 or in real-address mode.\nWhen the debug extension (DE) flag in register CR4 is clear, these instructions operate on debug registers in a manner that is compatible with Intel386 and Intel486 processors. In this mode, references to DR4 and DR5 refer to DR6 and DR7, respectively. When the DE flag in CR4 is set, attempts to reference DR4 and DR5 result in an undefined opcode (#UD) exception. (The CR4 register was added to the IA-32 Architecture beginning with the Pentium processor.)\nAt the opcode level, the reg field within the ModR/M byte specifies which of the debug registers is loaded or read. The two bits in the mod field are ignored. The r/m field specifies the general-purpose register loaded or read.\nIn 64-bit mode, the instruction’s default operation size is 64 bits. Use of the REX.B prefix permits access to additional registers (R8–R15). Use of the REX.W or 66H prefix is ignored. Use of the REX.R prefix causes an invalid-opcode exception. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF ((DE = 1) and (SRC or DEST = DR4 or DR5))\n    THEN\n        #UD;\n    ELSE\n        DEST := SRC;\nFI;",
    "flagsAffectedText": "The OF, SF, ZF, AF, PF, and CF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: If an attempt is made to write a 1 to any of bits 63:32 in DR6.; \ncolumn_1: If an attempt is made to write a 1 to any of bits 63:32 in DR7.; \ncolumn_1: #UD; column_2: If CR4.DE[bit 3] = 1 (debug extensions) and a MOV instruction is executed involving DR4 or DR5.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If the REX.R prefix is used.; \ncolumn_2: If any debug register is accessed while the DR7.GD[bit 13] = 1.; column_1: #DB;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If CR4.DE[bit 3] = 1 (debug extensions) and a MOV instruction is executed involving DR4 or DR5.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #DB; column_2: If any debug register is accessed while the DR7.GD[bit 13] = 1.;"
      ],
      "realAddressMode": [
        "column_1: If the LOCK prefix is used.; \ncolumn_1: #DB; column_2: If any debug register is accessed while the DR7.GD[bit 13] = 1.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/lmsw",
    "category": "Core Instructions",
    "instructionName": "LMSW\n\t\t— Load Machine Status Word",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Loads r/m16 in machine status word of CR0.",
        "Instruction": "LMSW r/m16",
        "Op/En": "M",
        "Opcode": "0F 01 /6"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operand-size attribute has no effect on this instruction.\nIf the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back to real-address mode.\nThe LMSW instruction is provided for use in operating-system software; it should not be used in application programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.\nThis instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to run on IA-32 and Intel 64 processors beginning with Intel386 processors should use the MOV (control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes.\nThis instruction is a serializing instruction.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode. Note that the operand size is fixed at 16 bits.\nSee “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 26 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
    "operationText": "CR0[0:3] := SRC[0:3];",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the current privilege level is not 0.; \ncolumn_1: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/add",
    "category": "Core Instructions",
    "instructionName": "ADD\n\t\t— Add",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add imm8 to AL.",
        "Instruction": "ADD AL, imm8",
        "Op/En": "I",
        "Opcode": "04 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add imm16 to AX.",
        "Instruction": "ADD AX, imm16",
        "Op/En": "I",
        "Opcode": "05 iw"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add imm32 to EAX.",
        "Instruction": "ADD EAX, imm32",
        "Op/En": "I",
        "Opcode": "05 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add imm32 sign-extended to 64-bits to RAX.",
        "Instruction": "ADD RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + 05 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add imm8 to r/m8.",
        "Instruction": "ADD r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "80 /0 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add sign-extended imm8 to r/m8.",
        "Instruction": "ADD r/m8*, imm8",
        "Op/En": "MI",
        "Opcode": "REX + 80 /0 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add imm16 to r/m16.",
        "Instruction": "ADD r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "81 /0 iw"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add imm32 to r/m32.",
        "Instruction": "ADD r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "81 /0 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add imm32 sign-extended to 64-bits to r/m64.",
        "Instruction": "ADD r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + 81 /0 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add sign-extended imm8 to r/m16.",
        "Instruction": "ADD r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "83 /0 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add sign-extended imm8 to r/m32.",
        "Instruction": "ADD r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "83 /0 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add sign-extended imm8 to r/m64.",
        "Instruction": "ADD r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 83 /0 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add r8 to r/m8.",
        "Instruction": "ADD r/m8, r8",
        "Op/En": "MR",
        "Opcode": "00 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add r8 to r/m8.",
        "Instruction": "ADD r/m8*, r8*",
        "Op/En": "MR",
        "Opcode": "REX + 00 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add r16 to r/m16.",
        "Instruction": "ADD r/m16, r16",
        "Op/En": "MR",
        "Opcode": "01 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add r32 to r/m32.",
        "Instruction": "ADD r/m32, r32",
        "Op/En": "MR",
        "Opcode": "01 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add r64 to r/m64.",
        "Instruction": "ADD r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 01 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add r/m8 to r8.",
        "Instruction": "ADD r8, r/m8",
        "Op/En": "RM",
        "Opcode": "02 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add r/m8 to r8.",
        "Instruction": "ADD r8*, r/m8*",
        "Op/En": "RM",
        "Opcode": "REX + 02 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add r/m16 to r16.",
        "Instruction": "ADD r16, r/m16",
        "Op/En": "RM",
        "Opcode": "03 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add r/m32 to r32.",
        "Instruction": "ADD r32, r/m32",
        "Op/En": "RM",
        "Opcode": "03 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add r/m64 to r64.",
        "Instruction": "ADD r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 03 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\nThe ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := DEST + SRC;",
    "flagsAffectedText": "The OF, SF, ZF, AF, CF, and PF flags are set according to the result.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used but the destination is not a memory operand.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ereport",
    "category": "SGX Instructions",
    "instructionName": "EREPORT\n\t\t— Create a Cryptographic Report of the Enclave",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function creates a cryptographic report of the enclave.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 00H ENCLU[EREPORT]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EREPORT (In)",
        "column_3": "Address of TARGETINFO (In)",
        "column_4": "Address of REPORTDATA (In)",
        "column_5": "Address where the REPORT is written to in an OUTPUTDATA (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pext",
    "category": "Core Instructions",
    "instructionName": "PEXT\n\t\t— Parallel Bits Extract",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI2",
        "Description": "Parallel extract of bits from r32b using mask in r/m32, result is written to r32a.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.LZ.F3.0F38.W0 F5 /r PEXT r32a, r32b, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI2",
        "Description": "Parallel extract of bits from r64b using mask in r/m64, result is written to r64a.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.LZ.F3.0F38.W1 F5 /r PEXT r64a, r64b, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "PEXT uses a mask in the second source operand (the third operand) to transfer either contiguous or non-contiguous bits in the first source operand (the second operand) to contiguous low order bit positions in the destination (the first operand). For each bit set in the MASK, PEXT extracts the corresponding bits from the first source operand and writes them into contiguous lower bits of destination operand. The remaining upper bits of destination are zeroed.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "TEMP := SRC1;\nMASK := SRC2;\nDEST := 0 ;\nm := 0, k := 0;\nDO WHILE m < OperandSize\n    IF MASK[ m] = 1 THEN\n        DEST[ k] := TEMP[ m];\n        k := k+ 1;\n    FI\n    m := m+ 1;\nOD",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/clrssbsy",
    "category": "Core Instructions",
    "instructionName": "CLRSSBSY\n\t\t— Clear Busy Flag in a Supervisor Shadow Stack Token",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Clear busy flag in supervisor shadow stack token reference by m64.",
        "Op / En": "M",
        "Opcode/Instruction": "F3 0F AE /6 CLRSSBSY m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      }
    ],
    "descriptionText": "Clear busy flag in supervisor shadow stack token reference by m64. Subsequent to marking the shadow stack as not busy the SSP is loaded with value 0.",
    "operationText": "IF (CR4.CET = 0)\n    THEN #UD; FI;\nIF (IA32_S_CET.SH_STK_EN = 0)\n    THEN #UD; FI;\nIF CPL > 0\n    THEN GP(0); FI;\nSSP_LA = Linear_Address(mem operand)\nIF SSP_LA not aligned to 8 bytes\n    THEN #GP(0); FI;\nexpected_token_value=SSP_LA|BUSY_BIT (*busybit-bitposition0-mustbeset*)\nnew_token_value = SSP_LA (* Clear the busy bit *)\nIF shadow_stack_lock_cmpxchg8b(SSP_LA, new_token_value, expected_token_value) != expected_token_value\n    invalid_token := 1; FI\n(* Set the CF if invalid token was detected *)\nRFLAGS.CF = (invalid_token == 1) ? 1 : 0;\nRFLAGS.ZF,PF,AF,OF,SF := 0;\nSSP := 0",
    "flagsAffectedText": "CF is set if an invalid token was detected, else it is cleared. ZF, PF, AF, OF, and SF are cleared.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: IF IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: #GP(0); column_2: If memory operand linear address not aligned to 8 bytes.; \ncolumn_1: If CPL is not 0.; \ncolumn_1: If the memory address is in a non-canonical form.; \ncolumn_1: If token is invalid.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "compatibilityMode": [
        "column_1: #GP(0); column_2: Same exceptions as in protected mode.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "protectedMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: IF IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: #GP(0); column_2: If memory operand linear address not aligned to 8 bytes.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If destination is located in a non-writeable segment.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If CPL is not 0.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movmskps",
    "category": "Core Instructions",
    "instructionName": "MOVMSKPS\n\t\t— Extract Packed Single Precision Floating-Point Sign Mask",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 50 /r MOVMSKPS reg, xmm"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract 4-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.0F.WIG 50 /r VMOVMSKPS reg, xmm2"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract 8-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.256.0F.WIG 50 /r VMOVMSKPS reg, ymm2"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Extracts the sign bits from the packed single precision floating-point values in the source operand (second operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand beyond the mask are filled with zeros.\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\n128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.\nVEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "DEST[0] := SRC[31];\nDEST[1] := SRC[63];\nDEST[2] := SRC[95];\nDEST[3] := SRC[127];\nIF DEST = r32\n    THEN DEST[31:4] := ZeroExtend;\n    ELSE DEST[63:4] := ZeroExtend;\nFI;\nDEST[0] := SRC[31]\nDEST[1] := SRC[63]\nDEST[2] := SRC[95]\nDEST[3] := SRC[127]\nIF DEST = r32\n    THEN DEST[31:4] := 0;\n    ELSE DEST[63:4] := 0;\nFI\nDEST[0] := SRC[31]\nDEST[1] := SRC[63]\nDEST[2] := SRC[95]\nDEST[3] := SRC[127]\nDEST[4] := SRC[159]\nDEST[5] := SRC[191]\nDEST[6] := SRC[223]\nDEST[7] := SRC[255]\nIF DEST = r32\n    THEN DEST[31:8] := 0;\n    ELSE DEST[63:8] := 0;\nFI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-24, “Type 7 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fsubr:fsubrp:fisubr",
    "category": "Core Instructions",
    "instructionName": "FSUBR/FSUBRP/FISUBR\n\t\t— Reverse Subtract",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(0) from m32fp and store result in ST(0).",
        "Instruction": "FSUBR m32fp",
        "Opcode": "D8 /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(0) from m64fp and store result in ST(0).",
        "Instruction": "FSUBR m64fp",
        "Opcode": "DC /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(0) from ST(i) and store result in ST(0).",
        "Instruction": "FSUBR ST(0), ST(i)",
        "Opcode": "D8 E8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(i) from ST(0) and store result in ST(i).",
        "Instruction": "FSUBR ST(i), ST(0)",
        "Opcode": "DC E0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(i) from ST(0), store result in ST(i), and pop register stack.",
        "Instruction": "FSUBRP ST(i), ST(0)",
        "Opcode": "DE E0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(1) from ST(0), store result in ST(1), and pop register stack.",
        "Instruction": "FSUBRP",
        "Opcode": "DE E1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(0) from m32int and store result in ST(0).",
        "Instruction": "FISUBR m32int",
        "Opcode": "DA /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(0) from m16int and store result in ST(0).",
        "Instruction": "FISUBR m16int",
        "Opcode": "DE /5"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Subtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\nThese instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.\nThe no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.\nThe FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.\nThe FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\nThe following table shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC − DEST = result).\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.\nWhen one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalidoperation exception is generated.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF Instruction = FISUBR\n    THEN\n        DEST := ConvertToDoubleExtendedPrecisionFP(SRC) − DEST;\n    ELSE (* Source operand is floating-point value *)\n        DEST := SRC − DEST; FI;\nIF Instruction = FSUBRP\n    THEN\n        PopRegisterStack; FI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Operand is an SNaN value or unsupported format.; \ncolumn_1: Operands are infinities of like sign.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmaskmov",
    "category": "Core Instructions",
    "instructionName": "VPMASKMOV\n\t\t— Conditional SIMD Integer Packed Loads and Stores",
    "detailsTable": [
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Conditionally load dword values from m128 using mask in xmm2 and store in xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 8C /r VPMASKMOVD xmm1, xmm2, m128"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Conditionally load dword values from m256 using mask in ymm2 and store in ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 8C /r VPMASKMOVD ymm1, ymm2, m256"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Conditionally load qword values from m128 using mask in xmm2 and store in xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 8C /r VPMASKMOVQ xmm1, xmm2, m128"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Conditionally load qword values from m256 using mask in ymm2 and store in ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 8C /r VPMASKMOVQ ymm1, ymm2, m256"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Conditionally store dword values from xmm2 using mask in xmm1.",
        "Op/En": "MVR",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 8E /r VPMASKMOVD m128, xmm1, xmm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Conditionally store dword values from ymm2 using mask in ymm1.",
        "Op/En": "MVR",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 8E /r VPMASKMOVD m256, ymm1, ymm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Conditionally store qword values from xmm2 using mask in xmm1.",
        "Op/En": "MVR",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 8E /r VPMASKMOVQ m128, xmm1, xmm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Conditionally store qword values from ymm2 using mask in ymm1.",
        "Op/En": "MVR",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 8E /r VPMASKMOVQ m256, ymm1, ymm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MVR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:reg (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.\nThe mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.\nThe second source operand is a memory address for the load form of these instructions. The destination operand is a memory address for the store form of these instructions. The other operands are either XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).\nFaults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.\nUnlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.\nInstruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.\nVMASKMOV should not be used to access memory mapped I/O as the ordering of the individual loads or stores it does is implementation specific.\nIn cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.\nNote: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.\nNote: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field.",
    "operationText": "DEST[31:0] := IF (SRC1[31]) Load_32(mem) ELSE 0\nDEST[63:32] := IF (SRC1[63]) Load_32(mem + 4) ELSE 0\nDEST[95:64] := IF (SRC1[95]) Load_32(mem + 8) ELSE 0\nDEST[127:96] := IF (SRC1[127]) Load_32(mem + 12) ELSE 0\nDEST[159:128] := IF (SRC1[159]) Load_32(mem + 16) ELSE 0\nDEST[191:160] := IF (SRC1[191]) Load_32(mem + 20) ELSE 0\nDEST[223:192] := IF (SRC1[223]) Load_32(mem + 24) ELSE 0\nDEST[255:224] := IF (SRC1[255]) Load_32(mem + 28) ELSE 0\nDEST[31:0] := IF (SRC1[31]) Load_32(mem) ELSE 0\nDEST[63:32] := IF (SRC1[63]) Load_32(mem + 4) ELSE 0\nDEST[95:64] := IF (SRC1[95]) Load_32(mem + 8) ELSE 0\nDEST[127:97] := IF (SRC1[127]) Load_32(mem + 12) ELSE 0\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := IF (SRC1[63]) Load_64(mem) ELSE 0\nDEST[127:64] := IF (SRC1[127]) Load_64(mem + 8) ELSE 0\nDEST[195:128] := IF (SRC1[191]) Load_64(mem + 16) ELSE 0\nDEST[255:196] := IF (SRC1[255]) Load_64(mem + 24) ELSE 0\nDEST[63:0] := IF (SRC1[63]) Load_64(mem) ELSE 0\nDEST[127:64] := IF (SRC1[127]) Load_64(mem + 16) ELSE 0\nDEST[MAXVL-1:128] := 0\nIF (SRC1[31]) DEST[31:0] := SRC2[31:0]\nIF (SRC1[63]) DEST[63:32] := SRC2[63:32]\nIF (SRC1[95]) DEST[95:64] := SRC2[95:64]\nIF (SRC1[127]) DEST[127:96] := SRC2[127:96]\nIF (SRC1[159]) DEST[159:128] :=SRC2[159:128]\nIF (SRC1[191]) DEST[191:160] := SRC2[191:160]\nIF (SRC1[223]) DEST[223:192] := SRC2[223:192]\nIF (SRC1[255]) DEST[255:224] := SRC2[255:224]\nIF (SRC1[31]) DEST[31:0] := SRC2[31:0]\nIF (SRC1[63]) DEST[63:32] := SRC2[63:32]\nIF (SRC1[95]) DEST[95:64] := SRC2[95:64]\nIF (SRC1[127]) DEST[127:96] := SRC2[127:96]\nIF (SRC1[63]) DEST[63:0] := SRC2[63:0]\nIF (SRC1[127]) DEST[127:64] :=SRC2[127:64]\nIF (SRC1[191]) DEST[191:128] := SRC2[191:128]\nIF (SRC1[255]) DEST[255:192] := SRC2[255:192]\nIF (SRC1[63]) DEST[63:0] := SRC2[63:0]\nIF (SRC1[127]) DEST[127:64] :=SRC2[127:64]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-23, “Type 6 Class Exception Conditions” (No AC# reported for any mask bit combinations)."
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/etrackc",
    "category": "SGX Instructions",
    "instructionName": "ETRACKC\n\t\t— Activates EBLOCK Checks",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "EAX[6]",
        "Description": "This leaf function activates EBLOCK checks.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 11H ENCLS[ETRACKC]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "ETRACK (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Address of the destination EPC page (In, EA)",
        "column_5": "Address of the SECS page (In, EA)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/tileloadd:tileloaddt1",
    "category": "Core Instructions",
    "instructionName": "TILELOADD/TILELOADDT1\n\t\t— Load Tile",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-TILE",
        "Description": "Load data into tmm1 as specified by information in sibmem.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F2.0F38.W0 4B !(11):rrr:100 TILELOADD tmm1, sibmem"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-TILE",
        "Description": "Load data into tmm1 as specified by information in sibmem with hint to optimize data caching.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 4B !(11):rrr:100 TILELOADDT1 tmm1, sibmem"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "This instruction is required to use SIB addressing. The index register serves as a stride indicator. If the SIB encoding omits an index register, the value zero is assumed for the content of the index register.\nThis instruction loads a tile destination with rows and columns as specified by the tile configuration. The “T1” version provides a hint to the implementation that the data would be reused but does not need to be resident in the nearest cache levels.\nThe TILECFG.start_row in the TILECFG data should be initialized to '0' in order to load the entire tile and is set to zero on successful completion of the TILELOADD instruction. TILELOADD is a restartable instruction and the TILECFG.start_row will be non-zero when restartable events occur during the instruction execution.\nOnly memory operands are supported and they can only be accessed using a SIB addressing mode, similar to the V[P]GATHER*/V[P]SCATTER* instructions.\nAny attempt to execute the TILELOADD/TILELOADDT1 instructions inside an Intel TSX transaction will result in a transaction abort.",
    "operationText": "TILELOADD[,T1] tdest, tsib\nstart := tilecfg.start_row\nzero_upper_rows(tdest,start)\nmembegin := tsib.base + displacement\n// if no index register in the SIB encoding, the value zero is used.\nstride := tsib.index << tsib.scale\nnbytes := tdest.colsb\nwhile start < tdest.rows:\n    memptr := membegin + start * stride\n    write_row_and_zero(tdest, start, read_memory(memptr, nbytes), nbytes)\n    start := start + 1\nzero_tilecfg_start()\n// In the case of a memory fault in the middle of an instruction, the tilecfg.start_row := start",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "AMX-E3; see Section 2.10, “Intel® AMX Instruction Exception Classes,” for details."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscalefps",
    "category": "Core Instructions",
    "instructionName": "VSCALEFPS\n\t\t— Scale Packed Float32 Values With Float32 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Scale the packed single-precision floating-point values in xmm2 using values from xmm3/m128/m32bcst. Under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 2C /r VSCALEFPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Scale the packed single-precision values in ymm2 using floating-point values from ymm3/m256/m32bcst. Under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 2C /r VSCALEFPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Scale the packed single-precision floating-point values in zmm2 using floating-point values from zmm3/m512/m32bcst. Under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 2C /r VSCALEFPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdsspd:rdsspq",
    "category": "Core Instructions",
    "instructionName": "RDSSPD/RDSSPQ\n\t\t— Read Shadow Stack Pointer",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Copy low 32 bits of shadow stack pointer (SSP) to r32.",
        "Op/En": "R",
        "Opcode/Instruction": "F3 0F 1E /1 (mod=11) RDSSPD r32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Copies shadow stack pointer (SSP) to r64.",
        "Op/En": "R",
        "Opcode/Instruction": "F3 REX.W 0F 1E /1 (mod=11) RDSSPQ r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "R",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies the current shadow stack pointer (SSP) register to the register destination. This opcode is a NOP when CET shadow stacks are not enabled and on processors that do not support CET.",
    "operationText": "IF CPL = 3\n    IF CR4.CET & IA32_U_CET.SH_STK_EN\n        IF (operand size is 64 bit)\n            THEN\n                Dest := SSP;\n            ELSE\n                Dest := SSP[31:0];\n        FI;\n    FI;\nELSE\n    IF CR4.CET & IA32_S_CET.SH_STK_EN\n        IF (operand size is 64 bit)\n            THEN\n                Dest := SSP;\n            ELSE\n                Dest := SSP[31:0];\n        FI;\n    FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "None."
      ],
      "compatibilityMode": [
        "None."
      ],
      "protectedMode": [
        "None."
      ],
      "realAddressMode": [
        "None."
      ],
      "virtual8086Mode": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/swapgs",
    "category": "Core Instructions",
    "instructionName": "SWAPGS\n\t\t— Swap GS Base Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Invalid",
        "Description": "Exchanges the current GS base register value with the value contained in MSR address C0000102H.",
        "Instruction": "SWAPGS",
        "Op/En": "ZO",
        "Opcode": "0F 01 F8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "SWAPGS exchanges the current GS base register value with the value contained in MSR address C0000102H (IA32_KERNEL_GS_BASE). The SWAPGS instruction is a privileged instruction intended for use by system software.\nWhen using SYSCALL to implement system calls, there is no kernel stack at the OS entry point. Neither is there a straightforward method to obtain a pointer to kernel structures from which the kernel stack pointer could be read. Thus, the kernel cannot save general purpose registers or reference memory.\nBy design, SWAPGS does not require any general purpose registers or memory operands. No registers need to be saved before using the instruction. SWAPGS exchanges the CPL 0 data pointer from the IA32_KERNEL_GS_BASE MSR with the GS base register. The kernel can then use the GS prefix on normal memory references to access kernel data structures. Similarly, when the OS kernel is entered using an interrupt or exception (where the kernel stack is already set up), SWAPGS can be used to quickly get a pointer to the kernel data structures.\nThe IA32_KERNEL_GS_BASE MSR itself is only accessible using RDMSR/WRMSR instructions. Those instructions are only accessible at privilege level 0. The WRMSR instruction ensures that the IA32_KERNEL_GS_BASE MSR contains a canonical address.",
    "operationText": "IF CS.L ≠ 1 (* Not in 64-Bit Mode *)\n    THEN\n        #UD; FI;\nIF CPL ≠ 0\n    THEN #GP(0); FI;\ntmp := GS.base;\nGS.base := IA32_KERNEL_GS_BASE;\nIA32_KERNEL_GS_BASE := tmp;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ficom:ficomp",
    "category": "Core Instructions",
    "instructionName": "FICOM/FICOMP\n\t\t— Compare Integer",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with m16int.",
        "Instruction": "FICOM m16int",
        "Opcode": "DE /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with m32int.",
        "Instruction": "FICOM m32int",
        "Opcode": "DA /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with m16int and pop stack register.",
        "Instruction": "FICOMP m16int",
        "Opcode": "DE /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with m32int and pop stack register.",
        "Instruction": "FICOMP m32int",
        "Opcode": "DA /3"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below). The integer value is converted to double extended-precision floating-point format before the comparison is made.\nThese instructions perform an “unordered comparison.” An unordered comparison also checks the class of the numbers being compared (see “FXAM—Examine Floating-Point” in this chapter). If either operand is a NaN or is in an undefined format, the condition flags are set to “unordered.”\nThe sign of zero is ignored, so that –0.0 := +0.0.\nThe FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor marks the ST(0) register empty and increments the stack pointer (TOP) by 1.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "CASE (relation of operands) OF\n    ST(0) > SRC:\n            C3, C2, C0 := 000;\n    ST(0) < SRC:\n            C3, C2, C0 := 001;\n    ST(0) = SRC:\n            C3, C2, C0 := 100;\n    Unordered:\n            C3, C2, C0 := 111;\nESAC;\nIF Instruction = FICOMP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: One or both operands are NaN values or have unsupported formats.; \ncolumn_1: #D; column_2: One or both operands are denormal values.;"
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; column_1: #NM; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/roundss",
    "category": "Core Instructions",
    "instructionName": "ROUNDSS\n\t\t— Round Scalar Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.",
        "Op/En": "RMI",
        "Opcode*/Instruction": "66 0F 3A 0A /r ib ROUNDSS xmm1, xmm2/m32, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1. The rounding mode is determined by imm8. Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].",
        "Op/En": "RVMI",
        "Opcode*/Instruction": "VEX.LIG.66.0F3A.WIG 0A /r ib VROUNDSS xmm1, xmm2, xmm3/m32, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Round the single precision floating-point value in the lowest dword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a single precision floating-point input to an integer value and returns the result as a single precision floating-point value in the lowest position. The upper three single precision floating-point values in the destination are retained.\nThe immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-18 lists the encoded values for rounding-mode field).\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
    "operationText": "IF (imm[2] = ‘1)\n    THEN // rounding mode is determined by MXCSR.RC\n        DEST[31:0] := ConvertSPFPToInteger_M(SRC[31:0]);\n    ELSE // rounding mode is determined by IMM8.RC\n        DEST[31:0] := ConvertSPFPToInteger_Imm(SRC[31:0]);\nFI;\nDEST[127:32] remains unchanged ;\nDEST[31:0] := RoundToInteger(SRC[31:0], ROUND_CONTROL)\nDEST[MAXVL-1:32] (Unmodified)\nDEST[31:0] := RoundToInteger(SRC2[31:0], ROUND_CONTROL)\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-20, “Type 3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (signaled only if SRC = SNaN).",
        "Precision (signaled only if imm[3] = ‘0; if imm[3] = ‘1, then the Precision Mask in the MXSCSR is ignored and precision exception is not signaled.)",
        "Note that Denormal is not signaled by ROUNDSS."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmuludq",
    "category": "Core Instructions",
    "instructionName": "PMULUDQ\n\t\t— Multiply Packed Unsigned Doubleword Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F F4 /r1 PMULUDQ mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F F4 /r PMULUDQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F4 /r VPMULUDQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG F4 /r VPMULUDQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 F4 /r VPMULUDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 F4 /r VPMULUDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed unsigned doubleword integers in zmm2 by packed unsigned doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 F4 /r VPMULUDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be an unsigned doubleword integer stored in the low doubleword of an MMX technology register or a 64-bit memory location. The destination operand can be an unsigned doubleword integer stored in the low doubleword an MMX technology register. The result is an unsigned\nquadword integer stored in the destination an MMX technology register. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).\nFor 64-bit memory operands, 64 bits are fetched from memory, but only the low doubleword is used in the computation.\n128-bit Legacy SSE version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is four packed unsigned doubleword integers stored in the first (low), third, fifth, and seventh doublewords of a YMM register or a 256-bit memory location. For 256-bit memory operands, 256 bits are fetched from memory, but only the first, third, fifth, and seventh doublewords are used in the computation. The first source operand is four packed unsigned doubleword integers stored in the first, third, fifth, and seventh doublewords of an YMM register. The destination contains four packed unaligned quadword integers stored in an YMM register.\nEVEX encoded version: The input unsigned doubleword integers are taken from the even-numbered elements of the source operands. The first source operand is a ZMM/YMM/XMM registers. The second source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination is a ZMM/YMM/XMM register, and updated according to the writemask at 64-bit granularity.",
    "operationText": "DEST[63:0] := DEST[31:0] ∗ SRC[31:0];\nDEST[63:0] := DEST[31:0] ∗ SRC[31:0];\nDEST[127:64] := DEST[95:64] ∗ SRC[95:64];\nDEST[63:0] := SRC1[31:0] * SRC2[31:0]\nDEST[127:64] := SRC1[95:64] * SRC2[95:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[31:0] * SRC2[31:0]\nDEST[127:64] := SRC1[95:64] * SRC2[95:64\nDEST[191:128] := SRC1[159:128] * SRC2[159:128]\nDEST[255:192] := SRC1[223:192] * SRC2[223:192]\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+63:i] := ZeroExtend64( SRC1[i+31:i]) * ZeroExtend64( SRC2[31:0] )\n                ELSE DEST[i+63:i] := ZeroExtend64( SRC1[i+31:i]) * ZeroExtend64( SRC2[i+31:i] )\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/psrlw:psrld:psrlq",
    "category": "Core Instructions",
    "instructionName": "PSRLW/PSRLD/PSRLQ\n\t\t— Shift Packed Data Right Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift words in mm right by amount specified in mm/m64 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F D1 /r1 PSRLW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F D1 /r PSRLW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift words in mm right by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 71 /2 ib1 PSRLW mm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift words in xmm1 right by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 71 /2 ib PSRLW xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F D2 /r1 PSRLD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F D2 /r PSRLD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift doublewords in mm right by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 72 /2 ib1 PSRLD mm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift doublewords in xmm1 right by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 72 /2 ib PSRLD xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift mm right by amount specified in mm/m64 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F D3 /r1 PSRLQ mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F D3 /r PSRLQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift mm right by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 73 /2 ib1 PSRLQ mm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift quadwords in xmm1 right by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 73 /2 ib PSRLQ xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D1 /r VPSRLW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift words in xmm2 right by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 71 /2 ib VPSRLW xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D2 /r VPSRLD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift doublewords in xmm2 right by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 72 /2 ib VPSRLD xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D3 /r VPSRLQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift quadwords in xmm2 right by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 73 /2 ib VPSRLQ xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D1 /r VPSRLW ymm1, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift words in ymm2 right by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 71 /2 ib VPSRLW ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D2 /r VPSRLD ymm1, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 right by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 72 /2 ib VPSRLD ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D3 /r VPSRLQ ymm1, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift quadwords in ymm2 right by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 73 /2 ib VPSRLQ ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG D1 /r VPSRLW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG D1 /r VPSRLW ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG D1 /r VPSRLW zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2/m128 right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 71 /2 ib VPSRLW xmm1 {k1}{z}, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2/m256 right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 71 /2 ib VPSRLW ymm1 {k1}{z}, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2/m512 right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 71 /2 ib VPSRLW zmm1 {k1}{z}, zmm2/m512, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 D2 /r VPSRLD xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 D2 /r VPSRLD ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 D2 /r VPSRLD zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2/m128/m32bcst right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 72 /2 ib VPSRLD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2/m256/m32bcst right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 72 /2 ib VPSRLD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2/m512/m32bcst right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 72 /2 ib VPSRLD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 D3 /r VPSRLQ xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 D3 /r VPSRLQ ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 D3 /r VPSRLQ zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2/m128/m64bcst right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 73 /2 ib VPSRLQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2/m256/m64bcst right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 73 /2 ib VPSRLQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2/m512/m64bcst right by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 73 /2 ib VPSRLQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "E",
        "Operand 1": "EVEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "F",
        "Operand 1": "EVEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "G",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Mem128"
      }
    ],
    "descriptionText": "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.\nNote that only the low 64-bits of a 128-bit count operand are checked to compute the count.\nThe (V)PSRLW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand; the (V)PSRLD instruction shifts each of the doublewords in the destination operand; and the PSRLQ instruction shifts the quadword (or quadwords) in the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instruction 64-bit operand: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.\n128-bit Legacy SSE version: The destination operand is an XMM register; the count operand can be either an XMM register or a 128-bit memory location, or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The destination operand is an XMM register; the count operand can be either an XMM register or a 128-bit memory location, or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location. The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded versions: The destination operand is a ZMM register updated according to the writemask. The count operand is either an 8-bit immediate (the immediate count version) or an 8-bit value from an XMM register or a memory location (the variable count version). For the immediate count version, the source operand (the second operand) can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. For the variable count version, the first source operand (the second operand) is a ZMM register, the second source operand (the third operand, 8-bit variable count) can be an XMM register or a memory location.\nNote: In VEX/EVEX encoded versions of shifts with an immediate count, vvvv of VEX/EVEX encode the destination register, and VEX.B/EVEX.B + ModRM.r/m encodes the source register.\nNote: For shifts with an immediate count (VEX.128.66.0F 71-73 /2, or EVEX.128.66.0F 71-73 /2), VEX.vvvv/EVEX.vvvv encodes the destination register.",
    "operationText": "IF (COUNT > 15)\nTHEN\n    DEST[64:0] := 0000000000000000H\nELSE\n    DEST[15:0] := ZeroExtend(DEST[15:0] >> COUNT);\n    (* Repeat shift operation for 2nd and 3rd words *)\n    DEST[63:48] := ZeroExtend(DEST[63:48] >> COUNT);\nFI;\nIF (COUNT > 31)\nTHEN\n    DEST[64:0] := 0000000000000000H\nELSE\n    DEST[31:0] := ZeroExtend(DEST[31:0] >> COUNT);\n    DEST[63:32] := ZeroExtend(DEST[63:32] >> COUNT);\nFI;\nIF (COUNT > 63)\n    THEN\n        DEST[64:0] := 0000000000000000H\n    ELSE\n        DEST := ZeroExtend(DEST >> COUNT);\n    FI;\nLOGICAL_RIGHT_SHIFT_DWORDS1(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\nTHEN\n    DEST[31:0] := 0\nELSE\n    DEST[31:0] := ZeroExtend(SRC[31:0] >> COUNT);\nFI;\nLOGICAL_RIGHT_SHIFT_QWORDS1(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 63)\nTHEN\n    DEST[63:0] := 0\nELSE\n    DEST[63:0] := ZeroExtend(SRC[63:0] >> COUNT);\nFI;\nLOGICAL_RIGHT_SHIFT_WORDS_256b(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 15)\nTHEN\n    DEST[255:0] := 0\nELSE\n    DEST[15:0] := ZeroExtend(SRC[15:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 15th words *)\n    DEST[255:240] := ZeroExtend(SRC[255:240] >> COUNT);\nFI;\nLOGICAL_RIGHT_SHIFT_WORDS(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 15)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\nELSE\n    DEST[15:0] := ZeroExtend(SRC[15:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 7th words *)\n    DEST[127:112] := ZeroExtend(SRC[127:112] >> COUNT);\nFI;\nLOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\nTHEN\n    DEST[255:0] := 0\nELSE\n    DEST[31:0] := ZeroExtend(SRC[31:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 3rd words *)\n    DEST[255:224] := ZeroExtend(SRC[255:224] >> COUNT);\nFI;\nLOGICAL_RIGHT_SHIFT_DWORDS(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\nELSE\n    DEST[31:0] := ZeroExtend(SRC[31:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 3rd words *)\n    DEST[127:96] := ZeroExtend(SRC[127:96] >> COUNT);\nFI;\nLOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 63)\nTHEN\n    DEST[255:0] := 0\nELSE\n    DEST[63:0] := ZeroExtend(SRC[63:0] >> COUNT);\n    DEST[127:64] := ZeroExtend(SRC[127:64] >> COUNT);\n    DEST[191:128] := ZeroExtend(SRC[191:128] >> COUNT);\n    DEST[255:192] := ZeroExtend(SRC[255:192] >> COUNT);\nFI;\nLOGICAL_RIGHT_SHIFT_QWORDS(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 63)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\nELSE\n    DEST[63:0] := ZeroExtend(SRC[63:0] >> COUNT);\n    DEST[127:64] := ZeroExtend(SRC[127:64] >> COUNT);\nFI;\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL = 128\n    TMP_DEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS_128b(SRC1[127:0], SRC2)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)\n    TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[511:256], SRC2)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL = 128\n    TMP_DEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS_128b(SRC1[127:0], imm8)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], imm8)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], imm8)\n    TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[511:256], imm8)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0;\nDEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1, imm8)\nDEST[MAXVL-1:256] := 0;\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS(SRC1, imm8)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS(DEST, imm8)\nDEST[MAXVL-1:128] (Unmodified)\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF VL = 128\n    TMP_DEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS_128b(SRC1[127:0], SRC2)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)\n    TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1[511:256], SRC2)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC1 *is memory*)\n                THEN DEST[i+31:i] := LOGICAL_RIGHT_SHIFT_DWORDS1(SRC1[31:0], imm8)\n                ELSE DEST[i+31:i] := LOGICAL_RIGHT_SHIFT_DWORDS1(SRC1[i+31:i], imm8)\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0;\nDEST[255:0] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1, imm8)\nDEST[MAXVL-1:256] := 0;\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS(SRC1, imm8)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS(DEST, imm8)\nDEST[MAXVL-1:128] (Unmodified)\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nTMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)\nTMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[511:256], SRC2)\nIF VL = 128\n    TMP_DEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS_128b(SRC1[127:0], SRC2)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)\n    TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[511:256], SRC2)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC1 *is memory*)\n                THEN DEST[i+63:i] := LOGICAL_RIGHT_SHIFT_QWORDS1(SRC1[63:0], imm8)\n                ELSE DEST[i+63:i] := LOGICAL_RIGHT_SHIFT_QWORDS1(SRC1[i+63:i], imm8)\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0;\nDEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1, imm8)\nDEST[MAXVL-1:256] := 0;\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS(SRC1, imm8)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS(DEST, imm8)\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": null
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscatterdps:vscatterdpd:vscatterqps:vscatterqpd",
    "category": "Core Instructions",
    "instructionName": "VSCATTERDPS/VSCATTERDPD/VSCATTERQPS/VSCATTERQPD\n\t\t— Scatter Packed Single, PackedDouble with Signed Dword and Qword Indices",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 A2 /vsib VSCATTERDPS vm32x {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 A2 /vsib VSCATTERDPS vm32y {k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 A2 /vsib VSCATTERDPS vm32z {k1}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, scatter double precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 A2 /vsib VSCATTERDPD vm32x {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, scatter double precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 A2 /vsib VSCATTERDPD vm32x {k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed dword indices, scatter double precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 A2 /vsib VSCATTERDPD vm32y {k1}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 A3 /vsib VSCATTERQPS vm64x {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 A3 /vsib VSCATTERQPS vm64y {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 A3 /vsib VSCATTERQPS vm64z {k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, scatter double precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 A3 /vsib VSCATTERQPD vm64x {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, scatter double precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 A3 /vsib VSCATTERQPD vm64y {k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed qword indices, scatter double precision floating-point values to memory using writemask k1.",
        "Op/E n": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 A3 /vsib VSCATTERQPD vm64z {k1}, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtsd2sh",
    "category": "Core Instructions",
    "instructionName": "VCVTSD2SH\n\t\t— Convert Low FP64 Value to an FP16 Value",
    "detailsTable": [
      {
        "Description": "Convert the low FP64 value in xmm3/m64 to an FP16 value and store the result in the low element of xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F2.MAP5.W1 5A /r VCVTSD2SH xmm1{k1}{z}, xmm2, xmm3/m64 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cpuid",
    "category": "Core Instructions",
    "instructionName": "CPUID\n\t\t— CPU Identification",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).",
        "Instruction": "CPUID",
        "Op/En": "ZO",
        "Opcode": "0F A2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction operates the same in non-64-bit modes and 64-bit mode.\nCPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The instruction’s output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well). For example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value and the Vendor Identification String in the appropriate registers:\nMOV EAX, 00H\nCPUID\nTable 3-8 shows information returned, depending on the initial value loaded into the EAX register.\nTwo types of information are returned: basic and extended function information. If a value entered for CPUID.EAX is higher than the maximum input value for basic or extended function for that processor then the data for the highest basic information leaf is returned. For example, using some Intel processors, the following is true:\nCPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *)\nCPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf. *) CPUID.EAX = 0BH (* Returns Extended Topology Enumeration leaf. *)2 CPUID.EAX =1FH (* Returns V2 Extended Topology Enumeration leaf. *)2\nCPUID.EAX = 80000008H (* Returns linear/physical address size data. *)\nCPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX = 0BH. *)\nIf a value entered for CPUID.EAX is less than or equal to the maximum input value and the leaf is not supported on that processor then 0 is returned in all the registers.\nWhen CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence on input ECX value in the basic leaf is honored.\nCPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution guarantees that any modifications to flags, registers, and memory for previous instructions are completed before the next instruction is fetched and executed.\nSee also:\n“Serializing Instructions” in Chapter 9, “Multiple-Processor Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n“Caching Translation Information” in Chapter 4, “Paging,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
    "operationText": "IA32_BIOS_SIGN_ID MSR := Update with installed microcode revision number;\nCASE (EAX) OF\n    EAX = 0:\n        EAX := Highest basic function input value understood by CPUID;\n        EBX := Vendor identification string;\n        EDX := Vendor identification string;\n        ECX := Vendor identification string;\n    BREAK;\n    EAX = 1H:\n        EAX[3:0] := Stepping ID;\n        EAX[7:4] := Model;\n        EAX[11:8] := Family;\n        EAX[13:12] := Processor type;\n        EAX[15:14] := Reserved;\n        EAX[19:16] := Extended Model;\n        EAX[27:20] := Extended Family;\n        EAX[31:28] := Reserved;\n        EBX[7:0] := Brand Index; (* Reserved if the value is zero. *)\n        EBX[15:8] := CLFLUSH Line Size;\n        EBX[16:23] := Reserved; (* Number of threads enabled = 2 if MT enable fuse set. *)\n        EBX[24:31] := Initial APIC ID;\n        ECX := Feature flags; (* See Figure 3-7. *)\n        EDX := Feature flags; (* See Figure 3-8. *)\n    BREAK;\n    EAX = 2H:\n        EAX := Cache and TLB information;\n        EBX := Cache and TLB information;\n        ECX := Cache and TLB information;\n        EDX := Cache and TLB information;\n    BREAK;\n    EAX = 3H:\n        EAX := Reserved;\n        EBX := Reserved;\n        ECX := ProcessorSerialNumber[31:0];\n        (* Pentium III processors only, otherwise reserved. *)\n        EDX := ProcessorSerialNumber[63:32];\n        (* Pentium III processors only, otherwise reserved. *\n    BREAK\n    EAX = 4H:\n        EAX := Deterministic Cache Parameters Leaf; (* See Table 3-8. *)\n        EBX := Deterministic Cache Parameters Leaf;\n        ECX := Deterministic Cache Parameters Leaf;\n        EDX := Deterministic Cache Parameters Leaf;\n    BREAK;\n    EAX = 5H:\n        EAX := MONITOR/MWAIT Leaf; (* See Table 3-8. *)\n        EBX := MONITOR/MWAIT Leaf;\n        ECX := MONITOR/MWAIT Leaf;\n        EDX := MONITOR/MWAIT Leaf;\n    BREAK;\n    EAX = 6H:\n        EAX := Thermal and Power Management Leaf; (* See Table 3-8. *)\n        EBX := Thermal and Power Management Leaf;\n        ECX := Thermal and Power Management Leaf;\n        EDX := Thermal and Power Management Leaf;\n    BREAK;\n    EAX = 7H:\n        EAX := Structured Extended Feature Flags Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Structured Extended Feature Flags Enumeration Leaf;\n        ECX := Structured Extended Feature Flags Enumeration Leaf;\n        EDX := Structured Extended Feature Flags Enumeration Leaf;\n    BREAK;\n    EAX = 8H:\n        EAX := Reserved = 0;\n        EBX := Reserved = 0;\n        ECX := Reserved = 0;\n        EDX := Reserved = 0;\n    BREAK;\n    EAX = 9H:\n        EAX := Direct Cache Access Information Leaf; (* See Table 3-8. *)\n        EBX := Direct Cache Access Information Leaf;\n        ECX := Direct Cache Access Information Leaf;\n        EDX := Direct Cache Access Information Leaf;\n    BREAK;\n    EAX = AH:\n        EAX := Architectural Performance Monitoring Leaf; (* See Table 3-8. *)\n        EBX := Architectural Performance Monitoring Leaf;\n        ECX := Architectural Performance Monitoring Leaf;\n        EDX := Architectural Performance Monitoring Leaf;\n        BREAK\n    EAX = BH:\n        EAX := Extended Topology Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Extended Topology Enumeration Leaf;\n        ECX := Extended Topology Enumeration Leaf;\n        EDX := Extended Topology Enumeration Leaf;\n    BREAK;\n    EAX = CH:\n        EAX := Reserved = 0;\n        EBX := Reserved = 0;\n        ECX := Reserved = 0;\n        EDX := Reserved = 0;\n    BREAK;\n    EAX = DH:\n        EAX := Processor Extended State Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Processor Extended State Enumeration Leaf;\n        ECX := Processor Extended State Enumeration Leaf;\n        EDX := Processor Extended State Enumeration Leaf;\n    BREAK;\n    EAX = EH:\n        EAX := Reserved = 0;\n        EBX := Reserved = 0;\n        ECX := Reserved = 0;\n        EDX := Reserved = 0;\n    BREAK;\n    EAX = FH:\n        EAX := Intel Resource Director Technology Monitoring Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Intel Resource Director Technology Monitoring Enumeration Leaf;\n        ECX := Intel Resource Director Technology Monitoring Enumeration Leaf;\n        EDX := Intel Resource Director Technology Monitoring Enumeration Leaf;\n    BREAK;\n    EAX = 10H:\n        EAX := Intel Resource Director Technology Allocation Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Intel Resource Director Technology Allocation Enumeration Leaf;\n        ECX := Intel Resource Director Technology Allocation Enumeration Leaf;\n        EDX := Intel Resource Director Technology Allocation Enumeration Leaf;\n    BREAK;\n    EAX = 12H:\n        EAX := Intel SGX Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Intel SGX Enumeration Leaf;\n        ECX := Intel SGX Enumeration Leaf;\n        EDX := Intel SGX Enumeration Leaf;\n    BREAK;\n    EAX = 14H:\n        EAX := Intel Processor Trace Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Intel Processor Trace Enumeration Leaf;\n        ECX := Intel Processor Trace Enumeration Leaf;\n        EDX := Intel Processor Trace Enumeration Leaf;\n    BREAK;\n    EAX = 15H:\n        EAX := Time Stamp Counter and Nominal Core Crystal Clock Information Leaf; (* See Table 3-8. *)\n        EBX := Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;\n        ECX := Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;\n        EDX := Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;\n    BREAK;\n    EAX = 16H:\n        EAX := Processor Frequency Information Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Processor Frequency Information Enumeration Leaf;\n        ECX := Processor Frequency Information Enumeration Leaf;\n        EDX := Processor Frequency Information Enumeration Leaf;\n    BREAK;\n    EAX = 17H:\n        EAX := System-On-Chip Vendor Attribute Enumeration Leaf; (* See Table 3-8. *)\n        EBX := System-On-Chip Vendor Attribute Enumeration Leaf;\n        ECX := System-On-Chip Vendor Attribute Enumeration Leaf;\n        EDX := System-On-Chip Vendor Attribute Enumeration Leaf;\n    BREAK;\n    EAX = 18H:\n        EAX := Deterministic Address Translation Parameters Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Deterministic Address Translation Parameters Enumeration Leaf;\n        ECX := Deterministic Address Translation Parameters Enumeration Leaf;\n        EDX := Deterministic Address Translation Parameters Enumeration Leaf;\n    BREAK;\n    EAX = 19H:\n        EAX := Key Locker Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Key Locker Enumeration Leaf;\n        ECX := Key Locker Enumeration Leaf;\n        EDX := Key Locker Enumeration Leaf;\n    BREAK;\n    EAX = 1AH:\n        EAX := Native Model ID Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Native Model ID Enumeration Leaf;\n        ECX := Native Model ID Enumeration Leaf;\n        EDX := Native Model ID Enumeration Leaf;\n    BREAK;\n    EAX = 1BH:\n        EAX := PCONFIG Information Enumeration Leaf; (* See “INPUT EAX = 1BH: Returns PCONFIG Information” on page 3-253. *)\n        EBX := PCONFIG Information Enumeration Leaf;\n        ECX := PCONFIG Information Enumeration Leaf;\n        EDX := PCONFIG Information Enumeration Leaf;\n    BREAK;\n    EAX = 1CH:\n        EAX := Last Branch Record Information Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Last Branch Record Information Enumeration Leaf;\n        ECX := Last Branch Record Information Enumeration Leaf;\n        EDX := Last Branch Record Information Enumeration Leaf;\n    BREAK;\n    EAX = 1DH:\n        EAX := Tile Information Enumeration Leaf; (* See Table 3-8. *)\n        EBX := Tile Information Enumeration Leaf;\n        ECX := Tile Information Enumeration Leaf;\n        EDX := Tile Information Enumeration Leaf;\n    BREAK;\n    EAX = 1EH:\n        EAX := TMUL Information Enumeration Leaf; (* See Table 3-8. *)\n        EBX := TMUL Information Enumeration Leaf;\n        ECX := TMUL Information Enumeration Leaf;\n        EDX := TMUL Information Enumeration Leaf;\n    BREAK;\n    EAX = 1FH:\n        EAX := V2 Extended Topology Enumeration Leaf; (* See Table 3-8. *)\n        EBX := V2 Extended Topology Enumeration Leaf;\n        ECX := V2 Extended Topology Enumeration Leaf;\n        EDX := V2 Extended Topology Enumeration Leaf;\n    BREAK;\n    EAX = 20H:\n        EAX := Processor History Reset Sub-leaf; (* See Table 3-8. *)\n        EBX := Processor History Reset Sub-leaf;\n        ECX := Processor History Reset Sub-leaf;\n        EDX := Processor History Reset Sub-leaf;\n    BREAK;\n    EAX = 80000000H:\n        EAX := Highest extended function input value understood by CPUID;\n        EBX := Reserved;\n        ECX := Reserved;\n        EDX := Reserved;\n    BREAK;\n    EAX = 80000001H:\n        EAX := Reserved;\n        EBX := Reserved;\n        ECX := Extended Feature Bits (* See Table 3-8.*);\n        EDX := Extended Feature Bits (* See Table 3-8. *);\n    BREAK;\n    EAX = 80000002H:\n        EAX := Processor Brand String;\n        EBX := Processor Brand String,\n            continued;\n        ECX := Processor Brand String,\n            continued;\n        EDX := Processor Brand String,\n            continued;\n    BREAK;\n    EAX = 80000003H:\n        EAX := Processor Brand String,\n            continued;\n        EBX := Processor Brand String,\n            continued;\n        ECX := Processor Brand String,\n            continued;\n        EDX := Processor Brand String,\n            continued;\n    BREAK;\n    EAX = 80000004H:\n        EAX := Processor Brand String,\n            continued;\n        EBX := Processor Brand String,\n            continued;\n        ECX := Processor Brand String,\n            continued;\n        EDX := Processor Brand String, continued;\n    BREAK;\n    EAX = 80000005H:\n        EAX := Reserved = 0;\n        EBX := Reserved = 0;\n        ECX := Reserved = 0;\n        EDX := Reserved = 0;\n    BREAK;\n    EAX = 80000006H:\n        EAX := Reserved = 0;\n        EBX := Reserved = 0;\n        ECX := Cache information;\n        EDX := Reserved = 0;\n    BREAK;\n    EAX = 80000007H:\n        EAX := Reserved = 0;\n        EBX := Reserved = 0;\n        ECX := Reserved = 0;\n        EDX := Reserved = Misc Feature Flags;\n    BREAK;\n    EAX = 80000008H:\n        EAX := Address Size Information;\n        EBX := Misc Feature Flags;\n        ECX := Reserved = 0;\n        EDX := Reserved = 0;\n    BREAK;\n    EAX >= 40000000H and EAX <= 4FFFFFFFH:\n    DEFAULT: (* EAX = Value outside of recognized range for CPUID. *)\n        (* If the highest basic information leaf data depend on ECX input value, ECX is honored.*)\n        EAX := Reserved; (* Information returned for highest basic information leaf. *)\n        EBX := Reserved; (* Information returned for highest basic information leaf. *)\n        ECX := Reserved; (* Information returned for highest basic information leaf. *)\n        EDX := Reserved; (* Information returned for highest basic information leaf. *)\n    BREAK;\nESAC;",
    "flagsAffectedText": "None.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermi2b",
    "category": "Core Instructions",
    "instructionName": "VPERMI2B\n\t\t— Full Permute of Bytes From Two Tables Overwriting the Index",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VBMI",
        "Description": "Permute bytes in xmm3/m128 and xmm2 using byte indexes in xmm1 and store the byte results in xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 75 /r VPERMI2B xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VBMI",
        "Description": "Permute bytes in ymm3/m256 and ymm2 using byte indexes in ymm1 and store the byte results in ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 75 /r VPERMI2B ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI",
        "Description": "Permute bytes in zmm3/m512 and zmm2 using byte indexes in zmm1 and store the byte results in zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 75 /r VPERMI2B zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vsqrtph",
    "category": "Core Instructions",
    "instructionName": "VSQRTPH\n\t\t— Compute Square Root of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Compute square roots of the packed FP16 values in xmm2/m128/m16bcst, and store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 51 /r VSQRTPH xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Compute square roots of the packed FP16 values in ymm2/m256/m16bcst, and store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 51 /r VSQRTPH ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Compute square roots of the packed FP16 values in zmm2/m512/m16bcst, and store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 51 /r VSQRTPH zmm1{k1}{z}, zmm2/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsubadd132ph:vfmsubadd213ph:vfmsubadd231ph",
    "category": "Core Instructions",
    "instructionName": "VFMSUBADD132PH/VFMSUBADD213PH/VFMSUBADD231PH\n\t\t— Fused Multiply-AlternatingSubtract/Add of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, subtract/add elements in xmm2, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 97 /r VFMSUBADD132PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, subtract/add elements in ymm2, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 97 /r VFMSUBADD132PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, subtract/add elements in zmm2, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 97 /r VFMSUBADD132PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 A7 /r VFMSUBADD213PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 A7 /r VFMSUBADD213PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 A7 /r VFMSUBADD213PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, subtract/add elements in xmm1, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 B7 /r VFMSUBADD231PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, subtract/add elements in ymm1, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 B7 /r VFMSUBADD231PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, subtract/add elements in zmm1, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 B7 /r VFMSUBADD231PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/minps",
    "category": "Core Instructions",
    "instructionName": "MINPS\n\t\t— Minimum of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Return the minimum single precision floating-point values between xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 5D /r MINPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the minimum single precision floating-point values between xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 5D /r VMINPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the minimum single double precision floating-point values between ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 5D /r VMINPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Return the minimum packed single precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 5D /r VMINPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Return the minimum packed single precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 5D /r VMINPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Return the minimum packed single precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 5D /r VMINPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed single precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "MIN(SRC1, SRC2)\n{\n    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;\n        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC1 < SRC2) THEN DEST := SRC1;\n        ELSE DEST := SRC2;\n    FI;\n}\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+31:i] := MIN(SRC1[i+31:i], SRC2[31:0])\n                ELSE\n                    DEST[i+31:i] := MIN(SRC1[i+31:i], SRC2[i+31:i])\n            FI;\n            ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0\n                        ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])\nDEST[63:32] := MIN(SRC1[63:32], SRC2[63:32])\nDEST[95:64] := MIN(SRC1[95:64], SRC2[95:64])\nDEST[127:96] := MIN(SRC1[127:96], SRC2[127:96])\nDEST[159:128] := MIN(SRC1[159:128], SRC2[159:128])\nDEST[191:160] := MIN(SRC1[191:160], SRC2[191:160])\nDEST[223:192] := MIN(SRC1[223:192], SRC2[223:192])\nDEST[255:224] := MIN(SRC1[255:224], SRC2[255:224])\nDEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])\nDEST[63:32] := MIN(SRC1[63:32], SRC2[63:32])\nDEST[95:64] := MIN(SRC1[95:64], SRC2[95:64])\nDEST[127:96] := MIN(SRC1[127:96], SRC2[127:96])\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])\nDEST[63:32] := MIN(SRC1[63:32], SRC2[63:32])\nDEST[95:64] := MIN(SRC1[95:64], SRC2[95:64])\nDEST[127:96] := MIN(SRC1[127:96], SRC2[127:96])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (including QNaN Source Operand), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movlpd",
    "category": "Core Instructions",
    "instructionName": "MOVLPD\n\t\t— Move Low Packed Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move double precision floating-point value from m64 to low quadword of xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 12 /r MOVLPD xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge double precision floating-point value from m64 and the high quadword of xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 12 /r VMOVLPD xmm2, xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Merge double precision floating-point value from m64 and the high quadword of xmm1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 12 /r VMOVLPD xmm2, xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move double precision floating-point value from low quadword of xmm1 to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "66 0F 13/r MOVLPD m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move double precision floating-point value from low quadword of xmm1 to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 13/r VMOVLPD m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move double precision floating-point value from low quadword of xmm1 to m64.",
        "Op / En": "E",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 13/r VMOVLPD m64, xmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      },
      {
        "Op/En": "E",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "This instruction cannot be used for register to register or memory to memory moves.\n128-bit Legacy SSE load:\nMoves a double precision floating-point value from the source 64-bit memory operand and stores it in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.\nVEX.128 & EVEX encoded load:\nLoads a double precision floating-point value from the source 64-bit memory operand (third operand), merges it with the upper 64-bits of the first source XMM register (second operand), and stores it in the low 128-bits of the destination XMM register (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n128-bit store:\nStores a double precision floating-point value from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).\nNote: VMOVLPD (store) (VEX.128.66.0F 13 /r) is legal and has the same behavior as the existing 66 0F 13 store. For VMOVLPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.\nIf VMOVLPD is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception.",
    "operationText": "DEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] (Unmodified)\nDEST[63:0] := SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC[63:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmaxsb:pmaxsw:pmaxsd:pmaxsq",
    "category": "Core Instructions",
    "instructionName": "PMAXSB/PMAXSW/PMAXSD/PMAXSQ\n\t\t— Maximum of Packed Signed Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Compare signed word integers in mm2/m64 and mm1 and return maximum values.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F EE /r1 PMAXSW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 38 3C /r PMAXSB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed signed word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F EE /r PMAXSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 38 3D /r PMAXSD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 3C /r VPMAXSB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG EE /r VPMAXSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 3D /r VPMAXSD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 3C /r VPMAXSB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed word integers in ymm3/m256 and ymm2 and store packed maximum values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG EE /r VPMAXSW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 3D /r VPMAXSD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 3C /r VPMAXSB xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 3C /r VPMAXSB ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 3C /r VPMAXSB zmm1{k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG EE /r VPMAXSW xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG EE /r VPMAXSW ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed signed word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG EE /r VPMAXSW zmm1{k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 3D /r VPMAXSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 3D /r VPMAXSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 3D /r VPMAXSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 3D /r VPMAXSQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 3D /r VPMAXSQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 3D /r VPMAXSQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\nLegacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\nEVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.\nEVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "IF DEST[15:0] > SRC[15:0]) THEN\n    DEST[15:0] := DEST[15:0];\nELSE\n    DEST[15:0] := SRC[15:0]; FI;\n(* Repeat operation for 2nd and 3rd words in source and destination operands *)\nIF DEST[63:48] > SRC[63:48]) THEN\n    DEST[63:48] := DEST[63:48];\nELSE\n    DEST[63:48] := SRC[63:48]; FI;\nIF DEST[7:0] > SRC[7:0] THEN\n        DEST[7:0] := DEST[7:0];\n    ELSE\n        DEST[7:0] := SRC[7:0]; FI;\n    (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n    IF DEST[127:120] >SRC[127:120] THEN\n        DEST[127:120] := DEST[127:120];\n    ELSE\n        DEST[127:120] := SRC[127:120]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[7:0] > SRC2[7:0] THEN\n        DEST[7:0] := SRC1[7:0];\n    ELSE\n        DEST[7:0] := SRC2[7:0]; FI;\n    (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n    IF SRC1[127:120] >SRC2[127:120] THEN\n        DEST[127:120] := SRC1[127:120];\n    ELSE\n        DEST[127:120] := SRC2[127:120]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[7:0] > SRC2[7:0] THEN\n        DEST[7:0] := SRC1[7:0];\n    ELSE\n        DEST[7:0] := SRC2[7:0]; FI;\n    (* Repeat operation for 2nd through 31st bytes in source and destination operands *)\n    IF SRC1[255:248] >SRC2[255:248] THEN\n        DEST[255:248] := SRC1[255:248];\n    ELSE\n        DEST[255:248] := SRC2[255:248]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask* THEN\n        IF SRC1[i+7:i] > SRC2[i+7:i]\n            THEN DEST[i+7:i] := SRC1[i+7:i];\n            ELSE DEST[i+7:i] := SRC2[i+7:i];\n        FI;\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nIF DEST[15:0] >SRC[15:0] THEN\n        DEST[15:0] := DEST[15:0];\n    ELSE\n        DEST[15:0] := SRC[15:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF DEST[127:112] >SRC[127:112] THEN\n        DEST[127:112] := DEST[127:112];\n    ELSE\n        DEST[127:112] := SRC[127:112]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[15:0] > SRC2[15:0] THEN\n        DEST[15:0] := SRC1[15:0];\n    ELSE\n        DEST[15:0] := SRC2[15:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF SRC1[127:112] >SRC2[127:112] THEN\n        DEST[127:112] := SRC1[127:112];\n    ELSE\n        DEST[127:112] := SRC2[127:112]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[15:0] > SRC2[15:0] THEN\n        DEST[15:0] := SRC1[15:0];\n    ELSE\n        DEST[15:0] := SRC2[15:0]; FI;\n    (* Repeat operation for 2nd through 15th words in source and destination operands *)\n    IF SRC1[255:240] >SRC2[255:240] THEN\n        DEST[255:240] := SRC1[255:240];\n    ELSE\n        DEST[255:240] := SRC2[255:240]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask* THEN\n        IF SRC1[i+15:i] > SRC2[i+15:i]\n            THEN DEST[i+15:i] := SRC1[i+15:i];\n            ELSE DEST[i+15:i] := SRC2[i+15:i];\n        FI;\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nIF DEST[31:0] >SRC[31:0] THEN\n        DEST[31:0] := DEST[31:0];\n    ELSE\n        DEST[31:0] := SRC[31:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF DEST[127:96] >SRC[127:96] THEN\n        DEST[127:96] := DEST[127:96];\n    ELSE\n        DEST[127:96] := SRC[127:96]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[31:0] > SRC2[31:0] THEN\n        DEST[31:0] := SRC1[31:0];\n    ELSE\n        DEST[31:0] := SRC2[31:0]; FI;\n    (* Repeat operation for 2nd through 3rd dwords in source and destination operands *)\n    IF SRC1[127:96] > SRC2[127:96] THEN\n        DEST[127:96] := SRC1[127:96];\n    ELSE\n        DEST[127:96] := SRC2[127:96]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[31:0] > SRC2[31:0] THEN\n        DEST[31:0] := SRC1[31:0];\n    ELSE\n        DEST[31:0] := SRC2[31:0]; FI;\n    (* Repeat operation for 2nd through 7th dwords in source and destination operands *)\n    IF SRC1[255:224] > SRC2[255:224] THEN\n        DEST[255:224] := SRC1[255:224];\n    ELSE\n        DEST[255:224] := SRC2[255:224]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*THEN\n        IF (EVEX.b = 1) AND (SRC2 *is memory*)\n            THEN\n                IF SRC1[i+31:i] > SRC2[31:0]\n                    THEN DEST[i+31:i] := SRC1[i+31:i];\n                    ELSE DEST[i+31:i] := SRC2[31:0];\n                FI;\n            ELSE\n                IF SRC1[i+31:i] > SRC2[i+31:i]\n                    THEN DEST[i+31:i] := SRC1[i+31:i];\n                    ELSE DEST[i+31:i] := SRC2[i+31:i];\n            FI;\n        FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0\n                        ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n        IF (EVEX.b = 1) AND (SRC2 *is memory*)\n            THEN\n                IF SRC1[i+63:i] > SRC2[63:0]\n                    THEN DEST[i+63:i] := SRC1[i+63:i];\n                    ELSE DEST[i+63:i] := SRC2[63:0];\n                FI;\n            ELSE\n                IF SRC1[i+63:i] > SRC2[i+63:i]\n                    THEN DEST[i+63:i] := SRC1[i+63:i];\n                    ELSE DEST[i+63:i] := SRC2[i+63:i];\n            FI;\n        FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    THEN DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPMAXSD/Q, see Table 2-49, “Type E4 Class Exception Conditions.”",
        "EVEX-encoded VPMAXSB/W, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movsldup",
    "category": "Core Instructions",
    "instructionName": "MOVSLDUP\n\t\t— Replicate Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Move even index single precision floating-point values from xmm2/mem and duplicate each element into xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 12 /r MOVSLDUP xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move even index single precision floating-point values from xmm2/mem and duplicate each element into xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F.WIG 12 /r VMOVSLDUP xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move even index single precision floating-point values from ymm2/mem and duplicate each element into ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.F3.0F.WIG 12 /r VMOVSLDUP ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move even index single precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.F3.0F.W0 12 /r VMOVSLDUP xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move even index single precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.F3.0F.W0 12 /r VMOVSLDUP ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move even index single precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.F3.0F.W0 12 /r VMOVSLDUP zmm1 {k1}{z}, zmm2/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Duplicates even-indexed single precision floating-point values from the source operand (the second operand). See Figure 4-4. The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.\nVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed.\nEVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nTMP_SRC[31:0] := SRC[31:0]\nTMP_SRC[63:32] := SRC[31:0]\nTMP_SRC[95:64] := SRC[95:64]\nTMP_SRC[127:96] := SRC[95:64]\nIF VL >= 256\n    TMP_SRC[159:128] := SRC[159:128]\n    TMP_SRC[191:160] := SRC[159:128]\n    TMP_SRC[223:192] := SRC[223:192]\n    TMP_SRC[255:224] := SRC[223:192]\nFI;\nIF VL >= 512\n    TMP_SRC[287:256] := SRC[287:256]\n    TMP_SRC[319:288] := SRC[287:256]\n    TMP_SRC[351:320] := SRC[351:320]\n    TMP_SRC[383:352] := SRC[351:320]\n    TMP_SRC[415:384] := SRC[415:384]\n    TMP_SRC[447:416] := SRC[415:384]\n    TMP_SRC[479:448] := SRC[479:448]\n    TMP_SRC[511:480] := SRC[479:448]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC[31:0]\nDEST[63:32] := SRC[31:0]\nDEST[95:64] := SRC[95:64]\nDEST[127:96] := SRC[95:64]\nDEST[159:128] := SRC[159:128]\nDEST[191:160] := SRC[159:128]\nDEST[223:192] := SRC[223:192]\nDEST[255:224] := SRC[223:192]\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := SRC[31:0]\nDEST[63:32] := SRC[31:0]\nDEST[95:64] := SRC[95:64]\nDEST[127:96] := SRC[95:64]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC[31:0]\nDEST[63:32] := SRC[31:0]\nDEST[95:64] := SRC[95:64]\nDEST[127:96] := SRC[95:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vbroadcast",
    "category": "Core Instructions",
    "instructionName": "VBROADCAST\n\t\t— Load with Broadcast Floating-Point Data",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Broadcast single precision floating-point element in mem to four locations in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 18 /r VBROADCASTSS xmm1, m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Broadcast single precision floating-point element in mem to eight locations in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 18 /r VBROADCASTSS ymm1, m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Broadcast double precision floating-point element in mem to four locations in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 19 /r VBROADCASTSD ymm1, m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 1A /r VBROADCASTF128 ymm1, m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast the low single precision floating-point element in the source operand to four locations in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 18/r VBROADCASTSS xmm1, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast low single precision floating-point element in the source operand to eight locations in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 18 /r VBROADCASTSS ymm1, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Broadcast low double precision floating-point element in the source operand to four locations in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 19 /r VBROADCASTSD ymm1, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast low double precision floating-point element in xmm2/m64 to four locations in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 19 /r VBROADCASTSD ymm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast low double precision floating-point element in xmm2/m64 to eight locations in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 19 /r VBROADCASTSD zmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Broadcast two single precision floating-point elements in xmm2/m64 to locations in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 19 /r VBROADCASTF32X2 ymm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Broadcast two single precision floating-point elements in xmm2/m64 to locations in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 19 /r VBROADCASTF32X2 zmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast low single precision floating-point element in xmm2/m32 to all locations in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 18 /r VBROADCASTSS xmm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast low single precision floating-point element in xmm2/m32 to all locations in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 18 /r VBROADCASTSS ymm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast low single precision floating-point element in xmm2/m32 to all locations in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 18 /r VBROADCASTSS zmm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast 128 bits of 4 single precision floating-point data in mem to locations in ymm1 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 1A /r VBROADCASTF32X4 ymm1 {k1}{z}, m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast 128 bits of 4 single precision floating-point data in mem to locations in zmm1 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 1A /r VBROADCASTF32X4 zmm1 {k1}{z}, m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Broadcast 128 bits of 2 double precision floating-point data in mem to locations in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 1A /r VBROADCASTF64X2 ymm1 {k1}{z}, m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Broadcast 128 bits of 2 double precision floating-point data in mem to locations in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 1A /r VBROADCASTF64X2 zmm1 {k1}{z}, m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Broadcast 256 bits of 8 single precision floating-point data in mem to locations in zmm1 using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 1B /r VBROADCASTF32X8 zmm1 {k1}{z}, m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast 256 bits of 4 double precision floating-point data in mem to locations in zmm1 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 1B /r VBROADCASTF64X4 zmm1 {k1}{z}, m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple2"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple4"
      },
      {
        "Op/En": "E",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple8"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpcompressd",
    "category": "Core Instructions",
    "instructionName": "VPCOMPRESSD\n\t\t— Store Sparse Packed Doubleword Integer Values Into Dense Memory/Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compress packed doubleword integer values from xmm2 to xmm1/m128 using control mask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 8B /r VPCOMPRESSD xmm1/m128 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compress packed doubleword integer values from ymm2 to ymm1/m256 using control mask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 8B /r VPCOMPRESSD ymm1/m256 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compress packed doubleword integer values from zmm2 to zmm1/m512 using control mask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 8B /r VPCOMPRESSD zmm1/m512 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmadd132sd:vfmadd213sd:vfmadd231sd",
    "category": "Core Instructions",
    "instructionName": "VFMADD132SD/VFMADD213SD/VFMADD231SD\n\t\t— Fused Multiply-Add of Scalar DoublePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 99 /r VFMADD132SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 A9 /r VFMADD213SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 B9 /r VFMADD231SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 99 /r VFMADD132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 A9 /r VFMADD213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 B9 /r VFMADD231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/blsmsk",
    "category": "Core Instructions",
    "instructionName": "BLSMSK\n\t\t— Get Mask Up to Lowest Set Bit",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI1",
        "Description": "Set all lower bits in r32 to “1” starting from bit 0 to lowest set bit in r/m32.",
        "Op/En": "VM",
        "Opcode/Instruction": "VEX.LZ.0F38.W0 F3 /2 BLSMSK r32, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI1",
        "Description": "Set all lower bits in r64 to “1” starting from bit 0 to lowest set bit in r/m64.",
        "Op/En": "VM",
        "Opcode/Instruction": "VEX.LZ.0F38.W1 F3 /2 BLSMSK r64, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "VM",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Sets all the lower bits of the destination operand to “1” up to and including lowest set bit (=1) in the source operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "temp := (SRC-1) XOR (SRC) ;\nSF := temp[OperandSize -1];\nZF := 0;\nIF SRC = 0\n    CF := 1;\nELSE\n    CF := 0;\nFI\nDEST := temp;",
    "flagsAffectedText": "SF is updated based on the result. CF is set if the source if zero. ZF and OF flags are cleared. AF and PF flag are undefined.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vreducesd",
    "category": "Core Instructions",
    "instructionName": "VREDUCESD\n\t\t— Perform a Reduction Transformation on a Scalar Float64 Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512D Q",
        "Description": "Perform a reduction transformation on a scalar double precision floating-point value in xmm3/m64 by subtracting a number of fraction bits specified by the imm8 field. Also, upper double precision floating-point value (bits[127:64]) from xmm2 are copied to xmm1[127:64]. Stores the result in xmm1 register.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W1 57 VREDUCESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8/r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfpclasspd",
    "category": "Core Instructions",
    "instructionName": "VFPCLASSPD\n\t\t— Tests Types of Packed Float64 Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 66 /r ib VFPCLASSPD k2 {k1}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 66 /r ib VFPCLASSPD k2 {k1}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 66 /r ib VFPCLASSPD k2 {k1}, zmm2/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/lsl",
    "category": "Core Instructions",
    "instructionName": "LSL\n\t\t— Load Segment Limit",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load: r16 := segment limit, selector r16/m16.",
        "Instruction": "LSL r16, r16/m16",
        "Op/En": "RM",
        "Opcode": "0F 03 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load: r32 := segment limit, selector r32/m16.",
        "Instruction": "LSL r32, r32/m161",
        "Op/En": "RM",
        "Opcode": "0F 03 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load: r64 := segment limit, selector r32/m16",
        "Instruction": "LSL r64, r32/m161",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 03 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.\nThe processor performs access checks as part of the loading process. Once loaded in the destination register, software can compare the segment limit with the offset of a pointer.\nThe segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte 6 of the segment descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit before loading it into the destination operand. The translation is performed by shifting the 20-bit “raw” limit left 12 bits and filling the low-order 12 bits with 1s.\nWhen the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits are loaded into the destination operand.\nThis instruction performs the following checks before it loads the segment limit into the destination register:\nIf the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no value is loaded in the destination operand.",
    "operationText": "IF SRC(Offset) > descriptor table limit\n    THEN ZF := 0; FI;\nRead segment descriptor;\nIF SegmentDescriptor(Type) ≠ conforming code segment\nand (CPL > DPL) OR (RPL > DPL)\nor Segment type is not valid for instruction\n        THEN\n            ZF := 0;\n        ELSE\n            temp := SegmentLimit([SRC]);\n            IF (SegmentDescriptor(G) = 1)\n                THEN temp := (temp << 12) OR 00000FFFH;\n            ELSE IF OperandSize = 32\n                THEN DEST := temp; FI;\n            ELSE IF OperandSize = 64 (* REX.W used *)\n                THEN DEST := temp(* Zero-extended *); FI;\n            ELSE (* OperandSize = 16 *)\n                DEST := temp AND FFFFH;\n            FI;\nFI;",
    "flagsAffectedText": "The ZF flag is set to 1 if the segment limit is loaded successfully; otherwise, it is set to 0.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory operand effective address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and the memory operand effective address is unaligned while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and the memory operand effective address is unaligned while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpbroadcastm",
    "category": "Core Instructions",
    "instructionName": "VPBROADCASTM\n\t\t— Broadcast Mask to Vector Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Broadcast low byte value in k1 to two locations in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W1 2A /r VPBROADCASTMB2Q xmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Broadcast low byte value in k1 to four locations in ymm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W1 2A /r VPBROADCASTMB2Q ymm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512CD",
        "Description": "Broadcast low byte value in k1 to eight locations in zmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W1 2A /r VPBROADCASTMB2Q zmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Broadcast low word value in k1 to four locations in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 3A /r VPBROADCASTMW2D xmm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Broadcast low word value in k1 to eight locations in ymm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 3A /r VPBROADCASTMW2D ymm1, k1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512CD",
        "Description": "Broadcast low word value in k1 to sixteen locations in zmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 3A /r VPBROADCASTMW2D zmm1, k1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vinsertf128:vinsertf32x4:vinsertf64x2:vinsertf32x8:vinsertf64x4",
    "category": "Core Instructions",
    "instructionName": "VINSERTF128/VINSERTF32x4/VINSERTF64x2/VINSERTF32x8/VINSERTF64x4\n\t\t— Insert PackedFloating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Insert 128 bits of packed floating-point values from xmm3/m128 and the remaining values from ymm2 into ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 18 /r ib VINSERTF128 ymm1, ymm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Insert 128 bits of packed single-precision floating-point values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 18 /r ib VINSERTF32X4 ymm1 {k1}{z}, ymm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Insert 128 bits of packed single-precision floating-point values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 18 /r ib VINSERTF32X4 zmm1 {k1}{z}, zmm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Insert 128 bits of packed double precision floating-point values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 18 /r ib VINSERTF64X2 ymm1 {k1}{z}, ymm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Insert 128 bits of packed double precision floating-point values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 18 /r ib VINSERTF64X2 zmm1 {k1}{z}, zmm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Insert 256 bits of packed single-precision floating-point values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 1A /r ib VINSERTF32X8 zmm1 {k1}{z}, zmm2, ymm3/m256, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Insert 256 bits of packed double precision floating-point values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 1A /r ib VINSERTF64X4 zmm1 {k1}{z}, zmm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple2"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple4"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple8"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpcompressb:vcompressw",
    "category": "Core Instructions",
    "instructionName": "VPCOMPRESSB/VCOMPRESSW\n\t\t— Store Sparse Packed Byte/Word Integer Values Into DenseMemory/Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Compress up to 128 bits of packed byte values from xmm1 to m128 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 63 /r VPCOMPRESSB m128{k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Compress up to 128 bits of packed byte values from xmm2 to xmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 63 /r VPCOMPRESSB xmm1{k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Compress up to 256 bits of packed byte values from ymm1 to m256 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 63 /r VPCOMPRESSB m256{k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Compress up to 256 bits of packed byte values from ymm2 to ymm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 63 /r VPCOMPRESSB ymm1{k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Compress up to 512 bits of packed byte values from zmm1 to m512 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 63 /r VPCOMPRESSB m512{k1}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Compress up to 512 bits of packed byte values from zmm2 to zmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 63 /r VPCOMPRESSB zmm1{k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Compress up to 128 bits of packed word values from xmm1 to m128 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 63 /r VPCOMPRESSW m128{k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Compress up to 128 bits of packed word values from xmm2 to xmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 63 /r VPCOMPRESSW xmm1{k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Compress up to 256 bits of packed word values from ymm1 to m256 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 63 /r VPCOMPRESSW m256{k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Compress up to 256 bits of packed word values from ymm2 to ymm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 63 /r VPCOMPRESSW ymm1{k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Compress up to 512 bits of packed word values from zmm1 to m512 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 63 /r VPCOMPRESSW m512{k1}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Compress up to 512 bits of packed word values from zmm2 to zmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 63 /r VPCOMPRESSW zmm1{k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Tuple1 Scalar"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermps",
    "category": "Core Instructions",
    "instructionName": "VPERMPS\n\t\t— Permute Single Precision Floating-Point Elements",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Permute single-precision floating-point elements in ymm3/m256 using indices in ymm2 and store the result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 16 /r VPERMPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point elements in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 subject to write mask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 16 /r VPERMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute single-precision floating-point values in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 subject to write mask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 16 /r VPERMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmadd132ph:vfnmadd132ph:vfmadd213ph:vfnmadd213ph:vfmadd231ph:vfnmadd231ph",
    "category": "Core Instructions",
    "instructionName": "VFMADD132PH/VFNMADD132PH/VFMADD213PH/VFNMADD213PH/VFMADD231PH/VFNMADD231PH\n\t\t— Fused Multiply-Add of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, add to xmm2, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 98 /r VFMADD132PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, add to ymm2, and store the result in ymm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 98 /r VFMADD132PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, add to zmm2, and store the result in zmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 98 /r VFMADD132PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm2, add to xmm3/m128/m16bcst, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 A8 /r VFMADD213PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm2, add to ymm3/m256/m16bcst, and store the result in ymm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 A8 /r VFMADD213PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm2, add to zmm3/m512/m16bcst, and store the result in zmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 A8 /r VFMADD213PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, add to xmm1, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 B8 /r VFMADD231PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, add to ymm1, and store the result in ymm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 B8 /r VFMADD231PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, add to zmm1, and store the result in zmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 B8 /r VFMADD231PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, and negate the value. Add this value to xmm2, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 9C /r VFNMADD132PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, and negate the value. Add this value to ymm2, and store the result in ymm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 9C /r VFNMADD132PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, and negate the value. Add this value to zmm2, and store the result in zmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 9C /r VFNMADD132PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm2, and negate the value. Add this value to xmm3/m128/m16bcst, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 AC /r VFNMADD213PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm2, and negate the value. Add this value to ymm3/m256/m16bcst, and store the result in ymm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 AC /r VFNMADD213PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm2, and negate the value. Add this value to zmm3/m512/m16bcst, and store the result in zmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 AC /r VFNMADD213PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, and negate the value. Add this value to xmm1, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 BC /r VFNMADD231PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, and negate the value. Add this value to ymm1, and store the result in ymm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 BC /r VFNMADD231PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, and negate the value. Add this value to zmm1, and store the result in zmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 BC /r VFNMADD231PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fucom:fucomp:fucompp",
    "category": "Core Instructions",
    "instructionName": "FUCOM/FUCOMP/FUCOMPP\n\t\t— Unordered Compare Floating-Point Values",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(i).",
        "Instruction": "FUCOM ST(i)",
        "Opcode": "DD E0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(1).",
        "Instruction": "FUCOM",
        "Opcode": "DD E1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(i) and pop register stack.",
        "Instruction": "FUCOMP ST(i)",
        "Opcode": "DD E8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(1) and pop register stack.",
        "Instruction": "FUCOMP",
        "Opcode": "DD E9"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(1) and pop register stack twice.",
        "Instruction": "FUCOMPP",
        "Opcode": "DA E9"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0.\nAn unordered comparison checks the class of the numbers being compared (see “FXAM—Examine Floating-Point” in this chapter). The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. The only difference is that the FUCOM/FUCOMP/FUCOMPP instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.\nAs with the FCOM/FCOMP/FCOMPP instructions, if the operation results in an invalid-arithmetic-operand exception being raised, the condition code flags are set only if the exception is masked.\nThe FUCOMP instruction pops the register stack following the comparison operation and the FUCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "CASE (relation of operands) OF\n    ST > SRC:\n                        C3, C2, C0 := 000;\n    ST < SRC:\n                        C3, C2, C0 := 001;\n    ST = SRC:\n                        C3, C2, C0 := 100;\nESAC;\nIF ST(0) or SRC = QNaN, but not SNaN or unsupported format\n    THEN\n        C3, C2, C0 := 111;\n    ELSE (* ST(0) or SRC is SNaN or unsupported format *)\n            #IA;\n        IF FPUControlWord.IM = 1\n                THEN\n                    C3, C2, C0 := 111;\n        FI;\nFI;\nIF Instruction = FUCOMP\n    THEN\n        PopRegisterStack;\nFI;\nIF Instruction = FUCOMPP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: One or both operands are SNaN values or have unsupported formats. Detection of a QNaN value in and of itself does not raise an invalid-operand exception.; \ncolumn_2: One or both operands are denormal values.; column_1: #D;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xadd",
    "category": "Core Instructions",
    "instructionName": "XADD\n\t\t— Exchange and Add",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange r8 and r/m8; load sum into r/m8.",
        "Instruction": "XADD r/m8, r8",
        "Op/En": "MR",
        "Opcode": "0F C0 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Exchange r8 and r/m8; load sum into r/m8.",
        "Instruction": "XADD r/m8*, r8*",
        "Op/En": "MR",
        "Opcode": "REX + 0F C0 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange r16 and r/m16; load sum into r/m16.",
        "Instruction": "XADD r/m16, r16",
        "Op/En": "MR",
        "Opcode": "0F C1 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange r32 and r/m32; load sum into r/m32.",
        "Instruction": "XADD r/m32, r32",
        "Op/En": "MR",
        "Opcode": "0F C1 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Exchange r64 and r/m64; load sum into r/m64.",
        "Instruction": "XADD r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 0F C1 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r, w)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
    "operationText": "TEMP := SRC + DEST;\nSRC := DEST;\nDEST := TEMP;",
    "flagsAffectedText": "The CF, PF, AF, SF, ZF, and OF flags are set according to the result of the addition, which is stored in the destination operand.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fclex:fnclex",
    "category": "Core Instructions",
    "instructionName": "FCLEX/FNCLEX\n\t\t— Clear Exceptions",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.",
        "Instruction": "FCLEX",
        "column_1": "9B DB E2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Clear floating-point exception flags without checking for pending unmasked floating-point exceptions.",
        "Instruction": "FNCLEX1",
        "column_1": "DB E2"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does not.\nThe assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.",
    "operationText": "FPUStatusWord[0:7] := 0;\nFPUStatusWord[15] := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xchg",
    "category": "Core Instructions",
    "instructionName": "XCHG\n\t\t— Exchange Register/Memory With Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange r16 with AX.",
        "Instruction": "XCHG AX, r16",
        "Op/En": "O",
        "Opcode": "90+rw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange AX with r16.",
        "Instruction": "XCHG r16, AX",
        "Op/En": "O",
        "Opcode": "90+rw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange r32 with EAX.",
        "Instruction": "XCHG EAX, r32",
        "Op/En": "O",
        "Opcode": "90+rd"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Exchange r64 with RAX.",
        "Instruction": "XCHG RAX, r64",
        "Op/En": "O",
        "Opcode": "REX.W + 90+rd"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange EAX with r32.",
        "Instruction": "XCHG r32, EAX",
        "Op/En": "O",
        "Opcode": "90+rd"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Exchange RAX with r64.",
        "Instruction": "XCHG r64, RAX",
        "Op/En": "O",
        "Opcode": "REX.W + 90+rd"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange r8 (byte register) with byte from r/m8.",
        "Instruction": "XCHG r/m8, r8",
        "Op/En": "MR",
        "Opcode": "86 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Exchange r8 (byte register) with byte from r/m8.",
        "Instruction": "XCHG r/m8*, r8*",
        "Op/En": "MR",
        "Opcode": "REX + 86 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange byte from r/m8 with r8 (byte register).",
        "Instruction": "XCHG r8, r/m8",
        "Op/En": "RM",
        "Opcode": "86 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Exchange byte from r/m8 with r8 (byte register).",
        "Instruction": "XCHG r8*, r/m8*",
        "Op/En": "RM",
        "Opcode": "REX + 86 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange r16 with word from r/m16.",
        "Instruction": "XCHG r/m16, r16",
        "Op/En": "MR",
        "Opcode": "87 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange word from r/m16 with r16.",
        "Instruction": "XCHG r16, r/m16",
        "Op/En": "RM",
        "Opcode": "87 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange r32 with doubleword from r/m32.",
        "Instruction": "XCHG r/m32, r32",
        "Op/En": "MR",
        "Opcode": "87 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Exchange r64 with quadword from r/m64.",
        "Instruction": "XCHG r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 87 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange doubleword from r/m32 with r32.",
        "Instruction": "XCHG r32, r/m32",
        "Op/En": "RM",
        "Opcode": "87 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Exchange quadword from r/m64 with r64.",
        "Instruction": "XCHG r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 87 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "O",
        "Operand 1": "AX/EAX/RAX (r, w)",
        "Operand 2": "opcode + rd (r, w)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "O",
        "Operand 1": "opcode + rd (r, w)",
        "Operand 2": "AX/EAX/RAX (r, w)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Exchanges the contents of the destination (first) and source (second) operands. The operands can be two general-purpose registers or a register and a memory location. If a memory operand is referenced, the processor’s locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL. (See the LOCK prefix description in this chapter for more information on the locking protocol.)\nThis instruction is useful for implementing semaphores or similar data structures for process synchronization. (See “Bus Locking” in Chapter 9 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for more information on bus locking.)\nThe XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "TEMP := DEST;\nDEST := SRC;\nSRC := TEMP;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If the LOCK prefix is used but the destination is not a memory operand.; column_1: #UD;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ecreate",
    "category": "SGX Instructions",
    "instructionName": "ECREATE\n\t\t— Create an SECS page in the Enclave Page Cache",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function begins an enclave build by creating an SECS page in EPC.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 00H ENCLS[ECREATE]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "ECREATE (In)",
        "column_3": "Address of a PAGEINFO (In)",
        "column_4": "Address of the destination SECS page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmread",
    "category": "VMX Instructions",
    "instructionName": "VMREAD\n\t\t— Read Field from Virtual-Machine Control Structure",
    "detailsTable": [
      {
        "Description": "Reads a specified VMCS field (in 64-bit mode).",
        "Op/En": "MR",
        "Opcode/Instruction": "NP 0F 78 VMREAD r/m64, r64"
      },
      {
        "Description": "Reads a specified VMCS field (outside 64-bit mode).",
        "Op/En": "MR",
        "Opcode/Instruction": "NP 0F 78 VMREAD r/m32, r32"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "MR",
        "column_2": "ModRM:r/m (w)",
        "column_3": "ModRM:reg (r)",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Reads a specified field from a VMCS and stores it into a specified destination operand (register or memory). In VMX root operation, the instruction reads from the current VMCS. If executed in VMX non-root operation, the instruction reads from the VMCS referenced by the VMCS link pointer field in the current VMCS.\nThe VMCS field is specified by the VMCS-field encoding contained in the register source operand. Outside IA-32e mode, the source operand has 32 bits, regardless of the value of CS.D. In 64-bit mode, the source operand has 64 bits.\nThe effective size of the destination operand, which may be a register or in memory, is always 32 bits outside IA-32e mode (the setting of CS.D is ignored with respect to operand size) and 64 bits in 64-bit mode. If the VMCS field specified by the source operand is shorter than this effective operand size, the high bits of the destination operand are cleared to 0. If the VMCS field is longer, then the high bits of the field are not read.\nNote that any faults resulting from accessing a memory destination operand can occur only after determining, in the operation section below, that the relevant VMCS pointer is valid and that the specified VMCS field is supported.",
    "operationText": "IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation AND (“VMCS shadowing” is 0 OR source operand sets bits in range 63:15 OR\nVMREAD bit corresponding to bits 14:0 of source operand is 1)1\n    THEN VMexit;\nELSIF CPL > 0\n    THEN #GP(0);\nELSIF (in VMX root operation AND current-VMCS pointer is not valid) OR\n(in VMX non-root operation AND VMCS link pointer is not valid)\n    THEN VMfailInvalid;\nELSIF source operand does not correspond to any VMCS field\n    THEN VMfailValid(VMREAD/VMWRITE from/to unsupported VMCS component);\n    ELSE\n        IF in VMX root operation\n            THEN destination operand := contents of field indexed by source operand in current VMCS;\n            ELSE destination operand := contents of field indexed by source operand in VMCS referenced by VMCS link pointer;\n        FI;\n        VMsucceed;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the memory destination operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.; \ncolumn_2: If a page fault occurs in accessing a memory destination operand.; column_1: #PF(fault-code); \ncolumn_1: #SS(0); column_2: If the memory destination operand is in the SS segment and the memory address is in a non-canonical form.; \ncolumn_1: #UD; column_2: If not in VMX operation.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: If a memory destination operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the destination operand is located in a read-only data segment or any code segment.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing a memory destination operand.; \ncolumn_1: #SS(0); column_2: If a memory destination operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_1: #UD; column_2: If not in VMX operation.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmc",
    "category": "Core Instructions",
    "instructionName": "CMC\n\t\t— Complement Carry Flag",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Complement CF flag.",
        "Instruction": "CMC",
        "Op/En": "ZO",
        "Opcode": "F5"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Complements the CF flag in the EFLAGS register. CMC operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "EFLAGS.CF[bit 0] := NOT EFLAGS.CF[bit 0];",
    "flagsAffectedText": "The CF flag contains the complement of its original value. The OF, ZF, SF, AF, and PF flags are unaffected.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pclmulqdq",
    "category": "Core Instructions",
    "instructionName": "PCLMULQDQ\n\t\t— Carry-Less Multiplication Quadword",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "PCLMULQDQ",
        "Description": "Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 3A 44 /r ib PCLMULQDQ xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "PCLMULQDQ AVX",
        "Description": "Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 44 /r ib VPCLMULQDQ xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "VPCLMULQDQ AVX",
        "Description": "Carry-less multiplication of one quadword of ymm2 by one quadword of ymm3/m256, stores the 128-bit result in ymm1. The immediate is used to determine which quadwords of ymm2 and ymm3/m256 should be used.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F3A.WIG 44 /r /ib VPCLMULQDQ ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "VPCLMULQDQ AVX512VL",
        "Description": "Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.WIG 44 /r /ib VPCLMULQDQ xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "VPCLMULQDQ AVX512VL",
        "Description": "Carry-less multiplication of one quadword of ymm2 by one quadword of ymm3/m256, stores the 128-bit result in ymm1. The immediate is used to determine which quadwords of ymm2 and ymm3/m256 should be used.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F3A.WIG 44 /r /ib VPCLMULQDQ ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "VPCLMULQDQ AVX512F",
        "Description": "Carry-less multiplication of one quadword of zmm2 by one quadword of zmm3/m512, stores the 128-bit result in zmm1. The immediate is used to determine which quadwords of zmm2 and zmm3/m512 should be used.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.WIG 44 /r /ib VPCLMULQDQ zmm1, zmm2, zmm3/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Full Mem"
      }
    ],
    "descriptionText": "Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use according to Table 4-13, other bits of the immediate byte are ignored.\nThe EVEX encoded form of this instruction does not support memory fault suppression.\nThe first source operand and the destination operand are the same and must be a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. Bits (VL_MAX-1:128) of the corresponding YMM destination register remain unchanged.\nCompilers and assemblers may implement the following pseudo-op syntax to simplify programming and emit the required encoding for imm8.",
    "operationText": "define PCLMUL128(X,Y): // helper function\n    FOR i := 0 to 63:\n        TMP [ i ] := X[ 0 ] and Y[ i ]\n        FOR j := 1 to i:\n            TMP [ i ] := TMP [ i ] xor (X[ j ] and Y[ i - j ])\n        DEST[ i ] := TMP[ i ]\n    FOR i := 64 to 126:\n        TMP [ i ] := 0\n        FOR j := i - 63 to 63:\n            TMP [ i ] := TMP [ i ] xor (X[ j ] and Y[ i - j ])\n        DEST[ i ] := TMP[ i ]\n    DEST[127] := 0;\n    RETURN DEST // 128b vector\nIF imm8[0] = 0:\n    TEMP1 := SRC1.qword[0]\nELSE:\n    TEMP1 := SRC1.qword[1]\nIF imm8[4] = 0:\n    TEMP2 := SRC2.qword[0]\nELSE:\n    TEMP2 := SRC2.qword[1]\nDEST[127:0] := PCLMUL128(TEMP1, TEMP2)\nDEST[MAXVL-1:128] (Unmodified)\n(KL,VL) = (1,128), (2,256)\nFOR i= 0 to KL-1:\n    IF imm8[0] = 0:\n        TEMP1 := SRC1.xmm[i].qword[0]\n    ELSE:\n        TEMP1 := SRC1.xmm[i].qword[1]\n    IF imm8[4] = 0:\n        TEMP2 := SRC2.xmm[i].qword[0]\n    ELSE:\n        TEMP2 := SRC2.xmm[i].qword[1]\n    DEST.xmm[i] := PCLMUL128(TEMP1, TEMP2)\nDEST[MAXVL-1:VL] := 0\n(KL,VL) = (1,128), (2,256), (4,512)\nFOR i = 0 to KL-1:\n    IF imm8[0] = 0:\n        TEMP1 := SRC1.xmm[i].qword[0]\n    ELSE:\n        TEMP1 := SRC1.xmm[i].qword[1]\n    IF imm8[4] = 0:\n        TEMP2 := SRC2.xmm[i].qword[0]\n    ELSE:\n        TEMP2 := SRC2.xmm[i].qword[1]\n    DEST.xmm[i] := PCLMUL128(TEMP1, TEMP2)\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded: See Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/kandw:kandb:kandq:kandd",
    "category": "Core Instructions",
    "instructionName": "KANDW/KANDB/KANDQ/KANDD\n\t\t— Bitwise Logical AND Masks",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise AND 16 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W0 41 /r KANDW k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Bitwise AND 8 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W0 41 /r KANDB k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise AND 64 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W1 41 /r KANDQ k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise AND 32 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W1 41 /r KANDD k1, k2, k3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.1vvv (r)",
        "Operand 3": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
    "operationText": "DEST[15:0] := SRC1[15:0] BITWISE AND SRC2[15:0]\nDEST[MAX_KL-1:16] := 0\nDEST[7:0] := SRC1[7:0] BITWISE AND SRC2[7:0]\nDEST[MAX_KL-1:8] := 0\nDEST[63:0] := SRC1[63:0] BITWISE AND SRC2[63:0]\nDEST[MAX_KL-1:64] := 0\nDEST[31:0] := SRC1[31:0] BITWISE AND SRC2[31:0]\nDEST[MAX_KL-1:32] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmovzx",
    "category": "Core Instructions",
    "instructionName": "PMOVZX\n\t\t— Packed Move With Zero Extend",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 30 /r PMOVZXBW xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 31 /r PMOVZXBD xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 32 /r PMOVZXBQ xmm1, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 33 /r PMOVZXWD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 34 /r PMOVZXWQ xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 35 /r PMOVZXDQ xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 30 /r VPMOVZXBW xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 31 /r VPMOVZXBD xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 32 /r VPMOVZXBQ xmm1, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 33 /r VPMOVZXWD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 34 /r VPMOVZXWQ xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F 38.WIG 35 /r VPMOVZXDQ xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 30 /r VPMOVZXBW ymm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 31 /r VPMOVZXBD ymm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 32 /r VPMOVZXBQ ymm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Zero extend 8 packed 16-bit integers xmm2/m128 to 8 packed 32-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 33 /r VPMOVZXWD ymm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 34 /r VPMOVZXWQ ymm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 35 /r VPMOVZXDQ ymm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38 30.WIG /r VPMOVZXBW xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 30 /r VPMOVZXBW ymm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Zero extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 30 /r VPMOVZXBW zmm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 31 /r VPMOVZXBD xmm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 31 /r VPMOVZXBD ymm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 31 /r VPMOVZXBD zmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 32 /r VPMOVZXBQ xmm1 {k1}{z}, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 32 /r VPMOVZXBQ ymm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 32 /r VPMOVZXBQ zmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 33 /r VPMOVZXWD xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 32-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 33 /r VPMOVZXWD ymm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Zero extend 16 packed 16-bit integers in ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 33 /r VPMOVZXWD zmm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 34 /r VPMOVZXWQ xmm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 34 /r VPMOVZXWQ ymm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 34 /r VPMOVZXWQ zmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 35 /r VPMOVZXDQ xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 35 /r VPMOVZXDQ ymm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Zero extend 8 packed 32-bit integers in ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 35 /r VPMOVZXDQ zmm1 {k1}{z}, ymm2/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half Mem"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Quarter Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Eighth Mem"
      }
    ],
    "descriptionText": "Legacy, VEX, and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\nEVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "DEST[15:0] := ZeroExtend(SRC[7:0]);\nDEST[31:16] := ZeroExtend(SRC[15:8]);\nDEST[47:32] := ZeroExtend(SRC[23:16]);\nDEST[63:48] := ZeroExtend(SRC[31:24]);\nDEST[79:64] := ZeroExtend(SRC[39:32]);\nDEST[95:80] := ZeroExtend(SRC[47:40]);\nDEST[111:96] := ZeroExtend(SRC[55:48]);\nDEST[127:112] := ZeroExtend(SRC[63:56]);\nDEST[31:0] := ZeroExtend(SRC[7:0]);\nDEST[63:32] := ZeroExtend(SRC[15:8]);\nDEST[95:64] := ZeroExtend(SRC[23:16]);\nDEST[127:96] := ZeroExtend(SRC[31:24]);\nDEST[63:0] := ZeroExtend(SRC[7:0]);\nDEST[127:64] := ZeroExtend(SRC[15:8]);\nDEST[31:0] := ZeroExtend(SRC[15:0]);\nDEST[63:32] := ZeroExtend(SRC[31:16]);\nDEST[95:64] := ZeroExtend(SRC[47:32]);\nDEST[127:96] := ZeroExtend(SRC[63:48]);\nDEST[63:0] := ZeroExtend(SRC[15:0]);\nDEST[127:64] := ZeroExtend(SRC[31:16]);\nDEST[63:0] := ZeroExtend(SRC[31:0]);\nDEST[127:64] := ZeroExtend(SRC[63:32]);\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nPacked_Zero_Extend_BYTE_to_WORD(TMP_DEST[127:0], SRC[63:0])\nIF VL >= 256\n    Packed_Zero_Extend_BYTE_to_WORD(TMP_DEST[255:128], SRC[127:64])\nFI;\nIF VL >= 512\n    Packed_Zero_Extend_BYTE_to_WORD(TMP_DEST[383:256], SRC[191:128])\n    Packed_Zero_Extend_BYTE_to_WORD(TMP_DEST[511:384], SRC[255:192])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TEMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nPacked_Zero_Extend_BYTE_to_DWORD(TMP_DEST[127:0], SRC[31:0])\nIF VL >= 256\n    Packed_Zero_Extend_BYTE_to_DWORD(TMP_DEST[255:128], SRC[63:32])\nFI;\nIF VL >= 512\n    Packed_Zero_Extend_BYTE_to_DWORD(TMP_DEST[383:256], SRC[95:64])\n    Packed_Zero_Extend_BYTE_to_DWORD(TMP_DEST[511:384], SRC[127:96])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TEMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nPacked_Zero_Extend_BYTE_to_QWORD(TMP_DEST[127:0], SRC[15:0])\nIF VL >= 256\n    Packed_Zero_Extend_BYTE_to_QWORD(TMP_DEST[255:128], SRC[31:16])\nFI;\nIF VL >= 512\n    Packed_Zero_Extend_BYTE_to_QWORD(TMP_DEST[383:256], SRC[47:32])\n    Packed_Zero_Extend_BYTE_to_QWORD(TMP_DEST[511:384], SRC[63:48])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TEMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nPacked_Zero_Extend_WORD_to_DWORD(TMP_DEST[127:0], SRC[63:0])\nIF VL >= 256\n    Packed_Zero_Extend_WORD_to_DWORD(TMP_DEST[255:128], SRC[127:64])\nFI;\nIF VL >= 512\n    Packed_Zero_Extend_WORD_to_DWORD(TMP_DEST[383:256], SRC[191:128])\n    Packed_Zero_Extend_WORD_to_DWORD(TMP_DEST[511:384], SRC[256:192])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TEMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nPacked_Zero_Extend_WORD_to_QWORD(TMP_DEST[127:0], SRC[31:0])\nIF VL >= 256\n    Packed_Zero_Extend_WORD_to_QWORD(TMP_DEST[255:128], SRC[63:32])\nFI;\nIF VL >= 512\n    Packed_Zero_Extend_WORD_to_QWORD(TMP_DEST[383:256], SRC[95:64])\n    Packed_Zero_Extend_WORD_to_QWORD(TMP_DEST[511:384], SRC[127:96])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TEMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nPacked_Zero_Extend_DWORD_to_QWORD(TEMP_DEST[127:0], SRC[63:0])\nIF VL >= 256\n    Packed_Zero_Extend_DWORD_to_QWORD(TEMP_DEST[255:128], SRC[127:64])\nFI;\nIF VL >= 512\n    Packed_Zero_Extend_DWORD_to_QWORD(TEMP_DEST[383:256], SRC[191:128])\n    Packed_Zero_Extend_DWORD_to_QWORD(TEMP_DEST[511:384], SRC[255:192])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TEMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nPacked_Zero_Extend_BYTE_to_WORD(DEST[127:0], SRC[63:0])\nPacked_Zero_Extend_BYTE_to_WORD(DEST[255:128], SRC[127:64])\nDEST[MAXVL-1:256] := 0\nPacked_Zero_Extend_BYTE_to_DWORD(DEST[127:0], SRC[31:0])\nPacked_Zero_Extend_BYTE_to_DWORD(DEST[255:128], SRC[63:32])\nDEST[MAXVL-1:256] := 0\nPacked_Zero_Extend_BYTE_to_QWORD(DEST[127:0], SRC[15:0])\nPacked_Zero_Extend_BYTE_to_QWORD(DEST[255:128], SRC[31:16])\nDEST[MAXVL-1:256] := 0\nPacked_Zero_Extend_WORD_to_DWORD(DEST[127:0], SRC[63:0])\nPacked_Zero_Extend_WORD_to_DWORD(DEST[255:128], SRC[127:64])\nDEST[MAXVL-1:256] := 0\nPacked_Zero_Extend_WORD_to_QWORD(DEST[127:0], SRC[31:0])\nPacked_Zero_Extend_WORD_to_QWORD(DEST[255:128], SRC[63:32])\nDEST[MAXVL-1:256] := 0\nPacked_Zero_Extend_DWORD_to_QWORD(DEST[127:0], SRC[63:0])\nPacked_Zero_Extend_DWORD_to_QWORD(DEST[255:128], SRC[127:64])\nDEST[MAXVL-1:256] := 0\nPacked_Zero_Extend_BYTE_to_WORD()\nDEST[MAXVL-1:128] := 0\nPacked_Zero_Extend_BYTE_to_DWORD()\nDEST[MAXVL-1:128] := 0\nPacked_Zero_Extend_BYTE_to_QWORD()\nDEST[MAXVL-1:128] := 0\nPacked_Zero_Extend_WORD_to_DWORD()\nDEST[MAXVL-1:128] := 0\nPacked_Zero_Extend_WORD_to_QWORD()\nDEST[MAXVL-1:128] := 0\nPacked_Zero_Extend_DWORD_to_QWORD()\nDEST[MAXVL-1:128] := 0\nPacked_Zero_Extend_BYTE_to_WORD()\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Zero_Extend_BYTE_to_DWORD()\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Zero_Extend_BYTE_to_QWORD()\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Zero_Extend_WORD_to_DWORD()\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Zero_Extend_WORD_to_QWORD()\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Zero_Extend_DWORD_to_QWORD()\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-51, “Type E5 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vreduceps",
    "category": "Core Instructions",
    "instructionName": "VREDUCEPS\n\t\t— Perform Reduction Transformation on Packed Float32 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Perform reduction transformation on packed single-precision floating-point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 56 /r ib VREDUCEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Perform reduction transformation on packed single-precision floating-point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 56 /r ib VREDUCEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Perform reduction transformation on packed single-precision floating-point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 56 /r ib VREDUCEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/orps",
    "category": "Core Instructions",
    "instructionName": "ORPS\n\t\t— Bitwise Logical OR of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Return the bitwise logical OR of packed single precision floating-point values in xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 56 /r ORPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical OR of packed single precision floating-point values in xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F 56 /r VORPS xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical OR of packed single precision floating-point values in ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F 56 /r VORPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical OR of packed single precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 56 /r VORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical OR of packed single precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 56 /r VORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Return the bitwise logical OR of packed single precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 56 /r VORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical OR of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+31:i] := SRC1[i+31:i] BITWISE OR SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] := SRC1[i+31:i] BITWISE OR SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC1[31:0] BITWISE OR SRC2[31:0]\nDEST[63:32] := SRC1[63:32] BITWISE OR SRC2[63:32]\nDEST[95:64] := SRC1[95:64] BITWISE OR SRC2[95:64]\nDEST[127:96] := SRC1[127:96] BITWISE OR SRC2[127:96]\nDEST[159:128] := SRC1[159:128] BITWISE OR SRC2[159:128]\nDEST[191:160] := SRC1[191:160] BITWISE OR SRC2[191:160]\nDEST[223:192] := SRC1[223:192] BITWISE OR SRC2[223:192]\nDEST[255:224] := SRC1[255:224] BITWISE OR SRC2[255:224].\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := SRC1[31:0] BITWISE OR SRC2[31:0]\nDEST[63:32] := SRC1[63:32] BITWISE OR SRC2[63:32]\nDEST[95:64] := SRC1[95:64] BITWISE OR SRC2[95:64]\nDEST[127:96] := SRC1[127:96] BITWISE OR SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] BITWISE OR SRC2[31:0]\nDEST[63:32] := SRC1[63:32] BITWISE OR SRC2[63:32]\nDEST[95:64] := SRC1[95:64] BITWISE OR SRC2[95:64]\nDEST[127:96] := SRC1[127:96] BITWISE OR SRC2[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fld",
    "category": "Core Instructions",
    "instructionName": "FLD\n\t\t— Load Floating-Point Value",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push m32fp onto the FPU register stack.",
        "Instruction": "FLD m32fp",
        "Opcode": "D9 /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push m64fp onto the FPU register stack.",
        "Instruction": "FLD m64fp",
        "Opcode": "DD /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push m80fp onto the FPU register stack.",
        "Instruction": "FLD m80fp",
        "Opcode": "DB /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push ST(i) onto the FPU register stack.",
        "Instruction": "FLD ST(i)",
        "Opcode": "D9 C0+i"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Pushes the source operand onto the FPU register stack. The source operand can be in single precision, double precision, or double extended-precision floating-point format. If the source operand is in single precision or double precision floating-point format, it is automatically converted to the double extended-precision floating-point format before being pushed on the stack.\nThe FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF SRC is ST(i)\n    THEN\n        temp := ST(i);\nFI;\nTOP := TOP − 1;\nIF SRC is memory-operand\n    THEN\n        ST(0) := ConvertToDoubleExtendedPrecisionFP(SRC);\n    ELSE (* SRC is ST(i) *)\n        ST(0) := temp;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN. Does not occur if the source operand is in double extended-precision floating-point format (FLD m80fp or FLD ST(i)).; \ncolumn_1: #D; column_2: Source operand is a denormal value. Does not occur if the source operand is in double extended-precision floating-point format.;"
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/enter",
    "category": "Core Instructions",
    "instructionName": "ENTER\n\t\t— Make Stack Frame for Procedure Parameters",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Create a stack frame for a procedure.",
        "Instruction": "ENTER imm16, 0",
        "Op/En": "II",
        "Opcode": "C8 iw 00"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Create a stack frame with a nested pointer for a procedure.",
        "Instruction": "ENTER imm16,1",
        "Op/En": "II",
        "Opcode": "C8 iw 01"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Create a stack frame with nested pointers for a procedure.",
        "Instruction": "ENTER imm16, imm8",
        "Op/En": "II",
        "Opcode": "C8 iw ib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "II",
        "Operand 1": "iw",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Creates a stack frame (comprising of space for dynamic storage and 1-32 frame pointer storage) for a procedure. The first operand (imm16) specifies the size of the dynamic storage in the stack frame (that is, the number of bytes of dynamically allocated on the stack for the procedure). The second operand (imm8) gives the lexical nesting level (0 to 31) of the procedure. The nesting level (imm8 mod 32) and the OperandSize attribute determine the size in bytes of the storage space for frame pointers.\nThe nesting level determines the number of frame pointers that are copied into the “display area” of the new stack frame from the preceding frame. The default size of the frame pointer is the StackAddrSize attribute, but can be overridden using the 66H prefix. Thus, the OperandSize attribute determines the size of each frame pointer that will be copied into the stack frame and the data being transferred from SP/ESP/RSP register into the BP/EBP/RBP register.\nThe ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to release the stack frame.\nIf the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack, copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of 1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These additional frame pointers provide the called procedure with access points to other nested frames on the stack. See “Procedure Calls for Block-Structured Languages” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information about the actions of the ENTER instruction.\nThe ENTER instruction causes a page fault whenever a write using the final value of the stack pointer (within the current stack segment) would do so.\nIn 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded. Use of 66H prefix changes frame pointer operand size to 16 bits.\nWhen the 66H prefix is used and causing the OperandSize attribute to be less than the StackAddrSize, software is responsible for the following:",
    "operationText": "AllocSize := imm16;\nNestingLevel := imm8 MOD 32;\nIF (OperandSize = 64)\n    THEN\n        Push(RBP); (* RSP decrements by 8 *)\n        FrameTemp := RSP;\n    ELSE IF OperandSize = 32\n        THEN\n            Push(EBP); (* (E)SP decrements by 4 *)\n            FrameTemp := ESP; FI;\n    ELSE (* OperandSize = 16 *)\n            Push(BP); (* RSP or (E)SP decrements by 2 *)\n            FrameTemp := SP;\nFI;\nIF NestingLevel = 0\n    THEN GOTO CONTINUE;\nFI;\nIF (NestingLevel > 1)\n    THEN FOR i := 1 to (NestingLevel - 1)\n        DO\n            IF (OperandSize = 64)\n                THEN\n                    RBP := RBP - 8;\n                    Push([RBP]); (* Quadword push *)\n                ELSE IF OperandSize = 32\n                    THEN\n                        IF StackSize = 32\n                            EBP := EBP - 4;\n                            Push([EBP]); (* Doubleword push *)\n                        ELSE (* StackSize = 16 *)\n                            BP := BP - 4;\n                            Push([BP]); (* Doubleword push *)\n                        FI;\n                    FI;\n                ELSE (* OperandSize = 16 *)\n                    IF StackSize = 64\n                        THEN\n                            RBP := RBP - 2;\n                            Push([RBP]); (* Word push *)\n                    ELSE IF StackSize = 32\n                        THEN\n                            EBP := EBP - 2;\n                            Push([EBP]); (* Word push *)\n                        ELSE (* StackSize = 16 *)\n                            BP := BP - 2;\n                            Push([BP]); (* Word push *)\n                    FI;\n                FI;\n    OD;\nFI;\nIF (OperandSize = 64) (* nestinglevel 1 *)\n    THEN\n        Push(FrameTemp); (* Quadword push and RSP decrements by 8 *)\n    ELSE IF OperandSize = 32\n        THEN\n            Push(FrameTemp); FI; (* Doubleword push and (E)SP decrements by 4 *)\n    ELSE (* OperandSize = 16 *)\n            Push(FrameTemp); (* Word push and RSP|ESP|SP decrements by 2 *)\nFI;\nCONTINUE:\nIF 64-Bit Mode (StackSize = 64)\n    THEN\n            RBP := FrameTemp;\n            RSP := RSP − AllocSize;\n    ELSE IF OperandSize = 32\n        THEN\n            EBP := FrameTemp;\n            ESP := ESP − AllocSize; FI;\n    ELSE (* OperandSize = 16 *)\n            BP := FrameTemp[15:1]; (* Bits 16 and above of applicable RBP/EBP are unmodified *)\n            SP := SP − AllocSize;\nFI;\nEND;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs or if a write using the final value of the stack pointer (within the current stack segment) would cause a page fault.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs or if a write using the final value of the stack pointer (within the current stack segment) would cause a page fault.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs or if a write using the final value of the stack pointer (within the current stack segment) would cause a page fault.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/lldt",
    "category": "Core Instructions",
    "instructionName": "LLDT\n\t\t— Load Local Descriptor Table Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load segment selector r/m16 into LDTR.",
        "Instruction": "LLDT r/m16",
        "Op/En": "M",
        "Opcode": "0F 00 /2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source operand (a general-purpose register or a memory location) contains a segment selector that points to a local descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task.\nIf bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT instruction completes silently. However, all subsequent references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions) cause a general protection exception (#GP).\nThe operand-size attribute has no effect on this instruction.\nThe LLDT instruction is provided for use in operating-system software; it should not be used in application programs. This instruction can only be executed in protected mode or 64-bit mode.\nIn 64-bit mode, the operand size is fixed at 16 bits.",
    "operationText": "IF SRC(Offset) > descriptor table limit\n    THEN #GP(segment selector); FI;\nIF segment selector is valid\n    Read segment descriptor;\n    IF SegmentDescriptor(Type) ≠ LDT\n        THEN #GP(segment selector); FI;\n    IF segment descriptor is not present\n        THEN #NP(segment selector); FI;\n    LDTR(SegmentSelector) := SRC;\n    LDTR(SegmentDescriptor) := GDTSegmentDescriptor;\nELSE LDTR := INVALID\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the current privilege level is not 0.; \ncolumn_1: If the memory address is in a non-canonical form.; \ncolumn_1: #GP(selector); column_2: If the selector operand does not point into the Global Descriptor Table or if the entry in the GDT is not a Local Descriptor Table.; \ncolumn_1: Segment selector is beyond GDT limit.; \ncolumn_1: #NP(selector); column_2: If the LDT descriptor is not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #GP(selector); column_2: If the selector operand does not point into the Global Descriptor Table or if the entry in the GDT is not a Local Descriptor Table.; \ncolumn_1: Segment selector is beyond GDT limit.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NP(selector); column_2: If the LDT descriptor is not present.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermi2w:vpermi2d:vpermi2q:vpermi2ps:vpermi2pd",
    "category": "Core Instructions",
    "instructionName": "VPERMI2W/VPERMI2D/VPERMI2Q/VPERMI2PS/VPERMI2PD\n\t\t— Full Permute From Two Tables Overwriting the Index",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Permute word integers from two tables in xmm3/m128 and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 75 /r VPERMI2W xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Permute word integers from two tables in ymm3/m256 and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 75 /r VPERMI2W ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Permute word integers from two tables in zmm3/m512 and zmm2 using indexes in zmm1 and store the result in zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 75 /r VPERMI2W zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double-words from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 76 /r VPERMI2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double-words from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 76 /r VPERMI2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute double-words from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 76 /r VPERMI2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute quad-words from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 76 /r VPERMI2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute quad-words from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 76 /r VPERMI2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute quad-words from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 76 /r VPERMI2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point values from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 77 /r VPERMI2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point values from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 77 /r VPERMI2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute single-precision floating-point values from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 77 /r VPERMI2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point values from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 77 /r VPERMI2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point values from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 77 /r VPERMI2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute double precision floating-point values from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 77 /r VPERMI2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r,w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtps2qq",
    "category": "Core Instructions",
    "instructionName": "VCVTPS2QQ\n\t\t— Convert Packed Single Precision Floating-Point Values to Packed SignedQuadword Integer Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 subject to writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 7B /r VCVTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 subject to writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 7B /r VCVTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 subject to writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 7B /r VCVTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movzx",
    "category": "Core Instructions",
    "instructionName": "MOVZX\n\t\t— Move With Zero-Extend",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move byte to word with zero-extension.",
        "Instruction": "MOVZX r16, r/m8",
        "Op/En": "RM",
        "Opcode": "0F B6 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move byte to doubleword, zero-extension.",
        "Instruction": "MOVZX r32, r/m8",
        "Op/En": "RM",
        "Opcode": "0F B6 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move byte to quadword, zero-extension.",
        "Instruction": "MOVZX r64, r/m81",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F B6 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move word to doubleword, zero-extension.",
        "Instruction": "MOVZX r32, r/m16",
        "Op/En": "RM",
        "Opcode": "0F B7 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move word to quadword, zero-extension.",
        "Instruction": "MOVZX r64, r/m16",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F B7 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value. The size of the converted value depends on the operand-size attribute.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bit operands. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := ZeroExtend(SRC);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_2: If the memory address is in a non-canonical form.; column_1: #GP(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xsavec",
    "category": "Core Instructions",
    "instructionName": "XSAVEC\n\t\t— Save Processor Extended States With Compaction",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "XSAVEC",
        "Description": "Save state components specified by EDX:EAX to mem with compaction.",
        "Op/En": "M",
        "Opcode / Instruction": "NP 0F C7 /4 XSAVEC mem"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "XSAVEC",
        "Description": "Save state components specified by EDX:EAX to mem with compaction.",
        "Op/En": "M",
        "Opcode / Instruction": "NP REX.W + 0F C7 /4 XSAVEC64 mem"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\nThe format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nSection 13.10, “Operation of XSAVEC,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVEC instruction. The following items provide a highlevel outline:\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.",
    "operationText": "RFBM := XCR0 AND EDX:EAX;\n                    /* bitwise logical AND */\nTO_BE_SAVED := RFBM AND XINUSE;\n                    /* bitwise logical AND */\nIf MXCSR ≠ 1F80H AND RFBM[1]\n    TO_BE_SAVED[1] = 1;\nFI;\nIF TO_BE_SAVED[0] = 1\n    THEN store x87 state into legacy region of XSAVE area;\nFI;\nIF TO_BE_SAVED[1] = 1\n    THEN store SSE state into legacy region of XSAVE area; // this step saves the XMM registers, MXCSR, and MXCSR_MASK\nFI;\nNEXT_FEATURE_OFFSET = 576;\n                    // Legacy area and XSAVE header consume 576 bytes\nFOR i := 2 TO 62\n    IF RFBM[i] = 1\n        THEN\n            IF TO_BE_SAVED[i]\n                THEN save XSAVE state component i at offset NEXT_FEATURE_OFFSET from base of XSAVE area;\n            FI;\n            NEXT_FEATURE_OFFSET = NEXT_FEATURE_OFFSET + n (n enumerated by CPUID(EAX=0DH,ECX=i):EAX);\n    FI;\nENDFOR;\nXSTATE_BV field in XSAVE header := TO_BE_SAVED;\nXCOMP_BV field in XSAVE header := RFBM OR 80000000_00000000H;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit 1] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #AC; column_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 64-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If CR0.TS[bit 3] = 1.; column_1: #NM; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit 1] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 64-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).; column_1: #AC;"
      ],
      "realAddressMode": [
        "column_1: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSAVEC[bit 1] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sidt",
    "category": "Core Instructions",
    "instructionName": "SIDT\n\t\t— Store Interrupt Descriptor Table Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store IDTR to m.",
        "Instruction": "",
        "Op/En": "",
        "column_1": "0F 01 /1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stores the content the interrupt descriptor table register (IDTR) in the destination operand. The destination operand specifies a 6-byte memory location.\nIn non-64-bit modes, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.\nIn 64-bit mode, the operand size fixed at 8+2 bytes. The instruction stores 8-byte base and 2-byte limit values.\nSIDT is only useful in operating-system software; however, it can be used in application programs without causing an exception to be generated if CR4.UMIP = 0. See “LGDT/LIDT—Load Global/Interrupt Descriptor Table Register” in Chapter 3, Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A, for information on loading the GDTR and IDTR.",
    "operationText": "IF instruction is SIDT\n    THEN\n        IF OperandSize =16 or OperandSize = 32 (* Legacy or Compatibility Mode *)\n            THEN\n                DEST[0:15] := IDTR(Limit);\n                DEST[16:47] := IDTR(Base); FI; (* Full 32-bit base address stored *)\n            ELSE (* 64-bit Mode *)\n                DEST[0:15] := IDTR(Limit);\n                DEST[16:79] := IDTR(Base); (* Full 64-bit base address stored *)\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL = 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL = 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If CR4.UMIP = 1.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/mulps",
    "category": "Core Instructions",
    "instructionName": "MULPS\n\t\t— Multiply Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Multiply packed single precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 59 /r MULPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply packed single precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 59 /r VMULPS xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply packed single precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 59 /r VMULPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 59 /r VMULPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 59 /r VMULPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values in zmm3/m512/m32bcst with zmm2 and store result in zmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 59 /r VMULPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst {er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Multiply the packed single precision floating-point values from the first source operand with the corresponding values in the second source operand, and stores the packed double precision floating-point results in the destination operand.\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the destination YMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF (VL = 512) AND (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+31:i] := SRC1[i+31:i] * SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] := SRC1[i+31:i] * SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC1[31:0] * SRC2[31:0]\nDEST[63:32] := SRC1[63:32] * SRC2[63:32]\nDEST[95:64] := SRC1[95:64] * SRC2[95:64]\nDEST[127:96] := SRC1[127:96] * SRC2[127:96]\nDEST[159:128] := SRC1[159:128] * SRC2[159:128]\nDEST[191:160] := SRC1[191:160] * SRC2[191:160]\nDEST[223:192] := SRC1[223:192] * SRC2[223:192]\nDEST[255:224] := SRC1[255:224] * SRC2[255:224].\nDEST[MAXVL-1:256] := 0;\nDEST[31:0] := SRC1[31:0] * SRC2[31:0]\nDEST[63:32] := SRC1[63:32] * SRC2[63:32]\nDEST[95:64] := SRC1[95:64] * SRC2[95:64]\nDEST[127:96] := SRC1[127:96] * SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] * SRC2[31:0]\nDEST[63:32] := SRC1[63:32] * SRC2[63:32]\nDEST[95:64] := SRC1[95:64] * SRC2[95:64]\nDEST[127:96] := SRC1[127:96] * SRC2[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xorps",
    "category": "Core Instructions",
    "instructionName": "XORPS\n\t\t— Bitwise Logical XOR of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 57 /r XORPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 57 /r VXORPS xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 57 /r VXORPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 57 /r VXORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 57 /r VXORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 57 /r VXORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/clac",
    "category": "Core Instructions",
    "instructionName": "CLAC\n\t\t— Clear AC Flag in EFLAGS Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SMAP",
        "Description": "Clear the AC flag in the EFLAGS register.",
        "Op / En": "ZO",
        "Opcode/Instruction": "NP 0F 01 CA CLAC"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. Ifthe SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute CLAC when CPL > 0 cause #UD.",
    "operationText": "EFLAGS.AC := 0;",
    "flagsAffectedText": "AC cleared. Other flags are unaffected.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the CPL > 0.; \ncolumn_1: If CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20] = 0.;"
      ],
      "compatibilityMode": [
        "column_1: If the CPL > 0.; \ncolumn_1: If CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20] = 0.;"
      ],
      "protectedMode": [
        "column_1: If the CPL > 0.; \ncolumn_1: If CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20] = 0.;"
      ],
      "realAddressMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20] = 0.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fxam",
    "category": "Core Instructions",
    "instructionName": "FXAM\n\t\t— Examine Floating-Point",
    "detailsTable": [
      {
        "Description": "Classify value or number in ST(0).",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 E5",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word to indicate the class of value or number in the register (see the table below).\nThe C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "C1 := sign bit of ST; (* 0 for positive, 1 for negative *)\nCASE (class of value or number in ST(0)) OF\n    Unsupported:C3, C2, C0 := 000;\n    NaN:\n        C3, C2, C0 := 001;\n    Normal:\n        C3, C2, C0 := 010;\n    Infinity:\n        C3, C2, C0 := 011;\n    Zero:\n        C3, C2, C0 := 100;\n    Empty:\n        C3, C2, C0 := 101;\n    Denormal:\n        C3, C2, C0 := 110;\nESAC;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/div",
    "category": "Core Instructions",
    "instructionName": "DIV\n\t\t— Unsigned Divide",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Unsigned divide AX by r/m8, with result stored in AL := Quotient, AH := Remainder.",
        "Instruction": "DIV r/m8",
        "Op/En": "M",
        "Opcode": "F6 /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Unsigned divide AX by r/m8, with result stored in AL := Quotient, AH := Remainder.",
        "Instruction": "DIV r/m81",
        "Op/En": "M",
        "Opcode": "REX + F6 /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Unsigned divide DX:AX by r/m16, with result stored in AX := Quotient, DX := Remainder.",
        "Instruction": "DIV r/m16",
        "Op/En": "M",
        "Opcode": "F7 /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Unsigned divide EDX:EAX by r/m32, with result stored in EAX := Quotient, EDX := Remainder.",
        "Instruction": "DIV r/m32",
        "Op/En": "M",
        "Opcode": "F7 /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Unsigned divide RDX:RAX by r/m64, with result stored in RAX := Quotient, RDX := Remainder.",
        "Instruction": "DIV r/m64",
        "Op/En": "M",
        "Opcode": "REX.W + F7 /6"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.\nNon-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the unsigned value in RDX:RAX by the source operand and stores the quotient in RAX, the remainder in RDX.\nSee the summary chart at the beginning of this section for encoding data and limits. See Table 3-15.",
    "operationText": "IF SRC = 0\n    THEN #DE; FI; (* Divide Error *)\nIF OperandSize = 8 (* Word/Byte Operation *)\n    THEN\n        temp := AX / SRC;\n        IF temp > FFH\n            THEN #DE; (* Divide error *)\n            ELSE\n                AL := temp;\n                AH := AX MOD SRC;\n        FI;\n    ELSE IF OperandSize = 16 (* Doubleword/word operation *)\n        THEN\n            temp := DX:AX / SRC;\n            IF temp > FFFFH\n                THEN #DE; (* Divide error *)\n            ELSE\n                AX := temp;\n                DX := DX:AX MOD SRC;\n            FI;\n        FI;\n    ELSE IF Operandsize = 32 (* Quadword/doubleword operation *)\n        THEN\n            temp := EDX:EAX / SRC;\n            IF temp > FFFFFFFFH\n                THEN #DE; (* Divide error *)\n            ELSE\n                EAX := temp;\n                EDX := EDX:EAX MOD SRC;\n            FI;\n        FI;\n    ELSE IF 64-Bit Mode and Operandsize = 64 (* Doublequadword/quadword operation *)\n        THEN\n            temp := RDX:RAX / SRC;\n            IF temp > FFFFFFFFFFFFFFFFH\n                THEN #DE; (* Divide error *)\n            ELSE\n                RAX := temp;\n                RDX := RDX:RAX MOD SRC;\n            FI;\n        FI;\nFI;",
    "flagsAffectedText": "The CF, OF, SF, ZF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #DE; column_2: If the source operand (divisor) is 0; \ncolumn_1: If the quotient is too large for the designated register.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the quotient is too large for the designated register.; \ncolumn_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If the quotient is too large for the designated register.; \ncolumn_1: #GP; column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If the quotient is too large for the designated register.; \ncolumn_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pand",
    "category": "Core Instructions",
    "instructionName": "PAND\n\t\t— Logical AND",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Bitwise AND mm/m64 and mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F DB /r1 PAND mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Bitwise AND of xmm2/m128 and xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F DB /r PAND xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Bitwise AND of xmm3/m128 and xmm.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG DB /r VPAND xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG DB /r VPAND ymm1, ymm2, ymm3/.m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 DB /r VPANDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 DB /r VPANDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 DB /r VPANDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 DB /r VPANDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 DB /r VPANDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 DB /r VPANDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1 at 32/64-bit granularity.\nVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
    "operationText": "DEST := DEST AND SRC\nDEST := DEST AND SRC\nDEST[MAXVL-1:128] (Unmodified)\nDEST := SRC1 AND SRC2\nDEST[MAXVL-1:128] := 0\nDEST[255:0] := (SRC1[255:0] AND SRC2[255:0])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+31:i] := SRC1[i+31:i] BITWISE AND SRC2[31:0]\n                ELSE DEST[i+31:i] := SRC1[i+31:i] BITWISE AND SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+63:i] := SRC1[i+63:i] BITWISE AND SRC2[63:0]\n                ELSE DEST[i+63:i] := SRC1[i+63:i] BITWISE AND SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vaddsh",
    "category": "Core Instructions",
    "instructionName": "VADDSH\n\t\t— Add Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Add the low FP16 value from xmm3/m16 to xmm2, and store the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 58 /r VADDSH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movntq",
    "category": "Core Instructions",
    "instructionName": "MOVNTQ\n\t\t— Store of Quadword Using Non-Temporal Hint",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move quadword from mm to m64 using non-temporal hint.",
        "Instruction": "MOVNTQ m64, mm",
        "Op/En": "MR",
        "Opcode": "NP 0F E7 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Moves the quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an MMX technology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The destination operand is a 64-bit memory location.\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTQ instructions if multiple processors might use different memory types to read/write the destination memory locations.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "DEST := SRC;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 23-8, “Exception Conditions for Legacy SIMD/MMX Instructions without FP Exception,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/unpckhps",
    "category": "Core Instructions",
    "instructionName": "UNPCKHPS\n\t\t— Unpack and Interleave High Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Unpacks and Interleaves single precision floating-point values from high quadwords of xmm1 and xmm2/m128.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 15 /r UNPCKHPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Unpacks and Interleaves single precision floating-point values from high quadwords of xmm2 and xmm3/m128.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 15 /r VUNPCKHPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Unpacks and Interleaves single precision floating-point values from high quadwords of ymm2 and ymm3/m256.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 15 /r VUNPCKHPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Unpacks and Interleaves single precision floating-point values from high quadwords of xmm2 and xmm3/m128/m32bcst and write result to xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 15 /r VUNPCKHPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Unpacks and Interleaves single precision floating-point values from high quadwords of ymm2 and ymm3/m256/m32bcst and write result to ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 15 /r VUNPCKHPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Unpacks and Interleaves single precision floating-point values from high quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 15 /r VUNPCKHPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs an interleaved unpack of the high single precision floating-point values from the first source operand and the second source operand.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.256 encoded version: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers.\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\nEVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\nEVEX.128 encoded version: The first source operand is a XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF VL >= 128\n    TMP_DEST[31:0] := SRC1[95:64]\n    TMP_DEST[63:32] := SRC2[95:64]\n    TMP_DEST[95:64] := SRC1[127:96]\n    TMP_DEST[127:96] := SRC2[127:96]\nFI;\nIF VL >= 256\n    TMP_DEST[159:128] := SRC1[223:192]\n    TMP_DEST[191:160] := SRC2[223:192]\n    TMP_DEST[223:192] := SRC1[255:224]\n    TMP_DEST[255:224] := SRC2[255:224]\nFI;\nIF VL >= 512\n    TMP_DEST[287:256] := SRC1[351:320]\n    TMP_DEST[319:288] := SRC2[351:320]\n    TMP_DEST[351:320] := SRC1[383:352]\n    TMP_DEST[383:352] := SRC2[383:352]\n    TMP_DEST[415:384] := SRC1[479:448]\n    TMP_DEST[447:416] := SRC2[479:448]\n    TMP_DEST[479:448] := SRC1[511:480]\n    TMP_DEST[511:480] := SRC2[511:480]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF (EVEX.b = 1)\n        THEN TMP_SRC2[i+31:i] := SRC2[31:0]\n        ELSE TMP_SRC2[i+31:i] := SRC2[i+31:i]\n    FI;\nENDFOR;\nIF VL >= 128\n    TMP_DEST[31:0] := SRC1[95:64]\n    TMP_DEST[63:32] := TMP_SRC2[95:64]\n    TMP_DEST[95:64] := SRC1[127:96]\n    TMP_DEST[127:96] := TMP_SRC2[127:96]\nFI;\nIF VL >= 256\n    TMP_DEST[159:128] := SRC1[223:192]\n    TMP_DEST[191:160] := TMP_SRC2[223:192]\n    TMP_DEST[223:192] := SRC1[255:224]\n    TMP_DEST[255:224] := TMP_SRC2[255:224]\nFI;\nIF VL >= 512\n    TMP_DEST[287:256] := SRC1[351:320]\n    TMP_DEST[319:288] := TMP_SRC2[351:320]\n    TMP_DEST[351:320] := SRC1[383:352]\n    TMP_DEST[383:352] := TMP_SRC2[383:352]\n    TMP_DEST[415:384] := SRC1[479:448]\n    TMP_DEST[447:416] := TMP_SRC2[479:448]\n    TMP_DEST[479:448] := SRC1[511:480]\n    TMP_DEST[511:480] := TMP_SRC2[511:480]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking* ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC1[95:64]\nDEST[63:32] := SRC2[95:64]\nDEST[95:64] := SRC1[127:96]\nDEST[127:96] := SRC2[127:96]\nDEST[159:128] := SRC1[223:192]\nDEST[191:160] := SRC2[223:192]\nDEST[223:192] := SRC1[255:224]\nDEST[255:224] := SRC2[255:224]\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := SRC1[95:64]\nDEST[63:32] := SRC2[95:64]\nDEST[95:64] := SRC1[127:96]\nDEST[127:96] := SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[95:64]\nDEST[63:32] := SRC2[95:64]\nDEST[95:64] := SRC1[127:96]\nDEST[127:96] := SRC2[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instructions, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetexpsh",
    "category": "Core Instructions",
    "instructionName": "VGETEXPSH\n\t\t— Convert Exponents of Scalar FP16 Values to FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert the exponent of FP16 values in the low word of the source operand to FP16 results representing unbiased integer exponents, and stores the results in the low word of the destination register subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 43 /r VGETEXPSH xmm1{k1}{z}, xmm2, xmm3/m16 {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/blendvps",
    "category": "Core Instructions",
    "instructionName": "BLENDVPS\n\t\t— Variable Blend Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.",
        "Op/En": "RM0",
        "Opcode/Instruction": "66 0F 38 14 /r BLENDVPS xmm1, xmm2/m128, <XMM0>"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally copy single precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4.",
        "Op/En": "RVMR",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 4A /r /is4 VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally copy single precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4.",
        "Op/En": "RVMR",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 4A /r /is4 VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM0",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "implicit XMM0",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8[7:4]"
      }
    ],
    "descriptionText": "Conditionally copy each dword data element of single precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register.\nEach quadword element of the destination operand is copied from:\nThe register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register XMM0.\n128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute BLENDVPS with a VEX prefix will cause #UD.\nVEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.W must be 0, otherwise, the instruction will #UD.\nVEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. VEX.W must be 0, otherwise, the instruction will #UD.\nVBLENDVPS permits the mask to be any XMM or YMM register. In contrast, BLENDVPS treats XMM0 implicitly as the mask and do not support non-destructive destination operation.",
    "operationText": "MASK := XMM0\nIF (MASK[31] = 0) THEN DEST[31:0] := DEST[31:0]\n    ELSE DEST [31:0] := SRC[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] := DEST[63:32]\n    ELSE DEST [63:32] := SRC[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] := DEST[95:64]\n    ELSE DEST [95:64] := SRC[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] := DEST[127:96]\n    ELSE DEST [127:96] := SRC[127:96] FI\nDEST[MAXVL-1:128] (Unmodified)\nMASK := SRC3\nIF (MASK[31] = 0) THEN DEST[31:0] := SRC1[31:0]\n    ELSE DEST [31:0] := SRC2[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] := SRC1[63:32]\n    ELSE DEST [63:32] := SRC2[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] := SRC1[95:64]\n    ELSE DEST [95:64] := SRC2[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] := SRC1[127:96]\n    ELSE DEST [127:96] := SRC2[127:96] FI\nDEST[MAXVL-1:128] := 0\nMASK := SRC3\nIF (MASK[31] = 0) THEN DEST[31:0] := SRC1[31:0]\n    ELSE DEST [31:0] := SRC2[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] := SRC1[63:32]\n    ELSE DEST [63:32] := SRC2[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] := SRC1[95:64]\n    ELSE DEST [95:64] := SRC2[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] := SRC1[127:96]\n    ELSE DEST [127:96] := SRC2[127:96] FI\nIF (MASK[159] = 0) THEN DEST[159:128] := SRC1[159:128]\n    ELSE DEST [159:128] := SRC2[159:128] FI\nIF (MASK[191] = 0) THEN DEST[191:160] := SRC1[191:160]\n    ELSE DEST [191:160] := SRC2[191:160] FI\nIF (MASK[223] = 0) THEN DEST[223:192] := SRC1[223:192]\n    ELSE DEST [223:192] := SRC2[223:192] FI\nIF (MASK[255] = 0) THEN DEST[255:224] := SRC1[255:224]\n    ELSE DEST [255:224] := SRC2[255:224] FI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sahf",
    "category": "Core Instructions",
    "instructionName": "SAHF\n\t\t— Store AH Into Flags",
    "detailsTable": [
      {
        "64-Bit Mode": "Invalid*",
        "Compat/Leg Mode": "Valid",
        "Description": "Loads SF, ZF, AF, PF, and CF from AH into the EFLAGS register.",
        "Instruction": "SAHF",
        "Op/En": "ZO",
        "column_1": "9E"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits (1, 3, and 5) in the EFLAGS register remain as shown in the “Operation” section below.\nThis instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.",
    "operationText": "IF IA-64 Mode\n    THEN\n        IF CPUID.80000001H.ECX[0] = 1;\n            THEN\n                RFLAGS(SF:ZF:0:AF:0:PF:1:CF) := AH;\n            ELSE\n                #UD;\n        FI\n    ELSE\n        EFLAGS(SF:ZF:0:AF:0:PF:1:CF) := AH;\nFI;",
    "flagsAffectedText": "The SF, ZF, AF, PF, and CF flags are loaded with values from the AH register. Bits 1, 3, and 5 of the EFLAGS register are unaffected, with the values remaining 1, 0, and 0, respectively.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "None."
      ],
      "protectedMode": [
        "None."
      ],
      "realAddressMode": [
        "None."
      ],
      "virtual8086Mode": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdmsr",
    "category": "Core Instructions",
    "instructionName": "RDMSR\n\t\t— Read From Model Specific Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Read MSR specified by ECX into EDX:EAX.",
        "Instruction": "",
        "Op/En": "",
        "column_1": "0F 32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Reads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception.\nThe MSRs control functions for testability, execution tracing, performance-monitoring, and machine check errors. Chapter 2, “Model-Specific Registers (MSRs)” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4, lists all the MSRs that can be read with this instruction and their addresses. Note that each processor family has its own set of MSRs.\nThe CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction.",
    "operationText": "EDX:EAX := MSR[ECX];",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the value in ECX specifies a reserved or unimplemented MSR address.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/enclv",
    "category": "SGX Instructions",
    "instructionName": "ENCLV\n\t\t— Execute an Enclave VMM Function of Specified Leaf Number",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "NA",
        "Description": "This instruction is used to execute privileged SGX leaf functions that are reserved for VMM use. They are used for managing the enclaves.",
        "Op/En": "ZO",
        "Opcode/Instruction": "NP 0F 01 C0 ENCLV"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "ZO",
        "column_2": "NA",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "See Section 38.3"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttsd2usi",
    "category": "Core Instructions",
    "instructionName": "VCVTTSD2USI\n\t\t— Convert With Truncation Scalar Double Precision Floating-Point Value toUnsigned Integer",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one unsigned doubleword integer r32 using truncation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W0 78 /r VCVTTSD2USI r32, xmm1/m64{sae}"
      },
      {
        "64/32 Bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one unsigned quadword integer zero-extended into r64 using truncation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 78 /r VCVTTSD2USI r64, xmm1/m64{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Fixed"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/smsw",
    "category": "Core Instructions",
    "instructionName": "SMSW\n\t\t— Store Machine Status Word",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store machine status word to r/m16.",
        "Instruction": "SMSW r/m16",
        "Op/En": "M",
        "Opcode*": "0F 01 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined.",
        "Instruction": "SMSW r32/m16",
        "Op/En": "M",
        "Opcode*": "0F 01 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined.",
        "Instruction": "SMSW r64/m16",
        "Op/En": "M",
        "Opcode*": "REX.W + 0F 01 /4"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The destination operand can be a general-purpose register or a memory location.\nIn non-64-bit modes, when the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are copied into the low-order 16 bits of the register and the high-order 16 bits are undefined. When the destination operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity, regardless of the operand size.\nIn 64-bit mode, the behavior of the SMSW instruction is defined by the following examples:\nSMSW is only useful in operating-system software. However, it is not a privileged instruction and can be used in application programs if CR4.UMIP = 0. It is provided for compatibility with the Intel 286 processor. Programs and procedures intended to run on IA-32 and Intel 64 processors beginning with the Intel386 processors should use the MOV CR instruction to load the machine status word.\nSee “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 26 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
    "operationText": "DEST := CR0[15:0];\n(* Machine status word *)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL = 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL = 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If CR4.UMIP = 1.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/v4fmaddss:v4fnmaddss",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "V4FMADDSS/V4FNMADDSS\n\t\t— Scalar Single Precision Floating-Point Fused Multiply-Add(4-Iterations)",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_4FMAPS",
        "Description": "Multiply scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F38.W0 9B /r V4FMADDSS xmm1{k1}{z}, xmm2+3, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_4FMAPS",
        "Description": "Multiply and negate scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F38.W0 AB /r V4FNMADDSS xmm1{k1}{z}, xmm2+3, m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Operand 1 Operand 2 Operand 3 Operand 4": "A Tuple1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtph2uqq",
    "category": "Core Instructions",
    "instructionName": "VCVTPH2UQQ\n\t\t— Convert Packed FP16 Values to Unsigned Quadword Integers",
    "detailsTable": [
      {
        "Description": "Convert two packed FP16 values in xmm2/m32/m16bcst to two unsigned quadword integers, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.W0 79 /r VCVTPH2UQQ xmm1{k1}{z}, xmm2/m32/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four unsigned quadword integers, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP5.W0 79 /r VCVTPH2UQQ ymm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned quadword integers, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP5.W0 79 /r VCVTPH2UQQ zmm1{k1}{z}, xmm2/m128/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Quarter"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/popa:popad",
    "category": "Core Instructions",
    "instructionName": "POPA/POPAD\n\t\t— Pop All General-Purpose Registers",
    "detailsTable": [
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop DI, SI, BP, BX, DX, CX, and AX.",
        "Instruction": "POPA",
        "Op/En": "ZO",
        "Opcode": "61"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.",
        "Instruction": "POPAD",
        "Op/En": "ZO",
        "Opcode": "61"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI, SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded.\nThe POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used (using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms (POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be popped from the stack, regardless of the mnemonic used. (The D flag in the current code segment’s segment descriptor determines the operand-size attribute.)\nThis instruction executes as described in non-64-bit modes. It is not valid in 64-bit mode.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        #UD;\nELSE\n    IF OperandSize = 32 (* Instruction = POPAD *)\n    THEN\n        EDI := Pop();\n        ESI := Pop();\n        EBP := Pop();\n        Increment ESP by 4; (* Skip next 4 bytes of stack *)\n        EBX := Pop();\n        EDX := Pop();\n        ECX := Pop();\n        EAX := Pop();\n    ELSE (* OperandSize = 16, instruction = POPA *)\n        DI := Pop();\n        SI := Pop();\n        BP := Pop();\n        Increment ESP by 2; (* Skip next 2 bytes of stack *)\n        BX := Pop();\n        DX := Pop();\n        CX := Pop();\n        AX := Pop();\n    FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        "Same as for protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fxtract",
    "category": "Core Instructions",
    "instructionName": "FXTRACT\n\t\t— Extract Exponent and Significand",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack.",
        "Opcode/Instruction": "D9 F4 FXTRACT"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0), and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0) contains the value of the original significand expressed as a floating-point value. The sign and significand of this value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true exponent of zero). The ST(1) register contains the value of the original operand’s true (unbiased) exponent expressed as a floating-point value. (The operation performed by this instruction is a superset of the IEEE-recommended logb(x) function.)\nThis instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to decimal representations (e.g., for printing or displaying).\nIf the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of –∞ is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "TEMP := Significand(ST(0));\nST(0) := Exponent(ST(0));\nTOP := TOP − 1;\nST(0) := TEMP;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_2: Source operand is an SNaN value or unsupported format.; column_1: #IA; \ncolumn_1: #Z; column_2: ST(0) operand is ±0.; \ncolumn_1: #D; column_2: Source operand is a denormal value.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sqrtss",
    "category": "Core Instructions",
    "instructionName": "SQRTSS\n\t\t— Compute Square Root of Scalar Single Precision Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Computes square root of the low single precision floating-point value in xmm2/m32 and stores the results in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 51 /r SQRTSS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 51 /r VSQRTSS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1 under writemask k1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 51 /r VSQRTSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Computes the square root of the low single precision floating-point value in the second source operand and stores the single precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands is an XMM register.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 and EVEX encoded versions: Bits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed.\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the write-mask.\nSoftware should ensure VSQRTSS is encoded with VEX.L=0. Encoding VSQRTSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (EVEX.b = 1) AND (SRC2 *is register*)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := SQRT(SRC2[31:0])\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SQRT(SRC2[31:0])\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SQRT(SRC2[31:0])\nDEST[MAXVL-1:32] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ud",
    "category": "Core Instructions",
    "instructionName": "UD\n\t\t— Undefined Instruction",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Raise invalid opcode exception.",
        "Instruction": "UD01 r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F FF /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Raise invalid opcode exception.",
        "Instruction": "UD1 r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F B9 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Raise invalid opcode exception.",
        "Instruction": "UD2",
        "Op/En": "ZO",
        "Opcode": "0F 0B"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Generates an invalid opcode exception. This instruction is provided for software testing to explicitly generate an invalid opcode exception. The opcodes for this instruction are reserved for this purpose.\nOther than raising the invalid opcode exception, this instruction has no effect on processor state or memory.\nEven though it is the execution of the UD instruction that causes the invalid opcode exception, the instruction pointer saved by delivery of the exception references the UD instruction (and not the following instruction).\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "#UD (* Generates invalid opcode exception *);",
    "flagsAffectedText": "None.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmadd52huq",
    "category": "Core Instructions",
    "instructionName": "VPMADD52HUQ\n\t\t— Packed Multiply of Unsigned 52-Bit Unsigned Integers and Add High 52-BitProducts to 64-Bit Accumulators",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID": "AVX512_IFMA AVX512VL",
        "Description": "Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the high 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 B5 /r VPMADD52HUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID": "AVX512_IFMA AVX512VL",
        "Description": "Multiply unsigned 52-bit integers in ymm2 and ymm3/m256 and add the high 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 B5 /r VPMADD52HUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID": "AVX512_IFMA",
        "Description": "Multiply unsigned 52-bit integers in zmm2 and zmm3/m512 and add the high 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 B5 /r VPMADD52HUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m(r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrt28ss",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VRSQRT28SS\n\t\t— Approximation to the Reciprocal Square Root of Scalar Single Precision Floating-Point Value With Less Than 2^-28 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes approximate reciprocal square root (<2^-28 relative error) of the scalar single-precision floating-point value from xmm3/m32 and stores result in xmm1with writemask k1. Also, upper 3 single-precision floating-point value (bits[127:32]) from xmm2 is copied to xmm1[127:32].",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 CD /r VRSQRT28SS xmm1 {k1}{z}, xmm2, xmm3/m32 {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A Tuple1 Scalar ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/eextend",
    "category": "SGX Instructions",
    "instructionName": "EEXTEND\n\t\t— Extend Uninitialized Enclave Measurement by 256 Bytes",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function measures 256 bytes of an uninitialized enclave page.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 06H ENCLS[EEXTEND]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EEXTEND (In)",
        "column_3": "Effective address of the SECS of the data chunk (In)",
        "column_4": "Effective address of a 256-byte chunk in the EPC (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrt14ss",
    "category": "Core Instructions",
    "instructionName": "VRSQRT14SS\n\t\t— Compute Approximate Reciprocal of Square Root of Scalar Float32 Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes the approximate reciprocal square root of the scalar single-precision floating-point value in xmm3/m32 and stores the result in the low doubleword element of xmm1 using writemask k1. Bits[127:32] of xmm2 is copied to xmm1[127:32].",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 4F /r VRSQRT14SS xmm1 {k1}{z}, xmm2, xmm3/m32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsub132ps:vfmsub213ps:vfmsub231ps",
    "category": "Core Instructions",
    "instructionName": "VFMSUB132PS/VFMSUB213PS/VFMSUB231PS\n\t\t— Fused Multiply-Subtract of Packed SinglePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 9A /r VFMSUB132PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 AA /r VFMSUB213PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 BA /r VFMSUB231PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 9A /r VFMSUB132PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 AA /r VFMSUB213PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.0 BA /r VFMSUB231PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 9A /r VFMSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m32bcst and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 AA /r VFMSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 BA /r VFMSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract ymm2 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 9A /r VFMSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m32bcst and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 AA /r VFMSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract ymm1 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 BA /r VFMSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract zmm2 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 9A /r VFMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m32bcst and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 AA /r VFMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract zmm1 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 BA /r VFMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xbegin",
    "category": "Core Instructions",
    "instructionName": "XBEGIN\n\t\t— Transactional Begin",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "RTM",
        "Description": "Specifies the start of an RTM region. Provides a 16-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.",
        "Op/En": "A",
        "Opcode/Instruction": "C7 F8 XBEGIN rel16"
      },
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "RTM",
        "Description": "Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.",
        "Op/En": "A",
        "Opcode/Instruction": "C7 F8 XBEGIN rel32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "Offset",
        "Operand2": "N/A",
        "Operand3": "N/A",
        "Operand4": "N/A"
      }
    ],
    "descriptionText": "The XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in transactional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execution. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback code path following a transactional abort. (Use of the 16-bit operand size does not cause this address to be truncated to 16 bits, unlike a near jump to a relative offset.)\nOn an RTM abort, the logical processor discards all architectural register and memory updates performed during the RTM execution and restores architectural state to that corresponding to the outermost XBEGIN instruction. The fallback address following an abort is computed from the outermost XBEGIN instruction.\nExecution of XBEGIN while in a suspend read address tracking region causes a transactional abort.",
    "operationText": "IF RTM_NEST_COUNT < MAX_RTM_NEST_COUNT AND SUSLDTRK_ACTIVE = 0\n    THEN\n        RTM_NEST_COUNT++\n        IF RTM_NEST_COUNT = 1 THEN\n            IF 64-bit Mode\n                THEN\n                    IF OperandSize = 16\n                        THEN fallbackRIP := RIP + SignExtend64(rel16);\n                        ELSE fallbackRIP := RIP + SignExtend64(rel32);\n                    FI;\n                    IF fallbackRIP is not canonical\n                        THEN #GP(0);\n                    FI;\n                ELSE\n                    IF OperandSize = 16\n                        THEN fallbackEIP := EIP + SignExtend32(rel16);\n                        ELSE fallbackEIP := EIP + rel32;\n                    FI;\n                    IF fallbackEIP outside code segment limit\n                        THEN #GP(0);\n                    FI;\n            FI;\n            RTM_ACTIVE := 1\n            Enter RTM Execution (* record register state, start tracking memory state*)\n        FI; (* RTM_NEST_COUNT = 1 *)\n    ELSE (* RTM_NEST_COUNT = MAX_RTM_NEST_COUNT OR SUSLDTRK_ACTIVE = 1 *)\n        GOTO RTM_ABORT_PROCESSING\nFI;\n(* For any RTM abort condition encountered during RTM execution *)\nRTM_ABORT_PROCESSING:\n    Restore architectural register state\n    Discard memory updates performed in transaction\n    Update EAX with status\n    RTM_NEST_COUNT := 0\n    RTM_ACTIVE := 0\n    SUSLDTRK_ACTIVE := 0\n    IF 64-bit mode\n        THEN\n            RIP := fallbackRIP\n        ELSE\n            EIP := fallbackEIP\n    FI;\nEND",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64-bitMode¶": [
        "column_1: If LOCK prefix is used.; \ncolumn_2: If the fallback address is non-canonical.; column_1: #GP(0);"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If the fallback address is outside the CS segment.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: CPUID.(EAX=7, ECX=0):EBX.RTM[bit 11]=0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ],
      "virtual8086Mode": [
        "column_1: #UD; column_2: CPUID.(EAX=7, ECX=0):EBX.RTM[bit 11]=0.; \ncolumn_1: If LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aam",
    "category": "Core Instructions",
    "instructionName": "AAM\n\t\t— ASCII Adjust AX After Multiply",
    "detailsTable": [
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "ASCII adjust AX after multiply.",
        "Instruction": "AAM",
        "Op/En": "ZO",
        "Opcode": "D4 0A"
      },
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Adjust AX after multiply to number base imm8.",
        "Instruction": "AAM imm8",
        "Op/En": "ZO",
        "Opcode": "D4 ib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain the correct 2-digit unpacked (base 10) BCD result.\nThe generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked digits of any number base (see the “Operation” section below). Here, the imm8 byte is set to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the instruction must be hand coded in machine code (D4 imm8).\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        #UD;\n    ELSE\n        tempAL := AL;\n        AH := tempAL / imm8; (* imm8 is set to 0AH for the AAM mnemonic *)\n        AL := tempAL MOD imm8;\nFI;\nThe immediate value (imm8) is taken from the second byte of the instruction.",
    "flagsAffectedText": "The SF, ZF, and PF flags are set according to the resulting binary value in the AL register. The OF, AF, and CF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        "Same exceptions as protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmovsx",
    "category": "Core Instructions",
    "instructionName": "PMOVSX\n\t\t— Packed Move With Sign Extend",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 20 /r PMOVSXBW xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 21 /r PMOVSXBD xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 22 /r PMOVSXBQ xmm1, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 23/r PMOVSXWD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 24 /r PMOVSXWQ xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0f 38 25 /r PMOVSXDQ xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 20 /r VPMOVSXBW xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 21 /r VPMOVSXBD xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 22 /r VPMOVSXBQ xmm1, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 23 /r VPMOVSXWD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 24 /r VPMOVSXWQ xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 25 /r VPMOVSXDQ xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 20 /r VPMOVSXBW ymm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 21 /r VPMOVSXBD ymm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 22 /r VPMOVSXBQ ymm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 23 /r VPMOVSXWD ymm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 24 /r VPMOVSXWQ ymm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 25 /r VPMOVSXDQ ymm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sign extend 8 packed 8-bit integers in xmm2/m64 to 8 packed 16-bit integers in zmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 20 /r VPMOVSXBW xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 20 /r VPMOVSXBW ymm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Sign extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 20 /r VPMOVSXBW zmm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 21 /r VPMOVSXBD xmm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 21 /r VPMOVSXBD ymm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Sign extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 21 /r VPMOVSXBD zmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 22 /r VPMOVSXBQ xmm1 {k1}{z}, xmm2/m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 22 /r VPMOVSXBQ ymm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 22 /r VPMOVSXBQ zmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of ymm2/mem to 4 packed 32-bit integers in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 23 /r VPMOVSXWD xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 8 packed 16-bit integers in the low 16 bytes of ymm2/m128 to 8 packed 32-bit integers in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 23 /r VPMOVSXWD ymm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Sign extend 16 packed 16-bit integers in the low 32 bytes of ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 23 /r VPMOVSXWD zmm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 24 /r VPMOVSXWQ xmm1 {k1}{z}, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 24 /r VPMOVSXWQ ymm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 24 /r VPMOVSXWQ zmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 25 /r VPMOVSXDQ xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 25 /r VPMOVSXDQ ymm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Sign extend 8 packed 32-bit integers in the low 32 bytes of ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 25 /r VPMOVSXDQ zmm1 {k1}{z}, ymm2/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half Mem"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Quarter Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Eighth Mem"
      }
    ],
    "descriptionText": "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\nEVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "DEST[15:0] := SignExtend(SRC[7:0]);\nDEST[31:16] := SignExtend(SRC[15:8]);\nDEST[47:32] := SignExtend(SRC[23:16]);\nDEST[63:48] := SignExtend(SRC[31:24]);\nDEST[79:64] := SignExtend(SRC[39:32]);\nDEST[95:80] := SignExtend(SRC[47:40]);\nDEST[111:96] := SignExtend(SRC[55:48]);\nDEST[127:112] := SignExtend(SRC[63:56]);\nDEST[31:0] := SignExtend(SRC[7:0]);\nDEST[63:32] := SignExtend(SRC[15:8]);\nDEST[95:64] := SignExtend(SRC[23:16]);\nDEST[127:96] := SignExtend(SRC[31:24]);\nDEST[63:0] := SignExtend(SRC[7:0]);\nDEST[127:64] := SignExtend(SRC[15:8]);\nDEST[31:0] := SignExtend(SRC[15:0]);\nDEST[63:32] := SignExtend(SRC[31:16]);\nDEST[95:64] := SignExtend(SRC[47:32]);\nDEST[127:96] := SignExtend(SRC[63:48]);\nDEST[63:0] := SignExtend(SRC[15:0]);\nDEST[127:64] := SignExtend(SRC[31:16]);\nDEST[63:0] := SignExtend(SRC[31:0]);\nDEST[127:64] := SignExtend(SRC[63:32]);\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nPacked_Sign_Extend_BYTE_to_WORD(TMP_DEST[127:0], SRC[63:0])\nIF VL >= 256\n    Packed_Sign_Extend_BYTE_to_WORD(TMP_DEST[255:128], SRC[127:64])\nFI;\nIF VL >= 512\n    Packed_Sign_Extend_BYTE_to_WORD(TMP_DEST[383:256], SRC[191:128])\n    Packed_Sign_Extend_BYTE_to_WORD(TMP_DEST[511:384], SRC[255:192])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TEMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nPacked_Sign_Extend_BYTE_to_DWORD(TMP_DEST[127:0], SRC[31:0])\nIF VL >= 256\n    Packed_Sign_Extend_BYTE_to_DWORD(TMP_DEST[255:128], SRC[63:32])\nFI;\nIF VL >= 512\n    Packed_Sign_Extend_BYTE_to_DWORD(TMP_DEST[383:256], SRC[95:64])\n    Packed_Sign_Extend_BYTE_to_DWORD(TMP_DEST[511:384], SRC[127:96])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TEMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nPacked_Sign_Extend_BYTE_to_QWORD(TMP_DEST[127:0], SRC[15:0])\nIF VL >= 256\n    Packed_Sign_Extend_BYTE_to_QWORD(TMP_DEST[255:128], SRC[31:16])\nFI;\nIF VL >= 512\n    Packed_Sign_Extend_BYTE_to_QWORD(TMP_DEST[383:256], SRC[47:32])\n    Packed_Sign_Extend_BYTE_to_QWORD(TMP_DEST[511:384], SRC[63:48])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TEMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nPacked_Sign_Extend_WORD_to_DWORD(TMP_DEST[127:0], SRC[63:0])\nIF VL >= 256\n    Packed_Sign_Extend_WORD_to_DWORD(TMP_DEST[255:128], SRC[127:64])\nFI;\nIF VL >= 512\n    Packed_Sign_Extend_WORD_to_DWORD(TMP_DEST[383:256], SRC[191:128])\n    Packed_Sign_Extend_WORD_to_DWORD(TMP_DEST[511:384], SRC[256:192])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TEMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nPacked_Sign_Extend_WORD_to_QWORD(TMP_DEST[127:0], SRC[31:0])\nIF VL >= 256\n    Packed_Sign_Extend_WORD_to_QWORD(TMP_DEST[255:128], SRC[63:32])\nFI;\nIF VL >= 512\n    Packed_Sign_Extend_WORD_to_QWORD(TMP_DEST[383:256], SRC[95:64])\n    Packed_Sign_Extend_WORD_to_QWORD(TMP_DEST[511:384], SRC[127:96])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TEMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nPacked_Sign_Extend_DWORD_to_QWORD(TEMP_DEST[127:0], SRC[63:0])\nIF VL >= 256\n    Packed_Sign_Extend_DWORD_to_QWORD(TEMP_DEST[255:128], SRC[127:64])\nFI;\nIF VL >= 512\n    Packed_Sign_Extend_DWORD_to_QWORD(TEMP_DEST[383:256], SRC[191:128])\n    Packed_Sign_Extend_DWORD_to_QWORD(TEMP_DEST[511:384], SRC[255:192])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TEMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nPacked_Sign_Extend_BYTE_to_WORD(DEST[127:0], SRC[63:0])\nPacked_Sign_Extend_BYTE_to_WORD(DEST[255:128], SRC[127:64])\nDEST[MAXVL-1:256] := 0\nPacked_Sign_Extend_BYTE_to_DWORD(DEST[127:0], SRC[31:0])\nPacked_Sign_Extend_BYTE_to_DWORD(DEST[255:128], SRC[63:32])\nDEST[MAXVL-1:256] := 0\nPacked_Sign_Extend_BYTE_to_QWORD(DEST[127:0], SRC[15:0])\nPacked_Sign_Extend_BYTE_to_QWORD(DEST[255:128], SRC[31:16])\nDEST[MAXVL-1:256] := 0\nPacked_Sign_Extend_WORD_to_DWORD(DEST[127:0], SRC[63:0])\nPacked_Sign_Extend_WORD_to_DWORD(DEST[255:128], SRC[127:64])\nDEST[MAXVL-1:256] := 0\nPacked_Sign_Extend_WORD_to_QWORD(DEST[127:0], SRC[31:0])\nPacked_Sign_Extend_WORD_to_QWORD(DEST[255:128], SRC[63:32])\nDEST[MAXVL-1:256] := 0\nPacked_Sign_Extend_DWORD_to_QWORD(DEST[127:0], SRC[63:0])\nPacked_Sign_Extend_DWORD_to_QWORD(DEST[255:128], SRC[127:64])\nDEST[MAXVL-1:256] := 0\nPacked_Sign_Extend_BYTE_to_WORDDEST[127:0], SRC[127:0]()\nDEST[MAXVL-1:128] := 0\nPacked_Sign_Extend_BYTE_to_DWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] := 0\nPacked_Sign_Extend_BYTE_to_QWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] := 0\nPacked_Sign_Extend_WORD_to_DWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] := 0\nPacked_Sign_Extend_WORD_to_QWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] := 0\nPacked_Sign_Extend_DWORD_to_QWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] := 0\nPacked_Sign_Extend_BYTE_to_WORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Sign_Extend_BYTE_to_DWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Sign_Extend_BYTE_to_QWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Sign_Extend_WORD_to_DWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Sign_Extend_WORD_to_QWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nPacked_Sign_Extend_DWORD_to_QWORD(DEST[127:0], SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-51, “Type E5 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/andn",
    "category": "Core Instructions",
    "instructionName": "ANDN\n\t\t— Logical AND NOT",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI1",
        "Description": "Bitwise AND of inverted r32b with r/m32, store result in r32a.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.LZ.0F38.W0 F2 /r ANDN r32a, r32b, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI1",
        "Description": "Bitwise AND of inverted r64b with r/m64, store result in r64a.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.LZ. 0F38.W1 F2 /r ANDN r64a, r64b, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the\nsecond source operand). The result is stored in the first operand (destination operand).\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "DEST := (NOT SRC1) bitwiseAND SRC2;\nSF := DEST[OperandSize -1];\nZF := (DEST = 0);",
    "flagsAffectedText": "SF and ZF are updated based on result. OF and CF flags are cleared. AF and PF flags are undefined.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpblendmb:vpblendmw",
    "category": "Core Instructions",
    "instructionName": "VPBLENDMB/VPBLENDMW\n\t\t— Blend Byte/Word Vectors Using an Opmask Control",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Blend byte integer vector xmm2 and byte vector xmm3/m128 and store the result in xmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 66 /r VPBLENDMB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Blend byte integer vector ymm2 and byte vector ymm3/m256 and store the result in ymm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 66 /r VPBLENDMB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Blend byte integer vector zmm2 and byte vector zmm3/m512 and store the result in zmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 66 /r VPBLENDMB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Blend word integer vector xmm2 and word vector xmm3/m128 and store the result in xmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 66 /r VPBLENDMW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Blend word integer vector ymm2 and word vector ymm3/m256 and store the result in ymm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 66 /r VPBLENDMW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Blend word integer vector zmm2 and word vector zmm3/m512 and store the result in zmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 66 /r VPBLENDMW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/v4fmaddps:v4fnmaddps",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "V4FMADDPS/V4FNMADDPS\n\t\t— Packed Single Precision Floating-Point Fused Multiply-Add(4-Iterations)",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_4FMAPS",
        "Description": "Multiply packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F2.0F38.W0 9A /r V4FMADDPS zmm1{k1}{z}, zmm2+3, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_4FMAPS",
        "Description": "Multiply and negate packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F2.0F38.W0 AA /r V4FNMADDPS zmm1{k1}{z}, zmm2+3, m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Operand 1 Operand 2 Operand 3 Operand 4": "A Tuple1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/bndmov",
    "category": "Core Instructions",
    "instructionName": "BNDMOV\n\t\t— Move Bounds",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "N.E./V",
        "CPUID Feature Flag": "MPX",
        "Description": "Move lower and upper bound from bnd2/m64 to bound register bnd1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 1A /r BNDMOV bnd1, bnd2/m64"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MPX",
        "Description": "Move lower and upper bound from bnd2/m128 to bound register bnd1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 1A /r BNDMOV bnd1, bnd2/m128"
      },
      {
        "64/32 bit Mode Support": "N.E./V",
        "CPUID Feature Flag": "MPX",
        "Description": "Move lower and upper bound from bnd2 to bnd1/m64.",
        "Op/En": "MR",
        "Opcode/Instruction": "66 0F 1B /r BNDMOV bnd1/m64, bnd2"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MPX",
        "Description": "Move lower and upper bound from bnd2 to bound register bnd1/m128.",
        "Op/En": "MR",
        "Opcode/Instruction": "66 0F 1B /r BNDMOV bnd1/m128, bnd2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "BNDMOV moves a pair of lower and upper bound values from the source operand (the second operand) to the destination (the first operand). Each operation is 128-bit move. The exceptions are same as the MOV instruction. The memory format for loading/store bounds in 64-bit mode is shown in Figure 3-5.\nThis instruction does not change flags.",
    "operationText": "DEST.LB := SRC.LB;\nDEST.UB := SRC.UB;\nIF 64-bit mode THEN\n        DEST.LB := LOAD_QWORD(SRC);\n        DEST.UB := LOAD_QWORD(SRC+8);\n    ELSE\n        DEST.LB := LOAD_DWORD_ZERO_EXT(SRC);\n        DEST.UB := LOAD_DWORD_ZERO_EXT(SRC+4);\nFI;\nIF 64-bit mode THEN\n        DEST[63:0] := SRC.LB;\n        DEST[127:64] := SRC.UB;\n    ELSE\n        DEST[31:0] := SRC.LB;\n        DEST[63:32] := SRC.UB;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If ModRM.r/m and REX encodes BND4-BND15 when Intel MPX is enabled.; \ncolumn_1: #SS(0); column_2: If the memory address referencing the SS segment is in a non-canonical form.; \ncolumn_2: If the memory address is in a non-canonical form.; column_1: #GP(0); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL is 3.; \ncolumn_1: #PF(fault; column_2: code) If a page fault occurs.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 67H prefix is not used and CS.D=0.; \ncolumn_1: If 67H prefix is used and CS.D=1.; \ncolumn_1: #SS(0); column_2: If the memory operand effective address is outside the SS segment limit.; \ncolumn_1: #GP(0); column_2: If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the destination operand points to a non-writable segment; \ncolumn_1: If the DS, ES, FS, or GS segment register contains a NULL segment selector.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL is 3.; \ncolumn_1: #PF(fault; column_2: code) If a page fault occurs.;"
      ],
      "realAddressMode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.; \ncolumn_2: If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; column_1: #GP(0); \ncolumn_1: #SS; column_2: If the memory operand effective address is outside the SS segment limit.;"
      ],
      "virtual8086Mode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.; \ncolumn_1: #GP(0); column_2: If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS(0); column_2: If the memory operand effective address is outside the SS segment limit.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL is 3.; \ncolumn_1: #PF(fault; column_2: code) If a page fault occurs.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fyl2xp1",
    "category": "Core Instructions",
    "instructionName": "FYL2XP1\n\t\t— Compute y ∗ log2(x +1)",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Replace ST(1) with ST(1) ∗ log2(ST(0) + 1.0) and pop the register stack.",
        "Instruction": "FYL2XP1",
        "Opcode": "D9 F9"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes (ST(1) ∗ log2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be in the range:\nThe source operand in ST(1) can range from −∞ to +∞. If the ST(0) operand is outside of its acceptable range, the result is undefined and software should not rely on an exception being generated. Under some circumstances exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not guaranteed.\nThe following table shows the results obtained when taking the log epsilon of various classes of numbers, assuming that underflow does not occur.\nThis instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. For small epsilon (ε) values, more significant digits can be retained by using the FYL2XP1 instruction than by using (ε+1) as an argument to the FYL2X instruction. The (ε+1) expression is commonly found in compound interest and annuity calculations. The result can be simply converted into a value in another logarithm base by including a scale factor in the ST(1) source operand. The following equation is used to calculate the scale factor for a particular logarithm base, where n is the logarithm base desired for the result of the FYL2XP1 instruction:\nscale factor := logn 2\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "ST(1) := ST(1) ∗ log2(ST(0) + 1.0);\nPopRegisterStack;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Either operand is an SNaN value or unsupported format.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sysexit",
    "category": "Core Instructions",
    "instructionName": "SYSEXIT\n\t\t— Fast Return from Fast System Call",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Fast return to privilege level 3 user code.",
        "Instruction": "SYSEXIT",
        "Op/En": "ZO",
        "Opcode": "0F 35"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Fast return to 64-bit mode privilege level 3 user code.",
        "Instruction": "SYSEXIT",
        "Op/En": "ZO",
        "Opcode": "REX.W + 0F 35"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Executes a fast return to privilege level 3 user code. SYSEXIT is a companion instruction to the SYSENTER instruction. The instruction is optimized to provide the maximum performance for returns from system procedures executing at protections levels 0 to user procedures executing at protection level 3. It must be executed from code executing at privilege level 0.\nWith a 64-bit operand size, SYSEXIT remains in 64-bit mode; otherwise, it either enters compatibility mode (if the logical processor is in IA-32e mode) or remains in protected mode (if it is not).\nPrior to executing SYSEXIT, software must specify the privilege level 3 code segment and code entry point, and the privilege level 3 stack segment and stack pointer by writing values into the following MSR and general-purpose registers:\nThe IA32_SYSENTER_CS MSR can be read from and written to using RDMSR and WRMSR.\nWhile SYSEXIT loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSEXIT instruction does not ensure this correspondence.\nThe SYSEXIT instruction can be invoked from all operating modes except real-address mode and virtual-8086 mode.\nThe SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor. The availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually present. For example:\nIF CPUID SEP bit is set\nTHEN IF (Family = 6) and (Model < 3) and (Stepping < 3)\nTHEN\nSYSENTER/SYSEXIT_Not_Supported; FI;\nELSE\nSYSENTER/SYSEXIT_Supported; FI;\nFI;\nWhen the CPUID instruction is executed on the Pentium Pro processor (model 1), the processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT instructions.\nWhen shadow stacks are enabled at privilege level 3 the instruction loads SSP with value from IA32_PL3_SSP MSR. Refer to Chapter 6, “Interrupt and Exception Handling‚” and Chapter 17, “Control-flow Enforcement Technology (CET)‚” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for additional CET details.\nInstruction ordering. Instructions following a SYSEXIT may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSEXIT have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).",
    "operationText": "IF IA32_SYSENTER_CS[15:2] = 0 OR CR0.PE = 0 OR CPL ≠ 0 THEN #GP(0); FI;\nIF operand size is 64-bit\n    THEN (* Return to 64-bit mode *)\n        RSP := RCX;\n        RIP := RDX;\n    ELSE (* Return to protected mode or compatibility mode *)\n        RSP := ECX;\n        RIP := EDX;\nFI;\nIF operand size is 64-bit (* Operating system provides CS; RPL forced to 3 *)\n    THEN CS.Selector := IA32_SYSENTER_CS[15:0] + 32;\n    ELSE CS.Selector := IA32_SYSENTER_CS[15:0] + 16;\nFI;\nCS.Selector := CS.Selector OR 3;\n            (* RPL forced to 3 *)\n(* Set rest of CS to a fixed value *)\nCS.Base := 0;\n            (* Flat segment *)\nCS.Limit := FFFFFH;\n            (* With 4-KByte granularity, implies a 4-GByte limit *)\nCS.Type := 11;\n            (* Execute/read code, accessed *)\nCS.S := 1;\nCS.DPL := 3;\nCS.P := 1;\nIF operand size is 64-bit\n    THEN (* return to 64-bit mode *)\n        CS.L := 1;\n            (* 64-bit code segment *)\n        CS.D := 0;\n    ELSE (* return to protected mode or compatibility mode *)\n        CS.L := 0;\n        CS.D := 1;\n            (* 32-bit code segment*)\nFI;\nCS.G := 1;\n            (* 4-KByte granularity *)\nCPL := 3;\nIF ShadowStackEnabled(CPL)\n    THEN SSP := IA32_PL3_SSP;\nFI;\nSS.Selector := CS.Selector + 8;\n            (* SS just above CS *)\n(* Set rest of SS to a fixed value *)\nSS.Base := 0;\n            (* Flat segment *)\nSS.Limit := FFFFFH;\n            (* With 4-KByte granularity, implies a 4-GByte limit *)\nSS.Type := 3;\n            (* Read/write data, accessed *)\nSS.S := 1;\nSS.DPL := 3;\nSS.P := 1;\nSS.B := 1;\n            (* 32-bit stack segment*)\nSS.G := 1; (* 4-KByte granularity *)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CPL ≠ 0.; \ncolumn_1: If RCX or RDX contains a non-canonical address.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CPL ≠ 0.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/subss",
    "category": "Core Instructions",
    "instructionName": "SUBSS\n\t\t— Subtract Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Subtract the low single precision floating-point value in xmm2/m32 from xmm1 and store the result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 5C /r SUBSS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract the low single precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 5C /r VSUBSS xmm1,xmm2, xmm3/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Subtract the low single precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 5C /r VSUBSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Subtract the low single precision floating-point value from the second source operand and the first source operand and store the double precision floating-point result in the low doubleword of the destination operand.\nThe second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded versions: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the write-mask.\nSoftware should ensure VSUBSS is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (SRC2 *is register*) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := SRC1[31:0] - SRC2[31:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] - SRC2[31:0]\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := DEST[31:0] - SRC[31:0]\nDEST[MAXVL-1:32] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtqq2pd",
    "category": "Core Instructions",
    "instructionName": "VCVTQQ2PD\n\t\t— Convert Packed Quadword Integers to Packed Double Precision Floating-PointValues",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed quadword integers from xmm2/m128/m64bcst to packed double precision floating-point values in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F.W1 E6 /r VCVTQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed quadword integers from ymm2/m256/m64bcst to packed double precision floating-point values in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F.W1 E6 /r VCVTQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed quadword integers from zmm2/m512/m64bcst to eight packed double precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F.W1 E6 /r VCVTQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/tilestored",
    "category": "Core Instructions",
    "instructionName": "TILESTORED\n\t\t— Store Tile",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-TILE",
        "Description": "Store a tile in sibmem as specified in tmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F38.W0 4B !(11):rrr:100 TILESTORED sibmem, tmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "This instruction is required to use SIB addressing. The index register serves as a stride indicator. If the SIB encoding omits an index register, the value zero is assumed for the content of the index register.\nThis instruction stores a tile source of rows and columns as specified by the tile configuration.\nThe TILECFG.start_row in the TILECFG data should be initialized to '0' in order to store the entire tile and are set to zero on successful completion of the TILESTORED instruction. TILESTORED is a restartable instruction and the TILECFG.start_row will be non-zero when restartable events occur during the instruction execution.\nOnly memory operands are supported and they can only be accessed using a SIB addressing mode, similar to the V[P]GATHER*/V[P]SCATTER* instructions.\nAny attempt to execute the TILESTORED instruction inside an Intel TSX transaction will result in a transaction abort.",
    "operationText": "TILESTORED tsib, tsrc\nstart := tilecfg.start_row\nmembegin := tsib.base + displacement\n// if no index register in the SIB encoding, the value zero is used.\nstride := tsib.index << tsib.scale\nwhile start < tdest.rows:\n    memptr := membegin + start * stride\n    write_memory(memptr, tsrc.colsb, tsrc.row[start])\n    start := start + 1\nzero_tilecfg_start()\n// In the case of a memory fault in the middle of an instruction, the tilecfg.start_row := start",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "AMX-E3; see Section 2.10, “Intel® AMX Instruction Exception Classes,” for details."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdpmc",
    "category": "Core Instructions",
    "instructionName": "RDPMC\n\t\t— Read Performance-Monitoring Counters",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Read performance-monitoring counter specified by ECX into EDX:EAX.",
        "Instruction": "RDPMC",
        "Op/En": "ZO",
        "Opcode*": "0F 33"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Reads the contents of the performance monitoring counter (PMC) specified in ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the PMC and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the PMC being read, unimplemented bits returned to EDX:EAX will have value zero.\nThe width of PMCs on processors supporting architectural performance monitoring (CPUID.0AH:EAX[7:0] ≠ 0) are reported by CPUID.0AH:EAX[23:16]. On processors that do not support architectural performance monitoring (CPUID.0AH:EAX[7:0]=0), the width of general-purpose performance PMCs is 40 bits, while the widths of special-purpose PMCs are implementation specific.\nUse of ECX to specify a PMC depends on whether the processor supports architectural performance monitoring:\nSpecifying an unsupported PMC encoding will cause a general protection exception #GP(0). For PMC details see Chapter 20, “Performance Monitoring,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B.\nWhen in protected or virtual 8086 mode, the Performance-monitoring Counters Enabled (PCE) flag in register CR4 restricts the use of the RDPMC instruction. When the PCE flag is set, the RDPMC instruction can be executed at any privilege level; when the flag is clear, the instruction can only be executed at privilege level 0. (When in real-address mode, the RDPMC instruction is always enabled.) The PMCs can also be read with the RDMSR instruction, when executing at privilege level 0.\nThe RDPMC instruction is not a serializing instruction; that is, it does not imply that all the events caused by the preceding instructions have been completed or that events caused by subsequent instructions have not begun. If an exact event count is desired, software must insert a serializing instruction (such as the CPUID instruction) before and/or after the RDPMC instruction.\nPerforming back-to-back fast reads are not guaranteed to be monotonic. To guarantee monotonicity on back-to-back reads, a serializing instruction must be placed between the two RDPMC instructions.\nThe RDPMC instruction can execute in 16-bit addressing mode or virtual-8086 mode; however, the full contents of the ECX register are used to select the PMC, and the event count is stored in the full EAX and EDX registers. The\nRDPMC instruction was introduced into the IA-32 Architecture in the Pentium Pro processor and the Pentium processor with MMX technology. The earlier Pentium processors have PMCs, but they must be read with the RDMSR instruction.",
    "operationText": "MSCB = Most Significant Counter Bit (* Model-specific *)\nIF (((CR4.PCE = 1) or (CPL = 0) or (CR0.PE = 0)) and (ECX indicates a supported counter))\n    THEN\n        EAX := counter[31:0];\n        EDX := ZeroExtend(counter[MSCB:32]);\n    ELSE (* ECX is not valid or CR4.PCE is 0 and CPL is 1, 2, or 3 and CR0.PE is 1 *)\n        #GP(0);\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If an invalid performance counter index is specified.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If an invalid performance counter index is specified.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If an invalid performance counter index is specified.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/eblock",
    "category": "SGX Instructions",
    "instructionName": "EBLOCK\n\t\t— Mark a page in EPC as Blocked",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function marks a page in the EPC as blocked.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 09H ENCLS[EBLOCK]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EBLOCK (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Effective address of the EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vdivph",
    "category": "Core Instructions",
    "instructionName": "VDIVPH\n\t\t— Divide Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Divide packed FP16 values in xmm2 by packed FP16 values in xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 5E /r VDIVPH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Divide packed FP16 values in ymm2 by packed FP16 values in ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 5E /r VDIVPH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Divide packed FP16 values in zmm2 by packed FP16 values in zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 5E /r VDIVPH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/psubsb:psubsw",
    "category": "Core Instructions",
    "instructionName": "PSUBSB/PSUBSW\n\t\t— Subtract Packed Signed Integers With Signed Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F E8 /r1 PSUBSB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F E8 /r PSUBSB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F E9 /r1 PSUBSW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F E9 /r PSUBSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E8 /r VPSUBSB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E9 /r VPSUBSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E8 /r VPSUBSB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E9 /r VPSUBSW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results and store in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG E8 /r VPSUBSB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results and store in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG E8 /r VPSUBSB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Subtract packed signed byte integers in zmm3/m512 from packed signed byte integers in zmm2 and saturate results and store in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG E8 /r VPSUBSB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results and store in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG E9 /r VPSUBSW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results and store in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG E9 /r VPSUBSW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Subtract packed signed word integers in zmm3/m512 from packed signed word integers in zmm2 and saturate results and store in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG E9 /r VPSUBSW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.\nThe (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\nThe (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
    "operationText": "DEST[7:0] := SaturateToSignedByte (DEST[7:0] − SRC (7:0]);\n(* Repeat subtract operation for 2nd through 7th bytes *)\nDEST[63:56] := SaturateToSignedByte (DEST[63:56] − SRC[63:56] );\nDEST[15:0] := SaturateToSignedWord (DEST[15:0] − SRC[15:0] );\n(* Repeat subtract operation for 2nd and 7th words *)\nDEST[63:48] := SaturateToSignedWord (DEST[63:48] − SRC[63:48] );\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8;\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := SaturateToSignedByte (SRC1[i+7:i] - SRC2[i+7:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] := 0;\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SaturateToSignedWord (SRC1[i+15:i] - SRC2[i+15:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0;\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0;\nDEST[7:0] := SaturateToSignedByte (SRC1[7:0] - SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 31th bytes *)\nDEST[255:248] := SaturateToSignedByte (SRC1[255:248] - SRC2[255:248]);\nDEST[MAXVL-1:256] := 0;\nDEST[7:0] := SaturateToSignedByte (SRC1[7:0] - SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 14th bytes *)\nDEST[127:120] := SaturateToSignedByte (SRC1[127:120] - SRC2[127:120]);\nDEST[MAXVL-1:128] := 0;\nDEST[7:0] := SaturateToSignedByte (DEST[7:0] - SRC[7:0]);\n(* Repeat subtract operation for 2nd through 14th bytes *)\nDEST[127:120] := SaturateToSignedByte (DEST[127:120] - SRC[127:120]);\nDEST[MAXVL-1:128] (Unmodified);\nDEST[15:0] := SaturateToSignedWord (SRC1[15:0] - SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 15th words *)\nDEST[255:240] := SaturateToSignedWord (SRC1[255:240] - SRC2[255:240]);\nDEST[MAXVL-1:256] := 0;\nDEST[15:0] := SaturateToSignedWord (SRC1[15:0] - SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 7th words *)\nDEST[127:112] := SaturateToSignedWord (SRC1[127:112] - SRC2[127:112]);\nDEST[MAXVL-1:128] := 0;\nDEST[15:0] := SaturateToSignedWord (DEST[15:0] - SRC[15:0]);\n(* Repeat subtract operation for 2nd through 7th words *)\nDEST[127:112] := SaturateToSignedWord (DEST[127:112] - SRC[127:112]);\nDEST[MAXVL-1:128] (Unmodified);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq",
    "category": "Core Instructions",
    "instructionName": "PADDB/PADDW/PADDD/PADDQ\n\t\t— Add Packed Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Add packed byte integers from mm/m64 and mm.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F FC /r1 PADDB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Add packed word integers from mm/m64 and mm.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F FD /r1 PADDW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Add packed doubleword integers from mm/m64 and mm.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F FE /r1 PADDD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Add packed quadword integers from mm/m64 and mm.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F D4 /r1 PADDQ mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed byte integers from xmm2/m128 and xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F FC /r PADDB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed word integers from xmm2/m128 and xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F FD /r PADDW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed doubleword integers from xmm2/m128 and xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F FE /r PADDD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed quadword integers from xmm2/m128 and xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F D4 /r PADDQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed byte integers from xmm2, and xmm3/m128 and store in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG FC /r VPADDB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed word integers from xmm2, xmm3/m128 and store in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG FD /r VPADDW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed doubleword integers from xmm2, xmm3/m128 and store in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG FE /r VPADDD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed quadword integers from xmm2, xmm3/m128 and store in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D4 /r VPADDQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG FC /r VPADDB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add packed word integers from ymm2, ymm3/m256 and store in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG FD /r VPADDW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG FE /r VPADDD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D4 /r VPADDQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed byte integers from xmm2, and xmm3/m128 and store in xmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG FC /r VPADDB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed word integers from xmm2, and xmm3/m128 and store in xmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG FD /r VPADDW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Add packed doubleword integers from xmm2, and xmm3/m128/m32bcst and store in xmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 FE /r VPADDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Add packed quadword integers from xmm2, and xmm3/m128/m64bcst and store in xmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 D4 /r VPADDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG FC /r VPADDB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed word integers from ymm2, and ymm3/m256 and store in ymm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG FD /r VPADDW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Add packed doubleword integers from ymm2, ymm3/m256/m32bcst and store in ymm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 FE /r VPADDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Add packed quadword integers from ymm2, ymm3/m256/m64bcst and store in ymm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 D4 /r VPADDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Add packed byte integers from zmm2, and zmm3/m512 and store in zmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG FC /r VPADDB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Add packed word integers from zmm2, and zmm3/m512 and store in zmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG FD /r VPADDW zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Add packed doubleword integers from zmm2, zmm3/m512/m32bcst and store in zmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 FE /r VPADDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Add packed quadword integers from zmm2, zmm3/m512/m64bcst and store in zmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 D4 /r VPADDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.\nThe PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).\nThe PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to\nbe represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).\nThe PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).\nThe PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).\nNote that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.\nEVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the write-mask.\nEVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "DEST[7:0] := DEST[7:0] + SRC[7:0];\n(* Repeat add operation for 2nd through 7th byte *)\nDEST[63:56] := DEST[63:56] + SRC[63:56];\nDEST[15:0] := DEST[15:0] + SRC[15:0];\n(* Repeat add operation for 2nd and 3th word *)\nDEST[63:48] := DEST[63:48] + SRC[63:48];\nDEST[31:0] := DEST[31:0] + SRC[31:0];\nDEST[63:32] := DEST[63:32] + SRC[63:32];\nDEST[63:0] := DEST[63:0] + SRC[63:0];\nDEST[7:0] := DEST[7:0] + SRC[7:0];\n(* Repeat add operation for 2nd through 15th byte *)\nDEST[127:120] := DEST[127:120] + SRC[127:120];\nDEST[MAXVL-1:128] (Unmodified)\nDEST[15:0] := DEST[15:0] + SRC[15:0];\n(* Repeat add operation for 2nd through 7th word *)\nDEST[127:112] := DEST[127:112] + SRC[127:112];\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := DEST[31:0] + SRC[31:0];\n(* Repeat add operation for 2nd and 3th doubleword *)\nDEST[127:96] := DEST[127:96] + SRC[127:96];\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := DEST[63:0] + SRC[63:0];\nDEST[127:64] := DEST[127:64] + SRC[127:64];\nDEST[MAXVL-1:128] (Unmodified)\nDEST[7:0] := SRC1[7:0] + SRC2[7:0];\n(* Repeat add operation for 2nd through 15th byte *)\nDEST[127:120] := SRC1[127:120] + SRC2[127:120];\nDEST[MAXVL-1:128] := 0;\nDEST[15:0] := SRC1[15:0] + SRC2[15:0];\n(* Repeat add operation for 2nd through 7th word *)\nDEST[127:112] := SRC1[127:112] + SRC2[127:112];\nDEST[MAXVL-1:128] := 0;\nDEST[31:0] := SRC1[31:0] + SRC2[31:0];\n(* Repeat add operation for 2nd and 3th doubleword *)\nDEST[127:96] := SRC1[127:96] + SRC2[127:96];\nDEST[MAXVL-1:128] := 0;\nDEST[63:0] := SRC1[63:0] + SRC2[63:0];\nDEST[127:64] := SRC1[127:64] + SRC2[127:64];\nDEST[MAXVL-1:128] := 0;\nDEST[7:0] := SRC1[7:0] + SRC2[7:0];\n(* Repeat add operation for 2nd through 31th byte *)\nDEST[255:248] := SRC1[255:248] + SRC2[255:248];\nDEST[15:0] := SRC1[15:0] + SRC2[15:0];\n(* Repeat add operation for 2nd through 15th word *)\nDEST[255:240] := SRC1[255:240] + SRC2[255:240];\nDEST[31:0] := SRC1[31:0] + SRC2[31:0];\n(* Repeat add operation for 2nd and 7th doubleword *)\nDEST[255:224] := SRC1[255:224] + SRC2[255:224];\nDEST[63:0] := SRC1[63:0] + SRC2[63:0];\nDEST[127:64] := SRC1[127:64] + SRC2[127:64];\nDEST[191:128] := SRC1[191:128] + SRC2[191:128];\nDEST[255:192] := SRC1[255:192] + SRC2[255:192];\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := SRC1[i+7:i] + SRC2[i+7:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SRC1[i+15:i] + SRC2[i+15:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+31:i] := SRC1[i+31:i] + SRC2[31:0]\n                ELSE DEST[i+31:i] := SRC1[i+31:i] + SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+63:i] := SRC1[i+63:i] + SRC2[63:0]\n                ELSE DEST[i+63:i] := SRC1[i+63:i] + SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPADDD/Q, see Table 2-49, “Type E4 Class Exception Conditions.”",
        "EVEX-encoded VPADDB/W, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sha256rnds2",
    "category": "Core Instructions",
    "instructionName": "SHA256RNDS2\n\t\t— Perform Two Rounds of SHA256 Operation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SHA",
        "Description": "Perform 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from xmm1, an initial SHA256 state (A,B,E,F) from xmm2/m128, and a pre-computed sum of the next 2 round message dwords and the corresponding round constants from the implicit operand XMM0, storing the updated SHA256 state (A,B,E,F) result in xmm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "NP 0F 38 CB /r SHA256RNDS2 xmm1, xmm2/m128, <XMM0>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "Implicit XMM0 (r)"
      }
    ],
    "descriptionText": "The SHA256RNDS2 instruction performs 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from the first operand, an initial SHA256 state (A,B,E,F) from the second operand, and a pre-computed sum of the next 2 round message dwords and the corresponding round constants from the implicit operand xmm0. Note that only the two lower dwords of XMM0 are used by the instruction.\nThe updated SHA256 state (A,B,E,F) is written to the first operand, and the second operand can be used as the updated state (C,D,G,H) in later rounds.",
    "operationText": "A_0 := SRC2[127:96];\nB_0 := SRC2[95:64];\nC_0 := SRC1[127:96];\nD_0 := SRC1[95:64];\nE_0 := SRC2[63:32];\nF_0 := SRC2[31:0];\nG_0 := SRC1[63:32];\nH_0 := SRC1[31:0];\nWK0 := XMM0[31: 0];\nWK1 := XMM0[63: 32];\nFOR i = 0 to 1\n    A_(i +1) :=\n        Ch (E_i, F_i, G_i) +Σ1( E_i) +WKi+ H_i + Maj(A_i , B_i, C_i) +Σ0( A_i);\n    B_(i +1) :=\n        A_i;\n    C_(i +1) :=\n        B_i ;\n    D_(i +1) :=\n        C_i;\n    E_(i +1) :=\n        Ch (E_i, F_i, G_i) +Σ1( E_i) +WKi+ H_i + D_i;\n    F_(i +1) :=\n        E_i ;\n    G_(i +1) :=\n        F_i;\n    H_(i +1) :=\n        G_i;\nENDFOR\nDEST[127:96] := A_2;\nDEST[95:64] := B_2;\nDEST[63:32] := E_2;\nDEST[31:0] := F_2;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttpd2qq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPD2QQ\n\t\t— Convert With Truncation Packed Double Precision Floating-Point Values toPacked Quadword Integers",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed double precision floating-point values from zmm2/m128/m64bcst to two packed quadword integers in zmm1 using truncation with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 7A /r VCVTTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed double precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 using truncation with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 7A /r VCVTTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed double precision floating-point values from zmm2/m512 to eight packed quadword integers in zmm1 using truncation with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 7A /r VCVTTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/inc",
    "category": "Core Instructions",
    "instructionName": "INC\n\t\t— Increment by 1",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Increment r/m byte by 1.",
        "Instruction": "INC r/m8",
        "Op/En": "M",
        "Opcode": "FE /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Increment r/m byte by 1.",
        "Instruction": "INC r/m81",
        "Op/En": "M",
        "Opcode": "REX + FE /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Increment r/m word by 1.",
        "Instruction": "INC r/m16",
        "Op/En": "M",
        "Opcode": "FF /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Increment r/m doubleword by 1.",
        "Instruction": "INC r/m32",
        "Op/En": "M",
        "Opcode": "FF /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Increment r/m quadword by 1.",
        "Instruction": "INC r/m64",
        "Op/En": "M",
        "Opcode": "REX.W + FF /0"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Increment word register by 1.",
        "Instruction": "INC r16",
        "Op/En": "O",
        "Opcode": "40+ rw2"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Increment doubleword register by 1.",
        "Instruction": "INC r32",
        "Op/En": "O",
        "Opcode": "40+ rd"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "O",
        "Operand 1": "opcode + rd (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.)\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.",
    "operationText": "DEST := DEST + 1;",
    "flagsAffectedText": "The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULLsegment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If the LOCK prefix is used but the destination is not a memory operand.; column_1: #UD;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmpss",
    "category": "Core Instructions",
    "instructionName": "CMPSS\n\t\t— Compare Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Compare low single precision floating-point value in xmm2/m32 and xmm1 using bits 2:0 of imm8 as comparison predicate.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F C2 /r ib CMPSS xmm1, xmm2/m32, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare low single precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG C2 /r ib VCMPSS xmm1, xmm2, xmm3/m32, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare low single precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 C2 /r ib VCMPSS k1 {k2}, xmm2, xmm3/m32{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the low single precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (immediate operand) specifies the type of comparison performed.\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 32-bit memory location. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 32-bit memory location. The result is stored in the low 32 bits of the destination operand; bits 127:32 of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\nEVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 32-bit memory location. The destination operand (first operand) is an opmask register. The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.\nThe comparison predicate operand is an 8-bit immediate:\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\nNote that processors with “CPUID.1H:ECX.AVX =0” do not implement the “greater-than”, “greater-than-or-equal”, “not-greater than”, and “not-greater-than-or-equal relations” predicates. These comparisons can be made either by using the inverse relationship (that is, use the “not-less-than-or-equal” to make a “greater-than” comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the first 8 rows of Table 3-7 (Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A) under the heading Emulation.\nCompilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPSS instruction, for processors with “CPUID.1H:ECX.AVX =0”. See Table 3-8. The compiler should treat reserved imm8 values as illegal syntax.\nThe greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)\nProcessors with “CPUID.1H:ECX.AVX =1” implement the full complement of 32 predicates shown in Table 3-7, software emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSS instruction. See Table 3-9, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. The compiler should treat reserved imm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface. Compilers and assemblers may implement three-operand pseudo-ops for EVEX encoded VCMPSS instructions in a similar fashion by extending the syntax listed in Table 3-9.\nSoftware should ensure VCMPSS is encoded with VEX.L=0. Encoding VCMPSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "CASE (COMPARISON PREDICATE) OF\n    0: OP3 := EQ_OQ; OP5 := EQ_OQ;\n    1: OP3 := LT_OS; OP5 := LT_OS;\n    2: OP3 := LE_OS; OP5 := LE_OS;\n    3: OP3 := UNORD_Q; OP5 := UNORD_Q;\n    4: OP3 := NEQ_UQ; OP5 := NEQ_UQ;\n    5: OP3 := NLT_US; OP5 := NLT_US;\n    6: OP3 := NLE_US; OP5 := NLE_US;\n    7: OP3 := ORD_Q; OP5 := ORD_Q;\n    8: OP5 := EQ_UQ;\n    9: OP5 := NGE_US;\n    10: OP5 := NGT_US;\n    11: OP5 := FALSE_OQ;\n    12: OP5 := NEQ_OQ;\n    13: OP5 := GE_OS;\n    14: OP5 := GT_OS;\n    15: OP5 := TRUE_UQ;\n    16: OP5 := EQ_OS;\n    17: OP5 := LT_OQ;\n    18: OP5 := LE_OQ;\n    19: OP5 := UNORD_S;\n    20: OP5 := NEQ_US;\n    21: OP5 := NLT_UQ;\n    22: OP5 := NLE_UQ;\n    23: OP5 := ORD_S;\n    24: OP5 := EQ_US;\n    25: OP5 := NGE_UQ;\n    26: OP5 := NGT_UQ;\n    27: OP5 := FALSE_OS;\n    28: OP5 := NEQ_OS;\n    29: OP5 := GE_OQ;\n    30: OP5 := GT_OQ;\n    31: OP5 := TRUE_US;\n    DEFAULT: Reserved\nESAC;\nCMP0 := SRC1[31:0] OP5 SRC2[31:0];\nIF k2[0] or *no writemask*\n    THEN IF CMP0 = TRUE\n        THEN DEST[0] := 1;\n        ELSE DEST[0] := 0; FI;\n    ELSE DEST[0] := 0\n            ; zeroing-masking only\nFI;\nDEST[MAX_KL-1:1] := 0\nCMP0 := DEST[31:0] OP3 SRC[31:0];\nIF CMP0 = TRUE\nTHEN DEST[31:0] := FFFFFFFFH;\nELSE DEST[31:0] := 00000000H; FI;\nDEST[MAXVL-1:32] (Unmodified)\nCMP0 := SRC1[31:0] OP5 SRC2[31:0];\nIF CMP0 = TRUE\nTHEN DEST[31:0] := FFFFFFFFH;\nELSE DEST[31:0] := 00000000H; FI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid if SNaN operand, Invalid if QNaN and predicate as listed in Table 3-1, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtuqq2ph",
    "category": "Core Instructions",
    "instructionName": "VCVTUQQ2PH\n\t\t— Convert Packed Unsigned Quadword Integers to Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert two packed unsigned doubleword integers from xmm2/m128/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F2.MAP5.W1 7A /r VCVTUQQ2PH xmm1{k1}{z}, xmm2/m128/m64bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert four packed unsigned doubleword integers from ymm2/m256/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F2.MAP5.W1 7A /r VCVTUQQ2PH xmm1{k1}{z}, ymm2/m256/m64bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed unsigned doubleword integers from zmm2/m512/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F2.MAP5.W1 7A /r VCVTUQQ2PH xmm1{k1}{z}, zmm2/m512/m64bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetmantpd",
    "category": "Core Instructions",
    "instructionName": "VGETMANTPD\n\t\t— Extract Float64 Vector of Normalized Mantissas From Float64 Vector",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Get Normalized Mantissa from float64 vector xmm2/m128/m64bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 26 /r ib VGETMANTPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Get Normalized Mantissa from float64 vector ymm2/m256/m64bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 26 /r ib VGETMANTPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Get Normalized Mantissa from float64 vector zmm2/m512/m64bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 26 /r ib VGETMANTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmadd132ss:vfmadd213ss:vfmadd231ss",
    "category": "Core Instructions",
    "instructionName": "VFMADD132SS/VFMADD213SS/VFMADD231SS\n\t\t— Fused Multiply-Add of Scalar Single PrecisionFloating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 99 /r VFMADD132SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 A9 /r VFMADD213SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 B9 /r VFMADD231SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 99 /r VFMADD132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 A9 /r VFMADD213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 B9 /r VFMADD231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/adcx",
    "category": "Core Instructions",
    "instructionName": "ADCX\n\t\t— Unsigned Integer Addition of Two Operands With Carry Flag",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "ADX",
        "Description": "Unsigned addition of r32 with CF, r/m32 to r32, writes CF.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 F6 /r ADCX r32, r/m32"
      },
      {
        "64/32bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "ADX",
        "Description": "Unsigned addition of r64 with CF, r/m64 to r64, writes CF.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 REX.w 0F 38 F6 /r ADCX r64, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.\nThe ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state. Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).\nThis instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.\nIn 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.\nADCX executes normally either inside or outside a transaction region.\nNote: ADCX defines the OF flag differently than the ADD/ADC instructions as defined in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.",
    "operationText": "IF OperandSize is 64-bit\n    THEN CF:DEST[63:0] := DEST[63:0] + SRC[63:0] + CF;\n    ELSE CF:DEST[31:0] := DEST[31:0] + SRC[31:0] + CF;\nFI;",
    "flagsAffectedText": "CF is updated based on result. OF, SF, ZF, AF, and PF flags are unmodified.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #GP(0); column_2: For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "realAddressMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #GP(0); column_2: If any part of the operand lies outside the effective address space from 0 to FFFFH.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ],
      "virtual8086Mode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #GP(0); column_2: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/clts",
    "category": "Core Instructions",
    "instructionName": "CLTS\n\t\t— Clear Task-Switched Flag in CR0",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Clears TS flag in CR0.",
        "Instruction": "CLTS",
        "Op/En": "ZO",
        "Opcode": "0F 06"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-address mode to allow initialization for protected mode.\nThe processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU context in multitasking applications. See the description of the TS flag in the section titled “Control Registers” in Chapter 2 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for more information about this flag.\nCLTS operation is the same in non-64-bit modes and 64-bit mode.\nSee Chapter 26, “VMX Non-Root Operation,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
    "operationText": "CR0.TS[bit 3] := 0;",
    "flagsAffectedText": "The TS flag in CR0 register is cleared.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        "column_2: If the LOCK prefix is used.; column_1: #UD;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fsave:fnsave",
    "category": "Core Instructions",
    "instructionName": "FSAVE/FNSAVE\n\t\t— Store x87 FPU State",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.",
        "Instruction": "FSAVE m94/108byte",
        "Opcode": "9B DD /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.",
        "Instruction": "FNSAVE1 m94/108byte",
        "Opcode": "DD /6"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Stores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state; the FNSAVE instruction does not.\nThe FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow the operating environment image.\nThe saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE instruction in the instruction stream have been executed.\nAfter the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT instructions (see “FINIT/FNINIT—Initialize Floating-Point Unit” in this chapter).\nThe FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch, an exception handler needs to use the FPU, or an application program needs to pass a “clean” FPU to a procedure.\nThe assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "(* Save FPU State and Registers *)\nDEST[FPUControlWord] := FPUControlWord;\nDEST[FPUStatusWord] := FPUStatusWord;\nDEST[FPUTagWord] := FPUTagWord;\nDEST[FPUDataPointer] := FPUDataPointer;\nDEST[FPUInstructionPointer] := FPUInstructionPointer;\nDEST[FPULastInstructionOpcode] := FPULastInstructionOpcode;\nDEST[ST(0)] := ST(0);\nDEST[ST(1)] := ST(1);\nDEST[ST(2)] := ST(2);\nDEST[ST(3)] := ST(3);\nDEST[ST(4)]:= ST(4);\nDEST[ST(5)] := ST(5);\nDEST[ST(6)] := ST(6);\nDEST[ST(7)] := ST(7);\n(* Initialize FPU *)\nFPUControlWord := 037FH;\nFPUStatusWord := 0;\nFPUTagWord := FFFFH;\nFPUDataPointer := 0;\nFPUInstructionPointer := 0;\nFPULastInstructionOpcode := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/edeccssa",
    "category": "SGX Instructions",
    "instructionName": "EDECCSSA\n\t\t— Decrements TCS.CSSA",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "EDECCSSA",
        "Description": "This leaf function decrements TCS.CSSA.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 09H ENCLU[EDECCSSA]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EDECCSSA (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/blendvpd",
    "category": "Core Instructions",
    "instructionName": "BLENDVPD\n\t\t— Variable Blend Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Select packed double precision floating-point values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.",
        "Op/En": "RM0",
        "Opcode/Instruction": "66 0F 38 15 /r BLENDVPD xmm1, xmm2/m128 , <XMM0>"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally copy double precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4.",
        "Op/En": "RVMR",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 4B /r /is4 VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally copy double precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4.",
        "Op/En": "RVMR",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 4B /r /is4 VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM0",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "implicit XMM0",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8[7:4]"
      }
    ],
    "descriptionText": "Conditionally copy each quadword data element of double precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register.\nEach quadword element of the destination operand is copied from:\nThe register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register XMM0.\n128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute BLENDVPD with a VEX prefix will cause #UD.\nVEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.W must be 0, otherwise, the instruction will #UD.\nVEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. VEX.W must be 0, otherwise, the instruction will #UD.\nVBLENDVPD permits the mask to be any XMM or YMM register. In contrast, BLENDVPD treats XMM0 implicitly as the mask and do not support non-destructive destination operation.",
    "operationText": "MASK := XMM0\nIF (MASK[63] = 0) THEN DEST[63:0] := DEST[63:0]\n    ELSE DEST [63:0] := SRC[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] := DEST[127:64]\n    ELSE DEST [127:64] := SRC[127:64] FI\nDEST[MAXVL-1:128] (Unmodified)\nMASK := SRC3\nIF (MASK[63] = 0) THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST [63:0] := SRC2[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] := SRC1[127:64]\n    ELSE DEST [127:64] := SRC2[127:64] FI\nDEST[MAXVL-1:128] := 0\nMASK := SRC3\nIF (MASK[63] = 0) THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST [63:0] := SRC2[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] := SRC1[127:64]\n    ELSE DEST [127:64] := SRC2[127:64] FI\nIF (MASK[191] = 0) THEN DEST[191:128] := SRC1[191:128]\n    ELSE DEST [191:128] := SRC2[191:128] FI\nIF (MASK[255] = 0) THEN DEST[255:192] := SRC1[255:192]\n    ELSE DEST [255:192] := SRC2[255:192] FI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movdqu:vmovdqu8:vmovdqu16:vmovdqu32:vmovdqu64",
    "category": "Core Instructions",
    "instructionName": "MOVDQU/VMOVDQU8/VMOVDQU16/VMOVDQU32/VMOVDQU64\n\t\t— Move Unaligned Packed Integer Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move unaligned packed integer values from xmm2/m128 to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 6F /r MOVDQU xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move unaligned packed integer values from xmm1 to xmm2/m128.",
        "Op/En": "B",
        "Opcode/Instruction": "F3 0F 7F /r MOVDQU xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed integer values from xmm2/m128 to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F.WIG 6F /r VMOVDQU xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed integer values from xmm1 to xmm2/m128.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.F3.0F.WIG 7F /r VMOVDQU xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed integer values from ymm2/m256 to ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.F3.0F.WIG 6F /r VMOVDQU ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed integer values from ymm1 to ymm2/m256.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.F3.0F.WIG 7F /r VMOVDQU ymm2/m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Move unaligned packed byte integer values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.F2.0F.W0 6F /r VMOVDQU8 xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Move unaligned packed byte integer values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.F2.0F.W0 6F /r VMOVDQU8 ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move unaligned packed byte integer values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.F2.0F.W0 6F /r VMOVDQU8 zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Move unaligned packed byte integer values from xmm1 to xmm2/m128 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.F2.0F.W0 7F /r VMOVDQU8 xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Move unaligned packed byte integer values from ymm1 to ymm2/m256 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.F2.0F.W0 7F /r VMOVDQU8 ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move unaligned packed byte integer values from zmm1 to zmm2/m512 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.F2.0F.W0 7F /r VMOVDQU8 zmm2/m512 {k1}{z}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Move unaligned packed word integer values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.F2.0F.W1 6F /r VMOVDQU16 xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Move unaligned packed word integer values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.F2.0F.W1 6F /r VMOVDQU16 ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move unaligned packed word integer values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.F2.0F.W1 6F /r VMOVDQU16 zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Move unaligned packed word integer values from xmm1 to xmm2/m128 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.F2.0F.W1 7F /r VMOVDQU16 xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Move unaligned packed word integer values from ymm1 to ymm2/m256 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.F2.0F.W1 7F /r VMOVDQU16 ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Move unaligned packed word integer values from zmm1 to zmm2/m512 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.F2.0F.W1 7F /r VMOVDQU16 zmm2/m512 {k1}{z}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.F3.0F.W0 6F /r VMOVDQU32 xmm1 {k1}{z}, xmm2/mm128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.F3.0F.W0 6F /r VMOVDQU32 ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move unaligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.F3.0F.W0 6F /r VMOVDQU32 zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.F3.0F.W0 7F /r VMOVDQU32 xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.F3.0F.W0 7F /r VMOVDQU32 ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move unaligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.F3.0F.W0 7F /r VMOVDQU32 zmm2/m512 {k1}{z}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed quadword integer values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.F3.0F.W1 6F /r VMOVDQU64 xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed quadword integer values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.F3.0F.W1 6F /r VMOVDQU64 ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move unaligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.F3.0F.W1 6F /r VMOVDQU64 zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.F3.0F.W1 7F /r VMOVDQU64 xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.F3.0F.W1 7F /r VMOVDQU64 ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move unaligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.F3.0F.W1 7F /r VMOVDQU64 zmm2/m512 {k1}{z}, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nEVEX encoded versions:\nMoves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand (the second operand) to the destination operand (first operand). This instruction can be used to load a vector register from a memory location, to store the contents of a vector register into a memory location, or to move data between two vector registers.\nThe destination operand is updated at 8-bit (VMOVDQU8), 16-bit (VMOVDQU16), 32-bit (VMOVDQU32), or 64-bit (VMOVDQU64) granularity according to the writemask.\nVEX.256 encoded version:\nMoves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.\nBits (MAXVL-1:256) of the destination register are zeroed.\n128-bit versions:\nMoves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nWhen the source or destination operand is a memory operand, the operand may be unaligned to any alignment without causing a general-protection exception (#GP) to be generated\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.",
    "operationText": "(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := SRC[i+7:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE DEST[i+7:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n                THEN DEST[i+7:i] :=\n                    SRC[i+7:i]\n                ELSE *DEST[i+7:i] remains unchanged*\n                        ; merging-masking\n        I\n            ;\nENDFOR;\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := SRC[i+7:i]\n        ELSE\n            IF *merging-masking*\n                    ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE DEST[i+7:i] := 0\n                    ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SRC[i+15:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE DEST[i+15:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n                THEN DEST[i+15:i] :=\n                    SRC[i+15:i]\n                ELSE *DEST[i+15:i] remains unchanged*\n                        ; merging-masking\n        I\n            ;\nENDFOR;\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SRC[i+15:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE DEST[i+15:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n                THEN DEST[i+31:i] :=\n                    SRC[i+31:i]\n                ELSE *DEST[i+31:i] remains unchanged*\n                        ; merging-masking\n        I\n            ;\nENDFOR;\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE *DEST[i+63:i] remains unchanged*\n            ; merging-masking\n    FI;\nENDFOR;\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := SRC[255:0]\nDEST[MAXVL-1:256] := 0\nDEST[255:0] := SRC[255:0]\nVMOVDQU (VEX.128 encoded version)\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := SRC[127:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/psllw:pslld:psllq",
    "category": "Core Instructions",
    "instructionName": "PSLLW/PSLLD/PSLLQ\n\t\t— Shift Packed Data Left Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift words in mm left mm/m64 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F F1 /r1 PSLLW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift words in xmm1 left by xmm2/m128 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F F1 /r PSLLW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift words in mm left by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 71 /6 ib PSLLW mm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift words in xmm1 left by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 71 /6 ib PSLLW xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift doublewords in mm left by mm/m64 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F F2 /r1 PSLLD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F F2 /r PSLLD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift doublewords in mm left by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 72 /6 ib1 PSLLD mm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift doublewords in xmm1 left by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 72 /6 ib PSLLD xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift quadword in mm left by mm/m64 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F F3 /r1 PSLLQ mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F F3 /r PSLLQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift quadword in mm left by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 73 /6 ib1 PSLLQ mm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift quadwords in xmm1 left by imm8 while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 73 /6 ib PSLLQ xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F1 /r VPSLLW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift words in xmm2 left by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 71 /6 ib VPSLLW xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F2 /r VPSLLD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift doublewords in xmm2 left by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 72 /6 ib VPSLLD xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F3 /r VPSLLQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift quadwords in xmm2 left by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 73 /6 ib VPSLLQ xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.256.66.0F.WIG F1 /r VPSLLW ymm1, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift words in ymm2 left by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 71 /6 ib VPSLLW ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.256.66.0F.WIG F2 /r VPSLLD ymm1, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 left by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 72 /6 ib VPSLLD ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.256.66.0F.WIG F3 /r VPSLLQ ymm1, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift quadwords in ymm2 left by imm8 while shifting in 0s.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 73 /6 ib VPSLLQ ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG F1 /r VPSLLW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG F1 /r VPSLLW ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG F1 /r VPSLLW zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2/m128 left by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 71 /6 ib VPSLLW xmm1 {k1}{z}, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2/m256 left by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 71 /6 ib VPSLLW ymm1 {k1}{z}, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2/m512 left by imm8 while shifting in 0 using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 71 /6 ib VPSLLW zmm1 {k1}{z}, zmm2/m512, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 F2 /r VPSLLD xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 F2 /r VPSLLD ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2 left by amount specified in xmm3/m128 while shifting in 0s under writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 F2 /r VPSLLD zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2/m128/m32bcst left by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 72 /6 ib VPSLLD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2/m256/m32bcst left by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 72 /6 ib VPSLLD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2/m512/m32bcst left by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 72 /6 ib VPSLLD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 F3 /r VPSLLQ xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 F3 /r VPSLLQ ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2 left by amount specified in xmm3/m128 while shifting in 0s using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 F3 /r VPSLLQ zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2/m128/m64bcst left by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 73 /6 ib VPSLLQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2/m256/m64bcst left by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 73 /6 ib VPSLLQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2/m512/m64bcst left by imm8 while shifting in 0s using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 73 /6 ib VPSLLQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "E",
        "Operand 1": "EVEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "F",
        "Operand 1": "EVEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "G",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Mem128"
      }
    ],
    "descriptionText": "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.\nThe (V)PSLLW instruction shifts each of the words in the destination operand to the left by the number of bits specified in the count operand; the (V)PSLLD instruction shifts each of the doublewords in the destination operand; and the (V)PSLLQ instruction shifts the quadword (or quadwords) in the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions 64-bit operand: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.\n128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.\nVEX.128 encoded version: The destination and first source operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.\nVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location. The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded versions: The destination operand is a ZMM register updated according to the writemask. The count operand is either an 8-bit immediate (the immediate count version) or an 8-bit value from an XMM register or a memory location (the variable count version). For the immediate count version, the source operand (the second operand) can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. For the variable count version, the first source operand (the second operand) is a ZMM register, the second source operand (the third operand, 8-bit variable count) can be an XMM register or a memory location.\nNote: In VEX/EVEX encoded versions of shifts with an immediate count, vvvv of VEX/EVEX encode the destination register, and VEX.B/EVEX.B + ModRM.r/m encodes the source register.\nNote: For shifts with an immediate count (VEX.128.66.0F 71-73 /6, or EVEX.128.66.0F 71-73 /6), VEX.vvvv/EVEX.vvvv encodes the destination register.",
    "operationText": "IF (COUNT > 15)\n    THEN\n        DEST[64:0] := 0000000000000000H;\n    ELSE\n        DEST[15:0] := ZeroExtend(DEST[15:0] << COUNT);\n        (* Repeat shift operation for 2nd and 3rd words *)\n        DEST[63:48] := ZeroExtend(DEST[63:48] << COUNT);\n    FI;\nPSLLD (with 64-bit operand)\n    IF (COUNT > 31)\n    THEN\n        DEST[64:0] := 0000000000000000H;\n    ELSE\n        DEST[31:0] := ZeroExtend(DEST[31:0] << COUNT);\n        DEST[63:32] := ZeroExtend(DEST[63:32] << COUNT);\n    FI;\nIF (COUNT > 63)\n    THEN\n        DEST[64:0] := 0000000000000000H;\n    ELSE\n        DEST := ZeroExtend(DEST << COUNT);\n    FI;\nLOGICAL_LEFT_SHIFT_WORDS(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 15)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\nELSE\n    DEST[15:0] := ZeroExtend(SRC[15:0] << COUNT);\n    (* Repeat shift operation for 2nd through 7th words *)\n    DEST[127:112] := ZeroExtend(SRC[127:112] << COUNT);\nFI;\nLOGICAL_LEFT_SHIFT_DWORDS1(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\nTHEN\n    DEST[31:0] := 0\nELSE\n    DEST[31:0] := ZeroExtend(SRC[31:0] << COUNT);\nFI;\nLOGICAL_LEFT_SHIFT_DWORDS(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\nELSE\n    DEST[31:0] := ZeroExtend(SRC[31:0] << COUNT);\n    (* Repeat shift operation for 2nd through 3rd words *)\n    DEST[127:96] := ZeroExtend(SRC[127:96] << COUNT);\nFI;\nLOGICAL_LEFT_SHIFT_QWORDS1(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 63)\nTHEN\n    DEST[63:0] := 0\nELSE\n    DEST[63:0] := ZeroExtend(SRC[63:0] << COUNT);\nFI;\nLOGICAL_LEFT_SHIFT_QWORDS(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 63)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\nELSE\n    DEST[63:0] := ZeroExtend(SRC[63:0] << COUNT);\n    DEST[127:64] := ZeroExtend(SRC[127:64] << COUNT);\nFI;\nLOGICAL_LEFT_SHIFT_WORDS_256b(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 15)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\n    DEST[255:128] := 00000000000000000000000000000000H\nELSE\n    DEST[15:0] := ZeroExtend(SRC[15:0] << COUNT);\n    (* Repeat shift operation for 2nd through 15th words *)\n    DEST[255:240] := ZeroExtend(SRC[255:240] << COUNT);\nFI;\nLOGICAL_LEFT_SHIFT_DWORDS_256b(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\n    DEST[255:128] := 00000000000000000000000000000000H\nELSE\n    DEST[31:0] := ZeroExtend(SRC[31:0] << COUNT);\n    (* Repeat shift operation for 2nd through 7th words *)\n    DEST[255:224] := ZeroExtend(SRC[255:224] << COUNT);\nFI;\nLOGICAL_LEFT_SHIFT_QWORDS_256b(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 63)\nTHEN\n    DEST[127:0] := 00000000000000000000000000000000H\n    DEST[255:128] := 00000000000000000000000000000000H\nELSE\n    DEST[63:0] := ZeroExtend(SRC[63:0] << COUNT);\n    DEST[127:64] := ZeroExtend(SRC[127:64] << COUNT)\n    DEST[191:128] := ZeroExtend(SRC[191:128] << COUNT);\n    DEST[255:192] := ZeroExtend(SRC[255:192] << COUNT);\nFI;\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL = 128\n    TMP_DEST[127:0] := LOGICAL_LEFT_SHIFT_WORDS_128b(SRC1[127:0], SRC2)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)\n    TMP_DEST[511:256] := LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[511:256], SRC2)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL = 128\n    TMP_DEST[127:0] := LOGICAL_LEFT_SHIFT_WORDS_128b(SRC1[127:0], imm8)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], imm8)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[255:0], imm8)\n    TMP_DEST[511:256] := LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1[511:256], imm8)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := LOGICAL_LEFT_SHIFT_WORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0;\nDEST[255:0] := LOGICAL_LEFT_SHIFT_WORD_256b(SRC1, imm8)\nDEST[MAXVL-1:256] := 0;\nDEST[127:0] := LOGICAL_LEFT_SHIFT_WORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_LEFT_SHIFT_WORDS(SRC1, imm8)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_LEFT_SHIFT_WORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := LOGICAL_LEFT_SHIFT_WORDS(DEST, imm8)\nDEST[MAXVL-1:128] (Unmodified)\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC1 *is memory*)\n                THEN DEST[i+31:i] := LOGICAL_LEFT_SHIFT_DWORDS1(SRC1[31:0], imm8)\n                ELSE DEST[i+31:i] := LOGICAL_LEFT_SHIFT_DWORDS1(SRC1[i+31:i], imm8)\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF VL = 128\n    TMP_DEST[127:0] := LOGICAL_LEFT_SHIFT_DWORDS_128b(SRC1[127:0], SRC2)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)\n    TMP_DEST[511:256] := LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1[511:256], SRC2)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking* ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0;\nDEST[255:0] := LOGICAL_LEFT_SHIFT_DWORDS_256b(SRC1, imm8)\nDEST[MAXVL-1:256] := 0;\nDEST[127:0] := LOGICAL_LEFT_SHIFT_DWORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_LEFT_SHIFT_DWORDS(SRC1, imm8)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_LEFT_SHIFT_DWORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := LOGICAL_LEFT_SHIFT_DWORDS(DEST, imm8)\nDEST[MAXVL-1:128] (Unmodified)\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC1 *is memory*)\n                THEN DEST[i+63:i] := LOGICAL_LEFT_SHIFT_QWORDS1(SRC1[63:0], imm8)\n                ELSE DEST[i+63:i] := LOGICAL_LEFT_SHIFT_QWORDS1(SRC1[i+63:i], imm8)\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF VL = 128\n    TMP_DEST[127:0] := LOGICAL_LEFT_SHIFT_QWORDS_128b(SRC1[127:0], SRC2)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)\n    TMP_DEST[511:256] := LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1[511:256], SRC2)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0;\nDEST[255:0] := LOGICAL_LEFT_SHIFT_QWORDS_256b(SRC1, imm8)\nDEST[MAXVL-1:256] := 0;\nDEST[127:0] := LOGICAL_LEFT_SHIFT_QWORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_LEFT_SHIFT_QWORDS(SRC1, imm8)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := LOGICAL_LEFT_SHIFT_QWORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := LOGICAL_LEFT_SHIFT_QWORDS(DEST, imm8)\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": null
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/lock",
    "category": "Core Instructions",
    "instructionName": "LOCK\n\t\t— Assert LOCK# Signal Prefix",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Asserts LOCK# signal for duration of the accompanying instruction.",
        "Instruction": "LOCK",
        "Op/En": "ZO",
        "column_1": "F0"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Causes the processor’s LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the processor has exclusive use of any shared memory while the signal is asserted.\nIn most IA-32 and all Intel 64 processors, locking may occur without the LOCK# signal being asserted. See the “IA-32 Architecture Compatibility” section below for more details.\nThe LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of the LOCK prefix.\nThe LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory location in shared memory environment.\nThe integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed for arbitrarily misaligned fields.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "AssertLOCK#(DurationOfAccompaningInstruction);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: Other exceptions can be generated by the instruction when the LOCK prefix is applied.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfnmsub132ps:vfnmsub213ps:vfnmsub231ps",
    "category": "Core Instructions",
    "instructionName": "VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS\n\t\t— Fused Negative Multiply-Subtract ofPacked Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 9E /r VFNMSUB132PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 AE /r VFNMSUB213PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 BE /r VFNMSUB231PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 9E /r VFNMSUB132PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 AE /r VFNMSUB213PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.0 BE /r VFNMSUB231PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and subtract xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 9E /r VFNMSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m32bcst and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 AE /r VFNMSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result subtract add to xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 BE /r VFNMSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and subtract ymm2 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 9E /r VFNMSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m32bcst and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 AE /r VFNMSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result subtract add to ymm1 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 BE /r VFNMSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and subtract zmm2 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 9E /r VFNMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m32bcst and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 AE /r VFNMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result subtract add to zmm1 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 BE /r VFNMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdtsc",
    "category": "Core Instructions",
    "instructionName": "RDTSC\n\t\t— Read Time-Stamp Counter",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Read time-stamp counter into EDX:EAX.",
        "Instruction": "RDTSC",
        "Op/En": "ZO",
        "Opcode*": "0F 31"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Reads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)\nThe processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See “Time Stamp Counter” in Chapter 18 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, for specific details of the time stamp counter behavior.\nThe time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0.\nThe time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0.\nThe RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the read operation is performed. The following items may guide software seeking to order executions of RDTSC:\nThis instruction was introduced by the Pentium processor.\nSee “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 26 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
    "operationText": "IF (CR4.TSD = 0) or (CPL = 0) or (CR0.PE = 0)\n    THEN EDX:EAX := TimeStampCounter;\n    ELSE (* CR4.TSD = 1 and (CPL = 1, 2, or 3) and CR0.PE = 1 *)\n        #GP(0);\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtusi2sh",
    "category": "Core Instructions",
    "instructionName": "VCVTUSI2SH\n\t\t— Convert Unsigned Doubleword Integer to an FP16 Value",
    "detailsTable": [
      {
        "Description": "Convert an unsigned doubleword integer from r32/m32 to an FP16 value, and store the result in xmm1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 7B /r VCVTUSI2SH xmm1, xmm2, r32/m32 {er}",
        "Support": "V/V1",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Convert an unsigned quadword integer from r64/m64 to an FP16 value, and store the result in xmm1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W1 7B /r VCVTUSI2SH xmm1, xmm2, r64/m64 {er}",
        "Support": "V/N.E.",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vexp2pd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VEXP2PD\n\t\t— Approximation to the Exponential 2^x of Packed Double Precision Floating-PointValues With Less Than 2^-23 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes approximations to the exponential 2^x (with less than 2^-23 of maximum relative error) of the packed double precision floating-point values from zmm2/m512/m64bcst and stores the floating-point result in zmm1with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C8 /r VEXP2PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A Full ModRM:reg (r, w) ModRM:r/m (r) N/A N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/and",
    "category": "Core Instructions",
    "instructionName": "AND\n\t\t— Logical AND",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AL AND imm8.",
        "Instruction": "AND AL, imm8",
        "Op/En": "I",
        "Opcode": "24 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AX AND imm16.",
        "Instruction": "AND AX, imm16",
        "Op/En": "I",
        "Opcode": "25 iw"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "EAX AND imm32.",
        "Instruction": "AND EAX, imm32",
        "Op/En": "I",
        "Opcode": "25 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "RAX AND imm32 sign-extended to 64-bits.",
        "Instruction": "AND RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + 25 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m8 AND imm8.",
        "Instruction": "AND r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "80 /4 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m8 AND imm8.",
        "Instruction": "AND r/m8*, imm8",
        "Op/En": "MI",
        "Opcode": "REX + 80 /4 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 AND imm16.",
        "Instruction": "AND r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "81 /4 iw"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 AND imm32.",
        "Instruction": "AND r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "81 /4 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 AND imm32 sign extended to 64-bits.",
        "Instruction": "AND r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + 81 /4 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 AND imm8 (sign-extended).",
        "Instruction": "AND r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "83 /4 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 AND imm8 (sign-extended).",
        "Instruction": "AND r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "83 /4 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 AND imm8 (sign-extended).",
        "Instruction": "AND r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 83 /4 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m8 AND r8.",
        "Instruction": "AND r/m8, r8",
        "Op/En": "MR",
        "Opcode": "20 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 AND r8 (sign-extended).",
        "Instruction": "AND r/m8*, r8*",
        "Op/En": "MR",
        "Opcode": "REX + 20 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 AND r16.",
        "Instruction": "AND r/m16, r16",
        "Op/En": "MR",
        "Opcode": "21 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 AND r32.",
        "Instruction": "AND r/m32, r32",
        "Op/En": "MR",
        "Opcode": "21 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 AND r32.",
        "Instruction": "AND r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 21 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r8 AND r/m8.",
        "Instruction": "AND r8, r/m8",
        "Op/En": "RM",
        "Opcode": "22 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 AND r8 (sign-extended).",
        "Instruction": "AND r8*, r/m8*",
        "Op/En": "RM",
        "Opcode": "REX + 22 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r16 AND r/m16.",
        "Instruction": "AND r16, r/m16",
        "Op/En": "RM",
        "Opcode": "23 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r32 AND r/m32.",
        "Instruction": "AND r32, r/m32",
        "Op/En": "RM",
        "Opcode": "23 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r64 AND r/m64.",
        "Instruction": "AND r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 23 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\nThis instruction can be used with a LOCK prefix to allow the it to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := DEST AND SRC;",
    "flagsAffectedText": "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/wakeup",
    "category": "SMX Instructions",
    "instructionName": "GETSEC[WAKEUP]\n\t\t— Wake Up Sleeping Processors in Measured Environment",
    "detailsTable": [
      {
        "Description": "Wake up the responding logical processors from the SENTER sleep state.",
        "Instruction": "GETSEC[WAKEUP]",
        "Opcode": "NP 0F 37 (EAX=8)"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The GETSEC[WAKEUP] leaf function broadcasts a wake-up message to all logical processors currently in the SENTER sleep state. This GETSEC leaf must be executed only by the ILP, in order to wake-up the RLPs. Responding logical processors (RLPs) enter the SENTER sleep state after completion of the SENTER rendezvous sequence.\nThe GETSEC[WAKEUP] instruction may only be executed:\nIf these conditions are not met, attempts to execute GETSEC[WAKEUP] result in a general protection violation.\nAn RLP exits the SENTER sleep state and start execution in response to a WAKEUP signal initiated by ILP’s execution of GETSEC[WAKEUP]. The RLP retrieves a pointer to a data structure that contains information to enable execution from a defined entry point. This data structure is located using a physical address held in the Intel® TXT-capable chipset configuration register LT.MLE.JOIN. The register is publicly writable in the chipset by all processors and is not restricted by the Intel® TXT-capable chipset configuration register lock status. The format of this data structure is defined in Table 7-12.\nThe MLE JOIN data structure contains the information necessary to initialize RLP processor state and permit the processor to join the measured environment. The GDTR, LIP, and CS, DS, SS, and ES selector values are initialized using this data structure. The CS selector index is derived directly from the segment selector initializer field; DS, SS, and ES selectors are initialized to CS+8. The segment descriptor fields are initialized implicitly with BASE = 0, LIMIT = FFFFFH, G = 1, D = 1, P = 1, S = 1; read/write/access for DS, SS, and ES; and execute/read/access for CS. It is the responsibility of external software to establish a GDT pointed to by the MLE JOIN data structure that contains descriptor entries consistent with the implicit settings initialized by the processor (see Table 7-6). Certain states from the content of Table 7-12 are checked for consistency by the processor prior to execution. A failure of any consistency check results in the RLP aborting entry into the protected environment and signaling an Intel® TXT shutdown condition. The specific checks performed are documented later in this section. After successful completion of processor consistency checks and subsequent initialization, RLP execution in the measured environment begins from the entry point at offset 12 (as indicated in Table 7-12).",
    "operationText": "(* The state of the internal flag ACMODEFLAG and SENTERFLAG persist across instruction boundary *)\nIF (CR4.SMXE=0)\n    THEN #UD;\nELSE IF (in VMX non-root operation)\n    THEN VM Exit (reason=”GETSEC instruction”);\nELSE IF (GETSEC leaf unsupported)\n    THEN #UD;\nELSE IF ((CR0.PE=0) or (CPL>0) or (EFLAGS.VM=1) or (SENTERFLAG=0) or (ACMODEFLAG=1) or (IN_SMM=0) or (in VMX operation) or\n(IA32_APIC_BASE.BSP=0) or (TXT chipset not present))\n    THEN #GP(0);\nELSE\n    SignalTXTMsg(WAKEUP);\nEND;\nWHILE (no SignalWAKEUP event);\nIF (IA32_SMM_MONITOR_CTL[0] ≠ ILP.IA32_SMM_MONITOR_CTL[0])\n    THEN TXT-SHUTDOWN(#IllegalEvent)\nIF (IA32_SMM_MONITOR_CTL[0] = 0)\n    THEN Unmask SMI pin event;\nELSE\n    Mask SMI pin event;\nMask A20M, and NMI external pin events (unmask INIT);\nMask SignalWAKEUP event;\nInvalidate processor TLB(s);\nDrain outgoing transactions;\nTempGDTRLIMIT := LOAD(LT.MLE.JOIN);\nTempGDTRBASE := LOAD(LT.MLE.JOIN+4);\nTempSegSel := LOAD(LT.MLE.JOIN+8);\nTempEIP := LOAD(LT.MLE.JOIN+12);\nIF (TempGDTLimit & FFFF0000h)\n    THEN TXT-SHUTDOWN(#BadJOINFormat);\nIF ((TempSegSel > TempGDTRLIMIT-15) or (TempSegSel < 8))\n    THEN TXT-SHUTDOWN(#BadJOINFormat);\nIF ((TempSegSel.TI=1) or (TempSegSel.RPL≠0))\n    THEN TXT-SHUTDOWN(#BadJOINFormat);\nCR0.[PG,CD,NW,AM,WP] := 0;\nCR0.[NE,PE] := 1;\nCR4 := 00004000h;\nEFLAGS := 00000002h;\nIA32_EFER := 0;\nGDTR.BASE := TempGDTRBASE;\nGDTR.LIMIT := TempGDTRLIMIT;\nCS.SEL := TempSegSel;\nCS.BASE := 0;\nCS.LIMIT := FFFFFh;\nCS.G := 1;\nCS.D := 1;\nCS.AR := 9Bh;\nDS.SEL := TempSegSel+8;\nDS.BASE := 0;\nDS.LIMIT := FFFFFh;\nDS.G := 1;\nDS.D := 1;\nDS.AR := 93h;\nSS := DS;\nES := DS;\nDR7 := 00000400h;\nIA32_DEBUGCTL := 0;\nEIP := TempEIP;\nEND;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "All protected mode exceptions apply."
      ],
      "compatibilityMode": [
        "All protected mode exceptions apply."
      ],
      "protectedMode": [
        "column_1: If GETSEC[WAKEUP] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: IfCR0.PE=0orCPL>0orEFLAGS.VM=1.; \ncolumn_1: If in VMX operation.; \ncolumn_1: If a protected partition is not already active or the processor is currently in authenticated code mode.; \ncolumn_1: If the processor is in SMM.; \ncolumn_1: #UD; column_2: If CR4.SMXE = 0.; \ncolumn_1: If GETSEC[WAKEUP] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[WAKEUP] is not recognized in real-address mode.;"
      ],
      "virtual8086Mode": [
        "column_1: If GETSEC[WAKEUP] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[WAKEUP] is not recognized in virtual-8086 mode.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/das",
    "category": "Core Instructions",
    "instructionName": "DAS\n\t\t— Decimal Adjust AL After Subtraction",
    "detailsTable": [
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Decimal adjust AL after subtraction.",
        "Instruction": "DAS",
        "Op/En": "ZO",
        "Opcode": "2F"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register. The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal borrow is detected, the CF and AF flags are set accordingly.\nThis instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        #UD;\n    ELSE\n        old_AL := AL;\n        old_CF := CF;\n        CF := 0;\n        IF (((AL AND 0FH) > 9) or AF = 1)\n            THEN\n                    AL:=AL -6;\n                    CF := old_CF or (Borrow from AL := AL − 6);\n                    AF := 1;\n            ELSE\n                    AF := 0;\n        FI;\n        IF ((old_AL > 99H) or (old_CF = 1))\n                THEN\n                    AL := AL − 60H;\n                    CF := 1;\n        FI;\nFI;",
    "flagsAffectedText": "The CF and AF flags are set if the adjustment of the value results in a decimal borrow in either digit of the result (see the “Operation” section above). The SF, ZF, and PF flags are set according to the result. The OF flag is undefined.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttph2w",
    "category": "Core Instructions",
    "instructionName": "VCVTTPH2W\n\t\t— Convert Packed FP16 Values to Signed Word Integers",
    "detailsTable": [
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed word integers, and store the result in xmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.W0 7C /r VCVTTPH2W xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen signed word integers, and store the result in ymm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP5.W0 7C /r VCVTTPH2W ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert thirty-two packed FP16 values in zmm2/m512/m16bcst to thirty-two signed word integers, and store the result in zmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP5.W0 7C /r VCVTTPH2W zmm1{k1}{z}, zmm2/m512/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgatherdps:vgatherdpd",
    "category": "Core Instructions",
    "instructionName": "VGATHERDPS/VGATHERDPD\n\t\t— Gather Packed Single, Packed Double with Signed Dword Indices",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 92 /vsib VGATHERDPS xmm1 {k1}, vm32x"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 92 /vsib VGATHERDPS ymm1 {k1}, vm32y"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 92 /vsib VGATHERDPS zmm1 {k1}, vm32z"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 92 /vsib VGATHERDPD xmm1 {k1}, vm32x"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 92 /vsib VGATHERDPD ymm1 {k1}, vm32x"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed dword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 92 /vsib VGATHERDPD zmm1 {k1}, vm32y"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpopcnt",
    "category": "Core Instructions",
    "instructionName": "VPOPCNT\n\t\t— Return the Count of Number of Bits Set to 1 in BYTE/WORD/DWORD/QWORD",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG AVX512VL",
        "Description": "Counts the number of bits set to one in xmm2/m128 and puts the result in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 54 /r VPOPCNTB xmm1{k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG AVX512VL",
        "Description": "Counts the number of bits set to one in ymm2/m256 and puts the result in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 54 /r VPOPCNTB ymm1{k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG",
        "Description": "Counts the number of bits set to one in zmm2/m512 and puts the result in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 54 /r VPOPCNTB zmm1{k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG AVX512VL",
        "Description": "Counts the number of bits set to one in xmm2/m128 and puts the result in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 54 /r VPOPCNTW xmm1{k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG AVX512VL",
        "Description": "Counts the number of bits set to one in ymm2/m256 and puts the result in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 54 /r VPOPCNTW ymm1{k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG",
        "Description": "Counts the number of bits set to one in zmm2/m512 and puts the result in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 54 /r VPOPCNTW zmm1{k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VPOPCNTDQ AVX512VL",
        "Description": "Counts the number of bits set to one in xmm2/m128/m32bcst and puts the result in xmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 55 /r VPOPCNTD xmm1{k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VPOPCNTDQ AVX512VL",
        "Description": "Counts the number of bits set to one in ymm2/m256/m32bcst and puts the result in ymm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 55 /r VPOPCNTD ymm1{k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VPOPCNTDQ",
        "Description": "Counts the number of bits set to one in zmm2/m512/m32bcst and puts the result in zmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 55 /r VPOPCNTD zmm1{k1}{z}, zmm2/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VPOPCNTDQ AVX512VL",
        "Description": "Counts the number of bits set to one in xmm2/m128/m32bcst and puts the result in xmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 55 /r VPOPCNTQ xmm1{k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VPOPCNTDQ AVX512VL",
        "Description": "Counts the number of bits set to one in ymm2/m256/m32bcst and puts the result in ymm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 55 /r VPOPCNTQ ymm1{k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VPOPCNTDQ",
        "Description": "Counts the number of bits set to one in zmm2/m512/m64bcst and puts the result in zmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 55 /r VPOPCNTQ zmm1{k1}{z}, zmm2/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vp4dpwssd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VP4DPWSSD\n\t\t— Dot Product of Signed Words With Dword Accumulation (4-Iterations)",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_4VNNIW",
        "Description": "Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate resulting signed dwords in zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F2.0F38.W0 52 /r VP4DPWSSD zmm1{k1}{z}, zmm2+3, m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2 Operand 3 Operand 4": "EVEX.vvvv (r) ModRM:r/m (r) N/A",
        "Tuple": "Tuple1_4X",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xsaveopt",
    "category": "Core Instructions",
    "instructionName": "XSAVEOPT\n\t\t— Save Processor Extended States Optimized",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "XSAVEOPT",
        "Description": "Save state components specified by EDX:EAX to mem, optimizing if possible.",
        "Op/En": "M",
        "Opcode/Instruction": "NP 0F AE /6 XSAVEOPT mem"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "XSAVEOPT",
        "Description": "Save state components specified by EDX:EAX to mem, optimizing if possible.",
        "Op/En": "M",
        "Opcode/Instruction": "NP REX.W + 0F AE /6 XSAVEOPT64 mem"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\nThe format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nSection 13.9, “Operation of XSAVEOPT,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVEOPT instruction. The following items provide a highlevel outline:\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) will result in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\nSee Section 13.6, “Processor Tracking of XSAVE-Managed State,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for discussion of the bitmap XMODIFIED and of the quantity XRSTOR_INFO.",
    "operationText": "RFBM := XCR0 AND EDX:EAX; /* bitwise logical AND */\nOLD_BV := XSTATE_BV field from XSAVE header;\nTO_BE_SAVED := RFBM AND XINUSE;\nIF in VMX non-root operation\n    THEN VMXNR := 1;\n    ELSE VMXNR := 0;\nFI;\nLAXA := linear address of XSAVE area;\nIF XRSTOR_INFO = CPL,VMXNR,LAXA,00000000_00000000H\n    THEN TO_BE_SAVED := TO_BE_SAVED AND XMODIFIED;\nFI;\nIF TO_BE_SAVED[0] = 1\n    THEN store x87 state into legacy region of XSAVE area;\nFI;\nIF TO_BE_SAVED[1]\n    THEN store XMM registers into legacy region of XSAVE area; // this step does not save MXCSR or MXCSR_MASK\nFI;\nIF RFBM[1] = 1 or RFBM[2] = 1\n    THEN store MXCSR and MXCSR_MASK into legacy region of XSAVE area;\nFI;\nFOR i := 2 TO 62\n    IF TO_BE_SAVED[i] = 1\n        THEN save XSAVE state component i at offset n from base of XSAVE area (n enumerated by CPUID(EAX=0DH,ECX=i):EBX);\n    FI;\nENDFOR;\nXSTATE_BV field in XSAVE header := (OLD_BV AND NOT RFBM) OR (XINUSE AND RFBM);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSAVEOPT[bit 0] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #AC; column_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 64-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSAVEOPT[bit 0] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #AC; column_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 64-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).;"
      ],
      "realAddressMode": [
        "column_1: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSAVEOPT[bit 0] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movdir64b",
    "category": "Core Instructions",
    "instructionName": "MOVDIR64B\n\t\t— Move 64 Bytes as Direct Store",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MOVDIR64B",
        "Description": "Move 64-bytes as direct-store with guaranteed 64-byte write atomicity from the source memory operand address to destination memory address specified as offset to ES segment in the register operand.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 F8 /r MOVDIR64B r16/r32/r64, m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "Moves 64-bytes as direct-store with 64-byte write atomicity from source memory address to destination memory address. The source operand is a normal memory operand. The destination operand is a memory location specified in a general-purpose register. The register content is interpreted as an offset into ES segment without any segment override. In 64-bit mode, the register operand width is 64-bits (32-bits with 67H prefix). Outside of 64-bit mode, the register width is 32-bits when CS.D=1 (16-bits with 67H prefix), and 16-bits when CS.D=0 (32-bits with 67H prefix). MOVDIR64B requires the destination address to be 64-byte aligned. No alignment restriction is enforced for source operand.\nMOVDIR64B first reads 64-bytes from the source memory address. It then performs a 64-byte direct-store operation to the destination address. The load operation follows normal read ordering based on source address memory-type. The direct-store is implemented by using the write combining (WC) memory type protocol for writing data. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. If the destination address is cached, the line is written-back (if modified) and invalidated from the cache, before the direct-store.\nUnlike stores with non-temporal hint which allow UC/WP memory-type for destination to override the non-temporal hint, direct-stores always follow WC memory type protocol irrespective of destination address memory type (including UC/WP types). Unlike WC stores and stores with non-temporal hint, direct-stores are eligible for immediate eviction from the write-combining buffer, and thus not combined with younger stores (including direct-stores) to the same address. Older WC and non-temporal stores held in the write-combing buffer may be combined with younger direct stores to the same address. Direct stores are weakly ordered relative to other stores. Software that desires stronger ordering should use a fencing instruction (MFENCE or SFENCE) before or after a direct store to enforce the ordering desired.\nThere is no atomicity guarantee provided for the 64-byte load operation from source address, and processor implementations may use multiple load operations to read the 64-bytes. The 64-byte direct-store issued by MOVDIR64B guarantees 64-byte write-completion atomicity. This means that the data arrives at the destination in a single undivided 64-byte write transaction.\nAvailability of the MOVDIR64B instruction is indicated by the presence of the CPUID feature flag MOVDIR64B (bit 28 of the ECX register in leaf 07H, see “CPUID—CPU Identification” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A).",
    "operationText": "DEST := SRC;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in non-canonical form.; \ncolumn_1: If address in destination (register) operand is not aligned to a 64-byte boundary.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.07H.0H:ECX.MOVDIR64B[bit 28] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If address in destination (register) operand is not aligned to a 64-byte boundary.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.07H.0H:ECX.MOVDIR64B[bit 28] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If address in destination (register) operand is not aligned to a 64-byte boundary.; \ncolumn_1: #UD; column_2: If CPUID.07H.0H:ECX.MOVDIR64B[bit 28] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode.",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vreducesh",
    "category": "Core Instructions",
    "instructionName": "VREDUCESH\n\t\t— Perform Reduction Transformation on Scalar FP16 Value",
    "detailsTable": [
      {
        "Description": "Perform a reduction transformation on the low binary encoded FP16 value in xmm3/m16 by subtracting a number of fraction bits specified by the imm8 field. Store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.NP.0F3A.W0 57 /r /ib VREDUCESH xmm1{k1}{z}, xmm2, xmm3/m16 {sae}, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfnmadd132ps:vfnmadd213ps:vfnmadd231ps",
    "category": "Core Instructions",
    "instructionName": "VFNMADD132PS/VFNMADD213PS/VFNMADD231PS\n\t\t— Fused Negative Multiply-Add of PackedSingle Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 9C /r VFNMADD132PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 AC /r VFNMADD213PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 BC /r VFNMADD231PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 9C /r VFNMADD132PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 AC /r VFNMADD213PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.0 BC /r VFNMADD231PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 9C /r VFNMADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m32bcst and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 AC /r VFNMADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 BC /r VFNMADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm2 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 9C /r VFNMADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m32bcst and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 AC /r VFNMADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm1 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 BC /r VFNMADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm2 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 9C /r VFNMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m32bcst and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 AC /r VFNMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm1 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 BC /r VFNMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvttps2pi",
    "category": "Core Instructions",
    "instructionName": "CVTTPS2PI\n\t\t— Convert With Truncation Packed Single Precision Floating-Point Values to PackedDword Integers",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Convert two single precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 2C /r CVTTPS2PI mm, xmm/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Converts two packed single precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single precision floating-point values are contained in the low quadword of the register.\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0]);\nDEST[63:32] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63:32]);",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 23-5, “Exception Conditions for Legacy SIMD/MMX Instructions with XMM and FP Exception,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sha1nexte",
    "category": "Core Instructions",
    "instructionName": "SHA1NEXTE\n\t\t— Calculate SHA1 State Variable E After Four Rounds",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SHA",
        "Description": "Calculates SHA1 state variable E after four rounds of operation from the current SHA1 state variable A in xmm1. The calculated value of the SHA1 state variable E is added to the scheduled dwords in xmm2/m128, and stored with some of the scheduled dwords in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 C8 /r SHA1NEXTE xmm1, xmm2/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "The SHA1NEXTE calculates the SHA1 state variable E after four rounds of operation from the current SHA1 state variable A in the destination operand. The calculated value of the SHA1 state variable E is added to the source operand, which contains the scheduled dwords.",
    "operationText": "TMP := (SRC1[127:96] ROL 30);\nDEST[127:96] := SRC2[127:96] + TMP;\nDEST[95:64] := SRC2[95:64];\nDEST[63:32] := SRC2[63:32];\nDEST[31:0] := SRC2[31:0];",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vaddph",
    "category": "Core Instructions",
    "instructionName": "VADDPH\n\t\t— Add Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Add packed FP16 value from xmm3/m128/m16bcst to xmm2, and store result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 58 /r VADDPH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Add packed FP16 value from ymm3/m256/m16bcst to ymm2, and store result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 58 /r VADDPH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Add packed FP16 value from zmm3/m512/m16bcst to zmm2, and store result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 58 /r VADDPH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/outs:outsb:outsw:outsd",
    "category": "Core Instructions",
    "instructionName": "OUTS/OUTSB/OUTSW/OUTSD\n\t\t— Output String to Port",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX2.",
        "Instruction": "OUTS DX, m8",
        "Op/En": "ZO",
        "column_1": "6E"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX2.",
        "Instruction": "OUTS DX, m16",
        "Op/En": "ZO",
        "column_1": "6F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX2.",
        "Instruction": "OUTS DX, m32",
        "Op/En": "ZO",
        "column_1": "6F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX2.",
        "Instruction": "OUTSB",
        "Op/En": "ZO",
        "column_1": "6E"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX2.",
        "Instruction": "OUTSW",
        "Op/En": "ZO",
        "column_1": "6F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX2.",
        "Instruction": "OUTSD",
        "Op/En": "ZO",
        "column_1": "6F"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.\nAt the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O port and the source address, and the destination operand must be DX. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which must be loaded correctly before the OUTS instruction is executed.\nThe no-operands form provides “short forms” of the byte, word, and doubleword versions of the OUTS instructions. Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).\nAfter the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.) The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.\nThe OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a\ndescription of the REP prefix. This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 19, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.\nIn 64-bit mode, the default operand size is 32 bits; operand size is not promoted by the use of REX.W. In 64-bit mode, the default address size is 64 bits, and 64-bit address is specified using RSI by default. 32-bit address using ESI is support using the prefix 67H, but 16-bit address is not supported in 64-bit mode.",
    "operationText": "IF ((PE = 1) and ((CPL > IOPL) or (VM = 1)))\n    THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)\n        IF (Any I/O Permission Bit for I/O port being accessed = 1)\n            THEN (* I/O operation is not allowed *)\n                #GP(0);\n            ELSE (* I/O operation is allowed *)\n                DEST := SRC; (* Writes to I/O port *)\n        FI;\n    ELSE (Real Mode or Protected Mode or 64-Bit Mode with CPL ≤ IOPL *)\n        DEST := SRC; (* Writes to I/O port *)\nFI;\nByte transfer:\n    IF 64-bit mode\n        Then\n            IF 64-Bit Address Size\n                THEN\n                    IF DF = 0\n                        THEN RSI := RSI RSI + 1;\n                        ELSE RSI := RSI or – 1;\n                    FI;\n                ELSE (* 32-Bit Address Size *)\n                    IF DF = 0\n                        THEN ESI := ESI + 1;\n                        ELSE ESI := ESI – 1;\n                    FI;\n            FI;\n        ELSE\n            IF DF = 0\n                THEN (E)SI := (E)SI + 1;\n                ELSE (E)SI := (E)SI – 1;\n            FI;\n    FI;\nWord transfer:\n    IF 64-bit mode\n        Then\n            IF 64-Bit Address Size\n                THEN\n                    IF DF = 0\n                        THEN RSI := RSI RSI + 2;\n                        ELSE RSI := RSI or – 2;\n                    FI;\n                ELSE (* 32-Bit Address Size *)\n                    IF DF = 0\n                        THEN ESI := ESI + 2;\n                        ELSE ESI := ESI – 2;\n                    FI;\n            FI;\n        ELSE\n            IF DF = 0\n                THEN (E)SI := (E)SI + 2;\n                ELSE (E)SI := (E)SI – 2;\n            FI;\n    FI;\nDoubleword transfer:\n    IF 64-bit mode\n        Then\n            IF 64-Bit Address Size\n                THEN\n                    IF DF = 0\n                        THEN RSI := RSI RSI + 4;\n                        ELSE RSI := RSI or – 4;\n                    FI;\n                ELSE (* 32-Bit Address Size *)\n                    IF DF = 0\n                        THEN ESI := ESI + 4;\n                        ELSE ESI := ESI – 4;\n                    FI;\n            FI;\n        ELSE\n            IF DF = 0\n                THEN (E)SI := (E)SI + 4;\n                ELSE (E)SI := (E)SI – 4;\n            FI;\n    FI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the CPL is greater than (has less privilege) the I/O privilege level (IOPL) and any of the corresponding I/O permission bits in TSS for the I/O port being accessed is 1.; \ncolumn_1: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same as for protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the limit of the CS, DS, ES, FS, or GS segment.; \ncolumn_1: If the segment register contains a NULL segment selector.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fabs",
    "category": "Core Instructions",
    "instructionName": "FABS\n\t\t— Absolute Value",
    "detailsTable": [
      {
        "Description": "Replace ST with its absolute value.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 E1",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Clears the sign bit of ST(0) to create the absolute value of the operand. The following table shows the results obtained when creating the absolute value of various classes of numbers.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "ST(0) := |ST(0)|;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        ""
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/psubb:psubw:psubd",
    "category": "Core Instructions",
    "instructionName": "PSUBB/PSUBW/PSUBD\n\t\t— Subtract Packed Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Subtract packed byte integers in mm/m64 from packed byte integers in mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F F8 /r1 PSUBB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F F8 /r PSUBB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Subtract packed word integers in mm/m64 from packed word integers in mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F F9 /r1 PSUBW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F F9 /r PSUBW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F FA /r1 PSUBD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F FA /r PSUBD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed byte integers in xmm3/m128 from xmm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F8 /r VPSUBB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed word integers in xmm3/m128 from xmm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F9 /r VPSUBW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed doubleword integers in xmm3/m128 from xmm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG FA /r VPSUBD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract packed byte integers in ymm3/m256 from ymm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG F8 /r VPSUBB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract packed word integers in ymm3/m256 from ymm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG F9 /r VPSUBW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract packed doubleword integers in ymm3/m256 from ymm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG FA /r VPSUBD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed byte integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG F8 /r VPSUBB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed byte integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG F8 /r VPSUBB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Subtract packed byte integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG F8 /r VPSUBB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed word integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG F9 /r VPSUBW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Subtract packed word integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG F9 /r VPSUBW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Subtract packed word integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG F9 /r VPSUBW zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Subtract packed doubleword integers in xmm3/m128/m32bcst from xmm2 and store in xmm1 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 FA /r VPSUBD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Subtract packed doubleword integers in ymm3/m256/m32bcst from ymm2 and store in ymm1 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 FA /r VPSUBD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Subtract packed doubleword integers in zmm3/m512/m32bcst from zmm2 and store in zmm1 using writemask k1",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 FA /r VPSUBD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.\nThe (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.\nThe (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.\nThe (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.\nNote that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded VPSUBD: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.\nEVEX encoded VPSUBB/W: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
    "operationText": "DEST[7:0] := DEST[7:0] − SRC[7:0];\n(* Repeat subtract operation for 2nd through 7th byte *)\nDEST[63:56] := DEST[63:56] − SRC[63:56];\nDEST[15:0] := DEST[15:0] − SRC[15:0];\n(* Repeat subtract operation for 2nd and 3rd word *)\nDEST[63:48] := DEST[63:48] − SRC[63:48];\nDEST[31:0] := DEST[31:0] − SRC[31:0];\nDEST[63:32] := DEST[63:32] − SRC[63:32];\nDEST[31:0] := DEST[31:0] − SRC[31:0];\n(* Repeat subtract operation for 2nd and 3rd doubleword *)\nDEST[127:96] := DEST[127:96] − SRC[127:96];\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := SRC1[i+7:i] - SRC2[i+7:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SRC1[i+15:i] - SRC2[i+15:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+31:i] := SRC1[i+31:i] - SRC2[31:0]\n                ELSE DEST[i+31:i] := SRC1[i+31:i] - SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nDEST[7:0] := SRC1[7:0]-SRC2[7:0]\nDEST[15:8] := SRC1[15:8]-SRC2[15:8]\nDEST[23:16] := SRC1[23:16]-SRC2[23:16]\nDEST[31:24] := SRC1[31:24]-SRC2[31:24]\nDEST[39:32] := SRC1[39:32]-SRC2[39:32]\nDEST[47:40] := SRC1[47:40]-SRC2[47:40]\nDEST[55:48] := SRC1[55:48]-SRC2[55:48]\nDEST[63:56] := SRC1[63:56]-SRC2[63:56]\nDEST[71:64] := SRC1[71:64]-SRC2[71:64]\nDEST[79:72] := SRC1[79:72]-SRC2[79:72]\nDEST[87:80] := SRC1[87:80]-SRC2[87:80]\nDEST[95:88] := SRC1[95:88]-SRC2[95:88]\nDEST[103:96] := SRC1[103:96]-SRC2[103:96]\nDEST[111:104] := SRC1[111:104]-SRC2[111:104]\nDEST[119:112] := SRC1[119:112]-SRC2[119:112]\nDEST[127:120] := SRC1[127:120]-SRC2[127:120]\nDEST[135:128] := SRC1[135:128]-SRC2[135:128]\nDEST[143:136] := SRC1[143:136]-SRC2[143:136]\nDEST[151:144] := SRC1[151:144]-SRC2[151:144]\nDEST[159:152] := SRC1[159:152]-SRC2[159:152]\nDEST[167:160] := SRC1[167:160]-SRC2[167:160]\nDEST[175:168] := SRC1[175:168]-SRC2[175:168]\nDEST[183:176] := SRC1[183:176]-SRC2[183:176]\nDEST[191:184] := SRC1[191:184]-SRC2[191:184]\nDEST[199:192] := SRC1[199:192]-SRC2[199:192]\nDEST[207:200] := SRC1[207:200]-SRC2[207:200]\nDEST[215:208] := SRC1[215:208]-SRC2[215:208]\nDEST[223:216] := SRC1[223:216]-SRC2[223:216]\nDEST[231:224] := SRC1[231:224]-SRC2[231:224]\nDEST[239:232] := SRC1[239:232]-SRC2[239:232]\nDEST[247:240] := SRC1[247:240]-SRC2[247:240]\nDEST[255:248] := SRC1[255:248]-SRC2[255:248]\nDEST[MAXVL-1:256] := 0\nDEST[7:0] := SRC1[7:0]-SRC2[7:0]\nDEST[15:8] := SRC1[15:8]-SRC2[15:8]\nDEST[23:16] := SRC1[23:16]-SRC2[23:16]\nDEST[31:24] := SRC1[31:24]-SRC2[31:24]\nDEST[39:32] := SRC1[39:32]-SRC2[39:32]\nDEST[47:40] := SRC1[47:40]-SRC2[47:40]\nDEST[55:48] := SRC1[55:48]-SRC2[55:48]\nDEST[63:56] := SRC1[63:56]-SRC2[63:56]\nDEST[71:64] := SRC1[71:64]-SRC2[71:64]\nDEST[79:72] := SRC1[79:72]-SRC2[79:72]\nDEST[87:80] := SRC1[87:80]-SRC2[87:80]\nDEST[95:88] := SRC1[95:88]-SRC2[95:88]\nDEST[103:96] := SRC1[103:96]-SRC2[103:96]\nDEST[111:104] := SRC1[111:104]-SRC2[111:104]\nDEST[119:112] := SRC1[119:112]-SRC2[119:112]\nDEST[127:120] := SRC1[127:120]-SRC2[127:120]\nDEST[MAXVL-1:128] := 0\nDEST[7:0] := DEST[7:0]-SRC[7:0]\nDEST[15:8] := DEST[15:8]-SRC[15:8]\nDEST[23:16] := DEST[23:16]-SRC[23:16]\nDEST[31:24] := DEST[31:24]-SRC[31:24]\nDEST[39:32] := DEST[39:32]-SRC[39:32]\nDEST[47:40] := DEST[47:40]-SRC[47:40]\nDEST[55:48] := DEST[55:48]-SRC[55:48]\nDEST[63:56] := DEST[63:56]-SRC[63:56]\nDEST[71:64] := DEST[71:64]-SRC[71:64]\nDEST[79:72] := DEST[79:72]-SRC[79:72]\nDEST[87:80] := DEST[87:80]-SRC[87:80]\nDEST[95:88] := DEST[95:88]-SRC[95:88]\nDEST[103:96] := DEST[103:96]-SRC[103:96]\nDEST[111:104] := DEST[111:104]-SRC[111:104]\nDEST[119:112] := DEST[119:112]-SRC[119:112]\nDEST[127:120] := DEST[127:120]-SRC[127:120]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[15:0] := SRC1[15:0]-SRC2[15:0]\nDEST[31:16] := SRC1[31:16]-SRC2[31:16]\nDEST[47:32] := SRC1[47:32]-SRC2[47:32]\nDEST[63:48] := SRC1[63:48]-SRC2[63:48]\nDEST[79:64] := SRC1[79:64]-SRC2[79:64]\nDEST[95:80] := SRC1[95:80]-SRC2[95:80]\nDEST[111:96] := SRC1[111:96]-SRC2[111:96]\nDEST[127:112] := SRC1[127:112]-SRC2[127:112]\nDEST[143:128] := SRC1[143:128]-SRC2[143:128]\nDEST[159:144] := SRC1[159:144]-SRC2[159:144]\nDEST[175:160] := SRC1[175:160]-SRC2[175:160]\nDEST[191:176] := SRC1[191:176]-SRC2[191:176]\nDEST[207:192] := SRC1207:192]-SRC2[207:192]\nDEST[223:208] := SRC1[223:208]-SRC2[223:208]\nDEST[239:224] := SRC1[239:224]-SRC2[239:224]\nDEST[255:240] := SRC1[255:240]-SRC2[255:240]\nDEST[MAXVL-1:256] := 0\nDEST[15:0] := SRC1[15:0]-SRC2[15:0]\nDEST[31:16] := SRC1[31:16]-SRC2[31:16]\nDEST[47:32] := SRC1[47:32]-SRC2[47:32]\nDEST[63:48] := SRC1[63:48]-SRC2[63:48]\nDEST[79:64] := SRC1[79:64]-SRC2[79:64]\nDEST[95:80] := SRC1[95:80]-SRC2[95:80]\nDEST[111:96] := SRC1[111:96]-SRC2[111:96]\nDEST[127:112] := SRC1[127:112]-SRC2[127:112]\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := DEST[15:0]-SRC[15:0]\nDEST[31:16] := DEST[31:16]-SRC[31:16]\nDEST[47:32] := DEST[47:32]-SRC[47:32]\nDEST[63:48] := DEST[63:48]-SRC[63:48]\nDEST[79:64] := DEST[79:64]-SRC[79:64]\nDEST[95:80] := DEST[95:80]-SRC[95:80]\nDEST[111:96] := DEST[111:96]-SRC[111:96]\nDEST[127:112] := DEST[127:112]-SRC[127:112]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := SRC1[31:0]-SRC2[31:0]\nDEST[63:32] := SRC1[63:32]-SRC2[63:32]\nDEST[95:64] := SRC1[95:64]-SRC2[95:64]\nDEST[127:96] := SRC1[127:96]-SRC2[127:96]\nDEST[159:128] := SRC1[159:128]-SRC2[159:128]\nDEST[191:160] := SRC1[191:160]-SRC2[191:160]\nDEST[223:192] := SRC1[223:192]-SRC2[223:192]\nDEST[255:224] := SRC1[255:224]-SRC2[255:224]\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := SRC1[31:0]-SRC2[31:0]\nDEST[63:32] := SRC1[63:32]-SRC2[63:32]\nDEST[95:64] := SRC1[95:64]-SRC2[95:64]\nDEST[127:96] := SRC1[127:96]-SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := DEST[31:0]-SRC[31:0]\nDEST[63:32] := DEST[63:32]-SRC[63:32]\nDEST[95:64] := DEST[95:64]-SRC[95:64]\nDEST[127:96] := DEST[127:96]-SRC[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPSUBD, see Table 2-49, “Type E4 Class Exception Conditions.”",
        "EVEX-encoded VPSUBB/W, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pause",
    "category": "Core Instructions",
    "instructionName": "PAUSE\n\t\t— Spin Loop Hint",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Gives hint to processor that improves performance of spin-wait loops.",
        "Instruction": "PAUSE",
        "Op/En": "ZO",
        "Opcode": "F3 90"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Improves the performance of spin-wait loops. When executing a “spin-wait loop,” processors will suffer a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.\nAn additional function of the PAUSE instruction is to reduce the power consumed by a processor while executing a spin loop. A processor can execute a spin-wait loop extremely quickly, causing the processor to consume a lot of power while it waits for the resource it is spinning on to become available. Inserting a pause instruction in a spin-wait loop greatly reduces the processor’s power consumption.\nThis instruction was introduced in the Pentium 4 processors, but is backward compatible with all IA-32 processors. In earlier IA-32 processors, the PAUSE instruction operates like a NOP instruction. The Pentium 4 and Intel Xeon processors implement the PAUSE instruction as a delay. The delay is finite and can be zero for some processors. This instruction does not change the architectural state of the processor (that is, it performs essentially a delaying no-op operation).\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "Execute_Next_Instruction(DELAY);",
    "flagsAffectedText": "",
    "exceptions": {
      "numeric¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmovb2m:vpmovw2m:vpmovd2m:vpmovq2m",
    "category": "Core Instructions",
    "instructionName": "VPMOVB2M/VPMOVW2M/VPMOVD2M/VPMOVQ2M\n\t\t— Convert a Vector Register to a Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in XMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 29 /r VPMOVB2M k1, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in YMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 29 /r VPMOVB2M k1, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in ZMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 29 /r VPMOVB2M k1, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in XMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W1 29 /r VPMOVW2M k1, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in YMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W1 29 /r VPMOVW2M k1, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in ZMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W1 29 /r VPMOVW2M k1, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in XMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 39 /r VPMOVD2M k1, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in YMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 39 /r VPMOVD2M k1, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in ZMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 39 /r VPMOVD2M k1, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in XMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W1 39 /r VPMOVQ2M k1, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in YMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W1 39 /r VPMOVQ2M k1, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in ZMM1.",
        "Op/En": "RM",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W1 39 /r VPMOVQ2M k1, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdpid",
    "category": "Core Instructions",
    "instructionName": "RDPID\n\t\t— Read Processor ID",
    "detailsTable": [
      {
        "64/32-bit Mode": "N.E./V",
        "CPUID Feature Flag": "RDPID",
        "Description": "Read IA32_TSC_AUX into r32.",
        "Op/En": "R",
        "Opcode/Instruction": "F3 0F C7 /7 RDPID r32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "RDPID",
        "Description": "Read IA32_TSC_AUX into r64.",
        "Op/En": "R",
        "Opcode/Instruction": "F3 0F C7 /7 RDPID r64"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the destination register. The value of CS.D and operand-size prefixes (66H and REX.W) do not affect the behavior of the RDPID instruction.",
    "operationText": "DEST := IA32_TSC_AUX",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CPUID.7H.0:ECX.RDPID[bit 22] = 0.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fsin",
    "category": "Core Instructions",
    "instructionName": "FSIN\n\t\t— Sine",
    "detailsTable": [
      {
        "Description": "Replace ST(0) with the approximate of its sine.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 FE",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes an approximation of the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −263 to +263. The following table shows the results obtained when taking the sine of various classes of numbers, assuming that underflow does not occur.\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range − 263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π. However, even within the range -263 to +263, inaccurate results can occur because the finite approximation of π used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply FSIN only to arguments reduced accurately in software, to a value smaller in absolute value than 3π/4. See the sections titled “Approximation of Pi” and “Transcendental Instruction Accuracy” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a discussion of the proper value to use for π in performing such reductions.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF -263 < ST(0) < 263\n    THEN\n        C2 := 0;\n        ST(0) := fsin(ST(0)); // approximation of the mathematical sin function\n    ELSE (* Source operand out of range *)\n        C2 := 1;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value, ∞, or unsupported format.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/unpcklps",
    "category": "Core Instructions",
    "instructionName": "UNPCKLPS\n\t\t— Unpack and Interleave Low Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Unpacks and Interleaves single precision floating-point values from low quadwords of xmm1 and xmm2/m128.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 14 /r UNPCKLPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Unpacks and Interleaves single precision floating-point values from low quadwords of xmm2 and xmm3/m128.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 14 /r VUNPCKLPS xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Unpacks and Interleaves single precision floating-point values from low quadwords of ymm2 and ymm3/m256.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 14 /r VUNPCKLPS ymm1,ymm2,ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Unpacks and Interleaves single precision floating-point values from low quadwords of xmm2 and xmm3/mem and write result to xmm1 subject to write mask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 14 /r VUNPCKLPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Unpacks and Interleaves single precision floating-point values from low quadwords of ymm2 and ymm3/mem and write result to ymm1 subject to write mask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 14 /r VUNPCKLPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Unpacks and Interleaves single precision floating-point values from low quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to write mask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 14 /r VUNPCKLPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs an interleaved unpack of the low single precision floating-point values from the first source operand and the second source operand.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\nEVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\nEVEX.128 encoded version: The first source operand is an XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF VL >= 128\n    TMP_DEST[31:0] := SRC1[31:0]\n    TMP_DEST[63:32] := SRC2[31:0]\n    TMP_DEST[95:64] := SRC1[63:32]\n    TMP_DEST[127:96] := SRC2[63:32]\nFI;\nIF VL >= 256\n    TMP_DEST[159:128] := SRC1[159:128]\n    TMP_DEST[191:160] := SRC2[159:128]\n    TMP_DEST[223:192] := SRC1[191:160]\n    TMP_DEST[255:224] := SRC2[191:160]\nFI;\nIF VL >= 512\n    TMP_DEST[287:256] := SRC1[287:256]\n    TMP_DEST[319:288] := SRC2[287:256]\n    TMP_DEST[351:320] := SRC1[319:288]\n    TMP_DEST[383:352] := SRC2[319:288]\n    TMP_DEST[415:384] := SRC1[415:384]\n    TMP_DEST[447:416] := SRC2[415:384]\n    TMP_DEST[479:448] := SRC1[447:416]\n    TMP_DEST[511:480] := SRC2[447:416]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 31\n    IF (EVEX.b = 1)\n        THEN TMP_SRC2[i+31:i] := SRC2[31:0]\n        ELSE TMP_SRC2[i+31:i] := SRC2[i+31:i]\n    FI;\nENDFOR;\nIF VL >= 128\nTMP_DEST[31:0] := SRC1[31:0]\nTMP_DEST[63:32] := TMP_SRC2[31:0]\nTMP_DEST[95:64] := SRC1[63:32]\nTMP_DEST[127:96] := TMP_SRC2[63:32]\nFI;\nIF VL >= 256\n    TMP_DEST[159:128] := SRC1[159:128]\n    TMP_DEST[191:160] := TMP_SRC2[159:128]\n    TMP_DEST[223:192] := SRC1[191:160]\n    TMP_DEST[255:224] := TMP_SRC2[191:160]\nFI;\nIF VL >= 512\n    TMP_DEST[287:256] := SRC1[287:256]\n    TMP_DEST[319:288] := TMP_SRC2[287:256]\n    TMP_DEST[351:320] := SRC1[319:288]\n    TMP_DEST[383:352] := TMP_SRC2[319:288]\n    TMP_DEST[415:384] := SRC1[415:384]\n    TMP_DEST[447:416] := TMP_SRC2[415:384]\n    TMP_DEST[479:448] := SRC1[447:416]\n    TMP_DEST[511:480] := TMP_SRC2[447:416]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking* ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC1[31:0]\nDEST[63:32] := SRC2[31:0]\nDEST[95:64] := SRC1[63:32]\nDEST[127:96] := SRC2[63:32]\nDEST[159:128] := SRC1[159:128]\nDEST[191:160] := SRC2[159:128]\nDEST[223:192] := SRC1[191:160]\nDEST[255:224] := SRC2[191:160]\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := SRC1[31:0]\nDEST[63:32] := SRC2[31:0]\nDEST[95:64] := SRC1[63:32]\nDEST[127:96] := SRC2[63:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0]\nDEST[63:32] := SRC2[31:0]\nDEST[95:64] := SRC1[63:32]\nDEST[127:96] := SRC2[63:32]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instructions, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/arpl",
    "category": "Core Instructions",
    "instructionName": "ARPL\n\t\t— Adjust RPL Field of Segment Selector",
    "detailsTable": [
      {
        "64-bit Mode": "N. E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Adjust RPL of r/m16 to not less than RPL of r16.",
        "Instruction": "ARPL r/m16, r16",
        "Op/En": "MR",
        "Opcode": "63 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0 and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand, the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand. Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can be a word register or a memory location; the source operand must be a word register.)\nThe ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applications). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system by an application program to match the privilege level of the application program. Here the segment selector passed to the operating system is placed in the destination operand and segment selector for the application program’s code segment is placed in the source operand. (The RPL field in the source operand represents the privilege level of the application program.) Execution of the ARPL instruction then ensures that the RPL of the segment selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of the application program (the segment selector for the application program’s code segment can be read from the stack following a procedure call).\nThis instruction executes as described in compatibility mode and legacy mode. It is not encodable in 64-bit mode.\nSee “Checking Caller Access Privileges” in Chapter 3, “Protected-Mode Memory Management,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for more information about the use of this instruction.",
    "operationText": "IF 64-BIT MODE\n    THEN\n        See MOVSXD;\n    ELSE\n        IF DEST[RPL] < SRC[RPL]\n            THEN\n                ZF := 1;\n                DEST[RPL] := SRC[RPL];\n            ELSE\n                ZF := 0;\n        FI;\nFI;",
    "flagsAffectedText": "The ZF flag is set to 1 if the RPL field of the destination operand is less than that of the source operand; otherwise, it is set to 0.",
    "exceptions": {
      "64BitMode": [
        "Not applicable."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/stos:stosb:stosw:stosd:stosq",
    "category": "Core Instructions",
    "instructionName": "STOS/STOSB/STOSW/STOSD/STOSQ\n\t\t— Store String",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.",
        "Instruction": "STOS m8",
        "Op/En": "ZO",
        "Opcode": "AA"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.",
        "Instruction": "STOS m16",
        "Op/En": "ZO",
        "Opcode": "AB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.",
        "Instruction": "STOS m32",
        "Op/En": "ZO",
        "Opcode": "AB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store RAX at address RDI or EDI.",
        "Instruction": "STOS m64",
        "Op/En": "ZO",
        "Opcode": "REX.W + AB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.",
        "Instruction": "STOSB",
        "Op/En": "ZO",
        "Opcode": "AA"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.",
        "Instruction": "STOSW",
        "Op/En": "ZO",
        "Opcode": "AB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.",
        "Instruction": "STOSD",
        "Op/En": "ZO",
        "Opcode": "AB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store RAX at address RDI or EDI.",
        "Instruction": "STOSQ",
        "Op/En": "ZO",
        "Opcode": "REX.W + AB"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.\nAt the assembly-code level, two forms of the instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.\nThe no-operands form provides “short forms” of the byte, word, doubleword, and quadword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), STOSD (doubleword from EAX).\nAfter the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).\nIn 64-bit mode, the default address size is 64 bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The promoted no-operand mnemonic is STOSQ. STOSQ (and its explicit operands variant) store a quadword from the RAX register into the destination addressed by RDI or EDI. See the summary chart at the beginning of this section for encoding data and limits.\nThe STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the REP prefix for block stores of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
    "operationText": "IF (Byte store)\n    THEN\n        DEST := AL;\n            THEN IF DF = 0\n                THEN (E)DI := (E)DI + 1;\n                ELSE (E)DI := (E)DI – 1;\n            FI;\n    ELSE IF (Word store)\n        THEN\n            DEST := AX;\n                THEN IF DF = 0\n                    THEN (E)DI := (E)DI + 2;\n                    ELSE (E)DI := (E)DI – 2;\n                FI;\n        FI;\n    ELSE IF (Doubleword store)\n        THEN\n            DEST := EAX;\n                THEN IF DF = 0\n                    THEN (E)DI := (E)DI + 4;\n                    ELSE (E)DI := (E)DI – 4;\n                FI;\n        FI;\nFI;\nIF (Byte store)\n    THEN\n        DEST := AL;\n            THEN IF DF = 0\n                THEN (R|E)DI := (R|E)DI + 1;\n                ELSE (R|E)DI := (R|E)DI – 1;\n            FI;\n    ELSE IF (Word store)\n        THEN\n            DEST := AX;\n                THEN IF DF = 0\n                    THEN (R|E)DI := (R|E)DI + 2;\n                    ELSE (R|E)DI := (R|E)DI – 2;\n                FI;\n        FI;\n    ELSE IF (Doubleword store)\n        THEN\n            DEST := EAX;\n                THEN IF DF = 0\n                    THEN (R|E)DI := (R|E)DI + 4;\n                    ELSE (R|E)DI := (R|E)DI – 4;\n                FI;\n        FI;\n    ELSE IF (Quadword store using REX.W )\n        THEN\n            DEST := RAX;\n                THEN IF DF = 0\n                    THEN (R|E)DI := (R|E)DI + 8;\n                    ELSE (R|E)DI := (R|E)DI – 8;\n                FI;\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the limit of the ES segment.; \ncolumn_1: If the ES register contains a NULL segment selector.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fisttp",
    "category": "Core Instructions",
    "instructionName": "FISTTP\n\t\t— Store Integer With Truncation",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store ST(0) in m16int with truncation.",
        "Instruction": "FISTTP m16int",
        "Opcode": "DF /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store ST(0) in m32int with truncation.",
        "Instruction": "FISTTP m32int",
        "Opcode": "DB /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store ST(0) in m64int with truncation.",
        "Instruction": "FISTTP m64int",
        "Opcode": "DD /1"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.\nThe following table shows the results obtained when storing various classes of numbers in integer format.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "DEST := ST;\npop ST;",
    "flagsAffectedText": "C1 is cleared; C0, C2, C3 undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "numeric¶": [
        "Invalid, Stack Invalid (stack underflow), Precision."
      ],
      "protectedMode": [
        "column_1: For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #NM; column_2: If CR0.EM[bit 2] = 1.; \ncolumn_1: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.SSE3[bit 0] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode¶": [
        "GP(0) If any part of the operand would lie outside of the effective address space from 0 to 0FFFFH.",
        "column_1: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.SSE3[bit 0] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode¶": [
        "GP(0) If any part of the operand would lie outside of the effective address space from 0 to 0FFFFH.",
        "column_1: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.SSE3[bit 0] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #AC(0); column_2: For unaligned memory reference if the current privilege is 3.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sub",
    "category": "Core Instructions",
    "instructionName": "SUB\n\t\t— Subtract",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract imm8 from AL.",
        "Instruction": "SUB AL, imm8",
        "Op/En": "I",
        "Opcode": "2C ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract imm16 from AX.",
        "Instruction": "SUB AX, imm16",
        "Op/En": "I",
        "Opcode": "2D iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract imm32 from EAX.",
        "Instruction": "SUB EAX, imm32",
        "Op/En": "I",
        "Opcode": "2D id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract imm32 sign-extended to 64-bits from RAX.",
        "Instruction": "SUB RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + 2D id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract imm8 from r/m8.",
        "Instruction": "SUB r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "80 /5 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract imm8 from r/m8.",
        "Instruction": "SUB r/m81, imm8",
        "Op/En": "MI",
        "Opcode": "REX + 80 /5 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract imm16 from r/m16.",
        "Instruction": "SUB r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "81 /5 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract imm32 from r/m32.",
        "Instruction": "SUB r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "81 /5 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract imm32 sign-extended to 64-bits from r/m64.",
        "Instruction": "SUB r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + 81 /5 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract sign-extended imm8 from r/m16.",
        "Instruction": "SUB r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "83 /5 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract sign-extended imm8 from r/m32.",
        "Instruction": "SUB r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "83 /5 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract sign-extended imm8 from r/m64.",
        "Instruction": "SUB r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 83 /5 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract r8 from r/m8.",
        "Instruction": "SUB r/m8, r8",
        "Op/En": "MR",
        "Opcode": "28 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract r8 from r/m8.",
        "Instruction": "SUB r/m81, r81",
        "Op/En": "MR",
        "Opcode": "REX + 28 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract r16 from r/m16.",
        "Instruction": "SUB r/m16, r16",
        "Op/En": "MR",
        "Opcode": "29 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract r32 from r/m32.",
        "Instruction": "SUB r/m32, r32",
        "Op/En": "MR",
        "Opcode": "29 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract r64 from r/m64.",
        "Instruction": "SUB r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 29 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract r/m8 from r8.",
        "Instruction": "SUB r8, r/m8",
        "Op/En": "RM",
        "Opcode": "2A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract r/m8 from r8.",
        "Instruction": "SUB r81, r/m81",
        "Op/En": "RM",
        "Opcode": "REX + 2A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract r/m16 from r16.",
        "Instruction": "SUB r16, r/m16",
        "Op/En": "RM",
        "Opcode": "2B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract r/m32 from r32.",
        "Instruction": "SUB r32, r/m32",
        "Op/En": "RM",
        "Opcode": "2B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract r/m64 from r64.",
        "Instruction": "SUB r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 2B /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\nThe SUB instruction performs integer subtraction. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate an overflow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
    "operationText": "DEST := (DEST – SRC);",
    "flagsAffectedText": "The OF, SF, ZF, AF, PF, and CF flags are set according to the result.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_2: If the LOCK prefix is used but the destination is not a memory operand.; column_1: #UD;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/clui",
    "category": "Core Instructions",
    "instructionName": "CLUI\n\t\t— Clear User Interrupt Flag",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "UINTR",
        "Description": "Clear user interrupt flag; user interrupts blocked when user interrupt flag cleared.",
        "Op/En": "ZO",
        "Opcode/Instruction": "F3 0F 01 EE CLUI"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: If executed inside an enclave.; \ncolumn_1: If CR4.UINTR = 0.; \ncolumn_1: If CPUID.07H.0H:EDX.UINTR[bit 5] = 0.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/edecvirtchild",
    "category": "SGX Instructions",
    "instructionName": "EDECVIRTCHILD\n\t\t— Decrement VIRTCHILDCNT in SECS",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "EAX[5]",
        "Description": "This leaf function decrements the SECS VIRTCHILDCNT field.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 00H ENCLV[EDECVIRTCHILD]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EDECVIRTCHILD (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Address of an enclave page (In)",
        "column_5": "Address of an SECS page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmadd52luq",
    "category": "Core Instructions",
    "instructionName": "VPMADD52LUQ\n\t\t— Packed Multiply of Unsigned 52-Bit Integers and Add the Low 52-Bit Productsto Qword Accumulators",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID": "AVX512_IFMA AVX512VL",
        "Description": "Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 B4 /r VPMADD52LUQ xmm1 {k1}{z}, xmm2,xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID": "AVX512_IFMA AVX512VL",
        "Description": "Multiply unsigned 52-bit integers in ymm2 and ymm3/m256 and add the low 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 B4 /r VPMADD52LUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID": "AVX512_IFMA",
        "Description": "Multiply unsigned 52-bit integers in zmm2 and zmm3/m512 and add the low 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 B4 /r VPMADD52LUQ zmm1 {k1}{z}, zmm2,zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m(r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetexpss",
    "category": "Core Instructions",
    "instructionName": "VGETEXPSS\n\t\t— Convert Exponents of Scalar Single Precision Floating-Point Value to SinglePrecision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert the biased exponent (bits 30:23) of the low single-precision floating-point value in xmm3/m32 to a single-precision floating-point value representing unbiased integer exponent. Stores the result to xmm1 under the writemask k1 and merge with the other elements of xmm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 43 /r VGETEXPSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/invpcid",
    "category": "Core Instructions",
    "instructionName": "INVPCID\n\t\t— Invalidate Process-Context Identifier",
    "detailsTable": [
      {
        "64/32-bit Mode": "N.E./V",
        "CPUID Feature Flag": "INVPCID",
        "Description": "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r32 and descriptor in m128.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 82 /r INVPCID r32, m128"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "INVPCID",
        "Description": "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 82 /r INVPCID r64, m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on process-context identifier (PCID). (See Section 4.10, “Caching Translation Information,” in the Intel 64 and IA-32 Architecture Software Developer’s Manual, Volume 3A.) Invalidation is based on the INVPCID type specified in the register operand and the INVPCID descriptor specified in the memory operand.\nOutside 64-bit mode, the register operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode the register operand has 64 bits.\nThere are four INVPCID types currently defined:\nThe INVPCID descriptor comprises 128 bits and consists of a PCID and a linear address as shown in Figure 3-25. For INVPCID type 0, the processor uses the full 64 bits of the linear address even outside 64-bit mode; the linear address is not used for other INVPCID types.\nIf CR4.PCIDE = 0, a logical processor does not cache information for any PCID other than 000H. In this case, executions with INVPCID types 0 and 1 are allowed only if the PCID specified in the INVPCID descriptor is 000H; executions with INVPCID types 2 and 3 invalidate mappings only for PCID 000H. Note that CR4.PCIDE must be 0 outside IA-32e mode (see Section 4.10.1, “Process-Context Identifiers (PCIDs),” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A).",
    "operationText": "INVPCID_TYPE := value of register operand; // must be in the range of 0–3\nINVPCID_DESC := value of memory operand;\nCASE INVPCID_TYPE OF\n    0:\n            // individual-address invalidation\n        PCID := INVPCID_DESC[11:0];\n        L_ADDR := INVPCID_DESC[127:64];\n        Invalidate mappings for L_ADDR associated with PCID except global translations;\n        BREAK;\n    1:\n            // single PCID invalidation\n        PCID := INVPCID_DESC[11:0];\n        Invalidate all mappings associated with PCID except global translations;\n        BREAK;\n    2:\n            // all PCID invalidation including global translations\n        Invalidate all mappings for all PCIDs, including global translations;\n        BREAK;\n    3:\n            // all PCID invalidation retaining global translations\n        Invalidate all mappings for all PCIDs except global translations;\n        BREAK;\nESAC;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: If the memory operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.; \ncolumn_1: If an invalid type is specified in the register operand, i.e., INVPCID_TYPE > 3.; \ncolumn_1: If bits 63:12 of INVPCID_DESC are not all zero.; \ncolumn_1: If CR4.PCIDE=0, INVPCID_TYPE is either 0 or 1, and INVPCID_DESC[11:0] is not zero.; \ncolumn_1: If INVPCID_TYPE is 0 and the linear address in INVPCID_DESC[127:64] is not canonical.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory operand.; \ncolumn_2: If the memory destination operand is in the SS segment and the memory address is in a non-canonical form.; column_1: #SS(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If CPUID.(EAX=07H, ECX=0H):EBX.INVPCID[bit 10] = 0.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the source operand is located in an execute-only code segment.; \ncolumn_1: If an invalid type is specified in the register operand, i.e., INVPCID_TYPE > 3.; \ncolumn_1: If bits 63:12 of INVPCID_DESC are not all zero.; \ncolumn_1: If INVPCID_TYPE is either 0 or 1 and INVPCID_DESC[11:0] is not zero.; \ncolumn_1: If INVPCID_TYPE is 0 and the linear address in INVPCID_DESC[127:64] is not canonical.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory operand.; \ncolumn_1: #SS(0); column_2: If the memory operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_1: #UD; column_2: If if CPUID.(EAX=07H, ECX=0H):EBX.INVPCID[bit 10] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If bits 63:12 of INVPCID_DESC are not all zero.; \ncolumn_1: If INVPCID_TYPE is either 0 or 1 and INVPCID_DESC[11:0] is not zero.; \ncolumn_1: If INVPCID_TYPE is 0 and the linear address in INVPCID_DESC[127:64] is not canonical.; \ncolumn_1: #UD; column_2: If CPUID.(EAX=07H, ECX=0H):EBX.INVPCID[bit 10] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/eadd",
    "category": "SGX Instructions",
    "instructionName": "EADD\n\t\t— Add a Page to an Uninitialized Enclave",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function adds a page to an uninitialized enclave.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 01H ENCLS[EADD]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EADD (In)",
        "column_3": "Address of a PAGEINFO (In)",
        "column_4": "Address of the destination EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpexpandd",
    "category": "Core Instructions",
    "instructionName": "VPEXPANDD\n\t\t— Load Sparse Packed Doubleword Integer Values From Dense Memory/Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Expand packed double-word integer values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 89 /r VPEXPANDD xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Expand packed double-word integer values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 89 /r VPEXPANDD ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Expand packed double-word integer values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 89 /r VPEXPANDD zmm1 {k1}{z}, zmm2/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/unpcklpd",
    "category": "Core Instructions",
    "instructionName": "UNPCKLPD\n\t\t— Unpack and Interleave Low Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Unpacks and Interleaves double precision floating-point values from low quadwords of xmm1 and xmm2/m128.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 14 /r UNPCKLPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Unpacks and Interleaves double precision floating-point values from low quadwords of xmm2 and xmm3/m128.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 14 /r VUNPCKLPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Unpacks and Interleaves double precision floating-point values from low quadwords of ymm2 and ymm3/m256.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 14 /r VUNPCKLPD ymm1,ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Unpacks and Interleaves double precision floating-point values from low quadwords of xmm2 and xmm3/m128/m64bcst subject to write mask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 14 /r VUNPCKLPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Unpacks and Interleaves double precision floating-point values from low quadwords of ymm2 and ymm3/m256/m64bcst subject to write mask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 14 /r VUNPCKLPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Unpacks and Interleaves double precision floating-point values from low quadwords of zmm2 and zmm3/m512/m64bcst subject to write mask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 14 /r VUNPCKLPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs an interleaved unpack of the low double precision floating-point values from the first source operand and the second source operand.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\nEVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\nEVEX.128 encoded version: The first source operand is an XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF VL >= 128\n    TMP_DEST[63:0] := SRC1[63:0]\n    TMP_DEST[127:64] := SRC2[63:0]\nFI;\nIF VL >= 256\n    TMP_DEST[191:128] := SRC1[191:128]\n    TMP_DEST[255:192] := SRC2[191:128]\nFI;\nIF VL >= 512\n    TMP_DEST[319:256] := SRC1[319:256]\n    TMP_DEST[383:320] := SRC2[319:256]\n    TMP_DEST[447:384] := SRC1[447:384]\n    TMP_DEST[511:448] := SRC2[447:384]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF (EVEX.b = 1)\n        THEN TMP_SRC2[i+63:i] := SRC2[63:0]\n        ELSE TMP_SRC2[i+63:i] := SRC2[i+63:i]\n    FI;\nENDFOR;\nIF VL >= 128\n    TMP_DEST[63:0] := SRC1[63:0]\n    TMP_DEST[127:64] := TMP_SRC2[63:0]\nFI;\nIF VL >= 256\n    TMP_DEST[191:128] := SRC1[191:128]\n    TMP_DEST[255:192] := TMP_SRC2[191:128]\nFI;\nIF VL >= 512\n    TMP_DEST[319:256] := SRC1[319:256]\n    TMP_DEST[383:320] := TMP_SRC2[319:256]\n    TMP_DEST[447:384] := SRC1[447:384]\n    TMP_DEST[511:448] := TMP_SRC2[447:384]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC1[63:0]\nDEST[127:64] := SRC2[63:0]\nDEST[191:128] := SRC1[191:128]\nDEST[255:192] := SRC2[191:128]\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := SRC1[63:0]\nDEST[127:64] := SRC2[63:0]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0]\nDEST[127:64] := SRC2[63:0]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instructions, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movlhps",
    "category": "Core Instructions",
    "instructionName": "MOVLHPS\n\t\t— Move Packed Single Precision Floating-Point Values Low to High",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move two packed single precision floating-point values from low quadword of xmm2 to high quadword of xmm1.",
        "Op / En": "RM",
        "Opcode/Instruction": "NP 0F 16 /r MOVLHPS xmm1, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge two packed single precision floating-point values from low quadword of xmm3 and low quadword of xmm2.",
        "Op / En": "RVM",
        "Opcode/Instruction": "VEX.128.0F.WIG 16 /r VMOVLHPS xmm1, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Merge two packed single precision floating-point values from low quadword of xmm3 and low quadword of xmm2.",
        "Op / En": "RVM",
        "Opcode/Instruction": "EVEX.128.0F.W0 16 /r VMOVLHPS xmm1, xmm2, xmm3"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "This instruction cannot be used for memory to register moves.\n128-bit two-argument form:\nMoves two packed single precision floating-point values from the low quadword of the second XMM argument (second operand) to the high quadword of the first XMM register (first argument). The low quadword of the destination operand is left unchanged. Bits (MAXVL-1:128) of the corresponding destination register are unmodified.\n128-bit three-argument forms:\nMoves two packed single precision floating-point values from the low quadword of the third XMM argument (third operand) to the high quadword of the destination (first operand). Copies the low quadword from the second XMM argument (second operand) to the low quadword of the destination (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nIf VMOVLHPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception.",
    "operationText": "DEST[63:0] (Unmodified)\nDEST[127:64] := SRC[63:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := SRC1[63:0]\nDEST[127:64] := SRC2[63:0]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-24, “Type 7 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Exceptions Type E7NM.128 in Table 2-55, “Type E7NM Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtudq2pd",
    "category": "Core Instructions",
    "instructionName": "VCVTUDQ2PD\n\t\t— Convert Packed Unsigned Doubleword Integers to Packed Double PrecisionFloating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert two packed unsigned doubleword integers from ymm2/m64/m32bcst to packed double precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F.W0 7A /r VCVTUDQ2PD xmm1 {k1}{z}, xmm2/m64/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed double precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F.W0 7A /r VCVTUDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to eight packed double precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F.W0 7A /r VCVTUDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtpi2pd",
    "category": "Core Instructions",
    "instructionName": "CVTPI2PD\n\t\t— Convert Packed Dword Integers to Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Convert two packed signed doubleword integers from mm/mem64 to two packed double precision floating-point values in xmm.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 2A /r CVTPI2PD xmm, mm/m641"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Converts two packed signed doubleword integers in the source operand (second operand) to two packed double precision floating-point values in the destination operand (first operand).\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. In addition, depending on the operand configuration:\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0]);\nDEST[127:64] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:32]);",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 23-6, “Exception Conditions for Legacy SIMD/MMX Instructions with XMM and without FP Exception” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsub132ss:vfmsub213ss:vfmsub231ss",
    "category": "Core Instructions",
    "instructionName": "VFMSUB132SS/VFMSUB213SS/VFMSUB231SS\n\t\t— Fused Multiply-Subtract of Scalar SinglePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 9B /r VFMSUB132SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 AB /r VFMSUB213SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 BB /r VFMSUB231SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 9B /r VFMSUB132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 AB /r VFMSUB213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 BB /r VFMSUB231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfnmadd132sd:vfnmadd213sd:vfnmadd231sd",
    "category": "Core Instructions",
    "instructionName": "VFNMADD132SD/VFNMADD213SD/VFNMADD231SD\n\t\t— Fused Negative Multiply-Add of ScalarDouble Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 9D /r VFNMADD132SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 AD /r VFNMADD213SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 BD /r VFNMADD231SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and add to xmm2 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 9D /r VFNMADD132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m64 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 AD /r VFNMADD213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and add to xmm1 and put result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 BD /r VFNMADD231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpexpandb:vpexpandw",
    "category": "Core Instructions",
    "instructionName": "VPEXPANDB/VPEXPANDW\n\t\t— Expand Byte/Word Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Expands up to 128 bits of packed byte values from m128 to xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 62 /r VPEXPANDB xmm1{k1}{z}, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Expands up to 128 bits of packed byte values from xmm2 to xmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 62 /r VPEXPANDB xmm1{k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Expands up to 256 bits of packed byte values from m256 to ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 62 /r VPEXPANDB ymm1{k1}{z}, m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Expands up to 256 bits of packed byte values from ymm2 to ymm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 62 /r VPEXPANDB ymm1{k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Expands up to 512 bits of packed byte values from m512 to zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 62 /r VPEXPANDB zmm1{k1}{z}, m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Expands up to 512 bits of packed byte values from zmm2 to zmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 62 /r VPEXPANDB zmm1{k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Expands up to 128 bits of packed word values from m128 to xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 62 /r VPEXPANDW xmm1{k1}{z}, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Expands up to 128 bits of packed word values from xmm2 to xmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 62 /r VPEXPANDW xmm1{k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Expands up to 256 bits of packed word values from m256 to ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 62 /r VPEXPANDW ymm1{k1}{z}, m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Expands up to 256 bits of packed word values from ymm2 to ymm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 62 /r VPEXPANDW ymm1{k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Expands up to 512 bits of packed word values from m512 to zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 62 /r VPEXPANDW zmm1{k1}{z}, m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Expands up to 512 bits of packed byte integer values from zmm2 to zmm1 with writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 62 /r VPEXPANDW zmm1{k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Tuple1 Scalar"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmfunc",
    "category": "VMX Instructions",
    "instructionName": "VMFUNC\n\t\t— Invoke VM function",
    "detailsTable": [
      {
        "Description": "Invoke VM function specified in EAX.",
        "Op/En": "ZO",
        "Opcode/Instruction": "NP 0F 01 D4 VMFUNC"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "ZO",
        "column_2": "NA",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "This instruction allows software in VMX non-root operation to invoke a VM function, which is processor functionality enabled and configured by software in VMX root operation. The value of EAX selects the specific VM function being invoked.\nThe behavior of each VM function (including any additional fault checking) is specified in Section 26.5.6, “VM Functions.”",
    "operationText": "Perform functionality of the VM function specified in EAX;",
    "flagsAffectedText": "Depends on the VM function specified in EAX. See Section 26.5.6, “VM Functions.”",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual-8086¶": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmaxph",
    "category": "Core Instructions",
    "instructionName": "VMAXPH\n\t\t— Return Maximum of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Return the maximum packed FP16 values between xmm2 and xmm3/m128/m16bcst and store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 5F /r VMAXPH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Return the maximum packed FP16 values between ymm2 and ymm3/m256/m16bcst and store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 5F /r VMAXPH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Return the maximum packed FP16 values between zmm2 and zmm3/m512/m16bcst and store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 5F /r VMAXPH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrndscaleps",
    "category": "Core Instructions",
    "instructionName": "VRNDSCALEPS\n\t\t— Round Packed Float32 Values to Include a Given Number of Fraction Bits",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rounds packed single-precision floating-point values in xmm2/m128/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 08 /r ib VRNDSCALEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rounds packed single-precision floating-point values in ymm2/m256/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 08 /r ib VRNDSCALEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rounds packed single-precision floating-point values in zmm2/m512/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register using writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 08 /r ib VRNDSCALEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttph2uqq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPH2UQQ\n\t\t— Convert with Truncation Packed FP16 Values to Unsigned Quadword Integers",
    "detailsTable": [
      {
        "Description": "Convert two packed FP16 values in xmm2/m32/m16bcst to two unsigned quadword integers, and store the result in xmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.W0 78 /r VCVTTPH2UQQ xmm1{k1}{z}, xmm2/m32/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four unsigned quadword integers, and store the result in ymm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP5.W0 78 /r VCVTTPH2UQQ ymm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned quadword integers, and store the result in zmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP5.W0 78 /r VCVTTPH2UQQ zmm1{k1}{z}, xmm2/m128/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Quarter"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/unpckhpd",
    "category": "Core Instructions",
    "instructionName": "UNPCKHPD\n\t\t— Unpack and Interleave High Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Unpacks and Interleaves double precision floating-point values from high quadwords of xmm1 and xmm2/m128.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 15 /r UNPCKHPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 15 /r VUNPCKHPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 15 /r VUNPCKHPD ymm1,ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 15 /r VUNPCKHPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 15 /r VUNPCKHPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Unpacks and Interleaves double precision floating-point values from high quadwords of zmm2 and zmm3/m512/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 15 /r VUNPCKHPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs an interleaved unpack of the high double precision floating-point values from the first source operand and the second source operand. See Figure 4-15 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.\nEVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.\nEVEX.128 encoded version: The first source operand is a XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF VL >= 128\n    TMP_DEST[63:0] := SRC1[127:64]\n    TMP_DEST[127:64] := SRC2[127:64]\nFI;\nIF VL >= 256\n    TMP_DEST[191:128] := SRC1[255:192]\n    TMP_DEST[255:192] := SRC2[255:192]\nFI;\nIF VL >= 512\n    TMP_DEST[319:256] := SRC1[383:320]\n    TMP_DEST[383:320] := SRC2[383:320]\n    TMP_DEST[447:384] := SRC1[511:448]\n    TMP_DEST[511:448] := SRC2[511:448]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF (EVEX.b = 1)\n        THEN TMP_SRC2[i+63:i] := SRC2[63:0]\n        ELSE TMP_SRC2[i+63:i] := SRC2[i+63:i]\n    FI;\nENDFOR;\nIF VL >= 128\n    TMP_DEST[63:0] := SRC1[127:64]\n    TMP_DEST[127:64] := TMP_SRC2[127:64]\nFI;\nIF VL >= 256\n    TMP_DEST[191:128] := SRC1[255:192]\n    TMP_DEST[255:192] := TMP_SRC2[255:192]\nFI;\nIF VL >= 512\n    TMP_DEST[319:256] := SRC1[383:320]\n    TMP_DEST[383:320] := TMP_SRC2[383:320]\n    TMP_DEST[447:384] := SRC1[511:448]\n    TMP_DEST[511:448] := TMP_SRC2[511:448]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC1[127:64]\nDEST[127:64] := SRC2[127:64]\nDEST[191:128] := SRC1[255:192]\nDEST[255:192] := SRC2[255:192]\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := SRC1[127:64]\nDEST[127:64] := SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[127:64]\nDEST[127:64] := SRC2[127:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instructions, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtph2qq",
    "category": "Core Instructions",
    "instructionName": "VCVTPH2QQ\n\t\t— Convert Packed FP16 Values to Signed Quadword Integer Values",
    "detailsTable": [
      {
        "Description": "Convert two packed FP16 values in xmm2/m32/m16bcst to two signed quadword integers, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.W0 7B /r VCVTPH2QQ xmm1{k1}{z}, xmm2/m32/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four signed quadword integers, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP5.W0 7B /r VCVTPH2QQ ymm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed quadword integers, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP5.W0 7B /r VCVTPH2QQ zmm1{k1}{z}, xmm2/m128/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Quarter"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fprem1",
    "category": "Core Instructions",
    "instructionName": "FPREM1\n\t\t— Partial Remainder",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1).",
        "Instruction": "FPREM1",
        "Opcode": "D9 F5"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:\nRemainder := ST(0) − (Q ∗ ST(1))\nHere, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)] toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the modulus, unless a partial remainder was computed (as described below).\nThis instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur.\nWhen the result is 0, its sign is the same as that of the dividend. When the modulus is ∞, the result is equal to the value in ST(0).\nThe FPREM1 instruction computes the remainder specified in IEEE Standard 754. This instruction operates differently from the FPREM instruction in the way that it rounds the quotient of ST(0) divided by ST(1) to an integer (see the “Operation” section below).\nLike the FPREM instruction, FPREM1 computes the remainder through iterative subtraction, but can reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than one half the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.)\nAn important use of the FPREM1 instruction is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU status word. This information is important in argument reduction for the tangent function (using a modulus of π/4), because it locates the original angle in the correct one of eight sectors of the unit circle.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "D := exponent(ST(0)) – exponent(ST(1));\nIF D < 64\n    THEN\n        Q := Integer(RoundTowardNearestInteger(ST(0) / ST(1)));\n        ST(0) := ST(0) – (ST(1) ∗ Q);\n        C2 := 0;\n        C0, C3, C1 := LeastSignificantBits(Q); (* Q2, Q1, Q0 *)\n    ELSE\n        C2 := 1;\n        N := An implementation-dependent number between 32 and 63;\n        QQ := Integer(TruncateTowardZero((ST(0) / ST(1)) / 2(D − N)));\n        ST(0) := ST(0) – (ST(1) ∗ QQ ∗ 2(D − N));\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value, modulus (divisor) is 0, dividend is ∞, or unsupported format.; \ncolumn_2: Source operand is a denormal value.; column_1: #D; \ncolumn_1: #U; column_2: Result is too small for destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsub132ph:vfnmsub132ph:vfmsub213ph:vfnmsub213ph:vfmsub231ph:vfnmsub231ph",
    "category": "Core Instructions",
    "instructionName": "VFMSUB132PH/VFNMSUB132PH/VFMSUB213PH/VFNMSUB213PH/VFMSUB231PH/VFNMSUB231PH\n\t\t— Fused Multiply-Subtract of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, subtract xmm2, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 9A /r VFMSUB132PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, subtract ymm2, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 9A /r VFMSUB132PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, subtract zmm2, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 9A /r VFMSUB132PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm2, subtract xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 AA /r VFMSUB213PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm2, subtract ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 AA /r VFMSUB213PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm2, subtract zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 AA /r VFMSUB213PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, subtract xmm1, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 BA /r VFMSUB231PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, subtract ymm1, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 BA /r VFMSUB231PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, subtract zmm1, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 BA /r VFMSUB231PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, and negate the value. Subtract xmm2 from this value, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 9E /r VFNMSUB132PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, and negate the value. Subtract ymm2 from this value, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 9E /r VFNMSUB132PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, and negate the value. Subtract zmm2 from this value, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 9E /r VFNMSUB132PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm2, and negate the value. Subtract xmm3/m128/m16bcst from this value, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 AE /r VFNMSUB213PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm2, and negate the value. Subtract ymm3/m256/m16bcst from this value, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 AE /r VFNMSUB213PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm2, and negate the value. Subtract zmm3/m512/m16bcst from this value, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 AE /r VFNMSUB213PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, and negate the value. Subtract xmm1 from this value, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 BE /r VFNMSUB231PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, and negate the value. Subtract ymm1 from this value, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 BE /r VFNMSUB231PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, and negate the value. Subtract zmm1 from this value, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 BE /r VFNMSUB231PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtps2pd",
    "category": "Core Instructions",
    "instructionName": "CVTPS2PD\n\t\t— Convert Packed Single Precision Floating-Point Values to Packed Double PrecisionFloating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert two packed single precision floating-point values in xmm2/m64 to two packed double precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 5A /r CVTPS2PD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert two packed single precision floating-point values in xmm2/m64 to two packed double precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.0F.WIG 5A /r VCVTPS2PD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert four packed single precision floating-point values in xmm2/m128 to four packed double precision floating-point values in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.0F.WIG 5A /r VCVTPS2PD ymm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert two packed single precision floating-point values in xmm2/m64/m32bcst to packed double precision floating-point values in xmm1 with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.0F.W0 5A /r VCVTPS2PD xmm1 {k1}{z}, xmm2/m64/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed single precision floating-point values in xmm2/m128/m32bcst to packed double precision floating-point values in ymm1 with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.0F.W0 5A /r VCVTPS2PD ymm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert eight packed single precision floating-point values in ymm2/m256/b32bcst to eight packed double precision floating-point values in zmm1 with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.0F.W0 5A /r VCVTPS2PD zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half"
      }
    ],
    "descriptionText": "Converts two, four or eight packed single precision floating-point values in the source operand (second operand) to two, four or eight packed double precision floating-point values in the destination operand (first operand).\nEVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    k := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] :=\n            Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[k+31:k])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    k := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+63:i] :=\n            Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0])\n                ELSE\n                    DEST[i+63:i] :=\n            Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[k+31:k])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[191:128] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[95:64])\nDEST[255:192] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[127:96)\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0])\nDEST[127:64] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[63:32])\nDEST[MAXVL-1:128] (unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtps2ph",
    "category": "Core Instructions",
    "instructionName": "VCVTPS2PH\n\t\t— Convert Single-Precision FP Value to 16-bit FP Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "F16C",
        "Description": "Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. Imm8 provides rounding controls.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 1D /r ib VCVTPS2PH xmm1/m64, xmm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "F16C",
        "Description": "Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. Imm8 provides rounding controls.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 1D /r ib VCVTPS2PH xmm1/m128, ymm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. Imm8 provides rounding controls.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 1D /r ib VCVTPS2PH xmm1/m64 {k1}{z}, xmm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. Imm8 provides rounding controls.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 1D /r ib VCVTPS2PH xmm1/m128 {k1}{z}, ymm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert sixteen packed single-precision floating-point values in zmm2 to packed half-precision (16-bit) floating-point values in ymm1/m256. Imm8 provides rounding controls.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 1D /r ib VCVTPS2PH ymm1/m256 {k1}{z}, zmm2{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Half Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/endbr32",
    "category": "Core Instructions",
    "instructionName": "ENDBR32\n\t\t— Terminate an Indirect Branch in 32-bit and Compatibility Mode",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_IBT",
        "Description": "Terminate indirect branch in 32-bit and compatibility mode.",
        "Op / En": "ZO",
        "Opcode/Instruction": "F3 0F 1E FB ENDBR32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      }
    ],
    "descriptionText": "Terminate an indirect branch in 32 bit and compatibility mode.",
    "operationText": "IF EndbranchEnabled(CPL) & (IA32_EFER.LMA = 0 | (IA32_EFER.LMA=1 & CS.L = 0)\n    IF CPL = 3\n        THEN\n            IA32_U_CET.TRACKER = IDLE\n            IA32_U_CET.SUPPRESS = 0\n        ELSE\n            IA32_S_CET.TRACKER = IDLE\n            IA32_S_CET.SUPPRESS = 0\n    FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpshufbitqmb",
    "category": "Core Instructions",
    "instructionName": "VPSHUFBITQMB\n\t\t— Shuffle Bits From Quadword Elements Using Byte Indexes Into Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG AVX512VL",
        "Description": "Extract values in xmm2 using control bits of xmm3/m128 with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 8F /r VPSHUFBITQMB k1{k2}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG AVX512VL",
        "Description": "Extract values in ymm2 using control bits of ymm3/m256 with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 8F /r VPSHUFBITQMB k1{k2}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_BITALG",
        "Description": "Extract values in zmm2 using control bits of zmm3/m512 with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 8F /r VPSHUFBITQMB k1{k2}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vminsh",
    "category": "Core Instructions",
    "instructionName": "VMINSH\n\t\t— Return Minimum Scalar FP16 Value",
    "detailsTable": [
      {
        "Description": "Return the minimum low FP16 value between xmm3/m16 and xmm2. Stores the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 5D /r VMINSH xmm1{k1}{z}, xmm2, xmm3/m16 {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscalefss",
    "category": "Core Instructions",
    "instructionName": "VSCALEFSS\n\t\t— Scale Scalar Float32 Value With Float32 Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Scale the scalar single-precision floating-point value in xmm2 using floating-point value from xmm3/m32. Under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 2D /r VSCALEFSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vzeroall",
    "category": "Core Instructions",
    "instructionName": "VZEROALL\n\t\t— Zero XMM, YMM, and ZMM Registers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Zero some of the XMM, YMM, and ZMM registers.",
        "Op /En": "ZO",
        "Opcode/Instruction": "VEX.256.0F.WIG 77 VZEROALL"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "In 64-bit mode, the instruction zeroes XMM0-XMM15, YMM0-YMM15, and ZMM0-ZMM15. Outside 64-bit mode, it zeroes only XMM0-XMM7, YMM0-YMM7, and ZMM0-ZMM7. VZEROALL does not modify ZMM16-ZMM31.\nNote: VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified.",
    "operationText": "simd_reg_file[][] is a two dimensional array representing the SIMD register file containing all the overlapping xmm, ymm, and zmm\nregisters present in that implementation. The major dimension is the register number: 0 for xmm0, ymm0, and zmm0; 1 for xmm1,\nymm1, and zmm1; etc. The minor dimension size is the width of the implemented SIMD state measured in bits. On a machine\nsupporting Intel AVX-512, the width is 512.\nIF (64-bit mode)\n    limit :=15\nELSE\n    limit := 7\nFOR i in 0 .. limit:\n    simd_reg_file[i][MAXVL-1:0] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-25, “Type 8 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpblendd",
    "category": "Core Instructions",
    "instructionName": "VPBLENDD\n\t\t— Blend Packed Dwords",
    "detailsTable": [
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 02 /r ib VPBLENDD xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 02 /r ib VPBLENDD ymm1, ymm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Dword elements from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding dword in the destination is copied from the source. If a bit in the mask, corresponding to a dword, is “1\", then the dword is copied, else the dword is unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "IF (imm8[0] == 1) THEN DEST[31:0] := SRC2[31:0]\nELSE DEST[31:0] := SRC1[31:0]\nIF (imm8[1] == 1) THEN DEST[63:32] := SRC2[63:32]\nELSE DEST[63:32] := SRC1[63:32]\nIF (imm8[2] == 1) THEN DEST[95:64] := SRC2[95:64]\nELSE DEST[95:64] := SRC1[95:64]\nIF (imm8[3] == 1) THEN DEST[127:96] := SRC2[127:96]\nELSE DEST[127:96] := SRC1[127:96]\nIF (imm8[4] == 1) THEN DEST[159:128] := SRC2[159:128]\nELSE DEST[159:128] := SRC1[159:128]\nIF (imm8[5] == 1) THEN DEST[191:160] := SRC2[191:160]\nELSE DEST[191:160] := SRC1[191:160]\nIF (imm8[6] == 1) THEN DEST[223:192] := SRC2[223:192]\nELSE DEST[223:192] := SRC1[223:192]\nIF (imm8[7] == 1) THEN DEST[255:224] := SRC2[255:224]\nELSE DEST[255:224] := SRC1[255:224]\nIF (imm8[0] == 1) THEN DEST[31:0] := SRC2[31:0]\nELSE DEST[31:0] := SRC1[31:0]\nIF (imm8[1] == 1) THEN DEST[63:32] := SRC2[63:32]\nELSE DEST[63:32] := SRC1[63:32]\nIF (imm8[2] == 1) THEN DEST[95:64] := SRC2[95:64]\nELSE DEST[95:64] := SRC1[95:64]\nIF (imm8[3] == 1) THEN DEST[127:96] := SRC2[127:96]\nELSE DEST[127:96] := SRC1[127:96]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtss2si",
    "category": "Core Instructions",
    "instructionName": "CVTSS2SI\n\t\t— Convert Scalar Single Precision Floating-Point Value to Doubleword Integer",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed doubleword integer in r32.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 2D /r CVTSS2SI r32, xmm1/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "SSE",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed quadword integer in r64.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 REX.W 0F 2D /r CVTSS2SI r64, xmm1/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed doubleword integer in r32.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.F3.0F.W0 2D /r 1 VCVTSS2SI r32, xmm1/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed quadword integer in r64.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.F3.0F.W1 2D /r 1 VCVTSS2SI r64, xmm1/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed doubleword integer in r32.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 2D /r VCVTSS2SI r32, xmm1/m32{er}"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed quadword integer in r64.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W1 2D /r VCVTSS2SI r64, xmm1/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Fixed"
      }
    ],
    "descriptionText": "Converts a single precision floating-point value in the source operand (the second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single precision floating-point value is contained in the low doubleword of the register.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.\nLegacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to produce 64-bit data. See the summary chart at the beginning of this section for encoding data and limits.\nVEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCVTSS2SI is encoded with VEX.L=0. Encoding VCVTSS2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (SRC *is register*) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF 64-bit Mode and OperandSize = 64\nTHEN\n    DEST[63:0] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0]);\nELSE\n    DEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0]);\nFI;\nIF 64-bit Mode and OperandSize = 64\nTHEN\n    DEST[63:0] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0]);\nELSE\n    DEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0]);\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/enqcmd",
    "category": "Core Instructions",
    "instructionName": "ENQCMD\n\t\t— Enqueue Command",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "ENQCMD",
        "Description": "Atomically enqueue 64-byte user command from source memory operand to destination offset in ES segment specified in register operand as offset in ES segment.",
        "Op/En": "A",
        "Opcode/Instruction": "F2 0F 38 F8 !(11):rrr:bbb ENQCMD r32/r64, m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/bt",
    "category": "Core Instructions",
    "instructionName": "BT\n\t\t— Bit Test",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag.",
        "Instruction": "BT r/m16, r16",
        "Op/En": "MR",
        "Opcode": "0F A3 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag.",
        "Instruction": "BT r/m32, r32",
        "Op/En": "MR",
        "Opcode": "0F A3 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store selected bit in CF flag.",
        "Instruction": "BT r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 0F A3 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag.",
        "Instruction": "BT r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "0F BA /4 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag.",
        "Instruction": "BT r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "0F BA /4 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store selected bit in CF flag.",
        "Instruction": "BT r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 0F BA /4 ib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:\nSee also: Bit(BitBase, BitOffset) on page 3-11.\nSome assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. In this case, the low-order 3 or 5 bits (3 for 16-bit operands, 5 for 32-bit operands) of the immediate bit offset are stored in the immediate bit offset field, and the high-order bits are shifted and combined with the byte displacement in the addressing mode by the assembler. The processor will ignore the high order bits if they are not zero.\nWhen accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit operand size, using by the following relationship:\nEffective Address + (4 ∗ (BitOffset DIV 32))\nOr, it may access 2 bytes starting from the memory address for a 16-bit operand, using this relationship:\nEffective Address + (2 ∗ (BitOffset DIV 16))\nIt may do so even when only a single byte needs to be accessed to reach the given bit. When using this bit addressing mechanism, software should avoid referencing areas of memory close to address space holes. In particular, it should avoid references to memory-mapped I/O registers. Instead, software should use the MOV instructions to load from or store to these addresses, and use the register form of these instructions to manipulate the data.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "CF := Bit(BitBase, BitOffset);",
    "flagsAffectedText": "The CF flag contains the value of the selected bit. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fsincos",
    "category": "Core Instructions",
    "instructionName": "FSINCOS\n\t\t— Sine and Cosine",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compute the sine and cosine of ST(0); replace ST(0) with the approximate sine, and push the approximate cosine onto the register stack.",
        "Instruction": "FSINCOS",
        "Opcode": "D9 FB"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes both the approximate sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.)\nThe source operand must be given in radians and must be within the range −263 to +263. The following table shows the results obtained when taking the sine and cosine of various classes of numbers, assuming that underflow does not occur.\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range − 263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π. However, even within the range -263 to +263, inaccurate results can occur because the finite approximation of π used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply FSINCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3π/8. See the sections titled “Approximation of Pi” and “Transcendental Instruction Accuracy” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a discussion of the proper value to use for π in performing such reductions.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF ST(0) < 263\n    THEN\n        C2 := 0;\n        TEMP := fcos(ST(0)); // approximation of cosine\n        ST(0) := fsin(ST(0)); // approximation of sine\n        TOP := TOP − 1;\n        ST(0) := TEMP;\n    ELSE (* Source operand out of range *)\n        C2 := 1;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value, ∞, or unsupported format.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_2: If there is a pending x87 FPU exception.; column_1: #MF; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesimc",
    "category": "Core Instructions",
    "instructionName": "AESIMC\n\t\t— Perform the AES InvMixColumn Transformation",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES",
        "Description": "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 DB /r AESIMC xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "Both AES and AVX flags",
        "Description": "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG DB /r VAESIMC xmm1, xmm2/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Perform the InvMixColumns transformation on the source operand and store the result in the destination operand. The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.\nNote: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round key) in order to prepare them for decryption using the “Equivalent Inverse Cipher” (defined in FIPS 197).\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "DEST[127:0] := InvMixColumns( SRC );\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := InvMixColumns( SRC );\nDEST[MAXVL-1:128] := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcpph",
    "category": "Core Instructions",
    "instructionName": "VRCPPH\n\t\t— Compute Reciprocals of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Compute the approximate reciprocals of packed FP16 values in xmm2/m128/m16bcst and store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 4C /r VRCPPH xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Compute the approximate reciprocals of packed FP16 values in ymm2/m256/m16bcst and store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 4C /r VRCPPH ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Compute the approximate reciprocals of packed FP16 values in zmm2/m512/m16bcst and store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 4C /r VRCPPH zmm1{k1}{z}, zmm2/m512/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdseed",
    "category": "Core Instructions",
    "instructionName": "RDSEED\n\t\t— Read Random SEED",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "RDSEED",
        "Description": "Read a 16-bit NIST SP800-90B & C compliant random value and store in the destination register.",
        "Op/En": "M",
        "Opcode/Instruction": "NFx 0F C7 /7 RDSEED r16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "RDSEED",
        "Description": "Read a 32-bit NIST SP800-90B & C compliant random value and store in the destination register.",
        "Op/En": "M",
        "Opcode/Instruction": "NFx 0F C7 /7 RDSEED r32"
      },
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "RDSEED",
        "Description": "Read a 64-bit NIST SP800-90B & C compliant random value and store in the destination register.",
        "Op/En": "M",
        "Opcode/Instruction": "NFx REX.W + 0F C7 /7 RDSEED r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads a hardware generated random value and store it in the destination register. The random value is generated from an Enhanced NRBG (Non Deterministic Random Bit Generator) that is compliant to NIST SP800-90B and NIST SP800-90C in the XOR construction mode. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random seed value has been returned, otherwise it is expected to loop and retry execution of RDSEED (see Section 1.2).\nThe RDSEED instruction is available at all privilege levels. The RDSEED instruction executes normally either inside or outside a transaction region.\nIn 64-bit mode, the instruction's default operand size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF HW_NRND_GEN.ready = 1\n    THEN\n        CASE of\n            operand size is 64: DEST[63:0] := HW_NRND_GEN.data;\n            operand size is 32: DEST[31:0] := HW_NRND_GEN.data;\n            operand size is 16: DEST[15:0] := HW_NRND_GEN.data;\n        ESAC;\n        CF := 1;\n    ELSE\n        CASE of\n            operand size is 64: DEST[63:0] := 0;\n            operand size is 32: DEST[31:0] := 0;\n            operand size is 16: DEST[15:0] := 0;\n        ESAC;\n        CF := 0;\nFI;\nOF, SF, ZF, AF, PF := 0;",
    "flagsAffectedText": "The CF flag is set according to the result (see the “Operation” section above). The OF, SF, ZF, AF, and PF flags are set to 0.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED[bit 18] = 0.;"
      ],
      "compatibilityMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED[bit 18] = 0.;"
      ],
      "protectedMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED[bit 18] = 0.;"
      ],
      "realAddressMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED[bit 18] = 0.;"
      ],
      "virtual8086Mode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED[bit 18] = 0.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/andps",
    "category": "Core Instructions",
    "instructionName": "ANDPS\n\t\t— Bitwise Logical AND of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 54 /r ANDPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F 54 /r VANDPS xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F 54 /r VANDPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 54 /r VANDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 54 /r VANDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Return the bitwise logical AND of packed single precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 54 /r VANDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical AND of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := SRC1[i+31:i] BITWISE AND SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] := SRC1[i+31:i] BITWISE AND SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0;\nDEST[31:0] := SRC1[31:0] BITWISE AND SRC2[31:0]\nDEST[63:32] := SRC1[63:32] BITWISE AND SRC2[63:32]\nDEST[95:64] := SRC1[95:64] BITWISE AND SRC2[95:64]\nDEST[127:96] := SRC1[127:96] BITWISE AND SRC2[127:96]\nDEST[159:128] := SRC1[159:128] BITWISE AND SRC2[159:128]\nDEST[191:160] := SRC1[191:160] BITWISE AND SRC2[191:160]\nDEST[223:192] := SRC1[223:192] BITWISE AND SRC2[223:192]\nDEST[255:224] := SRC1[255:224] BITWISE AND SRC2[255:224].\nDEST[MAXVL-1:256] := 0;\nDEST[31:0] := SRC1[31:0] BITWISE AND SRC2[31:0]\nDEST[63:32] := SRC1[63:32] BITWISE AND SRC2[63:32]\nDEST[95:64] := SRC1[95:64] BITWISE AND SRC2[95:64]\nDEST[127:96] := SRC1[127:96] BITWISE AND SRC2[127:96]\nDEST[MAXVL-1:128] := 0;\nDEST[31:0] := DEST[31:0] BITWISE AND SRC[31:0]\nDEST[63:32] := DEST[63:32] BITWISE AND SRC[63:32]\nDEST[95:64] := DEST[95:64] BITWISE AND SRC[95:64]\nDEST[127:96] := DEST[127:96] BITWISE AND SRC[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/leave",
    "category": "Core Instructions",
    "instructionName": "LEAVE\n\t\t— High Level Procedure Exit",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set SP to BP, then pop BP.",
        "Instruction": "LEAVE",
        "Op/En": "ZO",
        "Opcode": "C9"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Set ESP to EBP, then pop EBP.",
        "Instruction": "LEAVE",
        "Op/En": "ZO",
        "Opcode": "C9"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set RSP to RBP, then pop RBP.",
        "Instruction": "LEAVE",
        "Op/En": "ZO",
        "Opcode": "C9"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame. The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure’s stack frame.\nA RET instruction is commonly executed following a LEAVE instruction to return program control to the calling procedure.\nSee “Procedure Calls for Block-Structured Languages” in Chapter 7 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for detailed information on the use of the ENTER and LEAVE instructions.\nIn 64-bit mode, the instruction’s default operation size is 64 bits; 32-bit operation cannot be encoded. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF StackAddressSize = 32\n    THEN\n        ESP := EBP;\n    ELSE IF StackAddressSize = 64\n        THEN RSP := RBP; FI;\n    ELSE IF StackAddressSize = 16\n        THEN SP := BP; FI;\nFI;\nIF OperandSize = 32\n    THEN EBP := Pop();\n    ELSE IF OperandSize = 64\n        THEN RBP := Pop(); FI;\n    ELSE IF OperandSize = 16\n        THEN BP := Pop(); FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/mulpd",
    "category": "Core Instructions",
    "instructionName": "MULPD\n\t\t— Multiply Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Multiply packed double precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 59 /r MULPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply packed double precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 59 /r VMULPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply packed double precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 59 /r VMULPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 59 /r VMULPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 59 /r VMULPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values in zmm3/m512/m64bcst with zmm2 and store result in zmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 59 /r VMULPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Multiply packed double precision floating-point values from the first source operand with corresponding values in the second source operand, and stores the packed double precision floating-point results in the destination operand.\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the destination YMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF (VL = 512) AND (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := SRC1[i+63:i] * SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := SRC1[i+63:i] * SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC1[63:0] * SRC2[63:0]\nDEST[127:64] := SRC1[127:64] * SRC2[127:64]\nDEST[191:128] := SRC1[191:128] * SRC2[191:128]\nDEST[255:192] := SRC1[255:192] * SRC2[255:192]\nDEST[MAXVL-1:256] := 0;\n.\nDEST[63:0] := SRC1[63:0] * SRC2[63:0]\nDEST[127:64] := SRC1[127:64] * SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] * SRC[63:0]\nDEST[127:64] := DEST[127:64] * SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfnmadd132pd:vfnmadd213pd:vfnmadd231pd",
    "category": "Core Instructions",
    "instructionName": "VFNMADD132PD/VFNMADD213PD/VFNMADD231PD\n\t\t— Fused Negative Multiply-Add of PackedDouble Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 9C /r VFNMADD132PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 AC /r VFNMADD213PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 BC /r VFNMADD231PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 9C /r VFNMADD132PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 AC /r VFNMADD213PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 BC /r VFNMADD231PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 9C /r VFNMADD132PD xmm0 {k1}{z}, xmm1, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m64bcst and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 AC /r VFNMADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 BC /r VFNMADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm2 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 9C /r VFNMADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m64bcst and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 AC /r VFNMADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm1 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 BC /r VFNMADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm2 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 9C /r VFNMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m64bcst and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 AC /r VFNMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm1 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 BC /r VFNMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/or",
    "category": "Core Instructions",
    "instructionName": "OR\n\t\t— Logical Inclusive OR",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AL OR imm8.",
        "Instruction": "OR AL, imm8",
        "Op/En": "I",
        "Opcode": "0C ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AX OR imm16.",
        "Instruction": "OR AX, imm16",
        "Op/En": "I",
        "Opcode": "0D iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "EAX OR imm32.",
        "Instruction": "OR EAX, imm32",
        "Op/En": "I",
        "Opcode": "0D id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "RAX OR imm32 (sign-extended).",
        "Instruction": "OR RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + 0D id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m8 OR imm8.",
        "Instruction": "OR r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "80 /1 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m8 OR imm8.",
        "Instruction": "OR r/m81, imm8",
        "Op/En": "MI",
        "Opcode": "REX + 80 /1 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 OR imm16.",
        "Instruction": "OR r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "81 /1 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 OR imm32.",
        "Instruction": "OR r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "81 /1 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 OR imm32 (sign-extended).",
        "Instruction": "OR r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + 81 /1 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 OR imm8 (sign-extended).",
        "Instruction": "OR r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "83 /1 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 OR imm8 (sign-extended).",
        "Instruction": "OR r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "83 /1 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 OR imm8 (sign-extended).",
        "Instruction": "OR r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 83 /1 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m8 OR r8.",
        "Instruction": "OR r/m8, r8",
        "Op/En": "MR",
        "Opcode": "08 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m8 OR r8.",
        "Instruction": "OR r/m81, r81",
        "Op/En": "MR",
        "Opcode": "REX + 08 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 OR r16.",
        "Instruction": "OR r/m16, r16",
        "Op/En": "MR",
        "Opcode": "09 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 OR r32.",
        "Instruction": "OR r/m32, r32",
        "Op/En": "MR",
        "Opcode": "09 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 OR r64.",
        "Instruction": "OR r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 09 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r8 OR r/m8.",
        "Instruction": "OR r8, r/m8",
        "Op/En": "RM",
        "Opcode": "0A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r8 OR r/m8.",
        "Instruction": "OR r81, r/m81",
        "Op/En": "RM",
        "Opcode": "REX + 0A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r16 OR r/m16.",
        "Instruction": "OR r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r32 OR r/m32.",
        "Instruction": "OR r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r64 OR r/m64.",
        "Instruction": "OR r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0B /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := DEST OR SRC;",
    "flagsAffectedText": "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same as for protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used but the destination is not a memory operand.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/mov",
    "category": "Core Instructions",
    "instructionName": "MOV\n\t\t— Move",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r8 to r/m8.",
        "Instruction": "MOV r/m8, r8",
        "Op/En": "MR",
        "Opcode": "88 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move r8 to r/m8.",
        "Instruction": "MOV r/m81, r81",
        "Op/En": "MR",
        "Opcode": "REX + 88 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r16 to r/m16.",
        "Instruction": "MOV r/m16, r16",
        "Op/En": "MR",
        "Opcode": "89 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r32 to r/m32.",
        "Instruction": "MOV r/m32, r32",
        "Op/En": "MR",
        "Opcode": "89 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move r64 to r/m64.",
        "Instruction": "MOV r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 89 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r/m8 to r8.",
        "Instruction": "MOV r8, r/m8",
        "Op/En": "RM",
        "Opcode": "8A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move r/m8 to r8.",
        "Instruction": "MOV r81, r/m81",
        "Op/En": "RM",
        "Opcode": "REX + 8A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r/m16 to r16.",
        "Instruction": "MOV r16, r/m16",
        "Op/En": "RM",
        "Opcode": "8B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r/m32 to r32.",
        "Instruction": "MOV r32, r/m32",
        "Op/En": "RM",
        "Opcode": "8B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move r/m64 to r64.",
        "Instruction": "MOV r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 8B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move segment register to r/m16.",
        "Instruction": "MOV r/m16, Sreg2",
        "Op/En": "MR",
        "Opcode": "8C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move zero extended 16-bit segment register to r16/r32/m16.",
        "Instruction": "MOV r16/r32/m16, Sreg2",
        "Op/En": "MR",
        "Opcode": "8C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move zero extended 16-bit segment register to r64/m16.",
        "Instruction": "MOV r64/m16, Sreg2",
        "Op/En": "MR",
        "Opcode": "REX.W + 8C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r/m16 to segment register.",
        "Instruction": "MOV Sreg, r/m162",
        "Op/En": "RM",
        "Opcode": "8E /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move lower 16 bits of r/m64 to segment register.",
        "Instruction": "MOV Sreg, r/m642",
        "Op/En": "RM",
        "Opcode": "REX.W + 8E /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move byte at (seg:offset) to AL.",
        "Instruction": "MOV AL, moffs83",
        "Op/En": "FD",
        "Opcode": "A0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move byte at (offset) to AL.",
        "Instruction": "MOV AL, moffs83",
        "Op/En": "FD",
        "Opcode": "REX.W + A0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move word at (seg:offset) to AX.",
        "Instruction": "MOV AX, moffs163",
        "Op/En": "FD",
        "Opcode": "A1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move doubleword at (seg:offset) to EAX.",
        "Instruction": "MOV EAX, moffs323",
        "Op/En": "FD",
        "Opcode": "A1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move quadword at (offset) to RAX.",
        "Instruction": "MOV RAX, moffs643",
        "Op/En": "FD",
        "Opcode": "REX.W + A1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move AL to (seg:offset).",
        "Instruction": "MOV moffs8, AL",
        "Op/En": "TD",
        "Opcode": "A2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move AL to (offset).",
        "Instruction": "MOV moffs81, AL",
        "Op/En": "TD",
        "Opcode": "REX.W + A2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move AX to (seg:offset).",
        "Instruction": "MOV moffs163, AX",
        "Op/En": "TD",
        "Opcode": "A3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move EAX to (seg:offset).",
        "Instruction": "MOV moffs323, EAX",
        "Op/En": "TD",
        "Opcode": "A3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move RAX to (offset).",
        "Instruction": "MOV moffs643, RAX",
        "Op/En": "TD",
        "Opcode": "REX.W + A3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move imm8 to r8.",
        "Instruction": "MOV r8, imm8",
        "Op/En": "OI",
        "Opcode": "B0+ rb ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move imm8 to r8.",
        "Instruction": "MOV r81, imm8",
        "Op/En": "OI",
        "Opcode": "REX + B0+ rb ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move imm16 to r16.",
        "Instruction": "MOV r16, imm16",
        "Op/En": "OI",
        "Opcode": "B8+ rw iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move imm32 to r32.",
        "Instruction": "MOV r32, imm32",
        "Op/En": "OI",
        "Opcode": "B8+ rd id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move imm64 to r64.",
        "Instruction": "MOV r64, imm64",
        "Op/En": "OI",
        "Opcode": "REX.W + B8+ rd io"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move imm8 to r/m8.",
        "Instruction": "MOV r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "C6 /0 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move imm8 to r/m8.",
        "Instruction": "MOV r/m81, imm8",
        "Op/En": "MI",
        "Opcode": "REX + C6 /0 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move imm16 to r/m16.",
        "Instruction": "MOV r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "C7 /0 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move imm32 to r/m32.",
        "Instruction": "MOV r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "C7 /0 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move imm32 sign extended to 64-bits to r/m64.",
        "Instruction": "MOV r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + C7 /0 id"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "FD",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "Moffs",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "TD",
        "Operand 1": "Moffs (w)",
        "Operand 2": "AL/AX/EAX/RAX",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "OI",
        "Operand 1": "opcode + rd (w)",
        "Operand 2": "imm8/16/32/64",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "imm8/16/32/64",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, a doubleword, or a quadword.\nThe MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode exception (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.\nIf the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register. While loading this information, the segment selector and segment descriptor information is validated (see the “Operation” algorithm below). The segment descriptor data is obtained from the GDT or LDT entry for the specified segment selector.\nA NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a NULL value causes a general protection exception (#GP) and no memory reference occurs.\nLoading the SS register with a MOV instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP, stack-pointer value) before an event can be delivered. See Section 6.8.3, “Masking Exceptions and Interrupts When Switching Stacks,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. Intel recommends that software use the LSS instruction to load the SS register and ESP together.\nWhen executing MOV Reg, Sreg, the processor copies the content of Sreg to the 16 least significant bits of the general-purpose register. The upper bits of the destination register are zero for most IA-32 processors (Pentium Pro processors and later) and all Intel 64 processors, with the exception that bits 31:16 are undefined for Intel Quark X1000 processors, Pentium, and earlier processors.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := SRC;\nLoading a segment register while in protected mode results in special checks and actions, as described in the following listing. These\nchecks are performed on the segment selector and the segment descriptor to which it points.\nIF SS is loaded\n    THEN\n        IF segment selector is NULL\n            THEN #GP(0); FI;\n        IF segment selector index is outside descriptor table limits\n        OR segment selector's RPL ≠ CPL\n        OR segment is not a writable data segment\n        OR DPL ≠ CPL\n            THEN #GP(selector); FI;\n        IF segment not marked present\n            THEN #SS(selector);\n            ELSE\n                SS := segment selector;\n                SS := segment descriptor; FI;\nFI;\nIF DS, ES, FS, or GS is loaded with non-NULL selector\nTHEN\n    IF segment selector index is outside descriptor table limits\n    OR segment is not a data or readable code segment\n    OR ((segment is a data or nonconforming code segment) AND ((RPL > DPL) or (CPL > DPL)))\n        THEN #GP(selector); FI;\n    IF segment not marked present\n        THEN #NP(selector);\n        ELSE\n            SegmentRegister := segment selector;\n            SegmentRegister := segment descriptor; FI;\nFI;\nIF DS, ES, FS, or GS is loaded with NULL selector\n    THEN\n        SegmentRegister := segment selector;\n        SegmentRegister := segment descriptor;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If an attempt is made to load SS register with NULL segment selector when CPL = 3.; \ncolumn_1: If an attempt is made to load SS register with NULL segment selector when CPL < 3 and CPL ≠ RPL.; \ncolumn_1: #GP(selector); column_2: If segment selector index is outside descriptor table limits.; \ncolumn_1: If the memory access to the descriptor table is non-canonical.; \ncolumn_1: If the SS register is being loaded and the segment selector's RPL and the segment descriptor’s DPL are not equal to the CPL.; \ncolumn_1: If the SS register is being loaded and the segment pointed to is a nonwritable data segment.; \ncolumn_1: If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable code segment.; \ncolumn_1: If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment, but both the RPL and the CPL are greater than the DPL.; \ncolumn_1: #SS(0); column_2: If the stack address is in a non-canonical form.; \ncolumn_1: #SS(selector); column_2: If the SS register is being loaded and the segment pointed to is marked not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If attempt is made to load the CS register.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the destination operand is in a non-writable segment.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #GP(selector); column_2: If segment selector index is outside descriptor table limits.; \ncolumn_1: If the SS register is being loaded and the segment selector's RPL and the segment descriptor’s DPL are not equal to the CPL.; \ncolumn_1: If the SS register is being loaded and the segment pointed to is a non-writable data segment.; \ncolumn_1: If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable code segment.; \ncolumn_1: If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment, and either the RPL or the CPL is greater than the DPL.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If the SS register is being loaded and the segment pointed to is marked not present.; column_1: #SS(selector); \ncolumn_1: #NP; column_2: If the DS, ES, FS, or GS register is being loaded and the segment pointed to is marked not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If attempt is made to load the CS register.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If attempt is made to load the CS register.; column_1: #UD; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If attempt is made to load the CS register.; \ncolumn_1: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/not",
    "category": "Core Instructions",
    "instructionName": "NOT\n\t\t— One's Complement Negation",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Reverse each bit of r/m8.",
        "Instruction": "NOT r/m8",
        "Op/En": "M",
        "Opcode": "F6 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Reverse each bit of r/m8.",
        "Instruction": "NOT r/m81",
        "Op/En": "M",
        "Opcode": "REX + F6 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Reverse each bit of r/m16.",
        "Instruction": "NOT r/m16",
        "Op/En": "M",
        "Opcode": "F7 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Reverse each bit of r/m32.",
        "Instruction": "NOT r/m32",
        "Op/En": "M",
        "Opcode": "F7 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Reverse each bit of r/m64.",
        "Instruction": "NOT r/m64",
        "Op/En": "M",
        "Opcode": "REX.W + F7 /2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := NOT DEST;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same as for protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermt2b",
    "category": "Core Instructions",
    "instructionName": "VPERMT2B\n\t\t— Full Permute of Bytes From Two Tables Overwriting a Table",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VBMI",
        "Description": "Permute bytes in xmm3/m128 and xmm1 using byte indexes in xmm2 and store the byte results in xmm1 using writemask k1.",
        "Op /En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 7D /r VPERMT2B xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VBMI",
        "Description": "Permute bytes in ymm3/m256 and ymm1 using byte indexes in ymm2 and store the byte results in ymm1 using writemask k1.",
        "Op /En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 7D /r VPERMT2B ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI",
        "Description": "Permute bytes in zmm3/m512 and zmm1 using byte indexes in zmm2 and store the byte results in zmm1 using writemask k1.",
        "Op /En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 7D /r VPERMT2B zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpscatterdd:vpscatterdq:vpscatterqd:vpscatterqq",
    "category": "Core Instructions",
    "instructionName": "VPSCATTERDD/VPSCATTERDQ/VPSCATTERQD/VPSCATTERQQ\n\t\t— Scatter Packed Dword, PackedQword with Signed Dword, Signed Qword Indices",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, scatter dword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 A0 /vsib VPSCATTERDD vm32x {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, scatter dword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 A0 /vsib VPSCATTERDD vm32y {k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed dword indices, scatter dword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 A0 /vsib VPSCATTERDD vm32z {k1}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, scatter qword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 A0 /vsib VPSCATTERDQ vm32x {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, scatter qword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 A0 /vsib VPSCATTERDQ vm32x {k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed dword indices, scatter qword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 A0 /vsib VPSCATTERDQ vm32y {k1}, zmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, scatter dword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 A1 /vsib VPSCATTERQD vm64x {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, scatter dword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 A1 /vsib VPSCATTERQD vm64y {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed qword indices, scatter dword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 A1 /vsib VPSCATTERQD vm64z {k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, scatter qword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 A1 /vsib VPSCATTERQQ vm64x {k1}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, scatter qword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 A1 /vsib VPSCATTERQQ vm64y {k1}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed qword indices, scatter qword values to memory using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 A1 /vsib VPSCATTERQQ vm64z {k1}, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vextractf128:vextractf32x4:vextractf64x2:vextractf32x8:vextractf64x4",
    "category": "Core Instructions",
    "instructionName": "VEXTRACTF128/VEXTRACTF32x4/VEXTRACTF64x2/VEXTRACTF32x8/VEXTRACTF64x4\n\t\t— Extract Packed Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/m128.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 19 /r ib VEXTRACTF128 xmm1/m128, ymm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Extract 128 bits of packed single precision floating-point values from ymm2 and store results in xmm1/m128 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 19 /r ib VEXTRACTF32X4 xmm1/m128 {k1}{z}, ymm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Extract 128 bits of packed single precision floating-point values from zmm2 and store results in xmm1/m128 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 19 /r ib VEXTRACTF32x4 xmm1/m128 {k1}{z}, zmm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Extract 128 bits of packed double precision floating-point values from ymm2 and store results in xmm1/m128 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 19 /r ib VEXTRACTF64X2 xmm1/m128 {k1}{z}, ymm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Extract 128 bits of packed double precision floating-point values from zmm2 and store results in xmm1/m128 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 19 /r ib VEXTRACTF64X2 xmm1/m128 {k1}{z}, zmm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Extract 256 bits of packed single precision floating-point values from zmm2 and store results in ymm1/m256 subject to writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 1B /r ib VEXTRACTF32X8 ymm1/m256 {k1}{z}, zmm2, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Extract 256 bits of packed double precision floating-point values from zmm2 and store results in ymm1/m256 subject to writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 1B /r ib VEXTRACTF64x4 ymm1/m256 {k1}{z}, zmm2, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple2"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple4"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple8"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vexp2ps",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VEXP2PS\n\t\t— Approximation to the Exponential 2^x of Packed Single Precision Floating-PointValues With Less Than 2^-23 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes approximations to the exponential 2^x (with less than 2^-23 of maximum relative error) of the packed single-precision floating-point values from zmm2/m512/m32bcst and stores the floating-point result in zmm1with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C8 /r VEXP2PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A Full ModRM:reg (r, w) ModRM:r/m (r) N/A N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movd:movq",
    "category": "Core Instructions",
    "instructionName": "MOVD/MOVQ\n\t\t— Move Doubleword/Move Quadword",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Move doubleword from r/m32 to mm.",
        "Op/ En": "A",
        "Opcode/Instruction": "NP 0F 6E /r MOVD mm, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "MMX",
        "Description": "Move quadword from r/m64 to mm.",
        "Op/ En": "A",
        "Opcode/Instruction": "NP REX.W + 0F 6E /r MOVQ mm, r/m64"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Move doubleword from mm to r/m32.",
        "Op/ En": "B",
        "Opcode/Instruction": "NP 0F 7E /r MOVD r/m32, mm"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "MMX",
        "Description": "Move quadword from mm to r/m64.",
        "Op/ En": "B",
        "Opcode/Instruction": "NP REX.W + 0F 7E /r MOVQ r/m64, mm"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move doubleword from r/m32 to xmm.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F 6E /r MOVD xmm, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move quadword from r/m64 to xmm.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 REX.W 0F 6E /r MOVQ xmm, r/m64"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move doubleword from xmm register to r/m32.",
        "Op/ En": "B",
        "Opcode/Instruction": "66 0F 7E /r MOVD r/m32, xmm"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move quadword from xmm register to r/m64.",
        "Op/ En": "B",
        "Opcode/Instruction": "66 REX.W 0F 7E /r MOVQ r/m64, xmm"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move doubleword from r/m32 to xmm1.",
        "Op/ En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.W0 6E / VMOVD xmm1, r32/m32"
      },
      {
        "64/32-bit Mode": "V/N.E1.",
        "CPUID Feature Flag": "AVX",
        "Description": "Move quadword from r/m64 to xmm1.",
        "Op/ En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.W1 6E /r VMOVQ xmm1, r64/m64"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move doubleword from xmm1 register to r/m32.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.W0 7E /r VMOVD r32/m32, xmm1"
      },
      {
        "64/32-bit Mode": "V/N.E1.",
        "CPUID Feature Flag": "AVX",
        "Description": "Move quadword from xmm1 register to r/m64.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.W1 7E /r VMOVQ r64/m64, xmm1"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move doubleword from r/m32 to xmm1.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 6E /r VMOVD xmm1, r32/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move quadword from r/m64 to xmm1.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 6E /r VMOVQ xmm1, r64/m64"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move doubleword from xmm1 register to r/m32.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 7E /r VMOVD r32/m32, xmm1"
      },
      {
        "64/32-bit Mode": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move quadword from xmm1 register to r/m64.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 7E /r VMOVQ r64/m64, xmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or 32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot be used to transfer data between MMX technology registers, between XMM registers, between general-purpose registers, or between memory locations.\nWhen the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.\nMOVD/Q with XMM destination:\nMoves a dword/qword integer from the source operand and stores it in the low 32/64-bits of the destination XMM register. The upper bits of the destination are zeroed. The source operand can be a 32/64-bit register or 32/64-bit memory location.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. Qword operation requires the use of REX.W=1.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. Qword operation requires the use of VEX.W=1.\nEVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. Qword operation requires the use of EVEX.W=1.\nMOVD/Q with 32/64 reg/mem destination:\nStores the low dword/qword of the source XMM register to 32/64-bit memory location or general-purpose register. Qword operation requires the use of REX.W=1, VEX.W=1, or EVEX.W=1.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nIf VMOVD or VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
    "operationText": "DEST[31:0] := SRC;\nDEST[63:32] := 00000000H;\nDEST[31:0] := SRC;\nDEST[127:32] := 000000000000000000000000H;\nDEST[MAXVL-1:128] (Unmodified)\nDEST := SRC[31:0];\nDEST[31:0] := SRC[31:0]\nDEST[MAXVL-1:32] := 0\nDEST[63:0] := SRC[63:0];\nDEST[127:64] := 0000000000000000H;\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := SRC[63:0];\nDEST := SRC[63:0];\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] := 0\nDEST[31:0] := SRC[31:0]\nDEST[MAXVL-1:32] := 0\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”",
        "Additionally:",
        "column_1: If VEX.vvvv != 1111B or EVEX.vvvv != 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/umwait",
    "category": "Core Instructions",
    "instructionName": "UMWAIT\n\t\t— User Level Monitor Wait",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "WAITPKG",
        "Description": "A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.",
        "Op/En": "A",
        "Opcode / Instruction": "F2 0F AE /6 UMWAIT r32, <edx>, <eax>"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "UMWAIT instructs the processor to enter an implementation-dependent optimized state while monitoring a range of addresses. The optimized state may be either a light-weight power/performance optimized state or an improved power/performance optimized state. The selection between the two states is governed by the explicit input register bit[0] source operand.\nUMWAIT is available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. UMWAIT may be executed at any privilege level. This instruction’s operation is the same in non-64-bit modes and in 64-bit mode.\nThe input register contains information such as the preferred optimized state the processor should enter as described in the following table. Bits other than bit 0 are reserved and will result in #GP if nonzero.\nThe instruction wakes up when the time-stamp counter reaches or exceeds the implicit EDX:EAX 64-bit input value (if the monitoring hardware did not trigger beforehand).\nPrior to executing the UMWAIT instruction, an operating system may specify the maximum delay it allows the processor to suspend its operation. It can do so by writing TSC-quanta value to the following 32bit MSR (IA32_UM-WAIT_CONTROL at MSR index E1H):\nIf the processor that executed a UMWAIT instruction wakes due to the expiration of the operating system timelimit, the instructions sets RFLAGS.CF; otherwise, that flag is cleared.\nThe UMWAIT instruction causes a transactional abort when used inside a transactional region.\nThe UMWAIT instruction operates with the UMONITOR instruction. The two instructions allow the definition of an address at which to wait (UMONITOR) and an implementation-dependent optimized operation to perform while waiting (UMWAIT). The execution of UMWAIT is a hint to the processor that it can enter an implementation-dependent-optimized state while waiting for an event or a store operation to the address range armed by UMONITOR. The UMWAIT instruction will not wait (will not enter an implementation-dependent optimized state) if any of the\nfollowing instructions were executed before UMWAIT and after the most recent execution of UMONITOR: IRET, MONITOR, SYSEXIT, SYSRET, and far RET (the last if it is changing CPL).\nThe following additional events cause the processor to exit the implementation-dependent optimized state: a store to the address range armed by the UMONITOR instruction, an NMI or SMI, a debug exception, a machine check exception, the BINIT# signal, the INIT# signal, and the RESET# signal. Other implementation-dependent events may also cause the processor to exit the implementation-dependent optimized state.\nIn addition, an external interrupt causes the processor to exit the implementation-dependent optimized state regardless of whether maskable-interrupts are inhibited (EFLAGS.IF =0).\nFollowing exit from the implementation-dependent-optimized state, control passes to the instruction after the UMWAIT instruction. A pending interrupt that is not masked (including an NMI or an SMI) may be delivered before execution of that instruction.\nUnlike the HLT instruction, the UMWAIT instruction does not restart at the UMWAIT instruction following the handling of an SMI.\nIf the preceding UMONITOR instruction did not successfully arm an address range or if UMONITOR was not executed prior to executing UMWAIT and following the most recent execution of the legacy MONITOR instruction (UMWAIT does not interoperate with MONITOR), then the processor will not enter an optimized state. Execution will continue to the instruction following UMWAIT.\nA store to the address range armed by the UMONITOR instruction will cause the processor to exit UMWAIT if either the store was originated by other processor agents or the store was originated by a non-processor agent.",
    "operationText": "os_deadline := TSC+(IA32_UMWAIT_CONTROL[31:2]<<2)\ninstr_deadline := UINT64(EDX:EAX)\nIF os_deadline < instr_deadline:\n    deadline := os_deadline\n    using_os_deadline := 1\nELSE:\n    deadline := instr_deadline\n    using_os_deadline := 0\nWHILE monitor hardware armed AND TSC < deadline:\n    implementation_dependent_optimized_state(Source register, deadline, IA32_UMWAIT_CONTROL[0] )\nIF using_os_deadline AND TSC ≥ deadline:\n    RFLAGS.CF := 1\nELSE:\n    RFLAGS.CF := 0\nRFLAGS.AF,PF,SF,ZF,OF := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "numeric¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtw2ph",
    "category": "Core Instructions",
    "instructionName": "VCVTW2PH\n\t\t— Convert Packed Signed Word Integers to FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert eight packed signed word integers from xmm2/m128/m16bcst to FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F3.MAP5.W0 7D /r VCVTW2PH xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed signed word integers from ymm2/m256/m16bcst to FP16 values, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F3.MAP5.W0 7D /r VCVTW2PH ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert thirty-two packed signed word integers from zmm2/m512/m16bcst to FP16 values, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F3.MAP5.W0 7D /r VCVTW2PH zmm1{k1}{z}, zmm2/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmcall",
    "category": "VMX Instructions",
    "instructionName": "VMCALL\n\t\t— Call to VM Monitor",
    "detailsTable": [
      {
        "Description": "Call to VM monitor by causing VM exit.",
        "Op/En": "ZO",
        "Opcode/Instruction": "0F 01 C1 VMCALL"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "ZO",
        "column_2": "NA",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "This instruction allows guest software can make a call for service into an underlying VM monitor. The details of the programming interface for such calls are VMM-specific; this instruction does nothing more than cause a VM exit, registering the appropriate exit reason.\nUse of this instruction in VMX root operation invokes an SMM monitor (see Section 32.15.2). This invocation will activate the dual-monitor treatment of system-management interrupts (SMIs) and system-management mode (SMM) if it is not already active (see Section 32.15.6).",
    "operationText": "IF not in VMX operation\n    THEN #UD;\nELSIF in VMX non-root operation\n    THEN VM exit;\nELSIF (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF CPL > 0\n    THEN #GP(0);\nELSIF in SMM or the logical processor does not support the dual-monitor treatment of SMIs and SMM or the valid bit in the\nIA32_SMM_MONITOR_CTL MSR is clear\n    THEN VMfail (VMCALL executed in VMX root operation);\nELSIF dual-monitor treatment of SMIs and SMM is active\n    THEN perform an SMM VM exit (see Section 32.15.2);\nELSIF current-VMCS pointer is not valid\n    THEN VMfailInvalid;\nELSIF launch state of current VMCS is not clear\n    THEN VMfailValid(VMCALL with non-clear VMCS);\nELSIF VM-exit control fields are not valid (see Section 32.15.6.1)\n    THEN VMfailValid (VMCALL with invalid VM-exit control fields);\nELSE\n    enter SMM;\n    read revision identifier in MSEG;\n    IF revision identifier does not match that supported by processor\n        THEN\n            leave SMM;\n            VMfailValid(VMCALL with incorrect MSEG revision identifier);\n        ELSE\n            read SMM-monitor features field in MSEG (see Section 32.15.6.1);\n            IF features field is invalid\n                THEN\n                    leave SMM;\n                    VMfailValid(VMCALL with invalid SMM-monitor features);\n                ELSE activate dual-monitor treatment of SMIs and SMM (see Section 32.15.6);\n            FI;\n        FI;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_2: If executed outside VMX operation.; column_1: #UD;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xresldtrk",
    "category": "Core Instructions",
    "instructionName": "XRESLDTRK\n\t\t— Resume Tracking Load Addresses",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "TSXLDTRK",
        "Description": "Specifies the end of an Intel TSX suspend read address tracking region.",
        "Op/En": "ZO",
        "Opcode/Instruction": "F2 0F 01 E9 XRESLDTRK"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movdq2q",
    "category": "Core Instructions",
    "instructionName": "MOVDQ2Q\n\t\t— Move Quadword from XMM to MMX Technology Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move low quadword from xmm to mmx register.",
        "Instruction": "MOVDQ2Q mm, xmm",
        "Op/En": "RM",
        "Opcode": "F2 0F D6 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Moves the low quadword from the source operand (second operand) to the destination operand (first operand). The source operand is an XMM register and the destination operand is an MMX technology register.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVDQ2Q instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST := SRC[63:0];",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If CR0.EM[bit 2] = 1.; \ncolumn_1: If CR4.OSFXSR[bit 9] = 0.; \ncolumn_1: If CPUID.01H:EDX.SSE2[bit 26] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "simdFloating-Point¶": [
        "None."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/lar",
    "category": "Core Instructions",
    "instructionName": "LAR\n\t\t— Load Access Rights Byte",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r16 := access rights referenced by r16/m16",
        "Instruction": "LAR r16, r16/m16",
        "Op/En": "RM",
        "Opcode": "0F 02 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "reg := access rights referenced by r32/m16",
        "Instruction": "LAR reg, r32/m161",
        "Op/En": "RM",
        "Opcode": "0F 02 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. If the source operand is a memory address, only 16 bits of data are accessed. The destination operand is a general-purpose register.\nThe processor performs access checks as part of the loading process. Once loaded in the destination register, software can perform additional checks on the access rights information.\nThe access rights for a segment descriptor include fields located in the second doubleword (bytes 4–7) of the segment descriptor. The following fields are loaded by the LAR instruction:\nThis instruction performs the following checks before it loads the access rights in the destination register:\nIf the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no access rights are loaded in the destination operand.\nThe LAR instruction can only be executed in protected mode and IA-32e mode.",
    "operationText": "IF Offset(SRC) > descriptor table limit\n    THEN\n        ZF := 0;\n    ELSE\n        SegmentDescriptor := descriptor referenced by SRC;\n        IF SegmentDescriptor(Type) ≠ conforming code segment\n        and (CPL > DPL) or (RPL > DPL)\n        or SegmentDescriptor(Type) is not valid for instruction\n            THEN\n                ZF := 0;\n            ELSE\n                DEST := access rights from SegmentDescriptor as given in Description section;\n                ZF := 1;\n        FI;\nFI;",
    "flagsAffectedText": "The ZF flag is set to 1 if the access rights are loaded successfully; otherwise, it is cleared to 0.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory operand effective address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and the memory operand effective address is unaligned while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and the memory operand effective address is unaligned while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fstsw:fnstsw",
    "category": "Core Instructions",
    "instructionName": "FSTSW/FNSTSW\n\t\t— Store x87 FPU Status Word",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.",
        "Instruction": "FSTSW m2byte",
        "Opcode": "9B DD /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.",
        "Instruction": "FSTSW AX",
        "Opcode": "9B DF E0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.",
        "Instruction": "FNSTSW1 m2byte",
        "Opcode": "DD /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.",
        "Instruction": "FNSTSW1 AX",
        "Opcode": "DF E0"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Stores the current value of the x87 FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.\nThe FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on the state of the FPU condition code flags. (See the section titled “Branching and Conditional Moves on FPU Condition Codes” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.) This instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the completion of the prior FPU instruction.\nThe assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "DEST := FPUStatusWord;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xsusldtrk",
    "category": "Core Instructions",
    "instructionName": "XSUSLDTRK\n\t\t— Suspend Tracking Load Addresses",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "TSXLDTRK",
        "Description": "Specifies the start of an Intel TSX suspend read address tracking region.",
        "Op/En": "ZO",
        "Opcode/Instruction": "F2 0F 01 E8 XSUSLDTRK"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtqq2ph",
    "category": "Core Instructions",
    "instructionName": "VCVTQQ2PH\n\t\t— Convert Packed Signed Quadword Integers to Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert two packed signed quadword integers in xmm2/m128/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W1 5B /r VCVTQQ2PH xmm1{k1}{z}, xmm2/m128/m64bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert four packed signed quadword integers in ymm2/m256/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W1 5B /r VCVTQQ2PH xmm1{k1}{z}, ymm2/m256/m64bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed signed quadword integers in zmm2/m512/m64bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W1 5B /r VCVTQQ2PH xmm1{k1}{z}, zmm2/m512/m64bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermilps",
    "category": "Core Instructions",
    "instructionName": "VPERMILPS\n\t\t— Permute In-Lane of Quadruples of Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute single-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 0C /r VPERMILPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute single-precision floating-point values in xmm2/m128 using controls from imm8 and store result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 04 /r ib VPERMILPS xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute single-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 0C /r VPERMILPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute single-precision floating-point values in ymm2/m256 using controls from imm8 and store result in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 04 /r ib VPERMILPS ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point values xmm2 using control from xmm3/m128/m32bcst and store the result in xmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 0C /r VPERMILPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point values ymm2 using control from ymm3/m256/m32bcst and store the result in ymm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 0C /r VPERMILPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute single-precision floating-point values zmm2 using control from zmm3/m512/m32bcst and store the result in zmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 0C /r VPERMILPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point values xmm2/m128/m32bcst using controls from imm8 and store the result in xmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 04 /r ib VPERMILPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point values ymm2/m256/m32bcst using controls from imm8 and store the result in ymm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 04 /r ib VPERMILPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute single-precision floating-point values zmm2/m512/m32bcst using controls from imm8 and store the result in zmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 04 /r ibVPERMILPS zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/stac",
    "category": "Core Instructions",
    "instructionName": "STAC\n\t\t— Set AC Flag in EFLAGS Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SMAP",
        "Description": "Set the AC flag in the EFLAGS register.",
        "Op / En": "ZO",
        "Opcode/Instruction": "NP 0F 01 CB STAC"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Sets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register.\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute STAC when CPL > 0 cause #UD.",
    "operationText": "EFLAGS.AC := 1;",
    "flagsAffectedText": "AC set. Other flags are unaffected.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the CPL > 0.; \ncolumn_1: If CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20] = 0.;"
      ],
      "compatibilityMode": [
        "column_1: If the CPL > 0.; \ncolumn_1: If CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20] = 0.;"
      ],
      "protectedMode": [
        "column_1: If the CPL > 0.; \ncolumn_1: If CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20] = 0.;"
      ],
      "realAddressMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20] = 0.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/mulx",
    "category": "Core Instructions",
    "instructionName": "MULX\n\t\t— Unsigned Multiply Without Affecting Flags",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI2",
        "Description": "Unsigned multiply of r/m32 with EDX without affecting arithmetic flags.",
        "Op/ En": "RVM",
        "Opcode/Instruction": "VEX.LZ.F2.0F38.W0 F6 /r MULX r32a, r32b, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI2",
        "Description": "Unsigned multiply of r/m64 with RDX without affecting arithmetic flags.",
        "Op/ En": "RVM",
        "Opcode/Instruction": "VEX.LZ.F2.0F38.W1 F6 /r MULX r64a, r64b, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (w)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "RDX/EDX is implied 64/32 bits source"
      }
    ],
    "descriptionText": "Performs an unsigned multiplication of the implicit source operand (EDX/RDX) and the specified source operand (the third operand) and stores the low half of the result in the second destination (second operand), the high half of the result in the first destination operand (first operand), without reading or writing the arithmetic flags. This enables efficient programming where the software can interleave add with carry operations and multiplications.\nIf the first and second operand are identical, it will contain the high half of the multiplication result.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "// DEST1: ModRM:reg\n// DEST2: VEX.vvvv\nIF (OperandSize = 32)\n    SRC1 := EDX;\n    DEST2 := (SRC1*SRC2)[31:0];\n    DEST1 := (SRC1*SRC2)[63:32];\nELSE IF (OperandSize = 64)\n    SRC1 := RDX;\n        DEST2 := (SRC1*SRC2)[63:0];\n        DEST1 := (SRC1*SRC2)[127:64];\nFI",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/kshiftlw:kshiftlb:kshiftlq:kshiftld",
    "category": "Core Instructions",
    "instructionName": "KSHIFTLW/KSHIFTLB/KSHIFTLQ/KSHIFTLD\n\t\t— Shift Left Mask Registers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift left 16 bits in k2 by immediate and write result in k1.",
        "Op/En": "RRI",
        "Opcode/Instruction": "VEX.L0.66.0F3A.W1 32 /r KSHIFTLW k1, k2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Shift left 8 bits in k2 by immediate and write result in k1.",
        "Op/En": "RRI",
        "Opcode/Instruction": "VEX.L0.66.0F3A.W0 32 /r KSHIFTLB k1, k2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift left 64 bits in k2 by immediate and write result in k1.",
        "Op/En": "RRI",
        "Opcode/Instruction": "VEX.L0.66.0F3A.W1 33 /r KSHIFTLQ k1, k2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift left 32 bits in k2 by immediate and write result in k1.",
        "Op/En": "RRI",
        "Opcode/Instruction": "VEX.L0.66.0F3A.W0 33 /r KSHIFTLD k1, k2, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RRI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
        "Operand 3": "imm8"
      }
    ],
    "descriptionText": "Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
    "operationText": "COUNT := imm8[7:0]\nDEST[MAX_KL-1:0] := 0\nIF COUNT <=15\n    THEN DEST[15:0] := SRC1[15:0] << COUNT;\nFI;\nCOUNT := imm8[7:0]\nDEST[MAX_KL-1:0] := 0\nIF COUNT <=7\n    THEN DEST[7:0] := SRC1[7:0] << COUNT;\nFI;\nCOUNT := imm8[7:0]\nDEST[MAX_KL-1:0] := 0\nIF COUNT <=63\n    THEN DEST[63:0] := SRC1[63:0] << COUNT;\nFI;\nCOUNT := imm8[7:0]\nDEST[MAX_KL-1:0] := 0\nIF COUNT <=31\n    THEN DEST[31:0] := SRC1[31:0] << COUNT;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmovqb:vpmovsqb:vpmovusqb",
    "category": "Core Instructions",
    "instructionName": "VPMOVQB/VPMOVSQB/VPMOVUSQB\n\t\t— Down Convert QWord to Byte",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 2 packed quad-word integers from xmm2 into 2 packed byte integers in xmm1/m16 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 32 /r VPMOVQB xmm1/m16 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed byte integers in xmm1/m16 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 22 /r VPMOVSQB xmm1/m16 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned byte integers in xmm1/m16 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 12 /r VPMOVUSQB xmm1/m16 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed quad-word integers from ymm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 32 /r VPMOVQB xmm1/m32 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 22 /r VPMOVSQB xmm1/m32 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 12 /r VPMOVUSQB xmm1/m32 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed quad-word integers from zmm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 32 /r VPMOVQB xmm1/m64 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 22 /r VPMOVSQB xmm1/m64 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 12 /r VPMOVUSQB xmm1/m64 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Eighth Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/minsd",
    "category": "Core Instructions",
    "instructionName": "MINSD\n\t\t— Return Minimum Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Return the minimum scalar double precision floating-point value between xmm2/m64 and xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 5D /r MINSD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the minimum scalar double precision floating-point value between xmm3/m64 and xmm2.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 5D /r VMINSD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Return the minimum scalar double precision floating-point value between xmm3/m64 and xmm2.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 5D /r VMINSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the low double precision floating-point values in the first source operand and the second source operand, and returns the minimum value to the low quadword of the destination operand. When the source operand is a memory operand, only the 64 bits are accessed.\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, then SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second source) be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.\nSoftware should ensure VMINSD is encoded with VEX.L=0. Encoding VMINSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "MIN(SRC1, SRC2)\n{\n    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;\n        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC1 < SRC2) THEN DEST := SRC1;\n        ELSE DEST := SRC2;\n    FI;\n}\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := MIN(SRC1[63:0], SRC2[63:0])\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := MIN(SRC1[63:0], SRC2[63:0])\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := MIN(SRC1[63:0], SRC2[63:0])\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (including QNaN Source Operand), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fadd:faddp:fiadd",
    "category": "Core Instructions",
    "instructionName": "FADD/FADDP/FIADD\n\t\t— Add",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add m32fp to ST(0) and store result in ST(0).",
        "Instruction": "FADD m32fp",
        "Opcode": "D8 /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add m64fp to ST(0) and store result in ST(0).",
        "Instruction": "FADD m64fp",
        "Opcode": "DC /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add ST(0) to ST(i) and store result in ST(0).",
        "Instruction": "FADD ST(0), ST(i)",
        "Opcode": "D8 C0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add ST(i) to ST(0) and store result in ST(i).",
        "Instruction": "FADD ST(i), ST(0)",
        "Opcode": "DC C0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add ST(0) to ST(i), store result in ST(i), and pop the register stack.",
        "Instruction": "FADDP ST(i), ST(0)",
        "Opcode": "DE C0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add ST(0) to ST(1), store result in ST(1), and pop the register stack.",
        "Instruction": "FADDP",
        "Opcode": "DE C1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add m32int to ST(0) and store result in ST(0).",
        "Instruction": "FIADD m32int",
        "Opcode": "DA /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add m16int to ST(0) and store result in ST(0).",
        "Instruction": "FIADD m16int",
        "Opcode": "DE /0"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\nThe no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:\nFADD ST(0), ST(0);\nThe FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)\nThe FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.\nThe table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.\nWhen the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. When the source operand is an integer 0, it is treated as a +0.\nWhen both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated. See Table 3-18.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF Instruction = FIADD\n    THEN\n        DEST := DEST + ConvertToDoubleExtendedPrecisionFP(SRC);\n    ELSE (* Source operand is floating-point value *)\n        DEST := DEST + SRC;\nFI;\nIF Instruction = FADDP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Operand is an SNaN value or unsupported format.; \ncolumn_1: Operands are infinities of unlike sign.; \ncolumn_2: Source operand is a denormal value.; column_1: #D; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermd:vpermw",
    "category": "Core Instructions",
    "instructionName": "VPERMD/VPERMW\n\t\t— Permute Packed Doubleword/Word Elements",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Permute doublewords in ymm3/m256 using indices in ymm2 and store the result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 36 /r VPERMD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute doublewords in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 36 /r VPERMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute doublewords in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 36 /r VPERMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Permute word integers in xmm3/m128 using indexes in xmm2 and store the result in xmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 8D /r VPERMW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Permute word integers in ymm3/m256 using indexes in ymm2 and store the result in ymm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 8D /r VPERMW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Permute word integers in zmm3/m512 using indexes in zmm2 and store the result in zmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 8D /r VPERMW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpcmpd:vpcmpud",
    "category": "Core Instructions",
    "instructionName": "VPCMPD/VPCMPUD\n\t\t— Compare Packed Integer Values Into Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 1F /r ib VPCMPD k1 {k2}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 1F /r ib VPCMPD k1 {k2}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed signed doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of imm8 as a comparison predicate. The comparison results are written to the destination k1 under writemask k2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 1F /r ib VPCMPD k1 {k2}, zmm2, zmm3/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 1E /r ib VPCMPUD k1 {k2}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 1E /r ib VPCMPUD k1 {k2}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed unsigned doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of imm8 as a comparison predicate. The comparison results are written to the destination k1 under writemask k2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 1E /r ib VPCMPUD k1 {k2}, zmm2, zmm3/m512/m32bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/maxps",
    "category": "Core Instructions",
    "instructionName": "MAXPS\n\t\t— Maximum of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Return the maximum single precision floating-point values between xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 5F /r MAXPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the maximum single precision floating-point values between xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 5F /r VMAXPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the maximum single precision floating-point values between ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 5F /r VMAXPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Return the maximum packed single precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 5F /r VMAXPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Return the maximum packed single precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 5F /r VMAXPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Return the maximum packed single precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 5F /r VMAXPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed single precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "MAX(SRC1, SRC2)\n{\n    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;\n        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC1 > SRC2) THEN DEST := SRC1;\n        ELSE DEST := SRC2;\n    FI;\n}\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+31:i] := MAX(SRC1[i+31:i], SRC2[31:0])\n                ELSE\n                    DEST[i+31:i] := MAX(SRC1[i+31:i], SRC2[i+31:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0\n                        ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := MAX(SRC1[31:0], SRC2[31:0])\nDEST[63:32] := MAX(SRC1[63:32], SRC2[63:32])\nDEST[95:64] := MAX(SRC1[95:64], SRC2[95:64])\nDEST[127:96] := MAX(SRC1[127:96], SRC2[127:96])\nDEST[159:128] := MAX(SRC1[159:128], SRC2[159:128])\nDEST[191:160] := MAX(SRC1[191:160], SRC2[191:160])\nDEST[223:192] := MAX(SRC1[223:192], SRC2[223:192])\nDEST[255:224] := MAX(SRC1[255:224], SRC2[255:224])\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := MAX(SRC1[31:0], SRC2[31:0])\nDEST[63:32] := MAX(SRC1[63:32], SRC2[63:32])\nDEST[95:64] := MAX(SRC1[95:64], SRC2[95:64])\nDEST[127:96] := MAX(SRC1[127:96], SRC2[127:96])\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := MAX(DEST[31:0], SRC[31:0])\nDEST[63:32] := MAX(DEST[63:32], SRC[63:32])\nDEST[95:64] := MAX(DEST[95:64], SRC[95:64])\nDEST[127:96] := MAX(DEST[127:96], SRC[127:96])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (including QNaN Source Operand), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/comisd",
    "category": "Core Instructions",
    "instructionName": "COMISD\n\t\t— Compare Scalar Ordered Double Precision Floating-Point Values and Set EFLAGS",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 2F /r COMISD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F.WIG 2F /r VCOMISD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F.W1 2F /r VCOMISD xmm1, xmm2/m64{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the double precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory location. The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid operation exception only if a source operand is an SNaN.\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "RESULT := OrderedCompare(DEST[63:0] <> SRC[63:0]) {\n(* Set EFLAGS *) CASE (RESULT) OF\n    UNORDERED: ZF,PF,CF := 111;\n    GREATER_THAN: ZF,PF,CF := 000;\n    LESS_THAN: ZF,PF,CF := 001;\n    EQUAL: ZF,PF,CF := 100;\nESAC;\nOF, AF, SF := 0; }",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid (if SNaN or QNaN operands), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermpd",
    "category": "Core Instructions",
    "instructionName": "VPERMPD\n\t\t— Permute Double Precision Floating-Point Elements",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Permute double precision floating-point elements in ymm2/m256 using indices in imm8 and store the result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F3A.W1 01 /r ib VPERMPD ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point elements in ymm2/m256/m64bcst using indexes in imm8 and store the result in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 01 /r ib VPERMPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute double precision floating-point elements in zmm2/m512/m64bcst using indices in imm8 and store the result in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 01 /r ib VPERMPD zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point elements in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 16 /r VPERMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute double precision floating-point elements in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 16 /r VPERMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/btc",
    "category": "Core Instructions",
    "instructionName": "BTC\n\t\t— Bit Test and Complement",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and complement.",
        "Instruction": "BTC r/m16, r16",
        "Op/En": "MR",
        "Opcode": "0F BB /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and complement.",
        "Instruction": "BTC r/m32, r32",
        "Op/En": "MR",
        "Opcode": "0F BB /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store selected bit in CF flag and complement.",
        "Instruction": "BTC r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 0F BB /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and complement.",
        "Instruction": "BTC r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "0F BA /7 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and complement.",
        "Instruction": "BTC r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "0F BA /7 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store selected bit in CF flag and complement.",
        "Instruction": "BTC r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 0F BA /7 ib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:\nSee also: Bit(BitBase, BitOffset) on page 3-11.\nSome assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See “BT—Bit Test” in this chapter for more information on this addressing mechanism.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "CF := Bit(BitBase, BitOffset);\nBit(BitBase, BitOffset) := NOT Bit(BitBase, BitOffset);",
    "flagsAffectedText": "The CF flag contains the value of the selected bit before it is complemented. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/saveprevssp",
    "category": "Core Instructions",
    "instructionName": "SAVEPREVSSP\n\t\t— Save Previous Shadow Stack Pointer",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Save a restore-shadow-stack token on previous shadow stack.",
        "Op/En": "ZO",
        "Opcode/Instruction": "F3 0F 01 EA (mod!=11, /5, RM=010) SAVEPREVSSP"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Push a restore-shadow-stack token on the previous shadow stack at the next 8 byte aligned boundary. The previous SSP is obtained from the previous-ssp token at the top of the current shadow stack.",
    "operationText": "IF CPL = 3\n    IF (CR4.CET & IA32_U_CET.SH_STK_EN) = 0\n        THEN #UD; FI;\nELSE\n    IF (CR4.CET & IA32_S_CET.SH_STK_EN) = 0\n        THEN #UD; FI;\nFI;\nIF SSP not aligned to 8 bytes\n    THEN #GP(0); FI;\n(* Pop the “previous-ssp” token from current shadow stack *)\nprevious_ssp_token = ShadowStackPop8B(SSP)\n(* If the CF flag indicates there was a alignment hole on current shadow stack then pop that alignment hole *)\n(* Note that the alignment hole must be zero and can be present only when in legacy/compatibility mode *)\nIF RFLAGS.CF == 1 AND (IA32_EFER.LMA AND CS.L)\n    #GP(0)\nFI;\nIF RFLAGS.CF == 1\n    must_be_zero = ShadowStackPop4B(SSP)\n    IF must_be_zero != 0 THEN #GP(0)\nFI;\n(* Previous SSP token must have the bit 1 set *)\nIF ((previous_ssp_token & 0x02) == 0)\n    THEN #GP(0); (* bit 1 was 0 *)\nIF ((IA32_EFER.LMA AND CS.L) = 0 AND previous_ssp_token [63:32] != 0)\nTHEN #GP(0); FI; (* If compatibility/legacy mode and SSP not in 4G *)\n(* Save Prev SSP from previous_ssp_token to the old shadow stack at next 8 byte aligned address *)\nold_SSP = previous_ssp_token & ~0x03\ntemp := (old_SSP | (IA32_EFER.LMA & CS.L));\nShadow_stack_store 4 bytes of 0 to (old_SSP - 4)\nold_SSP := old_SSP & ~0x07;\nShadow_stack_store 8 bytes of temp to (old_SSP - 8)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: If CPL = 3 and IA32_U_CET.SH_STK_EN = 0.; \ncolumn_1: If CPL < 3 and IA32_S_CET.SH_STK_EN = 0.; \ncolumn_2: If SSP not 8 byte aligned.; column_1: #GP(0); \ncolumn_1: If carry flag is set.; \ncolumn_1: If bit 1 of the previous-ssp token is not set to 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "compatibilityMode": [
        "Same as protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: IF CPL = 3 and IA32_U_CET.SH_STK_EN = 0.; \ncolumn_1: IF CPL < 3 and IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: #GP(0); column_2: If SSP not 8 byte aligned.; \ncolumn_1: If alignment hole on shadow stack is not 0.; \ncolumn_1: If bit 1 of the previous-ssp token is not set to 1.; \ncolumn_1: If in 32-bit/compatibility mode and SSP recorded in previous-ssp token is beyond 4G.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fild",
    "category": "Core Instructions",
    "instructionName": "FILD\n\t\t— Load Integer",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push m16int onto the FPU register stack.",
        "Instruction": "FILD m16int",
        "Opcode": "DF /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push m32int onto the FPU register stack.",
        "Instruction": "FILD m32int",
        "Opcode": "DB /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push m64int onto the FPU register stack.",
        "Instruction": "FILD m64int",
        "Opcode": "DF /5"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Converts the signed-integer source operand into double extended-precision floating-point format and pushes the value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded without rounding errors. The sign of the source operand is preserved.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "TOP := TOP − 1;\nST(0) := ConvertToDoubleExtendedPrecisionFP(SRC);",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        ""
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpgatherdq:vpgatherqq",
    "category": "Core Instructions",
    "instructionName": "VPGATHERDQ/VPGATHERQQ\n\t\t— Gather Packed Qword Values Using Signed Dword/Qword Indices",
    "detailsTable": [
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 90 /r VPGATHERDQ xmm1, vm32x, xmm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using qword indices specified in vm64x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 91 /r VPGATHERQQ xmm1, vm64x, xmm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 90 /r VPGATHERDQ ymm1, vm32x, ymm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using qword indices specified in vm64y, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 91 /r VPGATHERQQ ymm1, vm64y, ymm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r,w)",
        "Operand 2": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 3": "VEX.vvvv (r, w)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction conditionally loads up to 2 or 4 qword values from memory addresses specified by the memory operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\nThe mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is specified by the most significant bit of each data element of the mask register. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.\nUsing dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 qword values from the VSIB addressing memory operand, and updates the destination register.\nThis instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.\nIf the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.\nVEX.128 version: The instruction will gather two qword values. For dword indices, only the lower two indices in the vector index register are used.\nVEX.256 version: The instruction will gather four qword values. For dword indices, only the lower four indices in the vector index register are used.\nNote that:",
    "operationText": "DEST := SRC1;\nBASE_ADDR: base register encoded in VSIB addressing;\nVINDEX: the vector index register encoded by VSIB addressing;\nSCALE: scale factor encoded by SIB:[7:6];\nDISP: optional 1, 4 byte displacement;\nMASK := SRC3;\nMASK[MAXVL-1:128] := 0;\nFOR j := 0 to 1\n    i := j * 64;\n    IF MASK[63+i] THEN\n        MASK[i +63:i] := FFFFFFFF_FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +63:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 1\n    k := j * 32;\n    i := j * 64;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX[k+31:k])*SCALE + DISP);\n    IF MASK[63+i] THEN\n        DEST[i +63:i] := FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +63:i] := 0;\nENDFOR\nDEST[MAXVL-1:128] := 0;\nMASK[MAXVL-1:128] := 0;\nFOR j := 0 to 1\n    i := j * 64;\n    IF MASK[63+i] THEN\n        MASK[i +63:i] := FFFFFFFF_FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +63:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 1\n    i := j * 64;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[i+63:i])*SCALE + DISP);\n    IF MASK[63+i] THEN\n        DEST[i +63:i] := FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +63:i] := 0;\nENDFOR\nDEST[MAXVL-1:128] := 0;\nMASK[MAXVL-1:256] := 0;\nFOR j := 0 to 3\n    i := j * 64;\n    IF MASK[63+i] THEN\n        MASK[i +63:i] := FFFFFFFF_FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +63:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 3\n    i := j * 64;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[i+63:i])*SCALE + DISP);\n    IF MASK[63+i] THEN\n        DEST[i +63:i] := FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +63:i] := 0;\nENDFOR\nDEST[MAXVL-1:256] := 0;\nMASK[MAXVL-1:256] := 0;\nFOR j := 0 to 3\n    i := j * 64;\n    IF MASK[63+i] THEN\n        MASK[i +63:i] := FFFFFFFF_FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +63:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 3\n    k := j * 32;\n    i := j * 64;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[k+31:k])*SCALE + DISP);\n    IF MASK[63+i] THEN\n        DEST[i +63:i] := FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +63:i] := 0;\nENDFOR\nDEST[MAXVL-1:256] := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-27, “Type 12 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesdecwide256kl",
    "category": "Core Instructions",
    "instructionName": "AESDECWIDE256KL\n\t\t— Perform 14 Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLEWIDE_KL",
        "Description": "Decrypt XMM0-7 using 256-bit AES key indicated by handle at m512 and store each resultant block back to its corresponding register.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 D8 !(11):011:bbb AESDECWIDE256KL m512, <XMM0-7>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r)",
        "Operands 2—9": "Implicit XMM0-7 (r, w)",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The AESDECWIDE256KL1 instruction performs 14 rounds of AES to decrypt each of the eight blocks in XMM0-7 using the 256-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding decrypted block if the operation succeeds (e.g., does not run into a handle violation failure).",
    "operationText": "Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL > 0)) ||\n                Handle [2] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256);\nIF (Illegal Handle) {\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                XMM0 := AES256Decrypt (XMM0, UnwrappedKey) ;\n                XMM1 := AES256Decrypt (XMM1, UnwrappedKey) ;\n                XMM2 := AES256Decrypt (XMM2, UnwrappedKey) ;\n                XMM3 := AES256Decrypt (XMM3, UnwrappedKey) ;\n                XMM4 := AES256Decrypt (XMM4, UnwrappedKey) ;\n                XMM5 := AES256Decrypt (XMM5, UnwrappedKey) ;\n                XMM6 := AES256Decrypt (XMM6, UnwrappedKey) ;\n                XMM7 := AES256Decrypt (XMM7, UnwrappedKey) ;\n                RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.\n1. Further details on Key Locker and usage of this instruction can be found here:",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pshufhw",
    "category": "Core Instructions",
    "instructionName": "PSHUFHW\n\t\t— Shuffle Packed High Words",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 70 /r ib PSHUFHW xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F.WIG 70 /r ib VPSHUFHW xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.F3.0F.WIG 70 /r ib VPSHUFHW ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1 under write mask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.F3.0F.WIG 70 /r ib VPSHUFHW xmm1 {k1}{z}, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1 under write mask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.F3.0F.WIG 70 /r ib VPSHUFHW ymm1 {k1}{z}, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shuffle the high words in zmm2/m512 based on the encoding in imm8 and store the result in zmm1 under write mask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.F3.0F.WIG 70 /r ib VPSHUFHW zmm1 {k1}{z}, zmm2/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Copies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. This 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand. The low quadword of the source operand is copied to the low quadword of the destination operand, for each 128-bit lane.\nNote that this instruction permits a word in the high quadword of the source operand to be copied to more than one word location in the high quadword of the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.\nVEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.\nEVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the write-mask.\nNote: In VEX encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "DEST[63:0] := SRC[63:0]\nDEST[79:64] := (SRC >> (imm[1:0] *16))[79:64]\nDEST[95:80] := (SRC >> (imm[3:2] * 16))[79:64]\nDEST[111:96] := (SRC >> (imm[5:4] * 16))[79:64]\nDEST[127:112] := (SRC >> (imm[7:6] * 16))[79:64]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := SRC1[63:0]\nDEST[79:64] := (SRC1 >> (imm[1:0] *16))[79:64]\nDEST[95:80] := (SRC1 >> (imm[3:2] * 16))[79:64]\nDEST[111:96] := (SRC1 >> (imm[5:4] * 16))[79:64]\nDEST[127:112] := (SRC1 >> (imm[7:6] * 16))[79:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0]\nDEST[79:64] := (SRC1 >> (imm[1:0] *16))[79:64]\nDEST[95:80] := (SRC1 >> (imm[3:2] * 16))[79:64]\nDEST[111:96] := (SRC1 >> (imm[5:4] * 16))[79:64]\nDEST[127:112] := (SRC1 >> (imm[7:6] * 16))[79:64]\nDEST[191:128] := SRC1[191:128]\nDEST[207192] := (SRC1 >> (imm[1:0] *16))[207:192]\nDEST[223:208] := (SRC1 >> (imm[3:2] * 16))[207:192]\nDEST[239:224] := (SRC1 >> (imm[5:4] * 16))[207:192]\nDEST[255:240] := (SRC1 >> (imm[7:6] * 16))[207:192]\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL >= 128\n    TMP_DEST[63:0] := SRC1[63:0]\n    TMP_DEST[79:64] := (SRC1 >> (imm[1:0] *16))[79:64]\n    TMP_DEST[95:80] := (SRC1 >> (imm[3:2] * 16))[79:64]\n    TMP_DEST[111:96] := (SRC1 >> (imm[5:4] * 16))[79:64]\n    TMP_DEST[127:112] := (SRC1 >> (imm[7:6] * 16))[79:64]\nFI;\nIF VL >= 256\n    TMP_DEST[191:128] := SRC1[191:128]\n    TMP_DEST[207:192] := (SRC1 >> (imm[1:0] *16))[207:192]\n    TMP_DEST[223:208] := (SRC1 >> (imm[3:2] * 16))[207:192]\n    TMP_DEST[239:224] := (SRC1 >> (imm[5:4] * 16))[207:192]\n    TMP_DEST[255:240] := (SRC1 >> (imm[7:6] * 16))[207:192]\nFI;\nIF VL >= 512\n    TMP_DEST[319:256] := SRC1[319:256]\n    TMP_DEST[335:320] := (SRC1 >> (imm[1:0] *16))[335:320]\n    TMP_DEST[351:336] := (SRC1 >> (imm[3:2] * 16))[335:320]\n    TMP_DEST[367:352] := (SRC1 >> (imm[5:4] * 16))[335:320]\n    TMP_DEST[383:368] := (SRC1 >> (imm[7:6] * 16))[335:320]\n    TMP_DEST[447:384] := SRC1[447:384]\n    TMP_DEST[463:448] := (SRC1 >> (imm[1:0] *16))[463:448]\n    TMP_DEST[479:464] := (SRC1 >> (imm[3:2] * 16))[463:448]\n    TMP_DEST[495:480] := (SRC1 >> (imm[5:4] * 16))[463:448]\n    TMP_DEST[511:496] := (SRC1 >> (imm[7:6] * 16))[463:448]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i];\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmxoff",
    "category": "VMX Instructions",
    "instructionName": "VMXOFF\n\t\t— Leave VMX Operation",
    "detailsTable": [
      {
        "Description": "Leaves VMX operation.",
        "Op/En": "ZO",
        "Opcode/Instruction": "0F 01 C4 VMXOFF"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "ZO",
        "column_2": "NA",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Takes the logical processor out of VMX operation, unblocks INIT signals, conditionally re-enables A20M, and clears any address-range monitoring.1",
    "operationText": "IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation\n    THEN VMexit;\nELSIF CPL > 0\n    THEN #GP(0);\nELSIF dual-monitor treatment of SMIs and SMM is active\n    THEN VMfail(VMXOFF under dual-monitor treatment of SMIs and SMM);\n    ELSE\n        leave VMX operation;\n        unblock INIT;\n        IF IA32_SMM_MONITOR_CTL[2] = 02\n            THEN unblock SMIs;\n        IF outside SMX operation3\n            THEN unblock and enable A20M;\n        FI;\n        clear address-range monitoring;\n        VMsucceed;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If executed outside VMX operation.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "",
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttph2qq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPH2QQ\n\t\t— Convert with Truncation Packed FP16 Values to Signed Quadword Integers",
    "detailsTable": [
      {
        "Description": "Convert two packed FP16 values in xmm2/m32/m16bcst to two signed quadword integers, and store the result in xmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.W0 7A /r VCVTTPH2QQ xmm1{k1}{z}, xmm2/m32/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four signed quadword integers, and store the result in ymm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP5.W0 7A /r VCVTTPH2QQ ymm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed quadword integers, and store the result in zmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP5.W0 7A /r VCVTTPH2QQ zmm1{k1}{z}, xmm2/m128/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Quarter"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vzeroupper",
    "category": "Core Instructions",
    "instructionName": "VZEROUPPER\n\t\t— Zero Upper Bits of YMM and ZMM Registers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Zero bits in positions 128 and higher of some YMM and ZMM registers.",
        "Op /En": "ZO",
        "Opcode/Instruction": "VEX.128.0F.WIG 77 VZEROUPPER"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "In 64-bit mode, the instruction zeroes the bits in positions 128 and higher in YMM0-YMM15 and ZMM0-ZMM15. Outside 64-bit mode, it zeroes those bits only in YMM0-YMM7 and ZMM0-ZMM7. VZEROUPPER does not modify the lower 128 bits of these registers and it does not modify ZMM16-ZMM31.\nThis instruction is recommended when transitioning between AVX and legacy SSE code; it will eliminate performance penalties caused by false dependencies.\nNote: VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified.",
    "operationText": "simd_reg_file[][] is a two dimensional array representing the SIMD register file containing all the overlapping xmm, ymm, and zmm\nregisters present in that implementation. The major dimension is the register number: 0 for xmm0, ymm0, and zmm0; 1 for xmm1,\nymm1, and zmm1; etc. The minor dimension size is the width of the implemented SIMD state measured in bits.\nIF (64-bit mode)\n    limit :=15\nELSE\n    limit := 7\nFOR i in 0 .. limit:\n    simd_reg_file[i][MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-25, “Type 8 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/clc",
    "category": "Core Instructions",
    "instructionName": "CLC\n\t\t— Clear Carry Flag",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Clear CF flag.",
        "Instruction": "CLC",
        "Op/En": "ZO",
        "Opcode": "F8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Clears the CF flag in the EFLAGS register. Operation is the same in all modes.",
    "operationText": "CF := 0;",
    "flagsAffectedText": "The CF flag is set to 0. The OF, ZF, SF, AF, and PF flags are unaffected.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetmantps",
    "category": "Core Instructions",
    "instructionName": "VGETMANTPS\n\t\t— Extract Float32 Vector of Normalized Mantissas From Float32 Vector",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Get normalized mantissa from float32 vector xmm2/m128/m32bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 26 /r ib VGETMANTPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Get normalized mantissa from float32 vector ymm2/m256/m32bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 26 /r ib VGETMANTPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Get normalized mantissa from float32 vector zmm2/m512/m32bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 26 /r ib VGETMANTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/andpd",
    "category": "Core Instructions",
    "instructionName": "ANDPD\n\t\t— Bitwise Logical AND of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Return the bitwise logical AND of packed double precision floating-point values in xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 54 /r ANDPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical AND of packed double precision floating-point values in xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F 54 /r VANDPD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical AND of packed double precision floating-point values in ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F 54 /r VANDPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical AND of packed double precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 54 /r VANDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical AND of packed double precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 54 /r VANDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Return the bitwise logical AND of packed double precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 54 /r VANDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical AND of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := SRC1[i+63:i] BITWISE AND SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := SRC1[i+63:i] BITWISE AND SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] = 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC1[63:0] BITWISE AND SRC2[63:0]\nDEST[127:64] := SRC1[127:64] BITWISE AND SRC2[127:64]\nDEST[191:128] := SRC1[191:128] BITWISE AND SRC2[191:128]\nDEST[255:192] := SRC1[255:192] BITWISE AND SRC2[255:192]\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := SRC1[63:0] BITWISE AND SRC2[63:0]\nDEST[127:64] := SRC1[127:64] BITWISE AND SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] BITWISE AND SRC[63:0]\nDEST[127:64] := DEST[127:64] BITWISE AND SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/tilezero",
    "category": "Core Instructions",
    "instructionName": "TILEZERO\n\t\t— Zero Tile",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-TILE",
        "Description": "Zero the destination tile.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F2.0F38.W0 49 11:rrr:000 TILEZERO tmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "This instruction zeroes the destination tile.\nAny attempt to execute the TILEZERO instruction inside an Intel TSX transaction will result in a transaction abort.",
    "operationText": "TILEZERO tdest\nnbytes := palette_table[palette_id].bytes_per_row\nfor i in 0 ... palette_table[palette_id].max_rows-1:\n    for j in 0 ... nbytes-1:\n        tdest.row[i].byte[j] := 0\nzero_tilecfg_start()",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "AMX-E5; see Section 2.10, “Intel® AMX Instruction Exception Classes,” for details."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sha256msg2",
    "category": "Core Instructions",
    "instructionName": "SHA256MSG2\n\t\t— Perform a Final Calculation for the Next Four SHA256 Message Dwords",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SHA",
        "Description": "Performs the final calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 CD /r SHA256MSG2 xmm1, xmm2/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "The SHA256MSG2 instruction is one of two SHA2 message scheduling instructions. The instruction performs the final calculation for the next four SHA256 message dwords.",
    "operationText": "W14 := SRC2[95:64] ;\nW15 := SRC2[127:96] ;\nW16 := SRC1[31: 0] + σ1( W14) ;\nW17 := SRC1[63: 32] + σ1( W15) ;\nW18 := SRC1[95: 64] + σ1( W16) ;\nW19 := SRC1[127: 96] + σ1( W17) ;\nDEST[127:96] := W19 ;\nDEST[95:64] := W18 ;\nDEST[63:32] := W17 ;\nDEST[31:0] := W16;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmulhw",
    "category": "Core Instructions",
    "instructionName": "PMULHW\n\t\t— Multiply Packed Signed Integers and Store High Result",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F E5 /r1 PMULHW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F E5 /r PMULHW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E5 /r VPMULHW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E5 /r VPMULHW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG E5 /r VPMULHW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG E5 /r VPMULHW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG E5 /r VPMULHW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)\nn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
    "operationText": "TEMP0[31:0] := DEST[15:0] ∗ SRC[15:0]; (* Signed multiplication *)\nTEMP1[31:0] := DEST[31:16] ∗ SRC[31:16];\nTEMP2[31:0] := DEST[47:32] ∗ SRC[47:32];\nTEMP3[31:0] := DEST[63:48] ∗ SRC[63:48];\nDEST[15:0] := TEMP0[31:16];\nDEST[31:16] := TEMP1[31:16];\nDEST[47:32] := TEMP2[31:16];\nDEST[63:48] := TEMP3[31:16];\nTEMP0[31:0] := DEST[15:0] ∗ SRC[15:0]; (* Signed multiplication *)\nTEMP1[31:0] := DEST[31:16] ∗ SRC[31:16];\nTEMP2[31:0] := DEST[47:32] ∗ SRC[47:32];\nTEMP3[31:0] := DEST[63:48] ∗ SRC[63:48];\nTEMP4[31:0] := DEST[79:64] ∗ SRC[79:64];\nTEMP5[31:0] := DEST[95:80] ∗ SRC[95:80];\nTEMP6[31:0] := DEST[111:96] ∗ SRC[111:96];\nTEMP7[31:0] := DEST[127:112] ∗ SRC[127:112];\nDEST[15:0] := TEMP0[31:16];\nDEST[31:16] := TEMP1[31:16];\nDEST[47:32] := TEMP2[31:16];\nDEST[63:48] := TEMP3[31:16];\nDEST[79:64] := TEMP4[31:16];\nDEST[95:80] := TEMP5[31:16];\nDEST[111:96] := TEMP6[31:16];\nDEST[127:112] := TEMP7[31:16];\nTEMP0[31:0] := SRC1[15:0] * SRC2[15:0] (*Signed Multiplication*)\nTEMP1[31:0] := SRC1[31:16] * SRC2[31:16]\nTEMP2[31:0] := SRC1[47:32] * SRC2[47:32]\nTEMP3[31:0] := SRC1[63:48] * SRC2[63:48]\nTEMP4[31:0] := SRC1[79:64] * SRC2[79:64]\nTEMP5[31:0] := SRC1[95:80] * SRC2[95:80]\nTEMP6[31:0] := SRC1[111:96] * SRC2[111:96]\nTEMP7[31:0] := SRC1[127:112] * SRC2[127:112]\nDEST[15:0] := TEMP0[31:16]\nDEST[31:16] := TEMP1[31:16]\nDEST[47:32] := TEMP2[31:16]\nDEST[63:48] := TEMP3[31:16]\nDEST[79:64] := TEMP4[31:16]\nDEST[95:80] := TEMP5[31:16]\nDEST[111:96] := TEMP6[31:16]\nDEST[127:112] := TEMP7[31:16]\nDEST[MAXVL-1:128] := 0\nTEMP0[31:0] := SRC1[15:0] * SRC2[15:0] (*Signed Multiplication*)\nTEMP1[31:0] := SRC1[31:16] * SRC2[31:16]\nTEMP2[31:0] := SRC1[47:32] * SRC2[47:32]\nTEMP3[31:0] := SRC1[63:48] * SRC2[63:48]\nTEMP4[31:0] := SRC1[79:64] * SRC2[79:64]\nTEMP5[31:0] := SRC1[95:80] * SRC2[95:80]\nTEMP6[31:0] := SRC1[111:96] * SRC2[111:96]\nTEMP7[31:0] := SRC1[127:112] * SRC2[127:112]\nTEMP8[31:0] := SRC1[143:128] * SRC2[143:128]\nTEMP9[31:0] := SRC1[159:144] * SRC2[159:144]\nTEMP10[31:0] := SRC1[175:160] * SRC2[175:160]\nTEMP11[31:0] := SRC1[191:176] * SRC2[191:176]\nTEMP12[31:0] := SRC1[207:192] * SRC2[207:192]\nTEMP13[31:0] := SRC1[223:208] * SRC2[223:208]\nTEMP14[31:0] := SRC1[239:224] * SRC2[239:224]\nTEMP15[31:0] := SRC1[255:240] * SRC2[255:240]\nDEST[15:0] := TEMP0[31:16]\nDEST[31:16] := TEMP1[31:16]\nDEST[47:32] := TEMP2[31:16]\nDEST[63:48] := TEMP3[31:16]\nDEST[79:64] := TEMP4[31:16]\nDEST[95:80] := TEMP5[31:16]\nDEST[111:96] := TEMP6[31:16]\nDEST[127:112] := TEMP7[31:16]\nDEST[143:128] := TEMP8[31:16]\nDEST[159:144] := TEMP9[31:16]\nDEST[175:160] := TEMP10[31:16]\nDEST[191:176] := TEMP11[31:16]\nDEST[207:192] := TEMP12[31:16]\nDEST[223:208] := TEMP13[31:16]\nDEST[239:224] := TEMP14[31:16]\nDEST[255:240] := TEMP15[31:16]\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN\n            temp[31:0] := SRC1[i+15:i] * SRC2[i+15:i]\n            DEST[i+15:i] := tmp[31:16]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movaps",
    "category": "Core Instructions",
    "instructionName": "MOVAPS\n\t\t— Move Aligned Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move aligned packed single precision floating-point values from xmm2/mem to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 28 /r MOVAPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move aligned packed single precision floating-point values from xmm1 to xmm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 29 /r MOVAPS xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed single precision floating-point values from xmm2/mem to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.0F.WIG 28 /r VMOVAPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed single precision floating-point values from xmm1 to xmm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 29 /r VMOVAPS xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed single precision floating-point values from ymm2/mem to ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.0F.WIG 28 /r VMOVAPS ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed single precision floating-point values from ymm1 to ymm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 29 /r VMOVAPS ymm2/m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed single precision floating-point values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 28 /r VMOVAPS xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed single precision floating-point values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 28 /r VMOVAPS ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move aligned packed single precision floating-point values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 28 /r VMOVAPS zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed single precision floating-point values from xmm1 to xmm2/m128 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.0F.W0 29 /r VMOVAPS xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed single precision floating-point values from ymm1 to ymm2/m256 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.0F.W0 29 /r VMOVAPS ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move aligned packed single precision floating-point values from zmm1 to zmm2/m512 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.0F.W0 29 /r VMOVAPS zmm2/m512 {k1}{z}, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Moves 4, 8 or 16 single precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.\nWhen the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection exception (#GP) will be generated. For EVEX.512 encoded versions, the operand must be aligned to the size of the memory operand. To move single precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nEVEX.512 encoded version:\nMoves 512 bits of packed single precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float32 memory location, to store the contents of a ZMM register into a float32 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 64-byte boundary or a general-protection exception (#GP) will be generated. To move single precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.\nVEX.256 and EVEX.256 encoded version:\nMoves 256 bits of packed single precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated.\n128-bit versions:\nMoves 128 bits of packed single precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.\n(E)VEX.128 encoded version: Bits (MAXVL-1:128) of the destination ZMM register are zeroed.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] :=\n            SRC[i+31:i]\n        ELSE *DEST[i+31:i] remains unchanged*\n                ; merging-masking\nENDFOR;\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := SRC[255:0]\nDEST[MAXVL-1:256] := 0\nDEST[255:0] := SRC[255:0]\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := SRC[127:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Exceptions Type1.SSE in Table 2-18, “Type 1 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-44, “Type E1 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/punpcklbw:punpcklwd:punpckldq:punpcklqdq",
    "category": "Core Instructions",
    "instructionName": "PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ\n\t\t— Unpack Low Data",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Interleave low-order bytes from mm and mm/m32 into mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 60 /r1 PUNPCKLBW mm, mm/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 60 /r PUNPCKLBW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Interleave low-order words from mm and mm/m32 into mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 61 /r1 PUNPCKLWD mm, mm/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Interleave low-order words from xmm1 and xmm2/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 61 /r PUNPCKLWD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Interleave low-order doublewords from mm and mm/m32 into mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 62 /r1 PUNPCKLDQ mm, mm/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 62 /r PUNPCKLDQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 6C /r PUNPCKLQDQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 60/r VPUNPCKLBW xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Interleave low-order words from xmm2 and xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 61/r VPUNPCKLWD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 62/r VPUNPCKLDQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 6C/r VPUNPCKLQDQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 60 /r VPUNPCKLBW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 61 /r VPUNPCKLWD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 62 /r VPUNPCKLDQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 6C /r VPUNPCKLQDQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 60 /r VPUNPCKLBW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Interleave low-order words from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 61 /r VPUNPCKLWD xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Interleave low-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register subject to write mask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 62 /r VPUNPCKLDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Interleave low-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register subject to write mask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 6C /r VPUNPCKLQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register subject to write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 60 /r VPUNPCKLBW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register subject to write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 61 /r VPUNPCKLWD ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Interleave low-order doublewords from ymm2 and ymm3/m256/m32bcst into ymm1 register subject to write mask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 62 /r VPUNPCKLDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Interleave low-order quadword from ymm2 and ymm3/m256/m64bcst into ymm1 register subject to write mask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 6C /r VPUNPCKLQDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Interleave low-order bytes from zmm2 and zmm3/m512 into zmm1 register subject to write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 60/r VPUNPCKLBW zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Interleave low-order words from zmm2 and zmm3/m512 into zmm1 register subject to write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 61/r VPUNPCKLWD zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Interleave low-order doublewords from zmm2 and zmm3/m512/m32bcst into zmm1 register subject to write mask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 62 /r VPUNPCKLDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Interleave low-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register subject to write mask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 6C /r VPUNPCKLQDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.\n255 31 0 255 31 0\nWhen the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.\nThe (V)PUNPCKLBW instruction interleaves the low-order bytes of the source and destination operands, the (V)PUNPCKLWD instruction interleaves the low-order words of the source and destination operands, the (V)PUNPCKLDQ instruction interleaves the low-order doubleword (or doublewords) of the source and destination operands, and the (V)PUNPCKLQDQ instruction interleaves the low-order quadwords of the source and destination operands.\nThese instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. For example, with the (V)PUNPCKLBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKLWD instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE versions 64-bit operand: The source operand can be an MMX technology register or a 32-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded VPUNPCKLDQ/QDQ: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source\noperand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.\nEVEX encoded VPUNPCKLWD/BW: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
    "operationText": "DEST[63:56] := SRC[31:24];\nDEST[55:48] := DEST[31:24];\nDEST[47:40] := SRC[23:16];\nDEST[39:32] := DEST[23:16];\nDEST[31:24] := SRC[15:8];\nDEST[23:16] := DEST[15:8];\nDEST[15:8] := SRC[7:0];\nDEST[7:0] := DEST[7:0];\nDEST[63:48] := SRC[31:16];\nDEST[47:32] := DEST[31:16];\nDEST[31:16] := SRC[15:0];\nDEST[15:0] := DEST[15:0];\nDEST[63:32] := SRC[31:0];\n    DEST[31:0] := DEST[31:0];\nINTERLEAVE_BYTES_512b (SRC1, SRC2)\nTMP_DEST[255:0] := INTERLEAVE_BYTES_256b(SRC1[255:0], SRC[255:0])\nTMP_DEST[511:256] := INTERLEAVE_BYTES_256b(SRC1[511:256], SRC[511:256])\nINTERLEAVE_BYTES_256b (SRC1, SRC2)\nDEST[7:0] := SRC1[7:0]\nDEST[15:8] := SRC2[7:0]\nDEST[23:16] := SRC1[15:8]\nDEST[31:24] := SRC2[15:8]\nDEST[39:32] := SRC1[23:16]\nDEST[47:40] := SRC2[23:16]\nDEST[55:48] := SRC1[31:24]\nDEST[63:56] := SRC2[31:24]\nDEST[71:64] := SRC1[39:32]\nDEST[79:72] := SRC2[39:32]\nDEST[87:80] := SRC1[47:40]\nDEST[95:88] := SRC2[47:40]\nDEST[103:96] := SRC1[55:48]\nDEST[111:104] := SRC2[55:48]\nDEST[119:112] := SRC1[63:56]\nDEST[127:120] := SRC2[63:56]\nDEST[135:128] := SRC1[135:128]\nDEST[143:136] := SRC2[135:128]\nDEST[151:144] := SRC1[143:136]\nDEST[159:152] := SRC2[143:136]\nDEST[167:160] := SRC1[151:144]\nDEST[175:168] := SRC2[151:144]\nDEST[183:176] := SRC1[159:152]\nDEST[191:184] := SRC2[159:152]\nDEST[199:192] := SRC1[167:160]\nDEST[207:200] := SRC2[167:160]\nDEST[215:208] := SRC1[175:168]\nDEST[223:216] := SRC2[175:168]\nDEST[231:224] := SRC1[183:176]\nDEST[239:232] := SRC2[183:176]\nDEST[247:240] := SRC1[191:184]\nDEST[255:248] := SRC2[191:184]\nINTERLEAVE_BYTES (SRC1, SRC2)\nDEST[7:0] := SRC1[7:0]\nDEST[15:8] := SRC2[7:0]\nDEST[23:16] := SRC1[15:8]\nDEST[31:24] := SRC2[15:8]\nDEST[39:32] := SRC1[23:16]\nDEST[47:40] := SRC2[23:16]\nDEST[55:48] := SRC1[31:24]\nDEST[63:56] := SRC2[31:24]\nDEST[71:64] := SRC1[39:32]\nDEST[79:72] := SRC2[39:32]\nDEST[87:80] := SRC1[47:40]\nDEST[95:88] := SRC2[47:40]\nDEST[103:96] := SRC1[55:48]\nDEST[111:104] := SRC2[55:48]\nDEST[119:112] := SRC1[63:56]\nDEST[127:120] := SRC2[63:56]\nINTERLEAVE_WORDS_512b (SRC1, SRC2)\nTMP_DEST[255:0] := INTERLEAVE_WORDS_256b(SRC1[255:0], SRC[255:0])\nTMP_DEST[511:256] := INTERLEAVE_WORDS_256b(SRC1[511:256], SRC[511:256])\nINTERLEAVE_WORDS_256b(SRC1, SRC2)\nDEST[15:0] := SRC1[15:0]\nDEST[31:16] := SRC2[15:0]\nDEST[47:32] := SRC1[31:16]\nDEST[63:48] := SRC2[31:16]\nDEST[79:64] := SRC1[47:32]\nDEST[95:80] := SRC2[47:32]\nDEST[111:96] := SRC1[63:48]\nDEST[127:112] := SRC2[63:48]\nDEST[143:128] := SRC1[143:128]\nDEST[159:144] := SRC2[143:128]\nDEST[175:160] := SRC1[159:144]\nDEST[191:176] := SRC2[159:144]\nDEST[207:192] := SRC1[175:160]\nDEST[223:208] := SRC2[175:160]\nDEST[239:224] := SRC1[191:176]\nDEST[255:240] := SRC2[191:176]\nINTERLEAVE_WORDS (SRC1, SRC2)\nDEST[15:0] := SRC1[15:0]\nDEST[31:16] := SRC2[15:0]\nDEST[47:32] := SRC1[31:16]\nDEST[63:48] := SRC2[31:16]\nDEST[79:64] := SRC1[47:32]\nDEST[95:80] := SRC2[47:32]\nDEST[111:96] := SRC1[63:48]\nDEST[127:112] := SRC2[63:48]\nINTERLEAVE_DWORDS_512b (SRC1, SRC2)\nTMP_DEST[255:0] := INTERLEAVE_DWORDS_256b(SRC1[255:0], SRC2[255:0])\nTMP_DEST[511:256] := INTERLEAVE_DWORDS_256b(SRC1[511:256], SRC2[511:256])\nINTERLEAVE_DWORDS_256b(SRC1, SRC2)\nDEST[31:0] := SRC1[31:0]\nDEST[63:32] := SRC2[31:0]\nDEST[95:64] := SRC1[63:32]\nDEST[127:96] := SRC2[63:32]\nDEST[159:128] := SRC1[159:128]\nDEST[191:160] := SRC2[159:128]\nDEST[223:192] := SRC1[191:160]\nDEST[255:224] := SRC2[191:160]\nINTERLEAVE_DWORDS(SRC1, SRC2)\nDEST[31:0] := SRC1[31:0]\nDEST[63:32] := SRC2[31:0]\nDEST[95:64] := SRC1[63:32]\nDEST[127:96] := SRC2[63:32]\nINTERLEAVE_QWORDS_512b (SRC1, SRC2)\nTMP_DEST[255:0] := INTERLEAVE_QWORDS_256b(SRC1[255:0], SRC2[255:0])\nTMP_DEST[511:256] := INTERLEAVE_QWORDS_256b(SRC1[511:256], SRC2[511:256])\nINTERLEAVE_QWORDS_256b(SRC1, SRC2)\nDEST[63:0] := SRC1[63:0]\nDEST[127:64] := SRC2[63:0]\nDEST[191:128] := SRC1[191:128]\nDEST[255:192] := SRC2[191:128]\nINTERLEAVE_QWORDS(SRC1, SRC2)\nDEST[63:0] := SRC1[63:0]\nDEST[127:64] := SRC2[63:0]\nDEST[127:0] := INTERLEAVE_BYTES(DEST, SRC)\nDEST[255:127] (Unmodified)\nDEST[127:0] := INTERLEAVE_BYTES(SRC1, SRC2)\nDEST[MAXVL-1:127] := 0\nDEST[255:0] := INTERLEAVE_BYTES_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nIF VL = 128\n    TMP_DEST[VL-1:0] := INTERLEAVE_BYTES(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nIF VL = 256\n    TMP_DEST[VL-1:0] := INTERLEAVE_BYTES_256b(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nIF VL = 512\n    TMP_DEST[VL-1:0] := INTERLEAVE_BYTES_512b(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := TMP_DEST[i+7:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[511:0] := INTERLEAVE_BYTES_512b(SRC1, SRC2)\nDEST[127:0] := INTERLEAVE_WORDS(DEST, SRC)\nDEST[255:127] (Unmodified)\nDEST[127:0] := INTERLEAVE_WORDS(SRC1, SRC2)\nDEST[MAXVL-1:127] := 0\nDEST[255:0] := INTERLEAVE_WORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL = 128\n    TMP_DEST[VL-1:0] := INTERLEAVE_WORDS(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nIF VL = 256\n    TMP_DEST[VL-1:0] := INTERLEAVE_WORDS_256b(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nIF VL = 512\n    TMP_DEST[VL-1:0] := INTERLEAVE_WORDS_512b(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[511:0] := INTERLEAVE_WORDS_512b(SRC1, SRC2)\nDEST[127:0] := INTERLEAVE_DWORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := INTERLEAVE_DWORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[255:0] := INTERLEAVE_DWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF (EVEX.b = 1) AND (SRC2 *is memory*)\n        THEN TMP_SRC2[i+31:i] := SRC2[31:0]\n        ELSE TMP_SRC2[i+31:i] := SRC2[i+31:i]\n    FI;\nENDFOR;\nIF VL = 128\n    TMP_DEST[VL-1:0] := INTERLEAVE_DWORDS(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nIF VL = 256\n    TMP_DEST[VL-1:0] := INTERLEAVE_DWORDS_256b(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nIF VL = 512\n    TMP_DEST[VL-1:0] := INTERLEAVE_DWORDS_512b(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking* ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST511:0] := INTERLEAVE_DWORDS_512b(SRC1, SRC2)\nDEST[MAXVL-1:VL] := 0\nDEST[127:0] := INTERLEAVE_QWORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := INTERLEAVE_QWORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[255:0] := INTERLEAVE_QWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF (EVEX.b = 1) AND (SRC2 *is memory*)\n        THEN TMP_SRC2[i+63:i] := SRC2[63:0]\n        ELSE TMP_SRC2[i+63:i] := SRC2[i+63:i]\n    FI;\nENDFOR;\nIF VL = 128\n    TMP_DEST[VL-1:0] := INTERLEAVE_QWORDS(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nIF VL = 256\n    TMP_DEST[VL-1:0] := INTERLEAVE_QWORDS_256b(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nIF VL = 512\n    TMP_DEST[VL-1:0] := INTERLEAVE_QWORDS_512b(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPUNPCKLDQ/QDQ, see Table 2-50, “Type E4NF Class Exception Conditions.”",
        "EVEX-encoded VPUNPCKLBW/WD, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfpclassss",
    "category": "Core Instructions",
    "instructionName": "VFPCLASSSS\n\t\t— Tests Type of a Scalar Float32 Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W0 67 /r VFPCLASSSS k2 {k1}, xmm2/m32, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/roundsd",
    "category": "Core Instructions",
    "instructionName": "ROUNDSD\n\t\t— Round Scalar Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.",
        "Op/En": "RMI",
        "Opcode*/Instruction": "66 0F 3A 0B /r ib ROUNDSD xmm1, xmm2/m64, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1. The rounding mode is determined by imm8. Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].",
        "Op/En": "RVMI",
        "Opcode*/Instruction": "VEX.LIG.66.0F3A.WIG 0B /r ib VROUNDSD xmm1, xmm2, xmm3/m64, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Round the double precision floating-point value in the lower qword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a double precision floating-point input to an integer value and returns the integer result as a double precision floating-point value in the lowest position. The upper double precision floating-point value in the destination is retained.\nThe immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-18 lists the encoded values for rounding-mode field).\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
    "operationText": "IF (imm[2] = ‘1)\n    THEN // rounding mode is determined by MXCSR.RC\n        DEST[63:0] := ConvertDPFPToInteger_M(SRC[63:0]);\n    ELSE // rounding mode is determined by IMM8.RC\n        DEST[63:0] := ConvertDPFPToInteger_Imm(SRC[63:0]);\nFI;\nDEST[127:63] remains unchanged ;\nDEST[63:0] := RoundToInteger(SRC[63:0], ROUND_CONTROL)\nDEST[MAXVL-1:64] (Unmodified)\nDEST[63:0] := RoundToInteger(SRC2[63:0], ROUND_CONTROL)\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-20, “Type 3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (signaled only if SRC = SNaN).",
        "Precision (signaled only if imm[3] = ‘0; if imm[3] = ‘1, then the Precision Mask in the MXSCSR is ignored and precision exception is not signaled.)",
        "Note that Denormal is not signaled by ROUNDSD."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xsave",
    "category": "Core Instructions",
    "instructionName": "XSAVE\n\t\t— Save Processor Extended States",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "XSAVE",
        "Description": "Save state components specified by EDX:EAX to mem.",
        "Op/En": "M",
        "Opcode / Instruction": "NP 0F AE /4 XSAVE mem"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "XSAVE",
        "Description": "Save state components specified by EDX:EAX to mem.",
        "Op/En": "M",
        "Opcode / Instruction": "NP REX.W + 0F AE /4 XSAVE64 mem"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.\nThe format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nSection 13.7, “Operation of XSAVE,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVE instruction. The following items provide a high-level outline:\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.",
    "operationText": "RFBM := XCR0 AND EDX:EAX; /* bitwise logical AND */\nOLD_BV := XSTATE_BV field from XSAVE header;\nIF RFBM[0] = 1\n    THEN store x87 state into legacy region of XSAVE area;\nFI;\nIF RFBM[1] = 1\n    THEN store XMM registers into legacy region of XSAVE area; // this step does not save MXCSR or MXCSR_MASK\nFI;\nIF RFBM[1] = 1 OR RFBM[2] = 1\n    THEN store MXCSR and MXCSR_MASK into legacy region of XSAVE area;\nFI;\nFOR i := 2 TO 62\n    IF RFBM[i] = 1\n        THEN save XSAVE state component i at offset n from base of XSAVE area (n enumerated by CPUID(EAX=0DH,ECX=i):EBX);\n    FI;\nENDFOR;\nXSTATE_BV field in XSAVE header := (OLD_BV AND NOT RFBM) OR (XINUSE AND RFBM);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #AC; column_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 64-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #AC; column_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 64-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).;"
      ],
      "realAddressMode": [
        "column_1: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvttps2dq",
    "category": "Core Instructions",
    "instructionName": "CVTTPS2DQ\n\t\t— Convert With Truncation Packed Single Precision Floating-Point Values to PackedSigned Doubleword Integer Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert four packed single precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 5B /r CVTTPS2DQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert four packed single precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F.WIG 5B /r VCVTTPS2DQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert eight packed single precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.F3.0F.WIG 5B /r VCVTTPS2DQ ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 using truncation subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.F3.0F.W0 5B /r VCVTTPS2DQ xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 using truncation subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.F3.0F.W0 5B /r VCVTTPS2DQ ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert sixteen packed single precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 using truncation subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.F3.0F.W0 5B /r VCVTTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Converts four, eight or sixteen packed single precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] :=\n            Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[i+31:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO 15\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+31:i] :=\n            Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0])\n                ELSE\n                    DEST[i+31:i] :=\n            Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[i+31:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0])\nDEST[63:32] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63:32])\nDEST[95:64] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[95:64])\nDEST[127:96] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[127:96)\nDEST[159:128] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[159:128])\nDEST[191:160] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[191:160])\nDEST[223:192] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[223:192])\nDEST[255:224] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[255:224])\nDEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0])\nDEST[63:32] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63:32])\nDEST[95:64] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[95:64])\nDEST[127:96] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[127:96])\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0])\nDEST[63:32] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63:32])\nDEST[95:64] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[95:64])\nDEST[127:96] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[127:96])\nDEST[MAXVL-1:128] (unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtss2sd",
    "category": "Core Instructions",
    "instructionName": "CVTSS2SD\n\t\t— Convert Scalar Single Precision Floating-Point Value to Scalar Double PrecisionFloating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert one single precision floating-point value in xmm2/m32 to one double precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 5A /r CVTSS2SD xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one single precision floating-point value in xmm3/m32 to one double precision floating-point value and merge with high bits of xmm2.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 5A /r VCVTSS2SD xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value in xmm3/m32 to one double precision floating-point value and merge with high bits of xmm2 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 5A /r VCVTSS2SD xmm1 {k1}{z}, xmm2, xmm3/m32{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Converts a single precision floating-point value in the “convert-from” source operand to a double precision floating-point value in the destination operand. When the “convert-from” source operand is an XMM register, the single precision floating-point value is contained in the low doubleword of the register. The result is stored in the low quadword of the destination operand.\n128-bit Legacy SSE version: The “convert-from” source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged. The destination operand is an XMM register.\nVEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nSoftware should ensure VCVTSS2SD is encoded with VEX.L=0. Encoding VCVTSS2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF k1[0] or *no writemask*\n    THEN DEST[63:0] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC2[31:0]);\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] = 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC2[31:0])\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31:0]);\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/shufpd",
    "category": "Core Instructions",
    "instructionName": "SHUFPD\n\t\t— Packed Interleave Shuffle of Pairs of Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shuffle two pairs of double precision floating-point values from xmm1 and xmm2/m128 using imm8 to select from each pair, interleaved result is stored in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F C6 /r ib SHUFPD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shuffle two pairs of double precision floating-point values from xmm2 and xmm3/m128 using imm8 to select from each pair, interleaved result is stored in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG C6 /r ib VSHUFPD xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shuffle four pairs of double precision floating-point values from ymm2 and ymm3/m256 using imm8 to select from each pair, interleaved result is stored in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG C6 /r ib VSHUFPD ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shuffle two pairs of double precision floating-point values from xmm2 and xmm3/m128/m64bcst using imm8 to select from each pair. store interleaved results in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 C6 /r ib VSHUFPD xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shuffle four pairs of double precision floating-point values from ymm2 and ymm3/m256/m64bcst using imm8 to select from each pair. store interleaved results in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 C6 /r ib VSHUFPD ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shuffle eight pairs of double precision floating-point values from zmm2 and zmm3/m512/m64bcst using imm8 to select from each pair. store interleaved results in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 C6 /r ib VSHUFPD zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Selects a double precision floating-point value of an input pair using a bit control and move to a designated element of the destination operand. The low-to-high order of double precision element of the destination operand is interleaved between the first source operand and the second source operand at the granularity of input pair of 128 bits. Each bit in the imm8 byte, starting from bit 0, is the select control of the corresponding element of the destination to received the shuffled result of an input pair.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location The destination operand is a ZMM/YMM/XMM register updated according to the writemask. The select controls are the lower 8/4/2 bits of the imm8 byte.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The select controls are the bit 3:0 of the imm8 byte, imm8[7:4) are ignored.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of\nthe corresponding ZMM register destination are zeroed. The select controls are the bit 1:0 of the imm8 byte, imm8[7:2) are ignored.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination operand and the first source operand is the same and is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. The select controls are the bit 1:0 of the imm8 byte, imm8[7:2) are ignored.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF IMM0[0] = 0\n    THEN TMP_DEST[63:0] := SRC1[63:0]\n    ELSE TMP_DEST[63:0] := SRC1[127:64] FI;\nIF IMM0[1] = 0\n    THEN TMP_DEST[127:64] := SRC2[63:0]\n    ELSE TMP_DEST[127:64] := SRC2[127:64] FI;\nIF VL >= 256\n    IF IMM0[2] = 0\n        THEN TMP_DEST[191:128] := SRC1[191:128]\n        ELSE TMP_DEST[191:128] := SRC1[255:192] FI;\n    IF IMM0[3] = 0\n        THEN TMP_DEST[255:192] := SRC2[191:128]\n        ELSE TMP_DEST[255:192] := SRC2[255:192] FI;\nFI;\nIF VL >= 512\n    IF IMM0[4] = 0\n        THEN TMP_DEST[319:256] := SRC1[319:256]\n        ELSE TMP_DEST[319:256] := SRC1[383:320] FI;\n    IF IMM0[5] = 0\n        THEN TMP_DEST[383:320] := SRC2[319:256]\n        ELSE TMP_DEST[383:320] := SRC2[383:320] FI;\n    IF IMM0[6] = 0\n        THEN TMP_DEST[447:384] := SRC1[447:384]\n        ELSE TMP_DEST[447:384] := SRC1[511:448] FI;\n    IF IMM0[7] = 0\n        THEN TMP_DEST[511:448] := SRC2[447:384]\n        ELSE TMP_DEST[511:448] := SRC2[511:448] FI;\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF (EVEX.b = 1)\n        THEN TMP_SRC2[i+63:i] := SRC2[63:0]\n        ELSE TMP_SRC2[i+63:i] := SRC2[i+63:i]\n    FI;\nENDFOR;\nIF IMM0[0] = 0\n    THEN TMP_DEST[63:0] := SRC1[63:0]\n    ELSE TMP_DEST[63:0] := SRC1[127:64] FI;\nIF IMM0[1] = 0\n    THEN TMP_DEST[127:64] := TMP_SRC2[63:0]\n    ELSE TMP_DEST[127:64] := TMP_SRC2[127:64] FI;\nIF VL >= 256\n    IF IMM0[2] = 0\n        THEN TMP_DEST[191:128] := SRC1[191:128]\n        ELSE TMP_DEST[191:128] := SRC1[255:192] FI;\n    IF IMM0[3] = 0\n        THEN TMP_DEST[255:192] := TMP_SRC2[191:128]\n        ELSE TMP_DEST[255:192] := TMP_SRC2[255:192] FI;\nFI;\nIF VL >= 512\n    IF IMM0[4] = 0\n        THEN TMP_DEST[319:256] := SRC1[319:256]\n        ELSE TMP_DEST[319:256] := SRC1[383:320] FI;\n    IF IMM0[5] = 0\n        THEN TMP_DEST[383:320] := TMP_SRC2[319:256]\n        ELSE TMP_DEST[383:320] := TMP_SRC2[383:320] FI;\n    IF IMM0[6] = 0\n        THEN TMP_DEST[447:384] := SRC1[447:384]\n        ELSE TMP_DEST[447:384] := SRC1[511:448] FI;\n    IF IMM0[7] = 0\n        THEN TMP_DEST[511:448] := TMP_SRC2[447:384]\n        ELSE TMP_DEST[511:448] := TMP_SRC2[511:448] FI;\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nIF IMM0[0] = 0\n    THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST[63:0] := SRC1[127:64] FI;\nIF IMM0[1] = 0\n    THEN DEST[127:64] := SRC2[63:0]\n    ELSE DEST[127:64] := SRC2[127:64] FI;\nIF IMM0[2] = 0\n    THEN DEST[191:128] := SRC1[191:128]\n    ELSE DEST[191:128] := SRC1[255:192] FI;\nIF IMM0[3] = 0\n    THEN DEST[255:192] := SRC2[191:128]\n    ELSE DEST[255:192] := SRC2[255:192] FI;\nDEST[MAXVL-1:256] (Unmodified)\nIF IMM0[0] = 0\n    THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST[63:0] := SRC1[127:64] FI;\nIF IMM0[1] = 0\n    THEN DEST[127:64] := SRC2[63:0]\n    ELSE DEST[127:64] := SRC2[127:64] FI;\nDEST[MAXVL-1:128] := 0\nIF IMM0[0] = 0\n    THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST[63:0] := SRC1[127:64] FI;\nIF IMM0[1] = 0\n    THEN DEST[127:64] := SRC2[63:0]\n    ELSE DEST[127:64] := SRC2[127:64] FI;\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fnop",
    "category": "Core Instructions",
    "instructionName": "FNOP\n\t\t— No Operation",
    "detailsTable": [
      {
        "Description": "No operation is performed.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 D0",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or machine context, except the EIP register and the FPU Instruction Pointer.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_2: If there is a pending x87 FPU exception.; column_1: #MF; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/enteraccs",
    "category": "SMX Instructions",
    "instructionName": "GETSEC[ENTERACCS]\n\t\t— Execute Authenticated Chipset Code",
    "detailsTable": [
      {
        "Description": "Enter authenticated code execution mode. EBX holds the authenticated code module physical base address. ECX holds the authenticated code module size (bytes).",
        "Instruction": "GETSEC[ENTERACCS]",
        "Opcode": "NP 0F 37 (EAX = 2)"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The GETSEC[ENTERACCS] function loads, authenticates, and executes an authenticated code module using an Intel® TXT platform chipset's public key. The ENTERACCS leaf of GETSEC is selected with EAX set to 2 at entry.\nThere are certain restrictions enforced by the processor for the execution of the GETSEC[ENTERACCS] instruction:\nFailure to conform to the above conditions results in the processor signaling a general protection exception.\nPrior to execution of the ENTERACCS leaf, other logical processors, i.e., RLPs, in the platform must be:\nIf other logical processor(s) in the same package are not idle in one of these states, execution of ENTERACCS signals a general protection exception. The same requirement and action applies if the other logical processor(s) of the same package do not have CR0.CD = 0.\nA successful execution of ENTERACCS results in the ILP entering an authenticated code execution mode. Prior to reaching this point, the processor performs several checks. These include:\nThe GETSEC[ENTERACCS] function requires two additional input parameters in the general purpose registers EBX and ECX. EBX holds the authenticated code (AC) module physical base address (the AC module must reside below 4 GBytes in physical address space) and ECX holds the AC module size (in bytes). The physical base address and size are used to retrieve the code module from system memory and load it into the internal authenticated code execution area. The base physical address is checked to verify it is on a modulo-4096 byte boundary. The size is verified to be a multiple of 64, that it does not exceed the internal authenticated code execution area capacity (as reported by GETSEC[CAPABILITIES]), and that the top address of the AC module does not exceed 32 bits. An error condition results in an abort of the authenticated code execution launch and the signaling of a general protection exception.\nAs an integrity check for proper processor hardware operation, execution of GETSEC[ENTERACCS] will also check the contents of all the machine check status registers (as reported by the MSRs IA32_MCi_STATUS) for any valid uncorrectable error condition. In addition, the global machine check status register IA32_MCG_STATUS MCIP bit must be cleared and the IERR processor package pin (or its equivalent) must not be asserted, indicating that no machine check exception processing is currently in progress. These checks are performed prior to initiating the load of the authenticated code module. Any outstanding valid uncorrectable machine check error condition present in these status registers at this point will result in the processor signaling a general protection violation.\nThe ILP masks the response to the assertion of the external signals INIT#, A20M, NMI#, and SMI#. This masking remains active until optionally unmasked by GETSEC[EXITAC] (this defined unmasking behavior assumes GETSEC[ENTERACCS] was not executed by a prior GETSEC[SENTER]). The purpose of this masking control is to prevent exposure to existing external event handlers that may not be under the control of the authenticated code module.\nThe ILP sets an internal flag to indicate it has entered authenticated code execution mode. The state of the A20M pin is likewise masked and forced internally to a de-asserted state so that any external assertion is not recognized during authenticated code execution mode.\nTo prevent other (logical) processors from interfering with the ILP operating in authenticated code execution mode, memory (excluding implicit write-back transactions) access and I/O originating from other processor agents are blocked. This protection starts when the ILP enters into authenticated code execution mode. Only memory and I/O transactions initiated from the ILP are allowed to proceed. Exiting authenticated code execution mode is done by executing GETSEC[EXITAC]. The protection of memory and I/O activities remains in effect until the ILP executes GETSEC[EXITAC].\nPrior to launching the authenticated execution module using GETSEC[ENTERACCS] or GETSEC[SENTER], the processor’s MTRRs (Memory Type Range Registers) must first be initialized to map out the authenticated RAM addresses as WB (writeback). Failure to do so may affect the ability for the processor to maintain isolation of the loaded authenticated code module. If the processor detected this requirement is not met, it will signal an Intel® TXT reset condition with an error code during the loading of the authenticated code module.\nWhile physical addresses within the load module must be mapped as WB, the memory type for locations outside of the module boundaries must be mapped to one of the supported memory types as returned by GETSEC[PARAMETERS] (or UC as default).\nTo conform to the minimum granularity of MTRR MSRs for specifying the memory type, authenticated code RAM (ACRAM) is allocated to the processor in 4096 byte granular blocks. If an AC module size as specified in ECX is not a multiple of 4096 then the processor will allocate up to the next 4096 byte boundary for mapping as ACRAM with indeterminate data. This pad area will not be visible to the authenticated code module as external memory nor can it depend on the value of the data used to fill the pad area.\nAt the successful completion of GETSEC[ENTERACCS], the architectural state of the processor is partially initialized from contents held in the header of the authenticated code module. The processor GDTR, CS, and DS selectors are initialized from fields within the authenticated code module. Since the authenticated code module must be relocatable, all address references must be relative to the authenticated code module base address in EBX. The processor GDTR base value is initialized to the AC module header field GDTBasePtr + module base address held in EBX and the GDTR limit is set to the value in the GDTLimit field. The CS selector is initialized to the AC module header SegSel field, while the DS selector is initialized to CS + 8. The segment descriptor fields are implicitly initialized to BASE=0, LIMIT=FFFFFh, G=1, D=1, P=1, S=1, read/write access for DS, and execute/read access for CS. The processor begins the authenticated code module execution with the EIP set to the AC module header EntryPoint field + module base address (EBX). The AC module based fields used for initializing the processor state are checked for consistency and any failure results in a shutdown condition.\nA summary of the register state initialization after successful completion of GETSEC[ENTERACCS] is given for the processor in Table 7-4. The paging is disabled upon entry into authenticated code execution mode. The authenticated code module is loaded and initially executed using physical addresses. It is up to the system software after execution of GETSEC[ENTERACCS] to establish a new (or restore its previous) paging environment with an appropriate mapping to meet new protection requirements. EBP is initialized to the authenticated code module base physical address for initial execution in the authenticated environment. As a result, the authenticated code can reference EBP for relative address based references, given that the authenticated code module must be position independent.\nThe segmentation related processor state that has not been initialized by GETSEC[ENTERACCS] requires appropriate initialization before use. Since a new GDT context has been established, the previous state of the segment selector values held in ES, SS, FS, GS, TR, and LDTR might not be valid.\nThe MSR IA32_EFER is also unconditionally cleared as part of the processor state initialized by ENTERACCS. Since paging is disabled upon entering authenticated code execution mode, a new paging environment will have to be reestablished in order to establish IA-32e mode while operating in authenticated code execution mode.\nDebug exception and trap related signaling is also disabled as part of GETSEC[ENTERACCS]. This is achieved by resetting DR7, TF in EFLAGs, and the MSR IA32_DEBUGCTL. These debug functions are free to be re-enabled once supporting exception handler(s), descriptor tables, and debug registers have been properly initialized following entry into authenticated code execution mode. Also, any pending single-step trap condition will have been cleared upon entry into this mode.\nPerformance related counters and counter control registers are cleared as part of execution of ENTERACCS. This implies any active performance counters at any time of ENTERACCS execution will be disabled. To reactive the processor performance counters, this state must be re-initialized and re-enabled.\nThe IA32_MISC_ENABLE MSR is initialized upon entry into authenticated execution mode. Certain bits of this MSR are preserved because preserving these bits may be important to maintain previously established platform settings (See the footnote for Table 7-5.). The remaining bits are cleared for the purpose of establishing a more consistent environment for the execution of authenticated code modules. One of the impacts of initializing this MSR is any previous condition established by the MONITOR instruction will be cleared.\nTo support the possible return to the processor architectural state prior to execution of GETSEC[ENTERACCS], certain critical processor state is captured and stored in the general- purpose registers at instruction completion. [E|R]BX holds effective address ([E|R]IP) of the instruction that would execute next after GETSEC[ENTERACCS], ECX[15:0] holds the CS selector value, ECX[31:16] holds the GDTR limit field, and [E|R]DX holds the GDTR base field. The subsequent authenticated code can preserve the contents of these registers so that this state can be manually restored if needed, prior to exiting authenticated code execution mode with GETSEC[EXITAC]. For the processor state after exiting authenticated code execution mode, see the description of GETSEC[SEXIT].\nThe IDTR will also require reloading with a new IDT context after entering authenticated code execution mode, before any exceptions or the external interrupts INTR and NMI can be handled. Since external interrupts are reenabled at the completion of authenticated code execution mode (as terminated with EXITAC), it is recommended\nthat a new IDT context be established before this point. Until such a new IDT context is established, the programmer must take care in not executing an INT n instruction or any other operation that would result in an exception or trap signaling.\nPrior to completion of the GETSEC[ENTERACCS] instruction and after successful authentication of the AC module, the private configuration space of the Intel TXT chipset is unlocked. The authenticated code module alone can gain access to this normally restricted chipset state for the purpose of securing the platform.\nOnce the authenticated code module is launched at the completion of GETSEC[ENTERACCS], it is free to enable interrupts by setting EFLAGS.IF and enable NMI by execution of IRET. This presumes that it has re-established interrupt handling support through initialization of the IDT, GDT, and corresponding interrupt handling code.",
    "operationText": "",
    "flagsAffectedText": "All flags are cleared.",
    "exceptions": {
      "64BitMode": [
        "All protected mode exceptions apply.",
        ""
      ],
      "compatibilityMode": [
        "All protected mode exceptions apply.",
        ""
      ],
      "protectedMode": [
        "column_1: If GETSEC[ENTERACCS] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: If CR0.CD = 1 or CR0.NW = 1 or CR0.NE = 0 or CR0.PE = 0 or CPL > 0 or EFLAGS.VM = 1.; \ncolumn_1: If a Intel® TXT-capable chipset is not present.; \ncolumn_1: If in VMX root operation.; \ncolumn_1: If the initiating processor is not designated as the bootstrap processor via the MSR bit IA32_APIC_BASE.BSP.; \ncolumn_1: If the processor is already in authenticated code execution mode.; \ncolumn_1: If the processor is in SMM.; \ncolumn_1: If a valid uncorrectable machine check error is logged in IA32_MC[I]_STATUS.; \ncolumn_1: If the authenticated code base is not on a 4096 byte boundary.; \ncolumn_1: If the authenticated code size > processor internal authenticated code area capacity.; \ncolumn_1: If the authenticated code size is not modulo 64.; \ncolumn_1: If other enabled logical processor(s) of the same package CR0.CD = 1.; \ncolumn_1: If other enabled logical processor(s) of the same package are not in the wait-for-SIPI or SENTER sleep state.;"
      ],
      "realAddressMode": [
        "column_1: If GETSEC[ENTERACCS] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[ENTERACCS] is not recognized in real-address mode.;"
      ],
      "virtual8086Mode": [
        "column_1: If GETSEC[ENTERACCS] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_2: GETSEC[ENTERACCS] is not recognized in virtual-8086 mode.; column_1: #GP(0);"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcompressps",
    "category": "Core Instructions",
    "instructionName": "VCOMPRESSPS\n\t\t— Store Sparse Packed Single Precision Floating-Point Values Into Dense Memory",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compress packed single precision floating-point values from xmm2 to xmm1/m128 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 8A /r VCOMPRESSPS xmm1/m128 {k1}{z}, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compress packed single precision floating-point values from ymm2 to ymm1/m256 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 8A /r VCOMPRESSPS ymm1/m256 {k1}{z}, ymm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compress packed single precision floating-point values from zmm2 using control mask k1 to zmm1/m512.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 8A /r VCOMPRESSPS zmm1/m512 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/sha1msg2",
    "category": "Core Instructions",
    "instructionName": "SHA1MSG2\n\t\t— Perform a Final Calculation for the Next Four SHA1 Message Dwords",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SHA",
        "Description": "Performs the final calculation for the next four SHA1 message dwords using intermediate results from xmm1 and the previous message dwords from xmm2/m128, storing the result in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 CA /r SHA1MSG2 xmm1, xmm2/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "The SHA1MSG2 instruction is one of two SHA1 message scheduling instructions. The instruction performs the final calculation to derive the next four SHA1 message dwords.",
    "operationText": "W13 := SRC2[95:64] ;\nW14 := SRC2[63: 32] ;\nW15 := SRC2[31: 0] ;\nW16 := (SRC1[127:96] XOR W13 ) ROL 1;\nW17 := (SRC1[95:64] XOR W14) ROL 1;\nW18 := (SRC1[63: 32] XOR W15) ROL 1;\nW19 := (SRC1[31: 0] XOR W16) ROL 1;\nDEST[127:96] := W16;\nDEST[95:64] := W17;\nDEST[63:32] := W18;\nDEST[31:0] := W19;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtsi2sd",
    "category": "Core Instructions",
    "instructionName": "CVTSI2SD\n\t\t— Convert Doubleword Integer to Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert one signed doubleword integer from r32/m32 to one double precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 2A /r CVTSI2SD xmm1, r32/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert one signed quadword integer from r/m64 to one double precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 REX.W 0F 2A /r CVTSI2SD xmm1, r/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one signed doubleword integer from r/m32 to one double precision floating-point value in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.W0 2A /r VCVTSI2SD xmm1, xmm2, r/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one signed quadword integer from r/m64 to one double precision floating-point value in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.W1 2A /r VCVTSI2SD xmm1, xmm2, r/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one signed doubleword integer from r/m32 to one double precision floating-point value in xmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W0 2A /r VCVTSI2SD xmm1, xmm2, r/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one signed quadword integer from r/m64 to one double precision floating-point value in xmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 2A /r VCVTSI2SD xmm1, xmm2, r/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the “convert-from” source operand to a double precision floating-point value in the destination operand. The result is stored in the low quadword of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\nThe second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: Use of the REX.W prefix promotes the instruction to 64-bit operands. The “convert-from” source operand (the second operand) is a general-purpose register or memory location. The destination is an XMM register Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be a general-purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored.\nVEX.W1 and EVEX.W1 versions: promotes the instruction to use 64-bit input value in 64-bit mode.\nSoftware should ensure VCVTSI2SD is encoded with VEX.L=0. Encoding VCVTSI2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (SRC2 *is register*) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n    DEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC2[63:0]);\nELSE\n    DEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC2[31:0]);\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n    DEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC2[63:0]);\nELSE\n    DEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC2[31:0]);\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n    DEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:0]);\nELSE\n    DEST[63:0] := Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0]);\nFI;\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions,” if W1; else see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions,” if W1; else see Table 2-59, “Type E10NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fptan",
    "category": "Core Instructions",
    "instructionName": "FPTAN\n\t\t— Partial Tangent",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Replace ST(0) with its approximate tangent and push 1 onto the FPU stack.",
        "Instruction": "FPTAN",
        "Opcode": "D9 F2"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes the approximate tangent of the source operand in register ST(0), stores the result in ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than ±263. The following table shows the unmasked results obtained when computing the partial tangent of various classes of numbers, assuming that underflow does not occur.\nIf the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range − 263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π. However, even within the range -263 to +263, inaccurate results can occur because the finite approximation of π used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply FPTAN only to arguments reduced accurately in software, to a value smaller in absolute value than 3π/8. See the sections titled “Approximation of Pi” and “Transcendental Instruction Accuracy” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a discussion of the proper value to use for π in performing such reductions.\nThe value 1.0 is pushed onto the register stack after the tangent has been computed to maintain compatibility with the Intel 8087 and Intel287 math coprocessors. This operation also simplifies the calculation of other trigonometric functions. For instance, the cotangent (which is the reciprocal of the tangent) can be computed by executing a FDIVR instruction after the FPTAN instruction.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF ST(0) < 263\n    THEN\n        C2 := 0;\n        ST(0) := fptan(ST(0)); // approximation of tan\n        TOP := TOP − 1;\n        ST(0) := 1.0;\n    ELSE (* Source operand is out-of-range *)\n        C2 := 1;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value, ∞, or unsupported format.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/mpsadbw",
    "category": "Core Instructions",
    "instructionName": "MPSADBW\n\t\t— Compute Multiple Packed Sums of Absolute Difference",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A 42 /r ib MPSADBW xmm1, xmm2/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by imm8.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 42 /r ib VMPSADBW xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1. Starting offsets within ymm2 and xmm3/m128 are determined by imm8.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.256.66.0F3A.WIG 42 /r ib VMPSADBW ymm1, ymm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "(V)MPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks of 32-bit dword elements, using two select fields in the immediate byte to select the offsets of the two blocks within the first source operand and the second operand. Packed SAD word results are calculated within each 128-bit lane. Each SAD word result is calculated between a stationary block_2 (whose offset within the second source operand is selected by a two bit select control, multiplied by 32 bits) and a sliding block_1 at consecutive byte-granular position within the first source operand. The offset of the first 32-bit block of block_1 is selectable using a one bit select control, multiplied by 32 bits.\n128-bit Legacy SSE version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand. Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source operand and destination operand are the same. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. Bits 7:3 of the immediate byte are ignored.\nVEX.128 encoded version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand. Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (127:128) of the corresponding YMM register are zeroed. Bits 7:3 of the immediate byte are ignored.\nVEX.256 encoded version: The sum-absolute-difference (SAD) operation is repeated 8 times for MPSADW between the same block_2 (fixed offset within the second source operand) and a variable block_1 (offset is shifted by 8 bits for each SAD operation) in the first source operand. Each 16-bit result of eight SAD operations between block_2 and block_1 is written to the respective word in the lower 128 bits of the destination operand.\nAdditionally, VMPSADBW performs another eight SAD operations on block_4 of the second source operand and block_3 of the first source operand. (Imm8[4:3]*32 + 128) specifies the bit offset of block_4 within the second source operand. (Imm[5]*32+128) specifies the initial bit offset of the block_3 within the first source operand. Each 16-bit result of eight SAD operations between block_4 and block_3 is written to the respective word in the upper 128 bits of the destination operand.\nThe first source operand is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits 7:6 of the immediate byte are ignored.\nNote: If VMPSADBW is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
    "operationText": "BLK2_OFFSET := imm8[1:0]*32\nBLK1_OFFSET := imm8[2]*32\nSRC1_BYTE0 := SRC1[BLK1_OFFSET+7:BLK1_OFFSET]\nSRC1_BYTE1 := SRC1[BLK1_OFFSET+15:BLK1_OFFSET+8]\nSRC1_BYTE2 := SRC1[BLK1_OFFSET+23:BLK1_OFFSET+16]\nSRC1_BYTE3 := SRC1[BLK1_OFFSET+31:BLK1_OFFSET+24]\nSRC1_BYTE4 := SRC1[BLK1_OFFSET+39:BLK1_OFFSET+32]\nSRC1_BYTE5 := SRC1[BLK1_OFFSET+47:BLK1_OFFSET+40]\nSRC1_BYTE6 := SRC1[BLK1_OFFSET+55:BLK1_OFFSET+48]\nSRC1_BYTE7 := SRC1[BLK1_OFFSET+63:BLK1_OFFSET+56]\nSRC1_BYTE8 := SRC1[BLK1_OFFSET+71:BLK1_OFFSET+64]\nSRC1_BYTE9 := SRC1[BLK1_OFFSET+79:BLK1_OFFSET+72]\nSRC1_BYTE10 := SRC1[BLK1_OFFSET+87:BLK1_OFFSET+80]\nSRC2_BYTE0 := SRC2[BLK2_OFFSET+7:BLK2_OFFSET]\nSRC2_BYTE1 := SRC2[BLK2_OFFSET+15:BLK2_OFFSET+8]\nSRC2_BYTE2 := SRC2[BLK2_OFFSET+23:BLK2_OFFSET+16]\nSRC2_BYTE3 := SRC2[BLK2_OFFSET+31:BLK2_OFFSET+24]\nTEMP0 := ABS(SRC1_BYTE0 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE1 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE2 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE3 - SRC2_BYTE3)\nDEST[15:0] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE1 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE2 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE3 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE4 - SRC2_BYTE3)\nDEST[31:16] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE2 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE3 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE4 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE5 - SRC2_BYTE3)\nDEST[47:32] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE3 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE4 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE5 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE6 - SRC2_BYTE3)\nDEST[63:48] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE4 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE5 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE6 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE7 - SRC2_BYTE3)\nDEST[79:64] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE5 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE6 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE7 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE8 - SRC2_BYTE3)\nDEST[95:80] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE6 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE7 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE8 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE9 - SRC2_BYTE3)\nDEST[111:96] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE7 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE8 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE9 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE10 - SRC2_BYTE3)\nDEST[127:112] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nBLK2_OFFSET := imm8[4:3]*32 + 128\nBLK1_OFFSET := imm8[5]*32 + 128\nSRC1_BYTE0 := SRC1[BLK1_OFFSET+7:BLK1_OFFSET]\nSRC1_BYTE1 := SRC1[BLK1_OFFSET+15:BLK1_OFFSET+8]\nSRC1_BYTE2 := SRC1[BLK1_OFFSET+23:BLK1_OFFSET+16]\nSRC1_BYTE3 := SRC1[BLK1_OFFSET+31:BLK1_OFFSET+24]\nSRC1_BYTE4 := SRC1[BLK1_OFFSET+39:BLK1_OFFSET+32]\nSRC1_BYTE5 := SRC1[BLK1_OFFSET+47:BLK1_OFFSET+40]\nSRC1_BYTE6 := SRC1[BLK1_OFFSET+55:BLK1_OFFSET+48]\nSRC1_BYTE7 := SRC1[BLK1_OFFSET+63:BLK1_OFFSET+56]\nSRC1_BYTE8 := SRC1[BLK1_OFFSET+71:BLK1_OFFSET+64]\nSRC1_BYTE9 := SRC1[BLK1_OFFSET+79:BLK1_OFFSET+72]\nSRC1_BYTE10 := SRC1[BLK1_OFFSET+87:BLK1_OFFSET+80]\nSRC2_BYTE0 := SRC2[BLK2_OFFSET+7:BLK2_OFFSET]\nSRC2_BYTE1 := SRC2[BLK2_OFFSET+15:BLK2_OFFSET+8]\nSRC2_BYTE2 := SRC2[BLK2_OFFSET+23:BLK2_OFFSET+16]\nSRC2_BYTE3 := SRC2[BLK2_OFFSET+31:BLK2_OFFSET+24]\nTEMP0 := ABS(SRC1_BYTE0 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE1 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE2 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE3 - SRC2_BYTE3)\nDEST[143:128] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE1 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE2 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE3 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE4 - SRC2_BYTE3)\nDEST[159:144] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE2 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE3 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE4 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE5 - SRC2_BYTE3)\nDEST[175:160] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE3 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE4 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE5 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE6 - SRC2_BYTE3)\nDEST[191:176] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE4 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE5 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE6 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE7 - SRC2_BYTE3)\nDEST[207:192] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE5 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE6 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE7 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE8 - SRC2_BYTE3)\nDEST[223:208] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE6 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE7 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE8 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE9 - SRC2_BYTE3)\nDEST[239:224] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE7 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE8 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE9 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE10 - SRC2_BYTE3)\nDEST[255:240] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nBLK2_OFFSET := imm8[1:0]*32\nBLK1_OFFSET := imm8[2]*32\nSRC1_BYTE0 := SRC1[BLK1_OFFSET+7:BLK1_OFFSET]\nSRC1_BYTE1 := SRC1[BLK1_OFFSET+15:BLK1_OFFSET+8]\nSRC1_BYTE2 := SRC1[BLK1_OFFSET+23:BLK1_OFFSET+16]\nSRC1_BYTE3 := SRC1[BLK1_OFFSET+31:BLK1_OFFSET+24]\nSRC1_BYTE4 := SRC1[BLK1_OFFSET+39:BLK1_OFFSET+32]\nSRC1_BYTE5 := SRC1[BLK1_OFFSET+47:BLK1_OFFSET+40]\nSRC1_BYTE6 := SRC1[BLK1_OFFSET+55:BLK1_OFFSET+48]\nSRC1_BYTE7 := SRC1[BLK1_OFFSET+63:BLK1_OFFSET+56]\nSRC1_BYTE8 := SRC1[BLK1_OFFSET+71:BLK1_OFFSET+64]\nSRC1_BYTE9 := SRC1[BLK1_OFFSET+79:BLK1_OFFSET+72]\nSRC1_BYTE10 := SRC1[BLK1_OFFSET+87:BLK1_OFFSET+80]\nSRC2_BYTE0 := SRC2[BLK2_OFFSET+7:BLK2_OFFSET]\nSRC2_BYTE1 := SRC2[BLK2_OFFSET+15:BLK2_OFFSET+8]\nSRC2_BYTE2 := SRC2[BLK2_OFFSET+23:BLK2_OFFSET+16]\nSRC2_BYTE3 := SRC2[BLK2_OFFSET+31:BLK2_OFFSET+24]\nTEMP0 := ABS(SRC1_BYTE0 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE1 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE2 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE3 - SRC2_BYTE3)\nDEST[15:0] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE1 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE2 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE3 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE4 - SRC2_BYTE3)\nDEST[31:16] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE2 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE3 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE4 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE5 - SRC2_BYTE3)\nDEST[47:32] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE3 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE4 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE5 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE6 - SRC2_BYTE3)\nDEST[63:48] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE4 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE5 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE6 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE7 - SRC2_BYTE3)\nDEST[79:64] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE5 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE6 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE7 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE8 - SRC2_BYTE3)\nDEST[95:80] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE6 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE7 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE8 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE9 - SRC2_BYTE3)\nDEST[111:96] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS(SRC1_BYTE7 - SRC2_BYTE0)\nTEMP1 := ABS(SRC1_BYTE8 - SRC2_BYTE1)\nTEMP2 := ABS(SRC1_BYTE9 - SRC2_BYTE2)\nTEMP3 := ABS(SRC1_BYTE10 - SRC2_BYTE3)\nDEST[127:112] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nDEST[MAXVL-1:128] := 0\nSRC_OFFSET := imm8[1:0]*32\nDEST_OFFSET := imm8[2]*32\nDEST_BYTE0 := DEST[DEST_OFFSET+7:DEST_OFFSET]\nDEST_BYTE1 := DEST[DEST_OFFSET+15:DEST_OFFSET+8]\nDEST_BYTE2 := DEST[DEST_OFFSET+23:DEST_OFFSET+16]\nDEST_BYTE3 := DEST[DEST_OFFSET+31:DEST_OFFSET+24]\nDEST_BYTE4 := DEST[DEST_OFFSET+39:DEST_OFFSET+32]\nDEST_BYTE5 := DEST[DEST_OFFSET+47:DEST_OFFSET+40]\nDEST_BYTE6 := DEST[DEST_OFFSET+55:DEST_OFFSET+48]\nDEST_BYTE7 := DEST[DEST_OFFSET+63:DEST_OFFSET+56]\nDEST_BYTE8 := DEST[DEST_OFFSET+71:DEST_OFFSET+64]\nDEST_BYTE9 := DEST[DEST_OFFSET+79:DEST_OFFSET+72]\nDEST_BYTE10 := DEST[DEST_OFFSET+87:DEST_OFFSET+80]\nSRC_BYTE0 := SRC[SRC_OFFSET+7:SRC_OFFSET]\nSRC_BYTE1 := SRC[SRC_OFFSET+15:SRC_OFFSET+8]\nSRC_BYTE2 := SRC[SRC_OFFSET+23:SRC_OFFSET+16]\nSRC_BYTE3 := SRC[SRC_OFFSET+31:SRC_OFFSET+24]\nTEMP0 := ABS( DEST_BYTE0 - SRC_BYTE0)\nTEMP1 := ABS( DEST_BYTE1 - SRC_BYTE1)\nTEMP2 := ABS( DEST_BYTE2 - SRC_BYTE2)\nTEMP3 := ABS( DEST_BYTE3 - SRC_BYTE3)\nDEST[15:0] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS( DEST_BYTE1 - SRC_BYTE0)\nTEMP1 := ABS( DEST_BYTE2 - SRC_BYTE1)\nTEMP2 := ABS( DEST_BYTE3 - SRC_BYTE2)\nTEMP3 := ABS( DEST_BYTE4 - SRC_BYTE3)\nDEST[31:16] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS( DEST_BYTE2 - SRC_BYTE0)\nTEMP1 := ABS( DEST_BYTE3 - SRC_BYTE1)\nTEMP2 := ABS( DEST_BYTE4 - SRC_BYTE2)\nTEMP3 := ABS( DEST_BYTE5 - SRC_BYTE3)\nDEST[47:32] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS( DEST_BYTE3 - SRC_BYTE0)\nTEMP1 := ABS( DEST_BYTE4 - SRC_BYTE1)\nTEMP2 := ABS( DEST_BYTE5 - SRC_BYTE2)\nTEMP3 := ABS( DEST_BYTE6 - SRC_BYTE3)\nDEST[63:48] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS( DEST_BYTE4 - SRC_BYTE0)\nTEMP1 := ABS( DEST_BYTE5 - SRC_BYTE1)\nTEMP2 := ABS( DEST_BYTE6 - SRC_BYTE2)\nTEMP3 := ABS( DEST_BYTE7 - SRC_BYTE3)\nDEST[79:64] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS( DEST_BYTE5 - SRC_BYTE0)\nTEMP1 := ABS( DEST_BYTE6 - SRC_BYTE1)\nTEMP2 := ABS( DEST_BYTE7 - SRC_BYTE2)\nTEMP3 := ABS( DEST_BYTE8 - SRC_BYTE3)\nDEST[95:80] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS( DEST_BYTE6 - SRC_BYTE0)\nTEMP1 := ABS( DEST_BYTE7 - SRC_BYTE1)\nTEMP2 := ABS( DEST_BYTE8 - SRC_BYTE2)\nTEMP3 := ABS( DEST_BYTE9 - SRC_BYTE3)\nDEST[111:96] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nTEMP0 := ABS( DEST_BYTE7 - SRC_BYTE0)\nTEMP1 := ABS( DEST_BYTE8 - SRC_BYTE1)\nTEMP2 := ABS( DEST_BYTE9 - SRC_BYTE2)\nTEMP3 := ABS( DEST_BYTE10 - SRC_BYTE3)\nDEST[127:112] := TEMP0 + TEMP1 + TEMP2 + TEMP3\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfixupimmps",
    "category": "Core Instructions",
    "instructionName": "VFIXUPIMMPS\n\t\t— Fix Up Special Packed Float32 Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Fix up special numbers in float32 vector xmm1, float32 vector xmm2 and int32 vector xmm3/m128/m32bcst and store the result in xmm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 54 /r VFIXUPIMMPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Fix up special numbers in float32 vector ymm1, float32 vector ymm2 and int32 vector ymm3/m256/m32bcst and store the result in ymm1, under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 54 /r VFIXUPIMMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Fix up elements of float32 vector in zmm2 using int32 vector table in zmm3/m512/m32bcst, combine with preserved elements from zmm1, and store the result in zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 54 /r ib VFIXUPIMMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xsaves",
    "category": "Core Instructions",
    "instructionName": "XSAVES\n\t\t— Save Processor Extended States Supervisor",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "XSS",
        "Description": "Save state components specified by EDX:EAX to mem with compaction, optimizing if possible.",
        "Op/En": "M",
        "Opcode / Instruction": "NP 0F C7 /5 XSAVES mem"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "XSS",
        "Description": "Save state components specified by EDX:EAX to mem with compaction, optimizing if possible.",
        "Op/En": "M",
        "Opcode / Instruction": "NP REX.W + 0F C7 /5 XSAVES64 mem"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logicalAND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0.\nThe format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nSection 13.11, “Operation of XSAVES,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVES instruction. The following items provide a high-level outline:\nUse of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\nSee Section 13.6, “Processor Tracking of XSAVE-Managed State,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for discussion of the bitmap XMODIFIED and of the quantity XRSTOR_INFO.",
    "operationText": "RFBM := (XCR0 OR IA32_XSS) AND EDX:EAX;\n                                /* bitwise logical OR and AND */\nIF in VMX non-root operation\n    THEN VMXNR := 1;\n    ELSE VMXNR := 0;\nFI;\nLAXA := linear address of XSAVE area;\nCOMPMASK := RFBM OR 80000000_00000000H;\nTO_BE_SAVED := RFBM AND XINUSE;\nIF XRSTOR_INFO = CPL,VMXNR,LAXA,COMPMASK\n    THEN TO_BE_SAVED := TO_BE_SAVED AND XMODIFIED;\nFI;\nIF MXCSR ≠ 1F80H AND RFBM[1]\n    THEN TO_BE_SAVED[1] = 1;\nFI;\nIF TO_BE_SAVED[0] = 1\n    THEN store x87 state into legacy region of XSAVE area;\nFI;\nIF TO_BE_SAVED[1] = 1\n    THEN store SSE state into legacy region of XSAVE area; // this step saves the XMM registers, MXCSR, and MXCSR_MASK\nFI;\nNEXT_FEATURE_OFFSET = 576;\n                            // Legacy area and XSAVE header consume 576 bytes\nFOR i := 2 TO 62\n    IF RFBM[i] = 1\n        THEN\n            IF TO_BE_SAVED[i]\n                THEN\n                    save XSAVE state component i at offset NEXT_FEATURE_OFFSET from base of XSAVE area;\n                    IF i = 8 // state component 8 is for PT state\n                        THEN IA32_RTIT_CTL.TraceEn[bit 0] := 0;\n                    FI;\n            FI;\n            NEXT_FEATURE_OFFSET = NEXT_FEATURE_OFFSET + n (n enumerated by CPUID(EAX=0DH,ECX=i):EAX);\n    FI;\nENDFOR;\nNEW_HEADER := RFBM AND XINUSE;\nIF MXCSR ≠ 1F80H AND RFBM[1]\n    THEN NEW_HEADER[1] = 1;\nFI;\nXSTATE_BV field in XSAVE header := NEW_HEADER;\nXCOMP_BV field in XSAVE header := COMPMASK;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the memory address is in a non-canonical form.; \ncolumn_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesenc",
    "category": "Core Instructions",
    "instructionName": "AESENC\n\t\t— Perform One Round of an AES Encryption Flow",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES",
        "Description": "Perform one round of an AES encryption flow, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 DC /r AESENC xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES AVX",
        "Description": "Perform one round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from the xmm3/m128; store the result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG DC /r VAESENC xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES",
        "Description": "Perform one round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from the ymm3/m256; store the result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG DC /r VAESENC ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512VL",
        "Description": "Perform one round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from the xmm3/m128; store the result in xmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG DC /r VAESENC xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512VL",
        "Description": "Perform one round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from the ymm3/m256; store the result in ymm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG DC /r VAESENC ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512F",
        "Description": "Perform one round of an AES encryption flow, using four 128-bit data (state) from zmm2 with four 128-bit round keys from the zmm3/m512; store the result in zmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG DC /r VAESENC zmm1, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      }
    ],
    "descriptionText": "This instruction performs a single round of an AES encryption flow using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\nUse the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENCCLAST instruction.\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\nThe EVEX encoded form of this instruction does not support memory fault suppression.",
    "operationText": "STATE := SRC1;\nRoundKey := SRC2;\nSTATE := ShiftRows( STATE );\nSTATE := SubBytes( STATE );\nSTATE := MixColumns( STATE );\nDEST[127:0] := STATE XOR RoundKey;\nDEST[MAXVL-1:128] (Unmodified)\n(KL,VL) = (1,128), (2,256)\nFOR I := 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := ShiftRows( STATE )\n    STATE := SubBytes( STATE )\n    STATE := MixColumns( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n(KL,VL) = (1,128), (2,256), (4,512)\nFOR i := 0 to KL-1:\n    STATE := SRC1.xmm[i] // xmm[i] is the i’th xmm word in the SIMD register\n    RoundKey := SRC2.xmm[i]\n    STATE := ShiftRows( STATE )\n    STATE := SubBytes( STATE )\n    STATE := MixColumns( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded: See Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/wrpkru",
    "category": "Core Instructions",
    "instructionName": "WRPKRU\n\t\t— Write Data to User Page Key Register",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "OSPKE",
        "Description": "Writes EAX into PKRU.",
        "Op/En": "ZO",
        "Opcode/Instruction": "NP 0F 01 EF WRPKRU"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Writes the value of EAX into PKRU. ECX and EDX must be 0 when WRPKRU is executed; otherwise, a general-protection exception (#GP) occurs.\nWRPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].\nOn processors that support the Intel 64 Architecture, the high-order 32-bits of RCX, RDX, and RAX are ignored.\nWRPKRU will never execute speculatively. Memory accesses affected by PKRU register will not execute (even speculatively) until all prior executions of WRPKRU have completed execution and updated the PKRU register.",
    "operationText": "IF (ECX = 0 AND EDX = 0)\n    THEN PKRU := EAX;\n    ELSE #GP(0);\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If EDX ≠ 0.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If CR4.PKE = 0.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmovw",
    "category": "Core Instructions",
    "instructionName": "VMOVW\n\t\t— Move Word",
    "detailsTable": [
      {
        "Description": "Copy word from reg/m16 to xmm1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.WIG 6E /r VMOVW xmm1, reg/m16",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Copy word from xmm1 to reg/m16.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.WIG 7E /r VMOVW reg/m16, xmm1",
        "Support": "V/V",
        "column_2": "B",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmpps",
    "category": "Core Instructions",
    "instructionName": "CMPPS\n\t\t— Compare Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Compare packed single precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of imm8 as a comparison predicate.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F C2 /r ib CMPPS xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed single precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG C2 /r ib VCMPPS xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed single precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG C2 /r ib VCMPPS ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed single precision floating-point values in xmm3/m128/m32bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 C2 /r ib VCMPPS k1 {k2}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed single precision floating-point values in ymm3/m256/m32bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 C2 /r ib VCMPPS k1 {k2}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed single precision floating-point values in zmm3/m512/m32bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 C2 /r ib VCMPPS k1 {k2}, zmm2, zmm3/m512/m32bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed single precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each of the pairs of packed values.\nEVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is an opmask register. Comparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).\nVEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Eight comparisons are performed with results written to the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Four comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. Four comparisons are performed with results written to bits 127:0 of the destination operand.\nThe comparison predicate operand is an 8-bit immediate:\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\nNote that processors with “CPUID.1H:ECX.AVX =0” do not implement the “greater-than”, “greater-than-or-equal”, “not-greater than”, and “not-greater-than-or-equal relations” predicates. These comparisons can be made either by using the inverse relationship (that is, use the “not-less-than-or-equal” to make a “greater-than” comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the first 8 rows of Table 3-7 (Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A) under the heading Emulation.\nCompilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPPS instruction, for processors with “CPUID.1H:ECX.AVX =0”. See Table 3-4. The compiler should treat reserved imm8 values as illegal syntax.\nThe greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)\nProcessors with “CPUID.1H:ECX.AVX =1” implement the full complement of 32 predicates shown in Table 3-5, software emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPPS instruction. See Table 3-5, where the notation of reg1 and reg2 represent either XMM registers or YMM registers. The compiler should treat reserved imm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface. Compilers and assemblers may implement three-operand pseudo-ops for EVEX encoded VCMPPS instructions in a similar fashion by extending the syntax listed in Table 3-5.\n:",
    "operationText": "CASE (COMPARISON PREDICATE) OF\n    0: OP3 := EQ_OQ; OP5 := EQ_OQ;\n    1: OP3 := LT_OS; OP5 := LT_OS;\n    2: OP3 := LE_OS; OP5 := LE_OS;\n    3: OP3 := UNORD_Q; OP5 := UNORD_Q;\n    4: OP3 := NEQ_UQ; OP5 := NEQ_UQ;\n    5: OP3 := NLT_US; OP5 := NLT_US;\n    6: OP3 := NLE_US; OP5 := NLE_US;\n    7: OP3 := ORD_Q; OP5 := ORD_Q;\n    8: OP5 := EQ_UQ;\n    9: OP5 := NGE_US;\n    10: OP5 := NGT_US;\n    11: OP5 := FALSE_OQ;\n    12: OP5 := NEQ_OQ;\n    13: OP5 := GE_OS;\n    14: OP5 := GT_OS;\n    15: OP5 := TRUE_UQ;\n    16: OP5 := EQ_OS;\n    17: OP5 := LT_OQ;\n    18: OP5 := LE_OQ;\n    19: OP5 := UNORD_S;\n    20: OP5 := NEQ_US;\n    21: OP5 := NLT_UQ;\n    22: OP5 := NLE_UQ;\n    23: OP5 := ORD_S;\n    24: OP5 := EQ_US;\n    25: OP5 := NGE_UQ;\n    26: OP5 := NGT_UQ;\n    27: OP5 := FALSE_OS;\n    28: OP5 := NEQ_OS;\n    29: OP5 := GE_OQ;\n    30: OP5 := GT_OQ;\n    31: OP5 := TRUE_US;\n    DEFAULT: Reserved\nESAC;\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k2[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    CMP := SRC1[i+31:i] OP5 SRC2[31:0]\n                ELSE\n                    CMP := SRC1[i+31:i] OP5 SRC2[i+31:i]\n            FI;\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                        ; zeroing-masking onlyFI;\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0\nCMP0 := SRC1[31:0] OP5 SRC2[31:0];\nCMP1 := SRC1[63:32] OP5 SRC2[63:32];\nCMP2 := SRC1[95:64] OP5 SRC2[95:64];\nCMP3 := SRC1[127:96] OP5 SRC2[127:96];\nCMP4 := SRC1[159:128] OP5 SRC2[159:128];\nCMP5 := SRC1[191:160] OP5 SRC2[191:160];\nCMP6 := SRC1[223:192] OP5 SRC2[223:192];\nCMP7 := SRC1[255:224] OP5 SRC2[255:224];\nIF CMP0 = TRUE\n    THEN DEST[31:0] :=FFFFFFFFH;\n    ELSE DEST[31:0] := 000000000H; FI;\nIF CMP1 = TRUE\n    THEN DEST[63:32] := FFFFFFFFH;\n    ELSE DEST[63:32] :=000000000H; FI;\nIF CMP2 = TRUE\n    THEN DEST[95:64] := FFFFFFFFH;\n    ELSE DEST[95:64] := 000000000H; FI;\nIF CMP3 = TRUE\n    THEN DEST[127:96] := FFFFFFFFH;\n    ELSE DEST[127:96] := 000000000H; FI;\nIF CMP4 = TRUE\n    THEN DEST[159:128] := FFFFFFFFH;\n    ELSE DEST[159:128] := 000000000H; FI;\nIF CMP5 = TRUE\n    THEN DEST[191:160] := FFFFFFFFH;\n    ELSE DEST[191:160] := 000000000H; FI;\nIF CMP6 = TRUE\n    THEN DEST[223:192] := FFFFFFFFH;\n    ELSE DEST[223:192] :=000000000H; FI;\nIF CMP7 = TRUE\n    THEN DEST[255:224] := FFFFFFFFH;\n    ELSE DEST[255:224] := 000000000H; FI;\nDEST[MAXVL-1:256] := 0\nCMP0 := SRC1[31:0] OP5 SRC2[31:0];\nCMP1 := SRC1[63:32] OP5 SRC2[63:32];\nCMP2 := SRC1[95:64] OP5 SRC2[95:64];\nCMP3 := SRC1[127:96] OP5 SRC2[127:96];\nIF CMP0 = TRUE\n    THEN DEST[31:0] :=FFFFFFFFH;\n    ELSE DEST[31:0] := 000000000H; FI;\nIF CMP1 = TRUE\n    THEN DEST[63:32] := FFFFFFFFH;\n    ELSE DEST[63:32] := 000000000H; FI;\nIF CMP2 = TRUE\n    THEN DEST[95:64] := FFFFFFFFH;\n    ELSE DEST[95:64] := 000000000H; FI;\nIF CMP3 = TRUE\n    THEN DEST[127:96] := FFFFFFFFH;\n    ELSE DEST[127:96] :=000000000H; FI;\nDEST[MAXVL-1:128] := 0\nCMP0 := SRC1[31:0] OP3 SRC2[31:0];\nCMP1 := SRC1[63:32] OP3 SRC2[63:32];\nCMP2 := SRC1[95:64] OP3 SRC2[95:64];\nCMP3 := SRC1[127:96] OP3 SRC2[127:96];\nIF CMP0 = TRUE\n    THEN DEST[31:0] :=FFFFFFFFH;\n    ELSE DEST[31:0] := 000000000H; FI;\nIF CMP1 = TRUE\n    THEN DEST[63:32] := FFFFFFFFH;\n    ELSE DEST[63:32] := 000000000H; FI;\nIF CMP2 = TRUE\n    THEN DEST[95:64] := FFFFFFFFH;\n    ELSE DEST[95:64] := 000000000H; FI;\nIF CMP3 = TRUE\n    THEN DEST[127:96] := FFFFFFFFH;\n    ELSE DEST[127:96] :=000000000H; FI;\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid if SNaN operand and invalid if QNaN and predicate as listed in Table 3-1, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmps:cmpsb:cmpsw:cmpsd:cmpsq",
    "category": "Core Instructions",
    "instructionName": "CMPS/CMPSB/CMPSW/CMPSD/CMPSQ\n\t\t— Compare String Operands",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly.",
        "Instruction": "CMPS m8, m8",
        "Op/En": "ZO",
        "Opcode": "A6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.",
        "Instruction": "CMPS m16, m16",
        "Op/En": "ZO",
        "Opcode": "A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly.",
        "Instruction": "CMPS m32, m32",
        "Op/En": "ZO",
        "Opcode": "A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.",
        "Instruction": "CMPS m64, m64",
        "Op/En": "ZO",
        "Opcode": "REX.W + A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly.",
        "Instruction": "CMPSB",
        "Op/En": "ZO",
        "Opcode": "A6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.",
        "Instruction": "CMPSW",
        "Op/En": "ZO",
        "Opcode": "A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly.",
        "Instruction": "CMPSD",
        "Op/En": "ZO",
        "Opcode": "A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.",
        "Instruction": "CMPSQ",
        "Op/En": "ZO",
        "Opcode": "REX.W + A7"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.\nBoth source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.\nAt the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operand form is provided to allow documentation. However, note that the documentation provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-\ntion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers, which must be loaded correctly before the compare string instruction is executed.\nThe no-operands form provides “short forms” of the byte, word, and doubleword versions of the CMPS instructions. Here also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the location of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte comparison), CMPSW (word comparison), CMPSD (doubleword comparison), or CMPSQ (quadword comparison using REX.W).\nAfter the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.\nThe CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block comparisons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.\nIn 64-bit mode, the instruction’s default address size is 64 bits, 32 bit address size is supported using the prefix 67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ). See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "temp := SRC1 - SRC2;\nSetStatusFlags(temp);\nIF (64-Bit Mode)\n    THEN\n        IF (Byte comparison)\n        THEN IF DF = 0\n            THEN\n                (R|E)SI := (R|E)SI + 1;\n                (R|E)DI := (R|E)DI + 1;\n            ELSE\n                (R|E)SI := (R|E)SI – 1;\n                (R|E)DI := (R|E)DI – 1;\n            FI;\n        ELSE IF (Word comparison)\n            THEN IF DF = 0\n                THEN\n                    (R|E)SI\n                        := (R|E)SI + 2;\n                    (R|E)DI\n                        := (R|E)DI + 2;\n                ELSE\n                    (R|E)SI\n                        := (R|E)SI – 2;\n                    (R|E)DI\n                        := (R|E)DI – 2;\n                FI;\n        ELSE IF (Doubleword\n                        comparison)\n            THEN IF DF = 0\n                THEN\n                    (R|E)SI\n                        := (R|E)SI + 4;\n                    (R|E)DI\n                        := (R|E)DI + 4;\n                ELSE\n                    (R|E)SI\n                        := (R|E)SI – 4;\n                    (R|E)DI\n                        := (R|E)DI – 4;\n                FI;\n        ELSE (* Quadword comparison *)\n            THEN IF DF = 0\n                (R|E)SI := (R|E)SI + 8;\n                (R|E)DI := (R|E)DI + 8;\n            ELSE\n                (R|E)SI := (R|E)SI – 8;\n                (R|E)DI := (R|E)DI – 8;\n            FI;\n        FI;\n    ELSE (* Non-64-bit Mode *)\n        IF (byte comparison)\n        THEN IF DF = 0\n            THEN\n                (E)SI := (E)SI + 1;\n                (E)DI := (E)DI + 1;\n            ELSE\n                (E)SI := (E)SI – 1;\n                (E)DI := (E)DI – 1;\n            FI;\n        ELSE IF (Word comparison)\n            THENIFDF =0\n                (E)SI := (E)SI + 2;\n                (E)DI := (E)DI + 2;\n            ELSE\n                (E)SI := (E)SI – 2;\n                (E)DI := (E)DI – 2;\n            FI;\n        ELSE (* Doubleword comparison *)\n            THEN IF DF = 0\n                (E)SI := (E)SI + 4;\n                (E)DI := (E)DI + 4;\n            ELSE\n                (E)SI := (E)SI – 4;\n                (E)DI := (E)DI – 4;\n            FI;\n        FI;\nFI;",
    "flagsAffectedText": "The CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result of the comparison.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/kxorw:kxorb:kxorq:kxord",
    "category": "Core Instructions",
    "instructionName": "KXORW/KXORB/KXORQ/KXORD\n\t\t— Bitwise Logical XOR Masks",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise XOR 16-bit masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W0 47 /r KXORW k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Bitwise XOR 8-bit masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W0 47 /r KXORB k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise XOR 64-bit masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W1 47 /r KXORQ k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise XOR 32-bit masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W1 47 /r KXORD k1, k2, k3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.1vvv (r)",
        "Operand 3": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
    "operationText": "DEST[15:0] := SRC1[15:0] BITWISE XOR SRC2[15:0]\nDEST[MAX_KL-1:16] := 0\nDEST[7:0] := SRC1[7:0] BITWISE XOR SRC2[7:0]\nDEST[MAX_KL-1:8] := 0\nDEST[63:0] := SRC1[63:0] BITWISE XOR SRC2[63:0]\nDEST[MAX_KL-1:64] := 0\nDEST[31:0] := SRC1[31:0] BITWISE XOR SRC2[31:0]\nDEST[MAX_KL-1:32] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/bzhi",
    "category": "Core Instructions",
    "instructionName": "BZHI\n\t\t— Zero High Bits Starting with Specified Bit Position",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI2",
        "Description": "Zero bits in r/m32 starting with the position in r32b, write result to r32a.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.0F38.W0 F5 /r BZHI r32a, r/m32, r32b"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI2",
        "Description": "Zero bits in r/m64 starting with the position in r64b, write result to r64a.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.0F38.W1 F5 /r BZHI r64a, r/m64, r64b"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMV",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "VEX.vvvv (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "BZHI copies the bits of the first source operand (the second operand) into the destination operand (the first operand) and clears the higher bits in the destination according to the INDEX value specified by the second source operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand is greater than OperandSize -1.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "N := SRC2[7:0]\nDEST := SRC1\nIF (N < OperandSize)\n    DEST[OperandSize-1:N] := 0\nFI\nIF (N > OperandSize - 1)\n    CF := 1\nELSE\n    CF := 0\nFI",
    "flagsAffectedText": "ZF and SF flags are updated based on the result. CF flag is set as specified in the Operation section. OF flag is cleared. AF and PF flags are undefined.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/packusdw",
    "category": "Core Instructions",
    "instructionName": "PACKUSDW\n\t\t— Pack With Unsigned Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 38 2B /r PACKUSDW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38 2B /r VPACKUSDW xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m256 into 16 packed unsigned word integers in ymm1 using unsigned saturation.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38 2B /r VPACKUSDW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Convert packed signed doubleword integers from xmm2 and packed signed doubleword integers from xmm3/m128/m32bcst into packed unsigned word integers in xmm1 using unsigned saturation under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 2B /r VPACKUSDW xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Convert packed signed doubleword integers from ymm2 and packed signed doubleword integers from ymm3/m256/m32bcst into packed unsigned word integers in ymm1 using unsigned saturation under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 2B /r VPACKUSDW ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Convert packed signed doubleword integers from zmm2 and packed signed doubleword integers from zmm3/m512/m32bcst into packed unsigned word integers in zmm1 using unsigned saturation under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 2B /r VPACKUSDW zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Converts packed signed doubleword integers in the first and second source operands into packed unsigned word integers using unsigned saturation to handle overflow conditions. If the signed doubleword value is beyond the range of an unsigned word (that is, greater than FFFFH or less than 0000H), the saturated unsigned word integer value of FFFFH or 0000H, respectively, is stored in the destination.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, updated conditionally under the writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding destination register destination are unmodified.",
    "operationText": "TMP[15:0] := (DEST[31:0] < 0) ? 0 : DEST[15:0];\nDEST[15:0] := (DEST[31:0] > FFFFH) ? FFFFH : TMP[15:0] ;\nTMP[31:16] := (DEST[63:32] < 0) ? 0 : DEST[47:32];\nDEST[31:16] := (DEST[63:32] > FFFFH) ? FFFFH : TMP[31:16] ;\nTMP[47:32] := (DEST[95:64] < 0) ? 0 : DEST[79:64];\nDEST[47:32] := (DEST[95:64] > FFFFH) ? FFFFH : TMP[47:32] ;\nTMP[63:48] := (DEST[127:96] < 0) ? 0 : DEST[111:96];\nDEST[63:48] := (DEST[127:96] > FFFFH) ? FFFFH : TMP[63:48] ;\nTMP[79:64] := (SRC[31:0] < 0) ? 0 : SRC[15:0];\nDEST[79:64] := (SRC[31:0] > FFFFH) ? FFFFH : TMP[79:64] ;\nTMP[95:80] := (SRC[63:32] < 0) ? 0 : SRC[47:32];\nDEST[95:80] := (SRC[63:32] > FFFFH) ? FFFFH : TMP[95:80] ;\nTMP[111:96] := (SRC[95:64] < 0) ? 0 : SRC[79:64];\nDEST[111:96] := (SRC[95:64] > FFFFH) ? FFFFH : TMP[111:96] ;\nTMP[127:112] := (SRC[127:96] < 0) ? 0 : SRC[111:96];\nDEST[127:112] := (SRC[127:96] > FFFFH) ? FFFFH : TMP[127:112] ;\nDEST[MAXVL-1:128] (Unmodified)\nTMP[15:0] := (SRC1[31:0] < 0) ? 0 : SRC1[15:0];\nDEST[15:0] := (SRC1[31:0] > FFFFH) ? FFFFH : TMP[15:0] ;\nTMP[31:16] := (SRC1[63:32] < 0) ? 0 : SRC1[47:32];\nDEST[31:16] := (SRC1[63:32] > FFFFH) ? FFFFH : TMP[31:16] ;\nTMP[47:32] := (SRC1[95:64] < 0) ? 0 : SRC1[79:64];\nDEST[47:32] := (SRC1[95:64] > FFFFH) ? FFFFH : TMP[47:32] ;\nTMP[63:48] := (SRC1[127:96] < 0) ? 0 : SRC1[111:96];\nDEST[63:48] := (SRC1[127:96] > FFFFH) ? FFFFH : TMP[63:48] ;\nTMP[79:64] := (SRC2[31:0] < 0) ? 0 : SRC2[15:0];\nDEST[79:64] := (SRC2[31:0] > FFFFH) ? FFFFH : TMP[79:64] ;\nTMP[95:80] := (SRC2[63:32] < 0) ? 0 : SRC2[47:32];\nDEST[95:80] := (SRC2[63:32] > FFFFH) ? FFFFH : TMP[95:80] ;\nTMP[111:96] := (SRC2[95:64] < 0) ? 0 : SRC2[79:64];\nDEST[111:96] := (SRC2[95:64] > FFFFH) ? FFFFH : TMP[111:96] ;\nTMP[127:112] := (SRC2[127:96] < 0) ? 0 : SRC2[111:96];\nDEST[127:112] := (SRC2[127:96] > FFFFH) ? FFFFH : TMP[127:112];\nDEST[MAXVL-1:128] := 0;\nTMP[15:0] := (SRC1[31:0] < 0) ? 0 : SRC1[15:0];\nDEST[15:0] := (SRC1[31:0] > FFFFH) ? FFFFH : TMP[15:0] ;\nTMP[31:16] := (SRC1[63:32] < 0) ? 0 : SRC1[47:32];\nDEST[31:16] := (SRC1[63:32] > FFFFH) ? FFFFH : TMP[31:16] ;\nTMP[47:32] := (SRC1[95:64] < 0) ? 0 : SRC1[79:64];\nDEST[47:32] := (SRC1[95:64] > FFFFH) ? FFFFH : TMP[47:32] ;\nTMP[63:48] := (SRC1[127:96] < 0) ? 0 : SRC1[111:96];\nDEST[63:48] := (SRC1[127:96] > FFFFH) ? FFFFH : TMP[63:48] ;\nTMP[79:64] := (SRC2[31:0] < 0) ? 0 : SRC2[15:0];\nDEST[79:64] := (SRC2[31:0] > FFFFH) ? FFFFH : TMP[79:64] ;\nTMP[95:80] := (SRC2[63:32] < 0) ? 0 : SRC2[47:32];\nDEST[95:80] := (SRC2[63:32] > FFFFH) ? FFFFH : TMP[95:80] ;\nTMP[111:96] := (SRC2[95:64] < 0) ? 0 : SRC2[79:64];\nDEST[111:96] := (SRC2[95:64] > FFFFH) ? FFFFH : TMP[111:96] ;\nTMP[127:112] := (SRC2[127:96] < 0) ? 0 : SRC2[111:96];\nDEST[127:112] := (SRC2[127:96] > FFFFH) ? FFFFH : TMP[127:112] ;\nTMP[143:128] := (SRC1[159:128] < 0) ? 0 : SRC1[143:128];\nDEST[143:128] := (SRC1[159:128] > FFFFH) ? FFFFH : TMP[143:128] ;\nTMP[159:144] := (SRC1[191:160] < 0) ? 0 : SRC1[175:160];\nDEST[159:144] := (SRC1[191:160] > FFFFH) ? FFFFH : TMP[159:144] ;\nTMP[175:160] := (SRC1[223:192] < 0) ? 0 : SRC1[207:192];\nDEST[175:160] := (SRC1[223:192] > FFFFH) ? FFFFH : TMP[175:160] ;\nTMP[191:176] := (SRC1[255:224] < 0) ? 0 : SRC1[239:224];\nDEST[191:176] := (SRC1[255:224] > FFFFH) ? FFFFH : TMP[191:176] ;\nTMP[207:192] := (SRC2[159:128] < 0) ? 0 : SRC2[143:128];\nDEST[207:192] := (SRC2[159:128] > FFFFH) ? FFFFH : TMP[207:192] ;\nTMP[223:208] := (SRC2[191:160] < 0) ? 0 : SRC2[175:160];\nDEST[223:208] := (SRC2[191:160] > FFFFH) ? FFFFH : TMP[223:208] ;\nTMP[239:224] := (SRC2[223:192] < 0) ? 0 : SRC2[207:192];\nDEST[239:224] := (SRC2[223:192] > FFFFH) ? FFFFH : TMP[239:224] ;\nTMP[255:240] := (SRC2[255:224] < 0) ? 0 : SRC2[239:224];\nDEST[255:240] := (SRC2[255:224] > FFFFH) ? FFFFH : TMP[255:240] ;\nDEST[MAXVL-1:256] := 0;\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO ((KL/2) - 1)\n    i := j * 32\n    IF (EVEX.b == 1) AND (SRC2 *is memory*)\n        THEN\n            TMP_SRC2[i+31:i] := SRC2[31:0]\n        ELSE\n            TMP_SRC2[i+31:i] := SRC2[i+31:i]\n    FI;\nENDFOR;\nTMP[15:0] := (SRC1[31:0] < 0) ? 0 : SRC1[15:0];\nDEST[15:0] := (SRC1[31:0] > FFFFH) ? FFFFH : TMP[15:0] ;\nTMP[31:16] := (SRC1[63:32] < 0) ? 0 : SRC1[47:32];\nDEST[31:16] := (SRC1[63:32] > FFFFH) ? FFFFH : TMP[31:16] ;\nTMP[47:32] := (SRC1[95:64] < 0) ? 0 : SRC1[79:64];\nDEST[47:32] := (SRC1[95:64] > FFFFH) ? FFFFH : TMP[47:32] ;\nTMP[63:48] := (SRC1[127:96] < 0) ? 0 : SRC1[111:96];\nDEST[63:48] := (SRC1[127:96] > FFFFH) ? FFFFH : TMP[63:48] ;\nTMP[79:64] := (TMP_SRC2[31:0] < 0) ? 0 : TMP_SRC2[15:0];\nDEST[79:64] := (TMP_SRC2[31:0] > FFFFH) ? FFFFH : TMP[79:64] ;\nTMP[95:80] := (TMP_SRC2[63:32] < 0) ? 0 : TMP_SRC2[47:32];\nDEST[95:80] := (TMP_SRC2[63:32] > FFFFH) ? FFFFH : TMP[95:80] ;\nTMP[111:96] := (TMP_SRC2[95:64] < 0) ? 0 : TMP_SRC2[79:64];\nDEST[111:96] := (TMP_SRC2[95:64] > FFFFH) ? FFFFH : TMP[111:96] ;\nTMP[127:112] := (TMP_SRC2[127:96] < 0) ? 0 : TMP_SRC2[111:96];\nDEST[127:112] := (TMP_SRC2[127:96] > FFFFH) ? FFFFH : TMP[127:112] ;\nIF VL >= 256\n    TMP[143:128] := (SRC1[159:128] < 0) ? 0 : SRC1[143:128];\n    DEST[143:128] := (SRC1[159:128] > FFFFH) ? FFFFH : TMP[143:128] ;\n    TMP[159:144] := (SRC1[191:160] < 0) ? 0 : SRC1[175:160];\n    DEST[159:144] := (SRC1[191:160] > FFFFH) ? FFFFH : TMP[159:144] ;\n    TMP[175:160] := (SRC1[223:192] < 0) ? 0 : SRC1[207:192];\n    DEST[175:160] := (SRC1[223:192] > FFFFH) ? FFFFH : TMP[175:160] ;\n    TMP[191:176] := (SRC1[255:224] < 0) ? 0 : SRC1[239:224];\n    DEST[191:176] := (SRC1[255:224] > FFFFH) ? FFFFH : TMP[191:176] ;\n    TMP[207:192] := (TMP_SRC2[159:128] < 0) ? 0 : TMP_SRC2[143:128];\n    DEST[207:192] := (TMP_SRC2[159:128] > FFFFH) ? FFFFH : TMP[207:192] ;\n    TMP[223:208] := (TMP_SRC2[191:160] < 0) ? 0 : TMP_SRC2[175:160];\n    DEST[223:208] := (TMP_SRC2[191:160] > FFFFH) ? FFFFH : TMP[223:208] ;\n    TMP[239:224] := (TMP_SRC2[223:192] < 0) ? 0 : TMP_SRC2[207:192];\n    DEST[239:224] := (TMP_SRC2[223:192] > FFFFH) ? FFFFH : TMP[239:224] ;\n    TMP[255:240] := (TMP_SRC2[255:224] < 0) ? 0 : TMP_SRC2[239:224];\n    DEST[255:240] := (TMP_SRC2[255:224] > FFFFH) ? FFFFH : TMP[255:240] ;\nFI;\nIF VL >= 512\n    TMP[271:256] := (SRC1[287:256] < 0) ? 0 : SRC1[271:256];\n    DEST[271:256] := (SRC1[287:256] > FFFFH) ? FFFFH : TMP[271:256] ;\n    TMP[287:272] := (SRC1[319:288] < 0) ? 0 : SRC1[303:288];\n    DEST[287:272] := (SRC1[319:288] > FFFFH) ? FFFFH : TMP[287:272] ;\n    TMP[303:288] := (SRC1[351:320] < 0) ? 0 : SRC1[335:320];\n    DEST[303:288] := (SRC1[351:320] > FFFFH) ? FFFFH : TMP[303:288] ;\n    TMP[319:304] := (SRC1[383:352] < 0) ? 0 : SRC1[367:352];\n    DEST[319:304] := (SRC1[383:352] > FFFFH) ? FFFFH : TMP[319:304] ;\n    TMP[335:320] := (TMP_SRC2[287:256] < 0) ? 0 : TMP_SRC2[271:256];\n    DEST[335:304] := (TMP_SRC2[287:256] > FFFFH) ? FFFFH : TMP[79:64] ;\n    TMP[351:336] := (TMP_SRC2[319:288] < 0) ? 0 : TMP_SRC2[303:288];\n    DEST[351:336] := (TMP_SRC2[319:288] > FFFFH) ? FFFFH : TMP[351:336] ;\n    TMP[367:352] := (TMP_SRC2[351:320] < 0) ? 0 : TMP_SRC2[315:320];\n    DEST[367:352] := (TMP_SRC2[351:320] > FFFFH) ? FFFFH : TMP[367:352] ;\n    TMP[383:368] := (TMP_SRC2[383:352] < 0) ? 0 : TMP_SRC2[367:352];\n    DEST[383:368] := (TMP_SRC2[383:352] > FFFFH) ? FFFFH : TMP[383:368] ;\n    TMP[399:384] := (SRC1[415:384] < 0) ? 0 : SRC1[399:384];\n    DEST[399:384] := (SRC1[415:384] > FFFFH) ? FFFFH : TMP[399:384] ;\n    TMP[415:400] := (SRC1[447:416] < 0) ? 0 : SRC1[431:416];\n    DEST[415:400] := (SRC1[447:416] > FFFFH) ? FFFFH : TMP[415:400] ;\n    TMP[431:416] := (SRC1[479:448] < 0) ? 0 : SRC1[463:448];\n    DEST[431:416] := (SRC1[479:448] > FFFFH) ? FFFFH : TMP[431:416] ;\n    TMP[447:432] := (SRC1[511:480] < 0) ? 0 : SRC1[495:480];\n    DEST[447:432] := (SRC1[511:480] > FFFFH) ? FFFFH : TMP[447:432] ;\n    TMP[463:448] := (TMP_SRC2[415:384] < 0) ? 0 : TMP_SRC2[399:384];\n    DEST[463:448] := (TMP_SRC2[415:384] > FFFFH) ? FFFFH : TMP[463:448] ;\n    TMP[475:464] := (TMP_SRC2[447:416] < 0) ? 0 : TMP_SRC2[431:416];\n    DEST[475:464] := (TMP_SRC2[447:416] > FFFFH) ? FFFFH : TMP[475:464] ;\n    TMP[491:476] := (TMP_SRC2[479:448] < 0) ? 0 : TMP_SRC2[463:448];\n    DEST[491:476] := (TMP_SRC2[479:448] > FFFFH) ? FFFFH : TMP[491:476] ;\n    TMP[511:492] := (TMP_SRC2[511:480] < 0) ? 0 : TMP_SRC2[495:480];\n    DEST[511:492] := (TMP_SRC2[511:480] > FFFFH) ? FFFFH : TMP[511:492] ;\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN\n            DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/exitac",
    "category": "SMX Instructions",
    "instructionName": "GETSEC[EXITAC]\n\t\t— Exit Authenticated Code Execution Mode",
    "detailsTable": [
      {
        "Description": "Exit authenticated code execution mode. RBX holds the Near Absolute Indirect jump target and EDX hold the exit parameter flags.",
        "Instruction": "GETSEC[EXITAC]",
        "Opcode": "NP 0F 37 (EAX=3)"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The GETSEC[EXITAC] leaf function exits the ILP out of authenticated code execution mode established by GETSEC[ENTERACCS] or GETSEC[SENTER]. The EXITAC leaf of GETSEC is selected with EAX set to 3 at entry. EBX (or RBX, if in 64-bit mode) holds the near jump target offset for where the processor execution resumes upon exiting authenticated code execution mode. EDX contains additional parameter control information. Currently only an input value of 0 in EDX is supported. All other EDX settings are considered reserved and result in a general protection violation.\nGETSEC[EXITAC] can only be executed if the processor is in protected mode with CPL = 0 and EFLAGS.VM = 0. The processor must also be in authenticated code execution mode. To avoid potential operability conflicts between modes, the processor is not allowed to execute this instruction if it is in SMM or in VMX operation. A violation of these conditions results in a general protection violation.\nUpon completion of the GETSEC[EXITAC] operation, the processor unmasks responses to external event signals INIT#, NMI#, and SMI#. This unmasking is performed conditionally, based on whether the authenticated code execution mode was entered via execution of GETSEC[SENTER] or GETSEC[ENTERACCS]. If the processor is in authenticated code execution mode due to the execution of GETSEC[SENTER], then these external event signals will remain masked. In this case, A20M is kept disabled in the measured environment until the measured environment executes GETSEC[SEXIT]. INIT# is unconditionally unmasked by EXITAC. Note that any events that are pending, but have been blocked while in authenticated code execution mode, will be recognized at the completion of the GETSEC[EXITAC] instruction if the pin event is unmasked.\nThe intent of providing the ability to optionally leave the pin events SMI#, and NMI# masked is to support the completion of a measured environment bring-up that makes use of VMX. In this envisioned security usage scenario, these events will remain masked until an appropriate virtual machine has been established in order to field servicing of these events in a safer manner. Details on when and how events are masked and unmasked in VMX operation are described in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C. It should be cautioned that if no VMX environment is to be activated following GETSEC[EXITAC], that these events will remain masked until the measured environment is exited with GETSEC[SEXIT]. If this is not desired then the GETSEC function SMCTRL(0) can be used for unmasking SMI# in this context. NMI# can be correspondingly unmasked by execution of IRET.\nA successful exit of the authenticated code execution mode requires the ILP to perform additional steps as outlined below:\nThe content of the authenticated code execution area is invalidated by hardware in order to protect it from further use or visibility. This internal processor storage area can no longer be used or relied upon after GETSEC[EXITAC]. Data structures need to be re-established outside of the authenticated code execution area if they are to be referenced after EXITAC. Since addressed memory content formerly mapped to the authenticated code execution area may no longer be coherent with external system memory after EXITAC, processor TLBs in support of linear to physical address translation are also invalidated.\nUpon completion of GETSEC[EXITAC] a near absolute indirect transfer is performed with EIP loaded with the contents of EBX (based on the current operating mode size). In 64-bit mode, all 64 bits of RBX are loaded into RIP if REX.W precedes GETSEC[EXITAC]. Otherwise RBX is treated as 32 bits even while in 64-bit mode. Conventional CS limit checking is performed as part of this control transfer. Any exception conditions generated as part of this control transfer will be directed to the existing IDT; thus it is recommended that an IDTR should also be established prior to execution of the EXITAC function if there is a need for fault handling. In addition, any segmentation related (and paging) data structures to be used after EXITAC should be re-established or validated by the authenticated code prior to EXITAC.\nIn addition, any segmentation related (and paging) data structures to be used after EXITAC need to be re-established and mapped outside of the authenticated RAM designated area by the authenticated code prior to EXITAC. Any data structure held within the authenticated RAM allocated area will no longer be accessible after completion by EXITAC.",
    "operationText": "(* The state of the internal flag ACMODEFLAG and SENTERFLAG persist across instruction boundary *)\nIF (CR4.SMXE=0)\n    THEN #UD;\nELSIF ( in VMX non-root operation)\n    THEN VM Exit (reason=”GETSEC instruction”);\nELSIF (GETSEC leaf unsupported)\n    THEN #UD;\nELSIF ((in VMX operation) or ( (in 64-bit mode) and ( RBX is non-canonical) )\n    (CR0.PE=0) or (CPL>0) or (EFLAGS.VM=1) or\n    (ACMODEFLAG=0) or (IN_SMM=1)) or (EDX ≠ 0))\n    THEN #GP(0);\nIF (OperandSize = 32)\n    THEN tempEIP := EBX;\nELSIF (OperandSize = 64)\n    THEN tempEIP := RBX;\nELSE\n    tempEIP := EBX AND 0000FFFFH;\nIF (tempEIP > code segment limit)\n    THEN #GP(0);\nInvalidate ACRAM contents;\nInvalidate processor TLB(s);\nDrain outgoing messages;\nSignalTXTMsg(CloseLocality3);\nSignalTXTMsg(LockSMRAM);\nSignalTXTMsg(ProcessorRelease);\nUnmask INIT;\nIF (SENTERFLAG=0)\n    THEN Unmask SMI, INIT, NMI, and A20M pin event;\nELSEIF (IA32_SMM_MONITOR_CTL[0] = 0)\n    THEN Unmask SMI pin event;\nACMODEFLAG := 0;\nIF IA32_EFER.LMA == 1\n    THEN CR3 := R8;\nEIP := tempEIP;\nEND;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "All protected mode exceptions apply.",
        ""
      ],
      "compatibilityMode": [
        "All protected mode exceptions apply."
      ],
      "protectedMode": [
        "column_1: If GETSEC[EXITAC] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: If CR0.PE = 0 or CPL>0 or EFLAGS.VM =1.; \ncolumn_1: If in VMX root operation.; \ncolumn_1: If the processor is not currently in authenticated code execution mode.; \ncolumn_1: If the processor is in SMM.; \ncolumn_1: If any reserved bit position is set in the EDX parameter register.;"
      ],
      "realAddressMode": [
        "column_1: If GETSEC[EXITAC] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[EXITAC] is not recognized in real-address mode.;"
      ],
      "virtual8086Mode": [
        "column_1: If GETSEC[EXITAC] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[EXITAC] is not recognized in virtual-8086 mode.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtudq2ph",
    "category": "Core Instructions",
    "instructionName": "VCVTUDQ2PH\n\t\t— Convert Packed Unsigned Doubleword Integers to Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F2.MAP5.W0 7A /r VCVTUDQ2PH xmm1{k1}{z}, xmm2/m128/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F2.MAP5.W0 7A /r VCVTUDQ2PH xmm1{k1}{z}, ymm2/m256/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed unsigned doubleword integers from zmm2/m512/m32bcst to packed FP16 values, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F2.MAP5.W0 7A /r VCVTUDQ2PH ymm1{k1}{z}, zmm2/m512/m32bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmaxub:pmaxuw",
    "category": "Core Instructions",
    "instructionName": "PMAXUB/PMAXUW\n\t\t— Maximum of Packed Unsigned Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F DE /r1 PMAXUB mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F DE /r PMAXUB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed unsigned word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 38 3E/r PMAXUW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F DE /r VPMAXUB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38 3E/r VPMAXUW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F DE /r VPMAXUB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38 3E/r VPMAXUW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG DE /r VPMAXUB xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG DE /r VPMAXUB ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed unsigned byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG DE /r VPMAXUB zmm1{k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 3E /r VPMAXUW xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 3E /r VPMAXUW ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed unsigned word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 3E /r VPMAXUW zmm1{k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed unsigned byte, word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\nLegacy SSE version PMAXUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "IF DEST[7:0] > SRC[17:0]) THEN\n    DEST[7:0] := DEST[7:0];\nELSE\n    DEST[7:0] := SRC[7:0]; FI;\n(* Repeat operation for 2nd through 7th bytes in source and destination operands *)\nIF DEST[63:56] > SRC[63:56]) THEN\n    DEST[63:56] := DEST[63:56];\nELSE\n    DEST[63:56] := SRC[63:56]; FI;\nIF DEST[7:0] >SRC[7:0] THEN\n        DEST[7:0] := DEST[7:0];\n    ELSE\n        DEST[15:0] := SRC[7:0]; FI;\n    (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n    IF DEST[127:120] >SRC[127:120] THEN\n        DEST[127:120] := DEST[127:120];\n    ELSE\n        DEST[127:120] := SRC[127:120]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[7:0] >SRC2[7:0] THEN\n        DEST[7:0] := SRC1[7:0];\n    ELSE\n        DEST[7:0] := SRC2[7:0]; FI;\n    (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n    IF SRC1[127:120] >SRC2[127:120] THEN\n        DEST[127:120] := SRC1[127:120];\n    ELSE\n        DEST[127:120] := SRC2[127:120]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[7:0] >SRC2[7:0] THEN\n        DEST[7:0] := SRC1[7:0];\n    ELSE\n        DEST[15:0] := SRC2[7:0]; FI;\n    (* Repeat operation for 2nd through 31st bytes in source and destination operands *)\n    IF SRC1[255:248] >SRC2[255:248] THEN\n        DEST[255:248] := SRC1[255:248];\n    ELSE\n        DEST[255:248] := SRC2[255:248]; FI;\nDEST[MAXVL-1:128] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask* THEN\n        IF SRC1[i+7:i] > SRC2[i+7:i]\n            THEN DEST[i+7:i] := SRC1[i+7:i];\n            ELSE DEST[i+7:i] := SRC2[i+7:i];\n        FI;\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nIF DEST[15:0] >SRC[15:0] THEN\n        DEST[15:0] := DEST[15:0];\n    ELSE\n        DEST[15:0] := SRC[15:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF DEST[127:112] >SRC[127:112] THEN\n        DEST[127:112] := DEST[127:112];\n    ELSE\n        DEST[127:112] := SRC[127:112]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[15:0] > SRC2[15:0] THEN\n        DEST[15:0] := SRC1[15:0];\n    ELSE\n        DEST[15:0] := SRC2[15:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF SRC1[127:112] >SRC2[127:112] THEN\n        DEST[127:112] := SRC1[127:112];\n    ELSE\n        DEST[127:112] := SRC2[127:112]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[15:0] > SRC2[15:0] THEN\n        DEST[15:0] := SRC1[15:0];\n    ELSE\n        DEST[15:0] := SRC2[15:0]; FI;\n    (* Repeat operation for 2nd through 15th words in source and destination operands *)\n    IF SRC1[255:240] >SRC2[255:240] THEN\n        DEST[255:240] := SRC1[255:240];\n    ELSE\n        DEST[255:240] := SRC2[255:240]; FI;\nDEST[MAXVL-1:128] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask* THEN\n        IF SRC1[i+15:i] > SRC2[i+15:i]\n            THEN DEST[i+15:i] := SRC1[i+15:i];\n            ELSE DEST[i+15:i] := SRC2[i+15:i];\n        FI;\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/emodt",
    "category": "SGX Instructions",
    "instructionName": "EMODT\n\t\t— Change the Type of an EPC Page",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX2",
        "Description": "This leaf function changes the type of an existing EPC page.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 0FH ENCLS[EMODT]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EMODT (In)",
        "column_3": "Return Error Code (Out)",
        "column_4": "Address of a SECINFO (In)",
        "column_5": "Address of the destination EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/bswap",
    "category": "Core Instructions",
    "instructionName": "BSWAP\n\t\t— Byte Swap",
    "detailsTable": [
      {
        "64-bit Mode": "Valid*",
        "Compat/Leg Mode": "Valid",
        "Description": "Reverses the byte order of a 32-bit register.",
        "Instruction": "BSWAP r32",
        "Op/En": "O",
        "Opcode": "0F C8+rd"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Reverses the byte order of a 64-bit register.",
        "Instruction": "BSWAP r64",
        "Op/En": "O",
        "Opcode": "REX.W + 0F C8+rd"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "O",
        "Operand 1": "opcode + rd (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Reverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting little-endian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "TEMP := DEST\nIF 64-bit mode AND OperandSize = 64\n    THEN\n        DEST[7:0] := TEMP[63:56];\n        DEST[15:8] := TEMP[55:48];\n        DEST[23:16] := TEMP[47:40];\n        DEST[31:24] := TEMP[39:32];\n        DEST[39:32] := TEMP[31:24];\n        DEST[47:40] := TEMP[23:16];\n        DEST[55:48] := TEMP[15:8];\n        DEST[63:56] := TEMP[7:0];\n    ELSE\n        DEST[7:0] := TEMP[31:24];\n        DEST[15:8] := TEMP[23:16];\n        DEST[23:16] := TEMP[15:8];\n        DEST[31:24] := TEMP[7:0];\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscalefph",
    "category": "Core Instructions",
    "instructionName": "VSCALEFPH\n\t\t— Scale Packed FP16 Values with FP16 Values",
    "detailsTable": [
      {
        "Description": "Scale the packed FP16 values in xmm2 using values from xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 2C /r VSCALEFPH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Scale the packed FP16 values in ymm2 using values from ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 2C /r VSCALEFPH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Scale the packed FP16 values in zmm2 using values from zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 2C /r VSCALEFPH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmullw",
    "category": "Core Instructions",
    "instructionName": "PMULLW\n\t\t— Multiply Packed Signed Integers and Store Low Result",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F D5 /r1 PMULLW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F D5 /r PMULLW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D5 /r VPMULLW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D5 /r VPMULLW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the low 16 bits of the results in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG D5 /r VPMULLW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG D5 /r VPMULLW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the low 16 bits of the results in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG D5 /r VPMULLW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "TEMP0[31:0] := DEST[15:0] ∗ SRC[15:0]; (* Signed multiplication *)\nTEMP1[31:0] := DEST[31:16] ∗ SRC[31:16];\nTEMP2[31:0] := DEST[47:32] ∗ SRC[47:32];\nTEMP3[31:0] := DEST[63:48] ∗ SRC[63:48];\nDEST[15:0] := TEMP0[15:0];\nDEST[31:16] := TEMP1[15:0];\nDEST[47:32] := TEMP2[15:0];\nDEST[63:48] := TEMP3[15:0];\nTEMP0[31:0] := DEST[15:0] ∗ SRC[15:0]; (* Signed multiplication *)\n    TEMP1[31:0] := DEST[31:16] ∗ SRC[31:16];\n    TEMP2[31:0] := DEST[47:32] ∗ SRC[47:32];\n    TEMP3[31:0] := DEST[63:48] ∗ SRC[63:48];\n    TEMP4[31:0] := DEST[79:64] ∗ SRC[79:64];\n    TEMP5[31:0] := DEST[95:80] ∗ SRC[95:80];\n    TEMP6[31:0] := DEST[111:96] ∗ SRC[111:96];\n    TEMP7[31:0] := DEST[127:112] ∗ SRC[127:112];\n    DEST[15:0] := TEMP0[15:0];\n    DEST[31:16] := TEMP1[15:0];\n    DEST[47:32] := TEMP2[15:0];\n    DEST[63:48] := TEMP3[15:0];\n    DEST[79:64] := TEMP4[15:0];\n    DEST[95:80] := TEMP5[15:0];\n    DEST[111:96] := TEMP6[15:0];\n    DEST[127:112] := TEMP7[15:0];\nDEST[MAXVL-1:256] := 0\nTemp0[31:0] := SRC1[15:0] * SRC2[15:0]\nTemp1[31:0] := SRC1[31:16] * SRC2[31:16]\nTemp2[31:0] := SRC1[47:32] * SRC2[47:32]\nTemp3[31:0] := SRC1[63:48] * SRC2[63:48]\nTemp4[31:0] := SRC1[79:64] * SRC2[79:64]\nTemp5[31:0] := SRC1[95:80] * SRC2[95:80]\nTemp6[31:0] := SRC1[111:96] * SRC2[111:96]\nTemp7[31:0] := SRC1[127:112] * SRC2[127:112]\nDEST[15:0] := Temp0[15:0]\nDEST[31:16] := Temp1[15:0]\nDEST[47:32] := Temp2[15:0]\nDEST[63:48] := Temp3[15:0]\nDEST[79:64] := Temp4[15:0]\nDEST[95:80] := Temp5[15:0]\nDEST[111:96] := Temp6[15:0]\nDEST[127:112] := Temp7[15:0]\nDEST[MAXVL-1:128] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN\n            temp[31:0] := SRC1[i+15:i] * SRC2[i+15:i]\n            DEST[i+15:i] := temp[15:0]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pcmpestrm",
    "category": "Core Instructions",
    "instructionName": "PCMPESTRM\n\t\t— Packed Compare Explicit Length Strings, Return Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_2",
        "Description": "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A 60 /r imm8 PCMPESTRM xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.",
        "Op/En": "RMI",
        "Opcode/Instruction": "VEX.128.66.0F3A 60 /r ib VPCMPESTRM xmm1, xmm2/m128, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction compares data from two string fragments based on the encoded value in the imm8 contol byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates a mask stored to XMM0.\nEach string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.\nThe length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).\nThe comparison and aggregation operations are performed according to the encoded value of imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.\nNote that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:\nCFlag – Reset if IntRes2 is equal to zero, set otherwise\nZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise\nSFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise\nOFlag –IntRes2[0]\nAFlag – Reset\nPFlag – Reset\nNote: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally, this instruction does not cause #GP if the memory operand is not aligned to 16 Byte boundary, and:",
        "column_1: If VEX.vvvv ≠ 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfpclasssh",
    "category": "Core Instructions",
    "instructionName": "VFPCLASSSH\n\t\t— Test Types of Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.NP.0F3A.W0 67 /r /ib VFPCLASSSH k1{k2}, xmm1/m16, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8 (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/sysenter",
    "category": "Core Instructions",
    "instructionName": "SYSENTER\n\t\t— Fast System Call",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Fast call to privilege level 0 system procedures.",
        "Instruction": "SYSENTER",
        "Op/En": "ZO",
        "Opcode": "0F 34"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT. The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to operating system or executive procedures running at privilege level 0.\nWhen executed in IA-32e mode, the SYSENTER instruction transitions the logical processor to 64-bit mode; otherwise, the logical processor remains in protected mode.\nPrior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:\nThese MSRs can be read from and written to using RDMSR/WRMSR. The WRMSR instruction ensures that the IA32_SYSENTER_EIP and IA32_SYSENTER_ESP MSRs always contain canonical addresses.\nWhile SYSENTER loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSENTER instruction does not ensure this correspondence.\nThe SYSENTER instruction can be invoked from all operating modes except real-address mode.\nThe SYSENTER and SYSEXIT instructions are companion instructions, but they do not constitute a call/return pair. When executing a SYSENTER instruction, the processor does not save state information for the user code (e.g., the instruction pointer), and neither the SYSENTER nor the SYSEXIT instruction supports passing parameters on the stack.\nTo use the SYSENTER and SYSEXIT instructions as companion instructions for transitions between privilege level 3 code and privilege level 0 operating system procedures, the following conventions must be followed:\nThe SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor. The availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature\nflag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually present. For example:\nIF CPUID SEP bit is set\nTHEN IF (Family = 6) and (Model < 3) and (Stepping < 3)\nTHEN\nSYSENTER/SYSEXIT_Not_Supported; FI;\nELSE\nSYSENTER/SYSEXIT_Supported; FI;\nFI;\nWhen the CPUID instruction is executed on the Pentium Pro processor (model 1), the processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT instructions.\nWhen shadow stacks are enabled at privilege level where SYSENTER instruction is invoked, the SSP is saved to the IA32_PL3_SSP MSR. If shadow stacks are enabled at privilege level 0, the SSP is loaded with 0. Refer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions‚” and Chapter 17, “Control-flow Enforcement Technology (CET)‚” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for additional CET details.\nInstruction ordering. Instructions following a SYSENTER may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSENTER have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).",
    "operationText": "IF CR0.PE = 0 OR IA32_SYSENTER_CS[15:2] = 0 THEN #GP(0); FI;\nRFLAGS.VM := 0;\n                    (* Ensures protected mode execution *)\nRFLAGS.IF := 0;\n                    (* Mask interrupts *)\nIF in IA-32e mode\n    THEN\n        RSP := IA32_SYSENTER_ESP;\n        RIP := IA32_SYSENTER_EIP;\nELSE\n        ESP := IA32_SYSENTER_ESP[31:0];\n        EIP := IA32_SYSENTER_EIP[31:0];\nFI;\nCS.Selector := IA32_SYSENTER_CS[15:0] AND\n                    FFFCH;\n                    (* Operating system provides CS; RPL forced to 0 *)\n(* Set rest of CS to a fixed value *)\nCS.Base := 0;\n                    (* Flat segment *)\nCS.Limit := FFFFFH;\n                    (* With 4-KByte granularity, implies a 4-GByte limit *)\nCS.Type := 11;\n                    (* Execute/read code, accessed *)\nCS.S := 1;\nCS.DPL := 0;\nCS.P := 1;\nIF in IA-32e mode\n    THEN\n        CS.L := 1;\n                    (* Entry is to 64-bit mode *)\n        CS.D := 0;\n                    (* Required if CS.L = 1 *)\n    ELSE\n        CS.L := 0;\n        CS.D := 1;\n                    (* 32-bit code segment*)\nFI;\nCS.G := 1;\n                    (* 4-KByte granularity *)\nIF ShadowStackEnabled(CPL)\n    THEN\n        IF IA32_EFER.LMA = 0\n            THEN IA32_PL3_SSP := SSP;\n            ELSE (* adjust so bits 63:N get the value of bit N–1, where N is the CPU’s maximum linear-address width *)\n                IA32_PL3_SSP := LA_adjust(SSP);\n        FI;\nFI;\nCPL := 0;\nIF ShadowStackEnabled(CPL)\n    SSP := 0;\nFI;\nIF EndbranchEnabled(CPL)\n    IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n    IA32_S_CET.SUPPRESS = 0\nFI;\nSS.Selector := CS.Selector + 8;\n                    (* SS just above CS *)\n(* Set rest of SS to a fixed value *)\nSS.Base := 0;\n                    (* Flat segment *)\nSS.Limit := FFFFFH;\n                    (* With 4-KByte granularity, implies a 4-GByte limit *)\nSS.Type := 3;\n                    (* Read/write data, accessed *)\nSS.S := 1;\nSS.DPL := 0;\nSS.P := 1;\nSS.B := 1;\n                    (* 32-bit stack segment*)\nSS.G := 1;\n                    (* 4-KByte granularity *)",
    "flagsAffectedText": "VM, IF (see Operation above).",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmulsh",
    "category": "Core Instructions",
    "instructionName": "VMULSH\n\t\t— Multiply Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Multiply the low FP16 value in xmm3/m16 by low FP16 value in xmm2, and store the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 59 /r VMULSH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/addsd",
    "category": "Core Instructions",
    "instructionName": "ADDSD\n\t\t— Add Scalar Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add the low double precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 58 /r ADDSD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add the low double precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 58 /r VADDSD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Add the low double precision floating-point value from xmm3/m64 to xmm2 and store the result in xmm1 with writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 58 /r VADDSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Adds the low double precision floating-point values from the second source operand and the first source operand and stores the double precision floating-point result in the destination operand.\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nEVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX version: The low quadword element of the destination is updated according to the writemask.\nSoftware should ensure VADDSD is encoded with VEX.L=0. Encoding VADDSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := SRC1[63:0] + SRC2[63:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0] + SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] + SRC[63:0]\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/knotw:knotb:knotq:knotd",
    "category": "Core Instructions",
    "instructionName": "KNOTW/KNOTB/KNOTQ/KNOTD\n\t\t— NOT Mask Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise NOT of 16 bits mask k2.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.0F.W0 44 /r KNOTW k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Bitwise NOT of 8 bits mask k2.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.66.0F.W0 44 /r KNOTB k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise NOT of 64 bits mask k2.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.0F.W1 44 /r KNOTQ k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise NOT of 32 bits mask k2.",
        "Op/En": "RR",
        "Opcode/Instruction": "VEX.L0.66.0F.W1 44 /r KNOTD k1, k2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.",
    "operationText": "DEST[15:0] := BITWISE NOT SRC[15:0]\nDEST[MAX_KL-1:16] := 0\nDEST[7:0] := BITWISE NOT SRC[7:0]\nDEST[MAX_KL-1:8] := 0\nDEST[63:0] := BITWISE NOT SRC[63:0]\nDEST[MAX_KL-1:64] := 0\nDEST[31:0] := BITWISE NOT SRC[31:0]\nDEST[MAX_KL-1:32] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesdecwide128kl",
    "category": "Core Instructions",
    "instructionName": "AESDECWIDE128KL\n\t\t— Perform Ten Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLEWIDE_KL",
        "Description": "Decrypt XMM0-7 using 128-bit AES key indicated by handle at m384 and store each resultant block back to its corresponding register.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 D8 !(11):001:bbb AESDECWIDE128KL m384, <XMM0-7>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r)",
        "Operands 2—9": "Implicit XMM0-7 (r, w)",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The AESDECWIDE128KL1 instruction performs ten rounds of AES to decrypt each of the eight blocks in XMM0-7 using the 128-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding decrypted block if the operation succeeds (e.g., does not run into a handle violation failure).",
    "operationText": "Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL > 0)) ||\n                Handle [2] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128);\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);\n        IF Authentic == 0 {\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    XMM0 := AES128Decrypt (XMM0, UnwrappedKey) ;\n                    XMM1 := AES128Decrypt (XMM1, UnwrappedKey) ;\n                    XMM2 := AES128Decrypt (XMM2, UnwrappedKey) ;\n                    XMM3 := AES128Decrypt (XMM3, UnwrappedKey) ;\n                    XMM4 := AES128Decrypt (XMM4, UnwrappedKey) ;\n                    XMM5 := AES128Decrypt (XMM5, UnwrappedKey) ;\n                    XMM6 := AES128Decrypt (XMM6, UnwrappedKey) ;\n                    XMM7 := AES128Decrypt (XMM7, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.\n1. Further details on Key Locker and usage of this instruction can be found here:",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/popf:popfd:popfq",
    "category": "Core Instructions",
    "instructionName": "POPF/POPFD/POPFQ\n\t\t— Pop Stack Into EFLAGS Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into lower 16 bits of EFLAGS.",
        "Instruction": "POPF",
        "Op/En": "ZO",
        "Opcode": "9D"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into EFLAGS.",
        "Instruction": "POPFD",
        "Op/En": "ZO",
        "Opcode": "9D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Pop top of stack and zero-extend into RFLAGS.",
        "Instruction": "POPFQ",
        "Op/En": "ZO",
        "Opcode": "9D"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD/PUSHFQ instructions.\nThe POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD. Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to determine the size of values to pop from the stack.\nThe effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation. See Table 4-16 and the key below for details.\nWhen operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equivalent to privilege level 0), all non-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be modified. VIP, VIF, and VM remain unaffected.\nWhen operating in protected, compatibility, or 64-bit mode with a privilege level greater than 0, but less than or equal to IOPL, all flags can be modified except the IOPL field and RF, IF, VIP, VIF, and VM; these remain unaffected. The AC and ID flags can only be modified if the operand-size attribute is 32. The interrupt flag (IF) is altered only when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with insufficient privilege, an exception does not occur but privileged bits do not change.\nWhen operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0), the POPF/POPFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs. If the virtual-8086 mode extensions are enabled (CR4.VME = 1), POPF (but not POPFD) can be executed in virtual-8086 mode with IOPL < 3.\n(The protected-mode virtual-interrupt feature — enabled by setting CR4.PVI — affects the CLI and STI instructions in the same manner as the virtual-8086 mode extensions. POPF, however, is not affected by CR4.PVI.)\nIn 64-bit mode, the mnemonic assigned is POPFQ (note that the 32-bit operand is not encodable). POPFQ pops 64 bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits of RFLAGS) are not affected.\nSee Chapter 3 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information about the EFLAGS registers.",
    "operationText": "IF EFLAGS.VM = 0 (* Not in Virtual-8086 Mode *)\n    THEN IF CPL = 0 OR CR0.PE = 0\n        THEN\n            IF OperandSize = 32;\n                THEN\n                    EFLAGS := Pop(); (* 32-bit pop *)\n                    (* All non-reserved flags except RF, VIP, VIF, and VM can be modified;\n                    VIP, VIF, VM, and all reserved bits are unaffected. RF is cleared. *)\n                ELSE IF (Operandsize = 64)\n                    RFLAGS = Pop(); (* 64-bit pop *)\n                    (* All non-reserved flags except RF, VIP, VIF, and VM can be modified;\n                    VIP, VIF, VM, and all reserved bits are unaffected. RF is cleared. *)\n                ELSE (* OperandSize = 16 *)\n                    EFLAGS[15:0] := Pop(); (* 16-bit pop *)\n                    (* All non-reserved flags can be modified. *)\n            FI;\n        ELSE (* CPL > 0 *)\n            IF OperandSize = 32\n                THEN\n                    IF CPL > IOPL\n                        THEN\n                            EFLAGS := Pop(); (* 32-bit pop *)\n                            (* All non-reserved bits except IF, IOPL, VIP, VIF, VM, and RF can be modified;\n                            IF, IOPL, VIP, VIF, VM, and all reserved bits are unaffected; RF is cleared. *)\n                        ELSE\n                            EFLAGS := Pop(); (* 32-bit pop *)\n                            (* All non-reserved bits except IOPL, VIP, VIF, VM, and RF can be modified;\n                            IOPL, VIP, VIF, VM, and all reserved bits are unaffected; RF is cleared. *)\n                    FI;\n                ELSE IF (Operandsize = 64)\n                    IF CPL > IOPL\n                        THEN\n                            RFLAGS := Pop(); (* 64-bit pop *)\n                            (* All non-reserved bits except IF, IOPL, VIP, VIF, VM, and RF can be modified;\n                            IF, IOPL, VIP, VIF, VM, and all reserved bits are unaffected; RF is cleared. *)\n                        ELSE\n                            RFLAGS := Pop(); (* 64-bit pop *)\n                            (* All non-reserved bits except IOPL, VIP, VIF, VM, and RF can be modified;\n                            IOPL, VIP, VIF, VM, and all reserved bits are unaffected; RF is cleared. *)\n                    FI;\n                ELSE (* OperandSize = 16 *)\n                    EFLAGS[15:0] := Pop(); (* 16-bit pop *)\n                    (* All non-reserved bits except IOPL can be modified; IOPL and all\n                    reserved bits are unaffected. *)\n            FI;\n        FI;\n    ELSE (* In virtual-8086 mode *)\n        IF IOPL = 3\n            THEN\n                IF OperandSize = 32\n                    THEN\n                        EFLAGS := Pop();\n                        (* All non-reserved bits except IOPL, VIP, VIF, VM, and RF can be modified;\n                        VIP, VIF, VM, IOPL, and all reserved bits are unaffected. RF is cleared. *)\n                    ELSE\n                        EFLAGS[15:0] := Pop(); FI;\n                        (* All non-reserved bits except IOPL can be modified; IOPL and all reserved bits are unaffected. *)\n                FI;\n            ELSE (* IOPL < 3 *)\n                IF (Operandsize = 32) OR (CR4.VME = 0)\n                    THEN #GP(0); (* Trap to virtual-8086 monitor. *)\n                    ELSE (* Operandsize = 16 and CR4.VME = 1 *)\n                        tempFLAGS := Pop();\n                        IF (EFLAGS.VIP = 1 AND tempFLAGS[9] = 1) OR tempFLAGS[8] = 1\n                            THEN #GP(0);\n                            ELSE\n                                EFLAGS.VIF := tempFLAGS[9];\n                                EFLAGS[15:0] := tempFLAGS;\n                                (* All non-reserved bits except IOPL and IF can be modified;\n                                IOPL, IF, and all reserved bits are unaffected. *)\n                        FI;\n                FI;\n        FI;\nFI;",
    "flagsAffectedText": "All flags may be affected; see the Operation section for details.",
    "exceptions": {
      "64BitMode": [
        "column_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same as for protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while CPL = 3 and alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If IOPL < 3 and the 32-bit operand size is used.; \ncolumn_1: If IOPL < 3, EFLAGS.VIP = 1, and bit 9 (IF) is set in the FLAGS value on the stack.; \ncolumn_1: If IOPL < 3 and bit 8 (TF) is set in the FLAGS value on the stack.; \ncolumn_1: If an attempt is made to execute the POPF/POPFD instruction with an operand-size override prefix.; \ncolumn_1: #SS(0); column_2: If the top of stack is not within the stack segment.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/btr",
    "category": "Core Instructions",
    "instructionName": "BTR\n\t\t— Bit Test and Reset",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and clear.",
        "Instruction": "BTR r/m16, r16",
        "Op/En": "MR",
        "Opcode": "0F B3 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and clear.",
        "Instruction": "BTR r/m32, r32",
        "Op/En": "MR",
        "Opcode": "0F B3 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store selected bit in CF flag and clear.",
        "Instruction": "BTR r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 0F B3 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and clear.",
        "Instruction": "BTR r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "0F BA /6 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and clear.",
        "Instruction": "BTR r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "0F BA /6 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store selected bit in CF flag and clear.",
        "Instruction": "BTR r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 0F BA /6 ib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:\nSee also: Bit(BitBase, BitOffset) on page 3-11.\nSome assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See “BT—Bit Test” in this chapter for more information on this addressing mechanism.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "CF := Bit(BitBase, BitOffset);\nBit(BitBase, BitOffset) := 0;",
    "flagsAffectedText": "The CF flag contains the value of the selected bit before it is cleared. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmlaunch:vmresume",
    "category": "VMX Instructions",
    "instructionName": "VMLAUNCH/VMRESUME\n\t\t— Launch/Resume Virtual Machine",
    "detailsTable": [
      {
        "Description": "Launch virtual machine managed by current VMCS.",
        "Op/En": "ZO",
        "Opcode/Instruction": "0F 01 C2 VMLAUNCH"
      },
      {
        "Description": "Resume virtual machine managed by current VMCS.",
        "Op/En": "ZO",
        "Opcode/Instruction": "0F 01 C3 VMRESUME"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "ZO",
        "column_2": "NA",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Effects a VM entry managed by the current VMCS.\nIf VM entry is attempted, the logical processor performs a series of consistency checks as detailed in Chapter 27, “VM Entries.” Failure to pass checks on the VMX controls or on the host-state area passes control to the instruction following the VMLAUNCH or VMRESUME instruction. If these pass but checks on the guest-state area fail, the logical processor loads state from the host-state area of the VMCS, passing control to the instruction referenced by the RIP field in the host-state area.\nVM entry is not allowed when events are blocked by MOV SS or POP SS. Neither VMLAUNCH nor VMRESUME should be used immediately after either MOV to SS or POP to SS.",
    "operationText": "IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation\n    THEN VMexit;\nELSIF CPL > 0\n    THEN #GP(0);\nELSIF current-VMCS pointer is not valid\n    THEN VMfailInvalid;\nELSIF events are being blocked by MOV SS\n    THEN VMfailValid(VM entry with events blocked by MOV SS);\nELSIF (VMLAUNCH and launch state of current VMCS is not “clear”)\n    THEN VMfailValid(VMLAUNCH with non-clear VMCS);\nELSIF (VMRESUME and launch state of current VMCS is not “launched”)\n    THEN VMfailValid(VMRESUME with non-launched VMCS);\n    ELSE\n        Check settings of VMX controls and host-state area;\n        IF invalid settings\n            THEN VMfailValid(VM entry with invalid VMX-control field(s)) or\n                    VMfailValid(VM entry with invalid host-state field(s)) or\n                    VMfailValid(VM entry with invalid executive-VMCS pointer)) or\n                    VMfailValid(VM entry with non-launched executive VMCS) or\n                    VMfailValid(VM entry with executive-VMCS pointer not VMXON pointer) or\n                    VMfailValid(VM entry with invalid VM-execution control fields in executive\n                    VMCS)\n                    as appropriate;\n            ELSE\n                Attempt to load guest state and PDPTRs as appropriate;\n                clear address-range monitoring;\n                IF failure in checking guest state or PDPTRs\n                    THEN VM entry fails (see Section 27.8);\n                    ELSE\n                        Attempt to load MSRs from VM-entry MSR-load area;\n                        IF failure\n                            THEN VM entry fails\n                            (see Section 27.8);\n                            ELSE\n                                IF VMLAUNCH\n                                    THEN launch state of VMCS := “launched”;\n                                FI;\n                                IF in SMM and “entry to SMM” VM-entry control is 0\n                                    THEN\n                                        IF “deactivate dual-monitor treatment” VM-entry\n                                        control is 0\n                                            THEN SMM-transfer VMCS pointer :=\n                                            current-VMCS pointer;\n                                        FI;\n                                        IF executive-VMCS pointer is VMXON pointer\n                                            THEN current-VMCS pointer :=\n                                            VMCS-link pointer;\n                                            ELSE current-VMCS pointer :=\n                                            executive-VMCS pointer;\n                                        FI;\n                                        leave SMM;\n                                FI;\n                                VM entry succeeds;\n                        FI;\n                FI;\n        FI;\nFI;\nFurther details of the operation of the VM-entry appear in Chapter 27.",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If executed outside VMX operation.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If executed outside VMX operation.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/blsi",
    "category": "Core Instructions",
    "instructionName": "BLSI\n\t\t— Extract Lowest Set Isolated Bit",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI1",
        "Description": "Extract lowest set bit from r/m32 and set that bit in r32.",
        "Op/En": "VM",
        "Opcode/Instruction": "VEX.LZ.0F38.W0 F3 /3 BLSI r32, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI1",
        "Description": "Extract lowest set bit from r/m64, and set that bit in r64.",
        "Op/En": "VM",
        "Opcode/Instruction": "VEX.LZ.0F38.W1 F3 /3 BLSI r64, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "VM",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in the destination to 0 and sets ZF and CF.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "temp := (-SRC) bitwiseAND (SRC);\nSF := temp[OperandSize -1];\nZF := (temp = 0);\nIF SRC = 0\n    CF := 0;\nELSE\n    CF := 1;\nFI\nDEST := temp;",
    "flagsAffectedText": "ZF and SF are updated based on the result. CF is set if the source is not zero. OF flags are cleared. AF and PF flags are undefined.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sbb",
    "category": "Core Instructions",
    "instructionName": "SBB\n\t\t— Integer Subtraction With Borrow",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow imm8 from AL.",
        "Instruction": "SBB AL, imm8",
        "Op/En": "I",
        "Opcode": "1C ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow imm16 from AX.",
        "Instruction": "SBB AX, imm16",
        "Op/En": "I",
        "Opcode": "1D iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow imm32 from EAX.",
        "Instruction": "SBB EAX, imm32",
        "Op/En": "I",
        "Opcode": "1D id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract with borrow sign-extended imm.32 to 64-bits from RAX.",
        "Instruction": "SBB RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + 1D id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow imm8 from r/m8.",
        "Instruction": "SBB r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "80 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract with borrow imm8 from r/m8.",
        "Instruction": "SBB r/m81, imm8",
        "Op/En": "MI",
        "Opcode": "REX + 80 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow imm16 from r/m16.",
        "Instruction": "SBB r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "81 /3 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow imm32 from r/m32.",
        "Instruction": "SBB r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "81 /3 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract with borrow sign-extended imm32 to 64-bits from r/m64.",
        "Instruction": "SBB r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + 81 /3 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow sign-extended imm8 from r/m16.",
        "Instruction": "SBB r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "83 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow sign-extended imm8 from r/m32.",
        "Instruction": "SBB r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "83 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract with borrow sign-extended imm8 from r/m64.",
        "Instruction": "SBB r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 83 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow r8 from r/m8.",
        "Instruction": "SBB r/m8, r8",
        "Op/En": "MR",
        "Opcode": "18 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract with borrow r8 from r/m8.",
        "Instruction": "SBB r/m81, r8",
        "Op/En": "MR",
        "Opcode": "REX + 18 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow r16 from r/m16.",
        "Instruction": "SBB r/m16, r16",
        "Op/En": "MR",
        "Opcode": "19 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow r32 from r/m32.",
        "Instruction": "SBB r/m32, r32",
        "Op/En": "MR",
        "Opcode": "19 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract with borrow r64 from r/m64.",
        "Instruction": "SBB r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 19 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow r/m8 from r8.",
        "Instruction": "SBB r8, r/m8",
        "Op/En": "RM",
        "Opcode": "1A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract with borrow r/m8 from r8.",
        "Instruction": "SBB r81, r/m81",
        "Op/En": "RM",
        "Opcode": "REX + 1A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow r/m16 from r16.",
        "Instruction": "SBB r16, r/m16",
        "Op/En": "RM",
        "Opcode": "1B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract with borrow r/m32 from r32.",
        "Instruction": "SBB r32, r/m32",
        "Op/En": "RM",
        "Opcode": "1B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Subtract with borrow r/m64 from r64.",
        "Instruction": "SBB r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 1B /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location.\n(However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction.\nWhen an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\nThe SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\nThe SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction is followed by a SBB instruction.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := (DEST – (SRC + CF));",
    "flagsAffectedText": "The OF, SF, ZF, AF, PF, and CF flags are set according to the result.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used but the destination is not a memory operand.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/test",
    "category": "Core Instructions",
    "instructionName": "TEST\n\t\t— Logical Compare",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND imm8 with AL; set SF, ZF, PF according to result.",
        "Instruction": "TEST AL, imm8",
        "Op/En": "I",
        "Opcode": "A8 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND imm16 with AX; set SF, ZF, PF according to result.",
        "Instruction": "TEST AX, imm16",
        "Op/En": "I",
        "Opcode": "A9 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND imm32 with EAX; set SF, ZF, PF according to result.",
        "Instruction": "TEST EAX, imm32",
        "Op/En": "I",
        "Opcode": "A9 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result.",
        "Instruction": "TEST RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + A9 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND imm8 with r/m8; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "F6 /0 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "AND imm8 with r/m8; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m81, imm8",
        "Op/En": "MI",
        "Opcode": "REX + F6 /0 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND imm16 with r/m16; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "F7 /0 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND imm32 with r/m32; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "F7 /0 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + F7 /0 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND r8 with r/m8; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m8, r8",
        "Op/En": "MR",
        "Opcode": "84 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "AND r8 with r/m8; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m81, r81",
        "Op/En": "MR",
        "Opcode": "REX + 84 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND r16 with r/m16; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m16, r16",
        "Op/En": "MR",
        "Opcode": "85 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AND r32 with r/m32; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m32, r32",
        "Op/En": "MR",
        "Opcode": "85 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "AND r64 with r/m64; set SF, ZF, PF according to result.",
        "Instruction": "TEST r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 85 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Computes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result. The result is then discarded.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "TEMP := SRC1 AND SRC2;\nSF := MSB(TEMP);\nIF TEMP = 0\n    THEN ZF := 1;\n    ELSE ZF := 0;\nFI:\nPF := BitwiseXNOR(TEMP[0:7]);\nCF := 0;\nOF := 0;\n(* AF is undefined *)",
    "flagsAffectedText": "The OF and CF flags are set to 0. The SF, ZF, and PF flags are set according to the result (see the “Operation” section above). The state of the AF flag is undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmaddwd",
    "category": "Core Instructions",
    "instructionName": "PMADDWD\n\t\t— Multiply and Add Packed Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F F5 /r1 PMADDWD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F F5 /r PMADDWD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F5 /r VPMADDWD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG F5 /r VPMADDWD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG F5 /r VPMADDWD xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG F5 /r VPMADDWD ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Multiply the packed word integers in zmm2 by the packed word integers in zmm3/m512, add adjacent doubleword results, and store in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG F5 /r VPMADDWD zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words of the source operand (second operand), producing temporary signed, doubleword results. The adjacent double-word results are then summed and stored in the destination operand. For example, the corresponding low-order words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the double-word results are added together and stored in the low doubleword of the destination register (31-0). The same operation is performed on the other pairs of adjacent words. (Figure 4-11 shows this operation when using 64-bit operands).\nThe (V)PMADDWD instruction wraps around only in one situation: when the 2 pairs of words being operated on in a group are all 8000H. In this case, the result wraps around to 80000000H.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version: The first source and destination operands are MMX registers. The second source operand is an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX.512 encoded version: The second source operand can be an ZMM register or a 512-bit memory location. The first source and destination operands are ZMM registers.",
    "operationText": "DEST[31:0] := (DEST[15:0] ∗ SRC[15:0]) + (DEST[31:16] ∗ SRC[31:16]);\nDEST[63:32] := (DEST[47:32] ∗ SRC[47:32]) + (DEST[63:48] ∗ SRC[63:48]);\nDEST[31:0] := (DEST[15:0] ∗ SRC[15:0]) + (DEST[31:16] ∗ SRC[31:16]);\nDEST[63:32] := (DEST[47:32] ∗ SRC[47:32]) + (DEST[63:48] ∗ SRC[63:48]);\nDEST[95:64] := (DEST[79:64] ∗ SRC[79:64]) + (DEST[95:80] ∗ SRC[95:80]);\nDEST[127:96] := (DEST[111:96] ∗ SRC[111:96]) + (DEST[127:112] ∗ SRC[127:112]);\nDEST[31:0] := (SRC1[15:0] * SRC2[15:0]) + (SRC1[31:16] * SRC2[31:16])\nDEST[63:32] := (SRC1[47:32] * SRC2[47:32]) + (SRC1[63:48] * SRC2[63:48])\nDEST[95:64] := (SRC1[79:64] * SRC2[79:64]) + (SRC1[95:80] * SRC2[95:80])\nDEST[127:96] := (SRC1[111:96] * SRC2[111:96]) + (SRC1[127:112] * SRC2[127:112])\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := (SRC1[15:0] * SRC2[15:0]) + (SRC1[31:16] * SRC2[31:16])\nDEST[63:32] := (SRC1[47:32] * SRC2[47:32]) + (SRC1[63:48] * SRC2[63:48])\nDEST[95:64] := (SRC1[79:64] * SRC2[79:64]) + (SRC1[95:80] * SRC2[95:80])\nDEST[127:96] := (SRC1[111:96] * SRC2[111:96]) + (SRC1[127:112] * SRC2[127:112])\nDEST[159:128] := (SRC1[143:128] * SRC2[143:128]) + (SRC1[159:144] * SRC2[159:144])\nDEST[191:160] := (SRC1[175:160] * SRC2[175:160]) + (SRC1[191:176] * SRC2[191:176])\nDEST[223:192] := (SRC1[207:192] * SRC2[207:192]) + (SRC1[223:208] * SRC2[223:208])\nDEST[255:224] := (SRC1[239:224] * SRC2[239:224]) + (SRC1[255:240] * SRC2[255:240])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := (SRC2[i+31:i+16]* SRC1[i+31:i+16]) + (SRC2[i+15:i]*SRC1[i+15:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xor",
    "category": "Core Instructions",
    "instructionName": "XOR\n\t\t— Logical Exclusive OR",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AL XOR imm8.",
        "Instruction": "XOR AL, imm8",
        "Op/En": "I",
        "Opcode": "34 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AX XOR imm16.",
        "Instruction": "XOR AX, imm16",
        "Op/En": "I",
        "Opcode": "35 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "EAX XOR imm32.",
        "Instruction": "XOR EAX, imm32",
        "Op/En": "I",
        "Opcode": "35 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "RAX XOR imm32 (sign-extended).",
        "Instruction": "XOR RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + 35 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m8 XOR imm8.",
        "Instruction": "XOR r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "80 /6 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m8 XOR imm8.",
        "Instruction": "XOR r/m8*, imm8",
        "Op/En": "MI",
        "Opcode": "REX + 80 /6 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 XOR imm16.",
        "Instruction": "XOR r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "81 /6 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 XOR imm32.",
        "Instruction": "XOR r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "81 /6 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 XOR imm32 (sign-extended).",
        "Instruction": "XOR r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + 81 /6 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 XOR imm8 (sign-extended).",
        "Instruction": "XOR r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "83 /6 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 XOR imm8 (sign-extended).",
        "Instruction": "XOR r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "83 /6 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 XOR imm8 (sign-extended).",
        "Instruction": "XOR r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 83 /6 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m8 XOR r8.",
        "Instruction": "XOR r/m8, r8",
        "Op/En": "MR",
        "Opcode": "30 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m8 XOR r8.",
        "Instruction": "XOR r/m8*, r8*",
        "Op/En": "MR",
        "Opcode": "REX + 30 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m16 XOR r16.",
        "Instruction": "XOR r/m16, r16",
        "Op/En": "MR",
        "Opcode": "31 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r/m32 XOR r32.",
        "Instruction": "XOR r/m32, r32",
        "Op/En": "MR",
        "Opcode": "31 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r/m64 XOR r64.",
        "Instruction": "XOR r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 31 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r8 XOR r/m8.",
        "Instruction": "XOR r8, r/m8",
        "Op/En": "RM",
        "Opcode": "32 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r8 XOR r/m8.",
        "Instruction": "XOR r8*, r/m8*",
        "Op/En": "RM",
        "Opcode": "REX + 32 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r16 XOR r/m16.",
        "Instruction": "XOR r16, r/m16",
        "Op/En": "RM",
        "Opcode": "33 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "r32 XOR r/m32.",
        "Instruction": "XOR r32, r/m32",
        "Op/En": "RM",
        "Opcode": "33 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "r64 XOR r/m64.",
        "Instruction": "XOR r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 33 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := DEST XOR SRC;",
    "flagsAffectedText": "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vdivsh",
    "category": "Core Instructions",
    "instructionName": "VDIVSH\n\t\t— Divide Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Divide low FP16 value in xmm2 by low FP16 value in xmm3/m16, and store the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 5E /r VDIVSH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrt14ps",
    "category": "Core Instructions",
    "instructionName": "VRSQRT14PS\n\t\t— Compute Approximate Reciprocals of Square Roots of Packed Float32 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 4E /r VRSQRT14PS xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 4E /r VRSQRT14PS ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 4E /r VRSQRT14PS zmm1 {k1}{z}, zmm2/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/kortestw:kortestb:kortestq:kortestd",
    "category": "Core Instructions",
    "instructionName": "KORTESTW/KORTESTB/KORTESTQ/KORTESTD\n\t\t— OR Masks and Set Flags",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise OR 16 bits masks k1 and k2 and update ZF and CF accordingly.",
        "Op/E n": "RR",
        "Opcode/Instruction": "VEX.L0.0F.W0 98 /r KORTESTW k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Bitwise OR 8 bits masks k1 and k2 and update ZF and CF accordingly.",
        "Op/E n": "RR",
        "Opcode/Instruction": "VEX.L0.66.0F.W0 98 /r KORTESTB k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise OR 64 bits masks k1 and k2 and update ZF and CF accordingly.",
        "Op/E n": "RR",
        "Opcode/Instruction": "VEX.L0.0F.W1 98 /r KORTESTQ k1, k2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise OR 32 bits masks k1 and k2 and update ZF and CF accordingly.",
        "Op/E n": "RR",
        "Opcode/Instruction": "VEX.L0.66.0F.W1 98 /r KORTESTD k1, k2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF based on the operation result.\nZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1’s.",
    "operationText": "TMP[15:0] := DEST[15:0] BITWISE OR SRC[15:0]\nIF(TMP[15:0]=0)\n    THEN ZF := 1\n    ELSE ZF := 0\nFI;\nIF(TMP[15:0]=FFFFh)\n    THEN CF := 1\n    ELSE CF := 0\nFI;\nTMP[7:0] := DEST[7:0] BITWISE OR SRC[7:0]\nIF(TMP[7:0]=0)\n    THEN ZF := 1\n    ELSE ZF := 0\nFI;\nIF(TMP[7:0]==FFh)\n    THEN CF := 1\n    ELSE CF := 0\nFI;\nTMP[63:0] := DEST[63:0] BITWISE OR SRC[63:0]\nIF(TMP[63:0]=0)\n    THEN ZF := 1\n    ELSE ZF := 0\nFI;\nIF(TMP[63:0]==FFFFFFFF_FFFFFFFFh)\n    THEN CF := 1\n    ELSE CF := 0\nFI;\nTMP[31:0] := DEST[31:0] BITWISE OR SRC[31:0]\nIF(TMP[31:0]=0)\n    THEN ZF := 1\n    ELSE ZF := 0\nFI;\nIF(TMP[31:0]=FFFFFFFFh)\n    THEN CF := 1\n    ELSE CF := 0\nFI;",
    "flagsAffectedText": "The ZF flag is set if the result of OR-ing both sources is all 0s.\nThe CF flag is set if the result of OR-ing both sources is all 1s.\nThe OF, SF, AF, and PF flags are set to 0.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesencwide256kl",
    "category": "Core Instructions",
    "instructionName": "AESENCWIDE256KL\n\t\t— Perform 14 Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLE WIDE_KL",
        "Description": "Encrypt XMM0-7 using 256-bit AES key indicated by handle at m512 and store each resultant block back to its corresponding register.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 D8 !(11):010:bbb AESENCWIDE256KL m512, <XMM0-7>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r)",
        "Operands 2—9": "Implicit XMM0-7 (r, w)",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The AESENCWIDE256KL1 instruction performs 14 rounds of AES to encrypt each of the eight blocks in XMM0-7 using the 256-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding encrypted block if the operation succeeds (e.g., does not run into a handle violation failure).",
    "operationText": "Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (\n                HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL > 0)) ||\n                Handle [1] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256\n                );\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    XMM0 := AES256Encrypt (XMM0, UnwrappedKey) ;\n                    XMM1 := AES256Encrypt (XMM1, UnwrappedKey) ;\n                    XMM2 := AES256Encrypt (XMM2, UnwrappedKey) ;\n                    XMM3 := AES256Encrypt (XMM3, UnwrappedKey) ;\n                    XMM4 := AES256Encrypt (XMM4, UnwrappedKey) ;\n                    XMM5 := AES256Encrypt (XMM5, UnwrappedKey) ;\n                    XMM6 := AES256Encrypt (XMM6, UnwrappedKey) ;\n                    XMM7 := AES256Encrypt (XMM7, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n1. Further details on Key Locker and usage of this instruction can be found here:",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/roundpd",
    "category": "Core Instructions",
    "instructionName": "ROUNDPD\n\t\t— Round Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.",
        "Op/En": "RMI",
        "Opcode*/Instruction": "66 0F 3A 09 /r ib ROUNDPD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.",
        "Op/En": "RMI",
        "Opcode*/Instruction": "VEX.128.66.0F3A.WIG 09 /r ib VROUNDPD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Round packed double precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8.",
        "Op/En": "RMI",
        "Opcode*/Instruction": "VEX.256.66.0F3A.WIG 09 /r ib VROUNDPD ymm1, ymm2/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Round the 2 double precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a double precision floating-point value.\nThe immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-18 lists the encoded values for rounding-mode field).\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.\nRounding RC Field Description Mode Setting\nRound to 00B Rounded result is the closest to the infinitely precise result. If two values are equally close, the result is nearest (even) the even value (i.e., the integer value with the least-significant bit of zero).\nRound down 01B Rounded result is closest to but no greater than the infinitely precise result. (toward −∞)\nRound up 10B Rounded result is closest to but no less than the infinitely precise result. (toward +∞)\nRound toward 11B Rounded result is closest to but no greater in absolute value than the infinitely precise result. zero (Truncate)",
    "operationText": "IF (imm[2] = ‘1)\n    THEN // rounding mode is determined by MXCSR.RC\n        DEST[63:0] := ConvertDPFPToInteger_M(SRC[63:0]);\n        DEST[127:64] := ConvertDPFPToInteger_M(SRC[127:64]);\n    ELSE // rounding mode is determined by IMM8.RC\n        DEST[63:0] := ConvertDPFPToInteger_Imm(SRC[63:0]);\n        DEST[127:64] := ConvertDPFPToInteger_Imm(SRC[127:64]);\nFI\nDEST[63:0] := RoundToInteger(SRC[63:0]], ROUND_CONTROL)\nDEST[127:64] := RoundToInteger(SRC[127:64]], ROUND_CONTROL)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := RoundToInteger(SRC[63:0]], ROUND_CONTROL)\nDEST[127:64] := RoundToInteger(SRC[127:64]], ROUND_CONTROL)\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := RoundToInteger(SRC[63:0], ROUND_CONTROL)\nDEST[127:64] := RoundToInteger(SRC[127:64]], ROUND_CONTROL)\nDEST[191:128] := RoundToInteger(SRC[191:128]], ROUND_CONTROL)\nDEST[255:192] := RoundToInteger(SRC[255:192] ], ROUND_CONTROL)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid (signaled only if SRC = SNaN).",
        "Precision (signaled only if imm[3] = ‘0; if imm[3] = ‘1, then the Precision Mask in the MXSCSR is ignored and precision exception is not signaled.)",
        "Note that Denormal is not signaled by ROUNDPD."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtph2ps:vcvtph2psx",
    "category": "Core Instructions",
    "instructionName": "VCVTPH2PS/VCVTPH2PSX\n\t\t— Convert Packed FP16 Values to Single Precision Floating-PointValues",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "F16C",
        "Description": "Convert four packed FP16 values in xmm2/m64 to packed single precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 13 /r VCVTPH2PS xmm1, xmm2/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "F16C",
        "Description": "Convert eight packed FP16 values in xmm2/m128 to packed single precision floating-point value in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 13 /r VCVTPH2PS ymm1, xmm2/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed FP16 values in xmm2/m64 to packed single precision floating-point values in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 13 /r VCVTPH2PS xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert eight packed FP16 values in xmm2/m128 to packed single precision floating-point values in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 13 /r VCVTPH2PS ymm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert sixteen packed FP16 values in ymm2/m256 to packed single precision floating-point values in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 13 /r VCVTPH2PS zmm1 {k1}{z}, ymm2/m256 {sae}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512-FP16 AVX512VL",
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four packed single precision floating-point values, and store result in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.MAP6.W0 13 /r VCVTPH2PSX xmm1{k1}{z}, xmm2/m64/m16bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512-FP16 AVX512VL",
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight packed single precision floating-point values, and store result in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.MAP6.W0 13 /r VCVTPH2PSX ymm1{k1}{z}, xmm2/m128/m16bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512-FP16",
        "Description": "Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen packed single precision floating-point values, and store result in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.MAP6.W0 13 /r VCVTPH2PSX zmm1{k1}{z}, ymm2/m256/m16bcst {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half Mem"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fscale",
    "category": "Core Instructions",
    "instructionName": "FSCALE\n\t\t— Scale",
    "detailsTable": [
      {
        "Description": "Scale ST(0) by ST(1).",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 FD",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of the destination operand. The destination and source operands are floating-point values located in registers ST(0) and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2. The following table shows the results obtained when scaling various classes of numbers, assuming that neither overflow nor underflow occurs.\nIn most cases, only the exponent is changed and the mantissa (significand) remains unchanged. However, when the value being scaled in ST(0) is a denormal value, the mantissa is also changed and the result may turn out to be a normalized number. Similarly, if overflow or underflow results from a scale operation, the resulting mantissa will differ from the source’s mantissa.\nThe FSCALE instruction can also be used to reverse the action of the FXTRACT instruction, as shown in the following example:\nFXTRACT;\nFSCALE;\nFSTP ST(1);\nIn this example, the FXTRACT instruction extracts the significand and exponent from the value in ST(0) and stores them in ST(0) and ST(1) respectively. The FSCALE then scales the significand in ST(0) by the exponent in ST(1), recreating the original value before the FXTRACT operation was performed. The FSTP ST(1) instruction overwrites the exponent (extracted by the FXTRACT instruction) with the recreated value, which returns the stack to its original state with only one register [ST(0)] occupied.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "ST(0) := ST(0) ∗ 2RoundTowardZero(ST(1));",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value or unsupported format.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sqrtsd",
    "category": "Core Instructions",
    "instructionName": "SQRTSD\n\t\t— Compute Square Root of Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Computes square root of the low double precision floating-point value in xmm2/m64 and stores the results in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 51/r SQRTSD xmm1,xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes square root of the low double precision floating-point value in xmm3/m64 and stores the results in xmm1. Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 51/r VSQRTSD xmm1,xmm2, xmm3/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes square root of the low double precision floating-point value in xmm3/m64 and stores the results in xmm1 under writemask k1. Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 51/r VSQRTSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Computes the square root of the low double precision floating-point value in the second source operand and stores the double precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. The quadword at bits 127:64 of the destination operand remains unchanged. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded versions: Bits 127:64 of the destination operand are copied from the corresponding bits of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: The low quadword element of the destination operand is updated according to the write-mask.\nSoftware should ensure VSQRTSD is encoded with VEX.L=0. Encoding VSQRTSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (EVEX.b = 1) AND (SRC2 *is register*)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := SQRT(SRC2[63:0])\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SQRT(SRC2[63:0])\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SQRT(SRC[63:0])\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfcmaddcsh:vfmaddcsh",
    "category": "Core Instructions",
    "instructionName": "VFCMADDCSH/VFMADDCSH\n\t\t— Complex Multiply and Accumulate Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Complex multiply a pair of FP16 values from xmm2 and complex conjugate of xmm3/m32, add to xmm1 and store the result in xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F2.MAP6.W0 57 /r VFCMADDCSH xmm1{k1}{z}, xmm2, xmm3/m32 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from xmm2 and xmm3/m32, add to xmm1 and store the result in xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP6.W0 57 /r VFMADDCSH xmm1{k1}{z}, xmm2, xmm3/m32 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/lgdt:lidt",
    "category": "Core Instructions",
    "instructionName": "LGDT/LIDT\n\t\t— Load Global/Interrupt Descriptor Table Register",
    "detailsTable": [
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Load m into GDTR.",
        "Instruction": "LGDT m16&32",
        "Op/En": "M",
        "Opcode": "0F 01 /2"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Load m into IDTR.",
        "Instruction": "LIDT m16&32",
        "Op/En": "M",
        "Opcode": "0F 01 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load m into GDTR.",
        "Instruction": "LGDT m16&64",
        "Op/En": "M",
        "Opcode": "0F 01 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load m into IDTR.",
        "Instruction": "LIDT m16&64",
        "Op/En": "M",
        "Opcode": "0F 01 /3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.\nThe LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.\nIn 64-bit mode, the instruction’s operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the summary chart at the beginning of this section for encoding data and limits.\nSee “SGDT—Store Global Descriptor Table Register” in Chapter 4, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for information on storing the contents of the GDTR and IDTR.",
    "operationText": "IF Instruction is LIDT\n    THEN\n        IF OperandSize = 16\n            THEN\n                IDTR(Limit) := SRC[0:15];\n                IDTR(Base) := SRC[16:47] AND 00FFFFFFH;\n            ELSE IF 32-bit Operand Size\n                THEN\n                    IDTR(Limit) := SRC[0:15];\n                    IDTR(Base) := SRC[16:47];\n                FI;\n            ELSE IF 64-bit Operand Size (* In 64-Bit Mode *)\n                THEN\n                    IDTR(Limit) := SRC[0:15];\n                    IDTR(Base) := SRC[16:79];\n                FI;\n        FI;\n    ELSE (* Instruction is LGDT *)\n        IF OperandSize = 16\n            THEN\n                GDTR(Limit) := SRC[0:15];\n                GDTR(Base) := SRC[16:47] AND 00FFFFFFH;\n            ELSE IF 32-bit Operand Size\n                THEN\n                    GDTR(Limit) := SRC[0:15];\n                    GDTR(Base) := SRC[16:47];\n                FI;\n            ELSE IF 64-bit Operand Size (* In 64-Bit Mode *)\n                THEN\n                    GDTR(Limit) := SRC[0:15];\n                    GDTR(Base) := SRC[16:79];\n                FI;\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_2: If the current privilege level is not 0.; column_1: #GP(0); \ncolumn_1: If the memory address is in a non-canonical form.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #GP(0); column_2: If the current privilege level is not 0.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "realAddressMode": [
        "column_1: #GP; column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.;"
      ],
      "virtual8086Mode": [
        "column_1: #GP; column_2: If the current privilege level is not 0.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xacquire:xrelease",
    "category": "Core Instructions",
    "instructionName": "XACQUIRE/XRELEASE\n\t\t— Hardware Lock Elision Prefix Hints",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "HLE1",
        "Description": "A hint used with an “XACQUIRE-enabled“ instruction to start lock elision on the instruction memory operand address.",
        "Opcode/Instruction": "F2 XACQUIRE"
      },
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "HLE",
        "Description": "A hint used with an “XRELEASE-enabled“ instruction to end lock elision on the instruction memory operand address.",
        "Opcode/Instruction": "F3 XRELEASE"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The XACQUIRE prefix is a hint to start lock elision on the memory address specified by the instruction and the XRELEASE prefix is a hint to end lock elision on the memory address specified by the instruction.\nThe XACQUIRE prefix hint can only be used with the following instructions (these instructions are also referred to as XACQUIRE-enabled when used with the XACQUIRE prefix):\nThe XRELEASE prefix hint can only be used with the following instructions (also referred to as XRELEASE-enabled when used with the XRELEASE prefix):\nThe lock variables must satisfy the guidelines described in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, Section 16.3.3, for elision to be successful, otherwise an HLE abort may be signaled.\nIf an encoded byte sequence that meets XACQUIRE/XRELEASE requirements includes both prefixes, then the HLE semantic is determined by the prefix byte that is placed closest to the instruction opcode. For example, an F3F2C6 will not be treated as a XRELEASE-enabled instruction since the F2H (XACQUIRE) is closest to the instruction opcode C6. Similarly, an F2F3F0 prefixed instruction will be treated as a XRELEASE-enabled instruction since F3H (XRELEASE) is closest to the instruction opcode.\nIntel 64 and IA-32 Compatibility\nThe effect of the XACQUIRE/XRELEASE prefix hint is the same in non-64-bit modes and in 64-bit mode.\nFor instructions that do not support the XACQUIRE hint, the presence of the F2H prefix behaves the same way as prior hardware, according to\nFor instructions that do not support the XRELEASE hint, the presence of the F3H prefix behaves the same way as in prior hardware, according to",
    "operationText": "IF XACQUIRE-enabled instruction\n    THEN\n        IF (HLE_NEST_COUNT < MAX_HLE_NEST_COUNT) THEN\n            HLE_NEST_COUNT++\n            IF (HLE_NEST_COUNT = 1) THEN\n                HLE_ACTIVE := 1\n                IF 64-bit mode\n                    THEN\n                        restartRIP := instruction pointer of the XACQUIRE-enabled instruction\n                    ELSE\n                        restartEIP := instruction pointer of the XACQUIRE-enabled instruction\n                FI;\n                Enter HLE Execution (* record register state, start tracking memory state *)\n            FI; (* HLE_NEST_COUNT = 1*)\n            IF ElisionBufferAvailable\n                THEN\n                    Allocate elision buffer\n                    Record address and data for forwarding and commit checking\n                    Perform elision\n                ELSE\n                    Perform lock acquire operation transactionally but without elision\n            FI;\n        ELSE (* HLE_NEST_COUNT = MAX_HLE_NEST_COUNT*)\n                GOTO HLE_ABORT_PROCESSING\n        FI;\n    ELSE\n        Treat instruction as non-XACQUIRE F2H prefixed legacy instruction\nFI;\nIF XRELEASE-enabled instruction\n    THEN\n        IF (HLE_NEST_COUNT > 0)\n            THEN\n                HLE_NEST_COUNT--\n                IF lock address matches in elision buffer THEN\n                    IF lock satisfies address and value requirements THEN\n                        Deallocate elision buffer\n                    ELSE\n                        GOTO HLE_ABORT_PROCESSING\n                    FI;\n                FI;\n                IF (HLE_NEST_COUNT = 0)\n                    THEN\n                        IF NoAllocatedElisionBuffer\n                            THEN\n                                Try to commit transactional execution\n                                IF fail to commit transactional execution\n                                    THEN\n                                        GOTO HLE_ABORT_PROCESSING;\n                                    ELSE (* commit success *)\n                                        HLE_ACTIVE := 0\n                                FI;\n                            ELSE\n                                GOTO HLE_ABORT_PROCESSING\n                        FI;\n                FI;\n        FI; (* HLE_NEST_COUNT > 0 *)\n    ELSE\n        Treat instruction as non-XRELEASE F3H prefixed legacy instruction\nFI;\n(* For any HLE abort condition encountered during HLE execution *)\nHLE_ABORT_PROCESSING:\n    HLE_ACTIVE := 0\n    HLE_NEST_COUNT := 0\n    Restore architectural register state\n    Discard memory updates performed in transaction\n    Free any allocated lock elision buffers\n    IF 64-bit mode\n        THEN\n            RIP := restartRIP\n        ELSE\n            EIP := restartEIP\n    FI;\n    Execute and retire instruction at RIP (or EIP) and ignore any HLE hint\nEND",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmppd",
    "category": "Core Instructions",
    "instructionName": "CMPPD\n\t\t— Compare Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed double precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of imm8 as a comparison predicate.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F C2 /r ib CMPPD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed double precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG C2 /r ib VCMPPD xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed double precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG C2 /r ib VCMPPD ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed double precision floating-point values in xmm3/m128/m64bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 C2 /r ib VCMPPD k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed double precision floating-point values in ymm3/m256/m64bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 C2 /r ib VCMPPD k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed double precision floating-point values in zmm3/m512/m64bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 C2 /r ib VCMPPD k1 {k2}, zmm2, zmm3/m512/m64bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed double precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands.\nEVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is an opmask register. Comparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).\nVEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Four comparisons are performed with results written to the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Two comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. Two comparisons are performed with results written to bits 127:0 of the destination operand.\nThe comparison predicate operand is an 8-bit immediate:\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\nNote that processors with “CPUID.1H:ECX.AVX =0” do not implement the “greater-than”, “greater-than-or-equal”, “not-greater than”, and “not-greater-than-or-equal relations” predicates. These comparisons can be made either by using the inverse relationship (that is, use the “not-less-than-or-equal” to make a “greater-than” comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the first 8 rows of Table 3-7 (Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A) under the heading Emulation.\nCompilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPPD instruction, for processors with “CPUID.1H:ECX.AVX =0”. See Table 3-2. The compiler should treat reserved imm8 values as illegal syntax.\nThe greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)\nProcessors with “CPUID.1H:ECX.AVX =1” implement the full complement of 32 predicates shown in Table 3-3, software emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPPD instruction. See Table 3-3, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. The compiler should treat reserved imm8 values as\nillegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface. Compilers and assemblers may implement three-operand pseudo-ops for EVEX encoded VCMPPD instructions in a similar fashion by extending the syntax listed in Table 3-3.",
    "operationText": "CASE (COMPARISON PREDICATE) OF\n0: OP3 := EQ_OQ; OP5 := EQ_OQ;\n    1: OP3 := LT_OS; OP5 := LT_OS;\n    2: OP3 := LE_OS; OP5 := LE_OS;\n    3: OP3 := UNORD_Q; OP5 := UNORD_Q;\n    4: OP3 := NEQ_UQ; OP5 := NEQ_UQ;\n    5: OP3 := NLT_US; OP5 := NLT_US;\n    6: OP3 := NLE_US; OP5 := NLE_US;\n    7: OP3 := ORD_Q; OP5 := ORD_Q;\n    8: OP5 := EQ_UQ;\n    9: OP5 := NGE_US;\n    10: OP5 := NGT_US;\n    11: OP5 := FALSE_OQ;\n    12: OP5 := NEQ_OQ;\n    13: OP5 := GE_OS;\n    14: OP5 := GT_OS;\n    15: OP5 := TRUE_UQ;\n    16: OP5 := EQ_OS;\n    17: OP5 := LT_OQ;\n    18: OP5 := LE_OQ;\n    19: OP5 := UNORD_S;\n    20: OP5 := NEQ_US;\n    21: OP5 := NLT_UQ;\n    22: OP5 := NLE_UQ;\n    23: OP5 := ORD_S;\n    24: OP5 := EQ_US;\n    25: OP5 := NGE_UQ;\n    26: OP5 := NGT_UQ;\n    27: OP5 := FALSE_OS;\n    28: OP5 := NEQ_OS;\n    29: OP5 := GE_OQ;\n    30: OP5 := GT_OQ;\n    31: OP5 := TRUE_US;\n    DEFAULT: Reserved;\nESAC;\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k2[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    CMP := SRC1[i+63:i] OP5 SRC2[63:0]\n                ELSE\n                    CMP := SRC1[i+63:i] OP5 SRC2[i+63:i]\n            FI;\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                        ; zeroing-masking only\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0\nCMP0 := SRC1[63:0] OP5 SRC2[63:0];\nCMP1 := SRC1[127:64] OP5 SRC2[127:64];\nCMP2 := SRC1[191:128] OP5 SRC2[191:128];\nCMP3 := SRC1[255:192] OP5 SRC2[255:192];\nIF CMP0 = TRUE\n    THEN DEST[63:0] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[63:0] := 0000000000000000H; FI;\nIF CMP1 = TRUE\n    THEN DEST[127:64] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[127:64] := 0000000000000000H; FI;\nIF CMP2 = TRUE\n    THEN DEST[191:128] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[191:128] := 0000000000000000H; FI;\nIF CMP3 = TRUE\n    THEN DEST[255:192] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[255:192] := 0000000000000000H; FI;\nDEST[MAXVL-1:256] := 0\nCMP0 := SRC1[63:0] OP5 SRC2[63:0];\nCMP1 := SRC1[127:64] OP5 SRC2[127:64];\nIF CMP0 = TRUE\n    THEN DEST[63:0] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[63:0] := 0000000000000000H; FI;\nIF CMP1 = TRUE\n    THEN DEST[127:64] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[127:64] := 0000000000000000H; FI;\nDEST[MAXVL-1:128] := 0\nCMP0 := SRC1[63:0] OP3 SRC2[63:0];\nCMP1 := SRC1[127:64] OP3 SRC2[127:64];\nIF CMP0 = TRUE\n    THEN DEST[63:0] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[63:0] := 0000000000000000H; FI;\nIF CMP1 = TRUE\n    THEN DEST[127:64] := FFFFFFFFFFFFFFFFH;\n    ELSE DEST[127:64] := 0000000000000000H; FI;\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid if SNaN operand and invalid if QNaN and predicate as listed in Table 3-1, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgatherpf1dps:vgatherpf1qps:vgatherpf1dpd:vgatherpf1qpd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VGATHERPF1DPS/VGATHERPF1QPS/VGATHERPF1DPD/VGATHERPF1QPD\n\t\t— Sparse PrefetchPacked SP/DP Data Values With Signed Dword, Signed Qword Indices Using T1 Hint",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T1 hint.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C6 /2 /vsib VGATHERPF1DPS vm32z {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T1 hint.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C7 /2 /vsib VGATHERPF1QPS vm64z {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed dword indices, prefetch sparse byte memory locations containing double precision data using opmask k1 and T1 hint.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C6 /2 /vsib VGATHERPF1DPD vm32y {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed qword indices, prefetch sparse byte memory locations containing double precision data using opmask k1 and T1 hint.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C7 /2 /vsib VGATHERPF1QPD vm64z {k1}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtpd2qq",
    "category": "Core Instructions",
    "instructionName": "VCVTPD2QQ\n\t\t— Convert Packed Double Precision Floating-Point Values to Packed QuadwordIntegers",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed double precision floating-point values from xmm2/m128/m64bcst to two packed quadword integers in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 7B /r VCVTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed double precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 7B /r VCVTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed double precision floating-point values from zmm2/m512/m64bcst to eight packed quadword integers in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 7B /r VCVTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/maskmovq",
    "category": "Core Instructions",
    "instructionName": "MASKMOVQ\n\t\t— Store Selected Bytes of Quadword",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F F7 /r MASKMOVQ mm1, mm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are MMX technology registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)\nThe most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.\nThe MASKMOVQ instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVQ instructions if multiple processors might use different memory types to read/write the destination memory locations.\nThis instruction causes a transition from x87 FPU to MMX technology state (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]).\nThe behavior of the MASKMOVQ instruction with a mask of all 0s is as follows:\nThe MASKMOVQ instruction can be used to improve performance for algorithms that need to merge data on a byteby-byte basis. It should not cause a read for ownership; doing so generates unnecessary bandwidth since data is to be written directly using the byte-mask without allocating old data prior to the store.\nIn 64-bit mode, the memory address is specified by DS:RDI.",
    "operationText": "IF (MASK[7] = 1)\n    THEN DEST[DI/EDI] := SRC[7:0] ELSE (* Memory location unchanged *); FI;\nIF (MASK[15] = 1)\n    THEN DEST[DI/EDI +1] := SRC[15:8] ELSE (* Memory location unchanged *); FI;\n    (* Repeat operation for 3rd through 6th bytes in source operand *)\nIF (MASK[63] = 1)\n    THEN DEST[DI/EDI +15] := SRC[63:56] ELSE (* Memory location unchanged *); FI;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 23-8, “Exception Conditions for Legacy SIMD/MMX Instructions without FP Exception,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/lds:les:lfs:lgs:lss",
    "category": "Core Instructions",
    "instructionName": "LDS/LES/LFS/LGS/LSS\n\t\t— Load Far Pointer",
    "detailsTable": [
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load DS:r16 with far pointer from memory.",
        "Instruction": "LDS r16,m16:16",
        "Op/En": "RM",
        "Opcode": "C5 /r"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load DS:r32 with far pointer from memory.",
        "Instruction": "LDS r32,m16:32",
        "Op/En": "RM",
        "Opcode": "C5 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load SS:r16 with far pointer from memory.",
        "Instruction": "LSS r16,m16:16",
        "Op/En": "RM",
        "Opcode": "0F B2 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load SS:r32 with far pointer from memory.",
        "Instruction": "LSS r32,m16:32",
        "Op/En": "RM",
        "Opcode": "0F B2 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load SS:r64 with far pointer from memory.",
        "Instruction": "LSS r64,m16:64",
        "Op/En": "RM",
        "Opcode": "REX + 0F B2 /r"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load ES:r16 with far pointer from memory.",
        "Instruction": "LES r16,m16:16",
        "Op/En": "RM",
        "Opcode": "C4 /r"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load ES:r32 with far pointer from memory.",
        "Instruction": "LES r32,m16:32",
        "Op/En": "RM",
        "Opcode": "C4 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load FS:r16 with far pointer from memory.",
        "Instruction": "LFS r16,m16:16",
        "Op/En": "RM",
        "Opcode": "0F B4 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load FS:r32 with far pointer from memory.",
        "Instruction": "LFS r32,m16:32",
        "Op/En": "RM",
        "Opcode": "0F B4 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load FS:r64 with far pointer from memory.",
        "Instruction": "LFS r64,m16:64",
        "Op/En": "RM",
        "Opcode": "REX + 0F B4 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load GS:r16 with far pointer from memory.",
        "Instruction": "LGS r16,m16:16",
        "Op/En": "RM",
        "Opcode": "0F B5 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load GS:r32 with far pointer from memory.",
        "Instruction": "LGS r32,m16:32",
        "Op/En": "RM",
        "Opcode": "0F B5 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load GS:r64 with far pointer from memory.",
        "Instruction": "LGS r64,m16:64",
        "Op/En": "RM",
        "Opcode": "REX + 0F B5 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.\nIf one of these instructions is executed in protected mode, additional information from the segment descriptor pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.\nAlso in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to the segment occurs.)\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "64-BIT_MODE\n    IF SS is loaded\n        THEN\n            IF SegmentSelector = NULL and ( (RPL = 3) or\n                    (RPL ≠ 3 and RPL ≠ CPL) )\n                THEN #GP(0);\n            ELSE IF descriptor is in non-canonical space\n                THEN #GP(selector); FI;\n            ELSE IF Segment selector index is not within descriptor table limits\n                    or segment selector RPL ≠ CPL\n                    or access rights indicate nonwritable data segment\n                    or DPL ≠ CPL\n                THEN #GP(selector); FI;\n            ELSE IF Segment marked not present\n                THEN #SS(selector); FI;\n            FI;\n            SS := SegmentSelector(SRC);\n            SS := SegmentDescriptor([SRC]);\n    ELSE IF attempt to load DS, or ES\n        THEN #UD;\n    ELSE IF FS, or GS is loaded with non-NULL segment selector\n        THEN IF Segment selector index is not within descriptor table limits\n            or access rights indicate segment neither data nor readable code segment\n            or segment is data or nonconforming-code segment\n            and ( RPL > DPL or CPL > DPL)\n                THEN #GP(selector); FI;\n            ELSE IF Segment marked not present\n                THEN #NP(selector); FI;\n            FI;\n            SegmentRegister := SegmentSelector(SRC) ;\n            SegmentRegister := SegmentDescriptor([SRC]);\n        FI;\n    ELSE IF FS, or GS is loaded with a NULL selector:\n        THEN\n            SegmentRegister := NULLSelector;\n            SegmentRegister(DescriptorValidBit) := 0; FI; (* Hidden flag;\n                not accessible by software *)\n    FI;\n    DEST := Offset(SRC);\nPREOTECTED MODE OR COMPATIBILITY MODE;\n    IF SS is loaded\n        THEN\n            IF SegementSelector = NULL\n                THEN #GP(0);\n            ELSE IF Segment selector index is not within descriptor table limits\n                    or segment selector RPL ≠ CPL\n                    or access rights indicate nonwritable data segment\n                    or DPL ≠ CPL\n                THEN #GP(selector); FI;\n            ELSE IF Segment marked not present\n                THEN #SS(selector); FI;\n            FI;\n            SS := SegmentSelector(SRC);\n            SS := SegmentDescriptor([SRC]);\n    ELSE IF DS, ES, FS, or GS is loaded with non-NULL segment selector\n        THEN IF Segment selector index is not within descriptor table limits\n            or access rights indicate segment neither data nor readable code segment\n            or segment is data or nonconforming-code segment\n            and (RPL > DPL or CPL > DPL)\n                THEN #GP(selector); FI;\n            ELSE IF Segment marked not present\n                THEN #NP(selector); FI;\n            FI;\n            SegmentRegister := SegmentSelector(SRC) AND RPL;\n            SegmentRegister := SegmentDescriptor([SRC]);\n        FI;\n    ELSE IF DS, ES, FS, or GS is loaded with a NULL selector:\n        THEN\n            SegmentRegister := NULLSelector;\n            SegmentRegister(DescriptorValidBit) := 0; FI; (* Hidden flag;\n                not accessible by software *)\n    FI;\n    DEST := Offset(SRC);\nReal-Address or Virtual-8086 Mode\n    SegmentRegister := SegmentSelector(SRC); FI;\n    DEST := Offset(SRC);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If a NULL selector is attempted to be loaded into the SS register in compatibility mode.; \ncolumn_1: If a NULL selector is attempted to be loaded into the SS register in CPL3 and 64-bit mode.; \ncolumn_1: If a NULL selector is attempted to be loaded into the SS register in non-CPL3 and 64-bit mode where its RPL is not equal to CPL.; \ncolumn_1: #GP(Selector); column_2: If the FS, or GS register is being loaded with a non-NULL segment selector and any of the following is true: the segment selector index is not within descriptor table limits, the memory address of the descriptor is non-canonical, the segment is neither a data nor a readable code segment, or the segment is a data or nonconforming-code segment and both RPL and CPL are greater than DPL.; \ncolumn_1: If the SS register is being loaded and any of the following is true: the segment selector index is not within the descriptor table limits, the memory address of the descriptor is non-canonical, the segment selector RPL is not equal to CPL, the segment is a nonwritable data segment, or DPL is not equal to CPL.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is non-canonical; \ncolumn_1: #SS(Selector); column_2: If the SS register is being loaded and the segment is marked not present.; \ncolumn_1: #NP(selector); column_2: If FS, or GS register is being loaded with a non-NULL segment selector and the segment is marked not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If source operand is not a memory location.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If a NULL selector is loaded into the SS register.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #GP(selector); column_2: If the SS register is being loaded and any of the following is true: the segment selector index is not within the descriptor table limits, the segment selector RPL is not equal to CPL, the segment is a non-writable data segment, or DPL is not equal to CPL.; \ncolumn_1: If the DS, ES, FS, or GS register is being loaded with a non-NULL segment selector and any of the following is true: the segment selector index is not within descriptor table limits, the segment is neither a data nor a readable code segment, or the segment is a data or nonconforming-code segment and both RPL and CPL are greater than DPL.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #SS(selector); column_2: If the SS register is being loaded and the segment is marked not present.; \ncolumn_1: #NP(selector); column_2: If DS, ES, FS, or GS register is being loaded with a non-NULL segment selector and the segment is marked not present.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0);"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If source operand is not a memory location.; column_1: #UD; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If the LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/einit",
    "category": "SGX Instructions",
    "instructionName": "EINIT\n\t\t— Initialize an Enclave for Execution",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function initializes the enclave and makes it ready to execute enclave code.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 02H ENCLS[EINIT]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EINIT (In)",
        "column_3": "Error code (Out)",
        "column_4": "Address of SIGSTRUCT (In)",
        "column_5": "Address of SECS (In)",
        "column_6": "Address of EINITTOKEN (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fxrstor",
    "category": "Core Instructions",
    "instructionName": "FXRSTOR\n\t\t— Restore x87 FPU, MMX, XMM, and MXCSR State",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.",
        "Op/En": "M",
        "Opcode/Instruction": "NP 0F AE /1 FXRSTOR m512byte"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.",
        "Op/En": "M",
        "Opcode/Instruction": "NP REX.W + 0F AE /1 FXRSTOR64 m512byte"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with FXSAVE64/FXRSTOR64. Table 3-43 shows the layout of the legacy/compatibility mode state information in memory and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions. Table 3-46 shows the layout of the 64-bit mode state information when REX.W is set (FXSAVE64/FXRSTOR64). Table 3-47 shows the layout of the 64-bit mode state information when REX.W is clear (FXSAVE/FXRSTOR).\nThe state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be in the same format as required by Table 3-43, Table 3-46, or Table 3-47. Referencing a state image saved with an FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.\nThe FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.\nIf the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM and MXCSR registers. This behavior is implementation dependent.\nIf the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next occurrence of this unmasked exception will result in the exception being generated.\nBits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1 in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.\nBytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511 in an FXSAVE state image.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        (x87 FPU, MMX, XMM15-XMM0, MXCSR)\n                Load(SRC);\n    ELSE\n            (x87 FPU, MMX, XMM7-XMM0, MXCSR) := Load(SRC);\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: If memory operand is not aligned on a 16-byte boundary, regardless of segment.; \ncolumn_1: For an attempt to set reserved bits in MXCSR.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: If CR0.EM[bit 2] = 1.; \ncolumn_2: If CPUID.01H:EDX.FXSR[bit 24] = 0.; column_1: #UD; \ncolumn_1: If instruction is preceded by a LOCK prefix.; \ncolumn_1: #AC; column_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 16-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand is not aligned on a 16-byte boundary, regardless of segment. (See alignment check exception [#AC] below.); \ncolumn_1: For an attempt to set reserved bits in MXCSR.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: If CR0.EM[bit 2] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:EDX.FXSR[bit 24] = 0.; \ncolumn_1: If instruction is preceded by a LOCK prefix.; \ncolumn_2: If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 16-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).; column_1: #AC; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: For an attempt to set reserved bits in MXCSR.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: If CR0.EM[bit 2] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:EDX.FXSR[bit 24] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode.",
        "column_1: #AC; column_2: For unaligned memory reference.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "x87FpuAndSimdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sysret",
    "category": "Core Instructions",
    "instructionName": "SYSRET\n\t\t— Return From Fast System Call",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Invalid",
        "Description": "Return to compatibility mode from fast system call.",
        "Instruction": "SYSRET",
        "Op/En": "ZO",
        "Opcode": "0F 07"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Invalid",
        "Description": "Return to 64-bit mode from fast system call.",
        "Instruction": "SYSRET",
        "Op/En": "ZO",
        "Opcode": "REX.W + 0F 07"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "SYSRET is a companion instruction to the SYSCALL instruction. It returns from an OS system-call handler to user code at privilege level 3. It does so by loading RIP from RCX and loading RFLAGS from R11.1 With a 64-bit operand size, SYSRET remains in 64-bit mode; otherwise, it enters compatibility mode and only the low 32 bits of the registers are loaded.\nSYSRET loads the CS and SS selectors with values derived from bits 63:48 of the IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSRET instruction does not ensure this correspondence.\nThe SYSRET instruction does not modify the stack pointer (ESP or RSP). For that reason, it is necessary for software to switch to the user stack. The OS may load the user stack pointer (if it was saved after SYSCALL) before executing SYSRET; alternatively, user code may load the stack pointer (if it was saved before SYSCALL) after receiving control from SYSRET.\nIf the OS loads the stack pointer before executing SYSRET, it must ensure that the handler of any interrupt or exception delivered between restoring the stack pointer and successful execution of SYSRET is not invoked with the user stack. It can do so using approaches such as the following:\nWhen shadow stacks are enabled at privilege level 3 the instruction loads SSP with value from IA32_PL3_SSP MSR. Refer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions‚” and Chapter 17, “Control-flow Enforcement Technology (CET)‚” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for additional CET details.\nInstruction ordering. Instructions following a SYSRET may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSRET have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).",
    "operationText": "IF (CS.L ≠ 1 ) or (IA32_EFER.LMA ≠ 1) or (IA32_EFER.SCE ≠ 1)\n(* Not in 64-Bit Mode or SYSCALL/SYSRET not enabled in IA32_EFER *)\n    THEN #UD; FI;\nIF (CPL ≠ 0) THEN #GP(0); FI;\nIF (operand size is 64-bit)\n    THEN (* Return to 64-Bit Mode *)\n        IF (RCX is not canonical) THEN #GP(0);\n        RIP := RCX;\n    ELSE (* Return to Compatibility Mode *)\n        RIP := ECX;\nFI;\nRFLAGS := (R11 & 3C7FD7H) | 2; (*\n                Clear RF, VM, reserved bits; set bit 1 *)\nIF (operand size is 64-bit)\n    THEN CS.Selector := IA32_STAR[63:48]+16;\n    ELSE CS.Selector := IA32_STAR[63:48];\nFI;\nCS.Selector := CS.Selector OR 3;\n            (* RPL forced to 3 *)\n(* Set rest of CS to a fixed value *)\nCS.Base := 0;\n            (* Flat segment *)\nCS.Limit := FFFFFH;\n            (* With 4-KByte granularity, implies a 4-GByte limit *)\nCS.Type := 11;\n            (* Execute/read code, accessed *)\nCS.S := 1;\nCS.DPL := 3;\nCS.P := 1;\nIF (operand size is 64-bit)\n    THEN (* Return to 64-Bit Mode *)\n        CS.L := 1;\n            (* 64-bit code segment *)\n        CS.D := 0;\n            (* Required if CS.L = 1 *)\n    ELSE (* Return to Compatibility Mode *)\n        CS.L := 0;\n            (* Compatibility mode *)\n        CS.D := 1;\n            (* 32-bit code segment *)\nFI;\nCS.G := 1;\n            (* 4-KByte granularity *)\nCPL := 3;\nIF ShadowStackEnabled(CPL)\n    SSP := IA32_PL3_SSP;\nFI;\nSS.Selector := (IA32_STAR[63:48]+8) OR 3;\n            (* RPL forced to 3 *)\n(* Set rest of SS to a fixed value *)\nSS.Base := 0;\n            (* Flat segment *)\nSS.Limit := FFFFFH;\n            (* With 4-KByte granularity, implies a 4-GByte limit *)\nSS.Type := 3;\n            (* Read/write data, accessed *)\nSS.S := 1;\nSS.DPL := 3;\nSS.P := 1;\nSS.B := 1;\n            (* 32-bit stack segment*)\nSS.G := 1;\n            (* 4-KByte granularity *)",
    "flagsAffectedText": "All.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If CPL ≠ 0.; \ncolumn_1: If the return is to 64-bit mode and RCX contains a non-canonical address.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/maskmovdqu",
    "category": "Core Instructions",
    "instructionName": "MASKMOVDQU\n\t\t— Store Selected Bytes of Double Quadword",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F F7 /r MASKMOVDQU xmm1, xmm2"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F7 /r VMASKMOVDQU xmm1, xmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stores selected bytes from the source operand (first operand) into an 128-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are XMM registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)\nThe most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.\nThe MASKMOVDQU instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVDQU instructions if multiple processors might use different memory types to read/write the destination memory locations.\nBehavior with a mask of all 0s is as follows:\nThe MASKMOVDQU instruction can be used to improve performance of algorithms that need to merge data on a byte-by-byte basis. MASKMOVDQU should not cause a read for ownership; doing so generates unnecessary bandwidth since data is to be written directly using the byte-mask without allocating old data prior to the store.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\nIf VMASKMOVDQU is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
    "operationText": "IF (MASK[7] = 1)\n    THEN DEST[DI/EDI] := SRC[7:0] ELSE (* Memory location unchanged *); FI;\nIF (MASK[15] = 1)\n    THEN DEST[DI/EDI +1] := SRC[15:8] ELSE (* Memory location unchanged *); FI;\n    (* Repeat operation for 3rd through 14th bytes in source operand *)\nIF (MASK[127] = 1)\n    THEN DEST[DI/EDI +15] := SRC[127:120] ELSE (* Memory location unchanged *); FI;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        "column_1: If VEX.vvvv ≠ 1111B.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/clwb",
    "category": "Core Instructions",
    "instructionName": "CLWB\n\t\t— Cache Line Write Back",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CLWB",
        "Description": "Writes back modified cache line containing m8, and may retain the line in cache hierarchy in non-modified state.",
        "Op/En": "M",
        "Opcode/Instruction": "66 0F AE /6 CLWB m8"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Writes back to memory the cache line (if modified) that contains the linear address specified with the memory operand from any level of the cache hierarchy in the cache coherence domain. The line may be retained in the cache hierarchy in non-modified state. Retaining the line in the cache hierarchy is a performance optimization (treated as a hint by hardware) to reduce the possibility of cache miss on a subsequent access. Hardware may choose to retain the line at any of the levels in the cache hierarchy, and in some cases, may invalidate the line from the cache hierarchy. The source operand is a byte memory location.\nThe availability of CLWB instruction is indicated by the presence of the CPUID feature flag CLWB (bit 24 of the EBX register, see “CPUID — CPU Identification” in this chapter). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLWB instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLWB instruction that references the cache line).\nExecutions of the CLWB instruction are ordered with respect to fence instructions and to locked read-modify-write instructions; they are also ordered with respect to older writes to the cache line being written back. They are not ordered with respect to other executions of CLWB, to executions of CLFLUSH and CLFLUSHOPT, or to younger writes to the cache line being written back. Software can use the SFENCE instruction to order an execution of CLWB relative to one of those operations.\nFor usages that require only writing back modified data from cache lines to memory (do not require the line to be invalidated), and expect to subsequently access the data, software is recommended to use CLWB (with appropriate fencing) instead of CLFLUSH or CLFLUSHOPT for improved performance.\nThe CLWB instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load. Like a load, the CLWB instruction sets the accessed flag but not the dirty flag in the page tables.\nIn some implementations, the CLWB instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX). CLWB instruction is not expected to be commonly used inside typical transactional regions. However, programmers must not rely on CLWB instruction to force a transactional abort, since whether they cause transactional abort is implementation dependent.",
    "operationText": "Cache_Line_Write_Back(m8);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.CLWB[bit 24] = 0.; \ncolumn_2: If a memory address referencing the SS segment is in a non-canonical form.; column_1: #SS(0); \ncolumn_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.CLWB[bit 24] = 0.; \ncolumn_1: #GP(0); column_2: For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.;"
      ],
      "realAddressMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.CLWB[bit 24] = 0.; \ncolumn_1: #GP; column_2: If any part of the operand lies outside the effective address space from 0 to FFFFH.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode.",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrt28ps",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VRSQRT28PS\n\t\t— Approximation to the Reciprocal Square Root of Packed Single PrecisionFloating-Point Values With Less Than 2^-28 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes approximations to the Reciprocal square root (<2^-28 relative error) of the packed single-precision floating-point values from zmm2/m512/m32bcst and stores result in zmm1with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 CC /r VRSQRT28PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A",
        "column_2": "Full ModRM:reg (w) ModRM:r/m (r) N/A N/A",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vminph",
    "category": "Core Instructions",
    "instructionName": "VMINPH\n\t\t— Return Minimum of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Return the minimum packed FP16 values between xmm2 and xmm3/m128/m16bcst and store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 5D /r VMINPH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Return the minimum packed FP16 values between ymm2 and ymm3/m256/m16bcst and store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 5D /r VMINPH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Return the minimum packed FP16 values between zmm2 and zmm3/m512/m16bcst and store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 5D /r VMINPH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmaxud:pmaxuq",
    "category": "Core Instructions",
    "instructionName": "PMAXUD/PMAXUQ\n\t\t— Maximum of Packed Unsigned Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 3F /r PMAXUD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 3F /r VPMAXUD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 3F /r VPMAXUD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 3F /r VPMAXUD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 3F /r VPMAXUD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 3F /r VPMAXUD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 3F /r VPMAXUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 3F /r VPMAXUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 3F /r VPMAXUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "IF DEST[31:0] >SRC[31:0] THEN\n        DEST[31:0] := DEST[31:0];\n    ELSE\n        DEST[31:0] := SRC[31:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF DEST[127:96] >SRC[127:96] THEN\n        DEST[127:96] := DEST[127:96];\n    ELSE\n        DEST[127:96] := SRC[127:96]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[31:0] > SRC2[31:0] THEN\n        DEST[31:0] := SRC1[31:0];\n    ELSE\n        DEST[31:0] := SRC2[31:0]; FI;\n    (* Repeat operation for 2nd through 3rd dwords in source and destination operands *)\n    IF SRC1[127:96] > SRC2[127:96] THEN\n        DEST[127:96] := SRC1[127:96];\n    ELSE\n        DEST[127:96] := SRC2[127:96]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[31:0] > SRC2[31:0] THEN\n        DEST[31:0] := SRC1[31:0];\n    ELSE\n        DEST[31:0] := SRC2[31:0]; FI;\n    (* Repeat operation for 2nd through 7th dwords in source and destination operands *)\n    IF SRC1[255:224] > SRC2[255:224] THEN\n        DEST[255:224] := SRC1[255:224];\n    ELSE\n        DEST[255:224] := SRC2[255:224]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n        IF (EVEX.b = 1) AND (SRC2 *is memory*)\n            THEN\n                IF SRC1[i+31:i] > SRC2[31:0]\n                    THEN DEST[i+31:i] := SRC1[i+31:i];\n                    ELSE DEST[i+31:i] := SRC2[31:0];\n                FI;\n            ELSE\n                IF SRC1[i+31:i] > SRC2[i+31:i]\n                    THEN DEST[i+31:i] := SRC1[i+31:i];\n                    ELSE DEST[i+31:i] := SRC2[i+31:i];\n            FI;\n        FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    THEN DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n        IF (EVEX.b = 1) AND (SRC2 *is memory*)\n            THEN\n                IF SRC1[i+63:i] > SRC2[63:0]\n                    THEN DEST[i+63:i] := SRC1[i+63:i];\n                    ELSE DEST[i+63:i] := SRC2[63:0];\n                FI;\n            ELSE\n                IF SRC1[i+31:i] > SRC2[i+31:i]\n                    THEN DEST[i+63:i] := SRC1[i+63:i];\n                    ELSE DEST[i+63:i] := SRC2[i+63:i];\n            FI;\n        FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    THEN DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcp28ps",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VRCP28PS\n\t\t— Approximation to the Reciprocal of Packed Single Precision Floating-Point ValuesWith Less Than 2^-28 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes the approximate reciprocals ( < 2^-28 relative error) of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 CA /r VRCP28PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A Full ModRM:reg (w) ModRM:r/m (r) N/A N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/eexit",
    "category": "SGX Instructions",
    "instructionName": "EEXIT\n\t\t— Exits an Enclave",
    "detailsTable": null,
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EEXIT (In)",
        "column_3": "Target address outside the enclave (In)",
        "column_4": "Address of the current AEP (Out)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/lods:lodsb:lodsw:lodsd:lodsq",
    "category": "Core Instructions",
    "instructionName": "LODS/LODSB/LODSW/LODSD/LODSQ\n\t\t— Load String",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.",
        "Instruction": "LODS m8",
        "Op/En": "ZO",
        "Opcode": "AC"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.",
        "Instruction": "LODS m16",
        "Op/En": "ZO",
        "Opcode": "AD"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.",
        "Instruction": "LODS m32",
        "Op/En": "ZO",
        "Opcode": "AD"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load qword at address (R)SI into RAX.",
        "Instruction": "LODS m64",
        "Op/En": "ZO",
        "Opcode": "REX.W + AD"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.",
        "Instruction": "LODSB",
        "Op/En": "ZO",
        "Opcode": "AC"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.",
        "Instruction": "LODSW",
        "Op/En": "ZO",
        "Opcode": "AD"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.",
        "Instruction": "LODSD",
        "Op/En": "ZO",
        "Opcode": "AD"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load qword at address (R)SI into RAX.",
        "Instruction": "LODSQ",
        "Op/En": "ZO",
        "Opcode": "REX.W + AD"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.\nAt the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed.\nThe no-operands form provides “short forms” of the byte, word, and doubleword versions of the LODS instructions. Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the destination operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).\nAfter the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.\nThe LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
    "operationText": "IF AL := SRC; (* Byte load *)\n    THEN AL := SRC; (* Byte load *)\n        IF DF = 0\n            THEN (E)SI := (E)SI + 1;\n            ELSE (E)SI := (E)SI – 1;\n        FI;\nELSE IF AX := SRC; (* Word load *)\n    THEN IF DF = 0\n            THEN (E)SI := (E)SI + 2;\n            ELSE (E)SI := (E)SI – 2;\n        IF;\n    FI;\nELSE IF EAX := SRC; (* Doubleword load *)\n    THENIFDF =0\n            THEN (E)SI := (E)SI + 4;\n            ELSE (E)SI := (E)SI – 4;\n        FI;\n    FI;\nELSE IF RAX := SRC; (* Quadword load *)\n    THEN IF DF = 0\n            THEN (R)SI := (R)SI + 8;\n            ELSE (R)SI := (R)SI – 8;\n        FI;\n    FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cli",
    "category": "Core Instructions",
    "instructionName": "CLI\n\t\t— Clear Interrupt Flag",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Clear interrupt flag; interrupts disabled when interrupt flag cleared.",
        "Instruction": "CLI",
        "Op/En": "ZO",
        "Opcode": "FA"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "In most cases, CLI clears the IF flag in the EFLAGS register and no other flags are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the CLI and STI instruction have no effect on the generation of exceptions and NMI interrupts.\nOperation is different in two modes defined as follows:\nIf IOPL < 3 and either VME mode or PVI mode is active, CLI clears the VIF flag in the EFLAGS register, leaving IF unaffected.\nTable 3-7 indicates the action of the CLI instruction depending on the processor operating mode, IOPL, and CPL.",
    "operationText": "IF CR0.PE = 0\n    THEN IF := 0; (* Reset Interrupt Flag *)\n    ELSE\n        IF IOPL ≥ CPL (* CPL = 3 if EFLAGS.VM = 1 *)\n            THEN IF := 0; (* Reset Interrupt Flag *)\n            ELSE\n                IF VME mode OR PVI mode\n                    THEN VIF := 0; (* Reset Virtual Interrupt Flag *)\n                    ELSE #GP(0);\n                FI;\n        FI;\nFI;",
    "flagsAffectedText": "Either the IF flag or the VIF flag is cleared to 0. Other flags are unaffected.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CPL is greater than IOPL and less than 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/stui",
    "category": "Core Instructions",
    "instructionName": "STUI\n\t\t— Set User Interrupt Flag",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "UINTR",
        "Description": "Set user interrupt flag.",
        "Op/En": "ZO",
        "Opcode/Instruction": "F3 0F 01 EF STUI"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "STUI sets the user interrupt flag (UIF). Its effect takes place immediately; a user interrupt may be delivered on the instruction boundary following STUI. (This is in contrast with STI, whose effect is delayed by one instruction).\nAn execution of STUI inside a transactional region causes a transactional abort; the abort loads EAX as it would have had it been due to an execution of STI.",
    "operationText": "UIF := 1;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If executed inside an enclave.; \ncolumn_1: If CR4.UINTR = 0.; \ncolumn_1: If CPUID.07H.0H:EDX.UINTR[bit 5] = 0.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movupd",
    "category": "Core Instructions",
    "instructionName": "MOVUPD\n\t\t— Move Unaligned Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move unaligned packed double precision floating-point from xmm2/mem to xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 10 /r MOVUPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move unaligned packed double precision floating-point from xmm1 to xmm2/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "66 0F 11 /r MOVUPD xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed double precision floating-point from xmm2/mem to xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 10 /r VMOVUPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed double precision floating-point from xmm1 to xmm2/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 11 /r VMOVUPD xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed double precision floating-point from ymm2/mem to ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 10 /r VMOVUPD ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed double precision floating-point from ymm1 to ymm2/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 11 /r VMOVUPD ymm2/m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed double precision floating-point from xmm2/m128 to xmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 10 /r VMOVUPD xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed double precision floating-point from xmm1 to xmm2/m128 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 11 /r VMOVUPD xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed double precision floating-point from ymm2/m256 to ymm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 10 /r VMOVUPD ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed double precision floating-point from ymm1 to ymm2/m256 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 11 /r VMOVUPD ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move unaligned packed double precision floating-point values from zmm2/m512 to zmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 10 /r VMOVUPD zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move unaligned packed double precision floating-point values from zmm1 to zmm2/m512 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 11 /r VMOVUPD zmm2/m512 {k1}{z}, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Note: VEX.vvvv and EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\nEVEX.512 encoded version:\nMoves 512 bits of packed double precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a float64 memory location, to store the contents of a ZMM register into a memory. The destination operand is updated according to the writemask.\nVEX.256 encoded version:\nMoves 256 bits of packed double precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. Bits (MAXVL-1:256) of the destination register are zeroed.\n128-bit versions:\nMoves 128 bits of packed double precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nWhen the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte boundary without causing a general-protection exception (#GP) to be generated\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the destination register are zeroed.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE *DEST[i+63:i] remains unchanged*\n            ; merging-masking\n    FI;\nENDFOR;\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := SRC[255:0]\nDEST[MAXVL-1:256] := 0\nDEST[255:0] := SRC[255:0]\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := SRC[127:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "Note treatment of #AC varies; additionally:",
        "",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/eldb:eldu:eldbc:elduc",
    "category": "SGX Instructions",
    "instructionName": "ELDB/ELDU/ELDBC/ELDUC\n\t\t— Load an EPC Page and Mark its State",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function loads, verifies an EPC page and marks the page as blocked.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 07H ENCLS[ELDB]"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function loads, verifies an EPC page and marks the page as unblocked.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 08H ENCLS[ELDU]"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "EAX[6]",
        "Description": "This leaf function behaves lie ELDB but with improved conflict handling for oversubscription.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 12H ENCLS[ELDBC]"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "EAX[6]",
        "Description": "This leaf function behaves like ELDU but with improved conflict handling for oversubscription.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 13H ENCLS[ELDUC]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "(In)  r (In)  LDU Return error   Return error",
        "column_3": "",
        "column_4": "Address of the PAGEINFO (In)",
        "column_5": "Address of the EPC page (In)",
        "column_6": "Address of the version-array slot (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmadd132ps:vfmadd213ps:vfmadd231ps",
    "category": "Core Instructions",
    "instructionName": "VFMADD132PS/VFMADD213PS/VFMADD231PS\n\t\t— Fused Multiply-Add of Packed SinglePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 98 /r VFMADD132PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 A8 /r VFMADD213PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 B8 /r VFMADD231PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 98 /r VFMADD132PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 A8 /r VFMADD213PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.0 B8 /r VFMADD231PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/m128/m32bcst, add to xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 98 /r VFMADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m32bcst and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 A8 /r VFMADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/m128/m32bcst, add to xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 B8 /r VFMADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/m256/m32bcst, add to ymm2 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 98 /r VFMADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m32bcst and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 A8 /r VFMADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/m256/m32bcst, add to ymm1 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 B8 /r VFMADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm3/m512/m32bcst, add to zmm2 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 98 /r VFMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m32bcst and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 A8 /r VFMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm2 and zmm3/m512/m32bcst, add to zmm1 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 B8 /r VFMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/wait:fwait",
    "category": "Core Instructions",
    "instructionName": "WAIT/FWAIT\n\t\t— Wait",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Check pending unmasked floating-point exceptions.",
        "Instruction": "WAIT",
        "Op/En": "ZO",
        "Opcode": "9B"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Check pending unmasked floating-point exceptions.",
        "Instruction": "FWAIT",
        "Op/En": "ZO",
        "Opcode": "9B"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for WAIT.)\nThis instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction ensures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction’s results. See the section titled “Floating-Point Exception Synchronization” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on using the WAIT/FWAIT instruction.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "CheckForPendingUnmaskedFloatingPointExceptions;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpshrd",
    "category": "Core Instructions",
    "instructionName": "VPSHRD\n\t\t— Concatenate and Shift Packed Data Right Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 72 /r /ib VPSHRDW xmm1{k1}{z}, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 72 /r /ib VPSHRDW ymm1{k1}{z}, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 72 /r /ib VPSHRDW zmm1{k1}{z}, zmm2, zmm3/m512, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 73 /r /ib VPSHRDD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 73 /r /ib VPSHRDD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 73 /r /ib VPSHRDD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 73 /r /ib VPSHRDQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 73 /r /ib VPSHRDQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 73 /r /ib VPSHRDQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscatterpf1dps:vscatterpf1qps:vscatterpf1dpd:vscatterpf1qpd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VSCATTERPF1DPS/VSCATTERPF1QPS/VSCATTERPF1DPD/VSCATTERPF1QPD\n\t\t— Sparse PrefetchPacked SP/DP Data Values With Signed Dword, Signed Qword Indices Using T1 Hint With Intentto Write",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T1 hint with intent to write.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C6 /6 /vsib VSCATTERPF1DPS vm32z {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T1 hint with intent to write.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C7 /6 /vsib VSCATTERPF1QPS vm64z {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed dword indices, prefetch sparse byte memory locations containing double precision data using writemask k1 and T1 hint with intent to write.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C6 /6 /vsib VSCATTERPF1DPD vm32y {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed qword indices, prefetch sparse byte memory locations containing double precision data using writemask k1 and T1 hint with intent to write.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C7 /6 /vsib VSCATTERPF1QPD vm64z {k1}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtss2sh",
    "category": "Core Instructions",
    "instructionName": "VCVTSS2SH\n\t\t— Convert Low FP32 Value to an FP16 Value",
    "detailsTable": [
      {
        "Description": "Convert low FP32 value in xmm3/m32 to an FP16 value and store in the low element of xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.NP.MAP5.W0 1D /r VCVTSS2SH xmm1{k1}{z}, xmm2, xmm3/m32 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsubadd132ps:vfmsubadd213ps:vfmsubadd231ps",
    "category": "Core Instructions",
    "instructionName": "VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS\n\t\t— Fused Multiply-AlternatingSubtract/Add of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 97 /r VFMSUBADD132PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 A7 /r VFMSUBADD213PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 B7 /r VFMSUBADD231PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 97 /r VFMSUBADD132PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 A7 /r VFMSUBADD213PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 B7 /r VFMSUBADD231PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 97 /r VFMSUBADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 A7 /r VFMSUBADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 B7 /r VFMSUBADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 97 /r VFMSUBADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 A7 /r VFMSUBADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 B7 /r VFMSUBADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 97 /r VFMSUBADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 A7 /r VFMSUBADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 B7 /r VFMSUBADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtsh2si",
    "category": "Core Instructions",
    "instructionName": "VCVTSH2SI\n\t\t— Convert Low FP16 Value to Signed Integer",
    "detailsTable": [
      {
        "Description": "Convert the low FP16 element in xmm1/m16 to a signed integer and store the result in r32.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 2D /r VCVTSH2SI r32, xmm1/m16 {er}",
        "Support": "V/V1",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Convert the low FP16 element in xmm1/m16 to a signed integer and store the result in r64.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W1 2D /r VCVTSH2SI r64, xmm1/m16 {er}",
        "Support": "V/N.E.",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movss",
    "category": "Core Instructions",
    "instructionName": "MOVSS\n\t\t— Move or Merge Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Merge scalar single precision floating-point value from xmm2 to xmm1 register.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 10 /r MOVSS xmm1, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Load scalar single precision floating-point value from m32 to xmm1 register.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 10 /r MOVSS xmm1, m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge scalar single precision floating-point value from xmm2 and xmm3 to xmm1 register",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 10 /r VMOVSS xmm1, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Load scalar single precision floating-point value from m32 to xmm1 register.",
        "Op / En": "D",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 10 /r VMOVSS xmm1, m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move scalar single precision floating-point value from xmm1 register to xmm2/m32.",
        "Op / En": "C",
        "Opcode/Instruction": "F3 0F 11 /r MOVSS xmm2/m32, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move scalar single precision floating-point value from xmm2 and xmm3 to xmm1 register.",
        "Op / En": "E",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 11 /r VMOVSS xmm1, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move scalar single precision floating-point value from xmm1 register to m32.",
        "Op / En": "C",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 11 /r VMOVSS m32, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move scalar single precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 10 /r VMOVSS xmm1 {k1}{z}, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move scalar single precision floating-point values from m32 to xmm1 under writemask k1.",
        "Op / En": "F",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 10 /r VMOVSS xmm1 {k1}{z}, m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move scalar single precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1.",
        "Op / En": "E",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 11 /r VMOVSS xmm1 {k1}{z}, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move scalar single precision floating-point values from xmm1 to m32 under writemask k1.",
        "Op / En": "G",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 11 /r VMOVSS m32 {k1}, xmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "E",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:reg (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "F",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      },
      {
        "Op/En": "G",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Moves a scalar single precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to move a single precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location, or to move a single precision floating-point value between the low doublewords of two XMM registers. The instruction cannot be used to transfer data between memory locations.\nLegacy version: When the source and destination operands are XMM registers, bits (MAXVL-1:32) of the corresponding destination register are unmodified. When the source operand is a memory location and destination\noperand is an XMM registers, Bits (127:32) of the destination operand is cleared to all 0s, bits MAXVL:128 of the destination operand remains unchanged.\nVEX and EVEX encoded register-register syntax: Moves a scalar single precision floating-point value from the second source operand (the third operand) to the low doubleword element of the destination operand (the first operand). Bits 127:32 of the destination operand are copied from the first source operand (the second operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX and EVEX encoded memory load syntax: When the source operand is a memory location and destination operand is an XMM registers, bits MAXVL:32 of the destination operand is cleared to all 0s.\nEVEX encoded versions: The low doubleword of the destination is updated according to the writemask.\nNote: For memory store form instruction “VMOVSS m32, xmm1”, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD. For memory store form instruction “VMOVSS mv {k1}, xmm1”, EVEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.\nSoftware should ensure VMOVSS is encoded with VEX.L=0. Encoding VMOVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF k1[0] or *no writemask*\n    THEN DEST[31:0] := SRC[31:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[MAXVL-1:32] := 0\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := SRC[31:0]\n    ELSE *DEST[31:0] remains unchanged* ; merging-masking\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := SRC2[31:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC[31:0]\nDEST[MAXVL-1:32] (Unmodified)\nDEST[31:0] := SRC2[31:0]\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC2[31:0]\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC[31:0]\nDEST[MAXVL-1:32] := 0\nDEST[31:0] := SRC[31:0]\nDEST[31:0] := SRC[31:0]\nDEST[127:32] := 0\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-58, “Type E10 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fyl2x",
    "category": "Core Instructions",
    "instructionName": "FYL2X\n\t\t— Compute y ∗ log2x",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Replace ST(1) with (ST(1) ∗ log2ST(0)) and pop the register stack.",
        "Instruction": "FYL2X",
        "Opcode": "D9 F1"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes (ST(1) ∗ log2 (ST(0))), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number.\nThe following table shows the results obtained when taking the log of various classes of numbers, assuming that neither overflow nor underflow occurs.\nIf the divide-by-zero exception is masked and register ST(0) contains ±0, the instruction returns ∞ with a sign that is the opposite of the sign of the source operand in register ST(1).\nThe FYL2X instruction is designed with a built-in multiplication to optimize the calculation of logarithms with an arbitrary positive base (b):\nlogbx := (log2b)–1 ∗ log2x\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "ST(1) := ST(1) ∗ log2ST(0);\nPopRegisterStack;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_2: Either operand is an SNaN or unsupported format.; column_1: #IA; \ncolumn_1: Source operand in register ST(0) is a negative finite value (not -0).; \ncolumn_1: #Z; column_2: Source operand in register ST(0) is ±0.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_2: Result is too small for destination format.; column_1: #U; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_2: If there is a pending x87 FPU exception.; column_1: #MF; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rsqrtss",
    "category": "Core Instructions",
    "instructionName": "RSQRTSS\n\t\t— Compute Reciprocal of Square Root of Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm2/m32 and stores the results in xmm1.",
        "Op/En": "RM",
        "Opcode*/Instruction": "F3 0F 52 /r RSQRTSS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].",
        "Op/En": "RVM",
        "Opcode*/Instruction": "VEX.LIG.F3.0F.WIG 52 /r VRSQRTSS xmm1, xmm2, xmm3/m32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Computes an approximate reciprocal of the square root of the low single precision floating-point value in the source operand (second operand) stores the single precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a scalar single precision floating-point operation.\nThe relative error for this approximation is:\n|Relative Error| ≤ 1.5 ∗ 2−12\nThe RSQRTSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than −0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
    "operationText": "DEST[31:0] := APPROXIMATE(1/SQRT(SRC2[31:0]))\nDEST[MAXVL-1:32] (Unmodified)\nDEST[31:0] := APPROXIMATE(1/SQRT(SRC2[31:0]))\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-22, “Type 5 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmovcc",
    "category": "Core Instructions",
    "instructionName": "CMOVcc\n\t\t— Conditional Move",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if above (CF=0 and ZF=0).",
        "Instruction": "CMOVA r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 47 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if above (CF=0 and ZF=0).",
        "Instruction": "CMOVA r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 47 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if above (CF=0 and ZF=0).",
        "Instruction": "CMOVA r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 47 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if above or equal (CF=0).",
        "Instruction": "CMOVAE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if above or equal (CF=0).",
        "Instruction": "CMOVAE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if above or equal (CF=0).",
        "Instruction": "CMOVAE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if below (CF=1).",
        "Instruction": "CMOVB r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if below (CF=1).",
        "Instruction": "CMOVB r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if below (CF=1).",
        "Instruction": "CMOVB r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if below or equal (CF=1 or ZF=1).",
        "Instruction": "CMOVBE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 46 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if below or equal (CF=1 or ZF=1).",
        "Instruction": "CMOVBE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 46 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if below or equal (CF=1 or ZF=1).",
        "Instruction": "CMOVBE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 46 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if carry (CF=1).",
        "Instruction": "CMOVC r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if carry (CF=1).",
        "Instruction": "CMOVC r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if carry (CF=1).",
        "Instruction": "CMOVC r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if equal (ZF=1).",
        "Instruction": "CMOVE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 44 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if equal (ZF=1).",
        "Instruction": "CMOVE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 44 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if equal (ZF=1).",
        "Instruction": "CMOVE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 44 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if greater (ZF=0 and SF=OF).",
        "Instruction": "CMOVG r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4F /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if greater (ZF=0 and SF=OF).",
        "Instruction": "CMOVG r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4F /r"
      },
      {
        "64-Bit Mode": "V/N.E.",
        "Compat/Leg Mode": "N/A",
        "Description": "Move if greater (ZF=0 and SF=OF).",
        "Instruction": "CMOVG r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4F /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if greater or equal (SF=OF).",
        "Instruction": "CMOVGE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4D /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if greater or equal (SF=OF).",
        "Instruction": "CMOVGE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4D /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if greater or equal (SF=OF).",
        "Instruction": "CMOVGE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4D /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if less (SF≠ OF).",
        "Instruction": "CMOVL r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if less (SF≠ OF).",
        "Instruction": "CMOVL r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if less (SF≠ OF).",
        "Instruction": "CMOVL r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if less or equal (ZF=1 or SF≠ OF).",
        "Instruction": "CMOVLE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4E /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if less or equal (ZF=1 or SF≠ OF).",
        "Instruction": "CMOVLE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4E /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if less or equal (ZF=1 or SF≠ OF).",
        "Instruction": "CMOVLE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4E /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not above (CF=1 or ZF=1).",
        "Instruction": "CMOVNA r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 46 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not above (CF=1 or ZF=1).",
        "Instruction": "CMOVNA r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 46 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not above (CF=1 or ZF=1).",
        "Instruction": "CMOVNA r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 46 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not above or equal (CF=1).",
        "Instruction": "CMOVNAE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not above or equal (CF=1).",
        "Instruction": "CMOVNAE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not above or equal (CF=1).",
        "Instruction": "CMOVNAE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 42 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not below (CF=0).",
        "Instruction": "CMOVNB r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not below (CF=0).",
        "Instruction": "CMOVNB r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not below (CF=0).",
        "Instruction": "CMOVNB r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not below or equal (CF=0 and ZF=0).",
        "Instruction": "CMOVNBE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 47 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not below or equal (CF=0 and ZF=0).",
        "Instruction": "CMOVNBE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 47 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not below or equal (CF=0 and ZF=0).",
        "Instruction": "CMOVNBE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 47 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not carry (CF=0).",
        "Instruction": "CMOVNC r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not carry (CF=0).",
        "Instruction": "CMOVNC r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not carry (CF=0).",
        "Instruction": "CMOVNC r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 43 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not equal (ZF=0).",
        "Instruction": "CMOVNE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 45 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not equal (ZF=0).",
        "Instruction": "CMOVNE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 45 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not equal (ZF=0).",
        "Instruction": "CMOVNE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 45 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not greater (ZF=1 or SF≠ OF).",
        "Instruction": "CMOVNG r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4E /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not greater (ZF=1 or SF≠ OF).",
        "Instruction": "CMOVNG r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4E /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not greater (ZF=1 or SF≠ OF).",
        "Instruction": "CMOVNG r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4E /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not greater or equal (SF≠ OF).",
        "Instruction": "CMOVNGE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not greater or equal (SF≠ OF).",
        "Instruction": "CMOVNGE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not greater or equal (SF≠ OF).",
        "Instruction": "CMOVNGE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4C /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not less (SF=OF).",
        "Instruction": "CMOVNL r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4D /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not less (SF=OF).",
        "Instruction": "CMOVNL r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4D /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not less (SF=OF).",
        "Instruction": "CMOVNL r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4D /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not less or equal (ZF=0 and SF=OF).",
        "Instruction": "CMOVNLE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4F /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not less or equal (ZF=0 and SF=OF).",
        "Instruction": "CMOVNLE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4F /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not less or equal (ZF=0 and SF=OF).",
        "Instruction": "CMOVNLE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4F /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not overflow (OF=0).",
        "Instruction": "CMOVNO r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 41 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not overflow (OF=0).",
        "Instruction": "CMOVNO r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 41 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not overflow (OF=0).",
        "Instruction": "CMOVNO r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 41 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not parity (PF=0).",
        "Instruction": "CMOVNP r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not parity (PF=0).",
        "Instruction": "CMOVNP r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not parity (PF=0).",
        "Instruction": "CMOVNP r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not sign (SF=0).",
        "Instruction": "CMOVNS r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 49 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not sign (SF=0).",
        "Instruction": "CMOVNS r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 49 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not sign (SF=0).",
        "Instruction": "CMOVNS r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 49 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not zero (ZF=0).",
        "Instruction": "CMOVNZ r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 45 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if not zero (ZF=0).",
        "Instruction": "CMOVNZ r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 45 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if not zero (ZF=0).",
        "Instruction": "CMOVNZ r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 45 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if overflow (OF=1).",
        "Instruction": "CMOVO r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 40 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if overflow (OF=1).",
        "Instruction": "CMOVO r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 40 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if overflow (OF=1).",
        "Instruction": "CMOVO r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 40 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if parity (PF=1).",
        "Instruction": "CMOVP r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if parity (PF=1).",
        "Instruction": "CMOVP r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if parity (PF=1).",
        "Instruction": "CMOVP r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if parity even (PF=1).",
        "Instruction": "CMOVPE r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if parity even (PF=1).",
        "Instruction": "CMOVPE r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if parity even (PF=1).",
        "Instruction": "CMOVPE r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if parity odd (PF=0).",
        "Instruction": "CMOVPO r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 4B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if parity odd (PF=0).",
        "Instruction": "CMOVPO r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 4B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if parity odd (PF=0).",
        "Instruction": "CMOVPO r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 4B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if sign (SF=1).",
        "Instruction": "CMOVS r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 48 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if sign (SF=1).",
        "Instruction": "CMOVS r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 48 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if sign (SF=1).",
        "Instruction": "CMOVS r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 48 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if zero (ZF=1).",
        "Instruction": "CMOVZ r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F 44 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move if zero (ZF=1).",
        "Instruction": "CMOVZ r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F 44 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move if zero (ZF=1).",
        "Instruction": "CMOVZ r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F 44 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Each of the CMOVcc instructions performs a move operation if the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.\nSpecifically, CMOVcc loads data from its source operand into a temporary register unconditionally (regardless of the condition code and the status flags in the EFLAGS register). If the condition code associated with the instruction (cc) is satisfied, the data in the temporary register is then copied into the instruction's destination operand.\nThese instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.\nThe condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.\nThe CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "temp := SRC\nIF condition TRUE\n    THEN DEST := temp;\nELSE IF (OperandSize = 32 and IA-32e mode active)\n    THEN DEST[63:32] := 0;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/prefetchw",
    "category": "Core Instructions",
    "instructionName": "PREFETCHW\n\t\t— Prefetch Data Into Caches in Anticipation of a Write",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "PREFETCHW",
        "Description": "Move data from m8 closer to the processor in anticipation of a write.",
        "Op/En": "M",
        "Opcode/Instruction": "0F 0D /1 PREFETCHW m8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Fetches the cache line of data from memory that contains the byte specified with the source operand to a location in the 1st or 2nd level cache and invalidates other cached instances of the line.\nThe source operand is a byte memory location. If the line selected is already present in the lowest level cache and is already in an exclusively owned state, no data movement occurs. Prefetches from non-writeback memory are ignored.\nThe PREFETCHW instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor and invalidates other cached copies in anticipation of the line being written to in the future.\nThe characteristic of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes. Additional details of the implementation-dependent locality hints are described in Section 7.4 of Intel® 64 and IA-32 Architectures Optimization Reference Manual.\nIt should be noted that processors are free to speculatively fetch and cache data with exclusive ownership from system memory regions that permit such accesses (that is, the WB memory type). A PREFETCHW instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHW instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHW instruction is also unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHW instructions, or any other general instruction\nIt is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.\nThis instruction's operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "FETCH_WITH_EXCLUSIVE_OWNERSHIP (m8);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/erdinfo",
    "category": "SGX Instructions",
    "instructionName": "ERDINFO\n\t\t— Read Type and Status Information About an EPC Page",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "EAX[6]",
        "Description": "This leaf function returns type and status information about an EPC page.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 10H ENCLS[ERDINFO]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "ERDINFO (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Address of a RDINFO structure (In)",
        "column_5": "Address of the destination EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/palignr",
    "category": "Core Instructions",
    "instructionName": "PALIGNR\n\t\t— Packed Align Right",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 3A 0F /r ib1 PALIGNR mm1, mm2/m64, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 3A 0F /r ib PALIGNR xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 0F /r ib VPALIGNR xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F3A.WIG 0F /r ib VPALIGNR ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Concatenate xmm2 and xmm3/m128 into a 32-byte intermediate result, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.WIG 0F /r ib VPALIGNR xmm1 {k1}{z}, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F3A.WIG 0F /r ib VPALIGNR ymm1 {k1}{z}, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Concatenate pairs of 16 bytes in zmm2 and zmm3/m512 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and four 16-byte results are stored in zmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.WIG 0F /r ib VPALIGNR zmm1 {k1}{z}, zmm2, zmm3/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant immediate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX, XMM or a YMM register. The immediate value is considered unsigned. Immediate shift counts larger than the 2L (i.e., 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result. Both operands can be MMX registers, XMM registers or YMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nIn 64-bit mode and not encoded by VEX/EVEX prefix, use the REX prefix to access additional registers.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nEVEX.512 encoded version: The first source operand is a ZMM register and contains four 16-byte blocks. The second source operand is a ZMM register or a 512-bit memory location containing four 16-byte block. The destination operand is a ZMM register and contain four 16-byte results. The imm8[7:0] is the common shift count\nused for each of the four successive 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand and so on for the blocks in the middle.\nVEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register and contains two 16-byte blocks. The second source operand is a YMM register or a 256-bit memory location containing two 16-byte block. The destination operand is a YMM register and contain two 16-byte results. The imm8[7:0] is the common shift count used for the two lower 16-byte block sources and the two upper 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nConcatenation is done with 128-bit data in the first and second source operand for both 128-bit and 256-bit instructions. The high 128-bits of the intermediate composite 256-bit result came from the 128-bit data from the first source operand; the low 128-bits of the intermediate result came from the 128-bit data of the second source operand.\n0 127 0 127",
    "operationText": "temp1[127:0] = CONCATENATE(DEST,SRC)>>(imm8*8)\nDEST[63:0] = temp1[63:0]\ntemp1[255:0] := ((DEST[127:0] << 128) OR SRC[127:0])>>(imm8*8);\nDEST[127:0] := temp1[127:0]\nDEST[MAXVL-1:128] (Unmodified)\ntemp1[255:0] := ((SRC1[127:0] << 128) OR SRC2[127:0])>>(imm8*8);\nDEST[127:0] := temp1[127:0]\nDEST[MAXVL-1:128] := 0\ntemp1[255:0] := ((SRC1[127:0] << 128) OR SRC2[127:0])>>(imm8[7:0]*8);\nDEST[127:0] := temp1[127:0]\ntemp1[255:0] := ((SRC1[255:128] << 128) OR SRC2[255:128])>>(imm8[7:0]*8);\nDEST[MAXVL-1:128] := temp1[127:0]\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR l := 0 TO VL-1 with increments of 128\n    temp1[255:0] := ((SRC1[l+127:l] << 128) OR SRC2[l+127:l])>>(imm8[7:0]*8);\n    TMP_DEST[l+127:l] := temp1[127:0]\nENDFOR;\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := TMP_DEST[i+7:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+7:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvttpd2dq",
    "category": "Core Instructions",
    "instructionName": "CVTTPD2DQ\n\t\t— Convert with Truncation Packed Double Precision Floating-Point Values toPacked Doubleword Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert two packed double precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F E6 /r CVTTPD2DQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert two packed double precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E6 /r VCVTTPD2DQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert four packed double precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E6 /r VCVTTPD2DQ xmm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert two packed double precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 using truncation subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 E6 /r VCVTTPD2DQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed double precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 using truncation subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 E6 /r VCVTTPD2DQ xmm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert eight packed double precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 using truncation subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 E6 /r VCVTTPD2DQ ymm1 {k1}{z}, zmm2/m512/m64bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Converts two, four or eight packed double precision floating-point values in the source operand (second operand) to two, four or eight packed signed doubleword integers in the destination operand (first operand).\nWhen a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    k := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] :=\n            Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[k+63:k])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL/2] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    k := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+31:i] :=\n            Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0])\n                ELSE\n                    DEST[i+31:i] :=\n            Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[k+63:k])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL/2] := 0\nDEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[127:64])\nDEST[95:64] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[191:128])\nDEST[127:96] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[255:192)\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[127:64])\nDEST[MAXVL-1:64] := 0\nDEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[127:64])\nDEST[127:64] := 0\nDEST[MAXVL-1:128] (unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtps2dq",
    "category": "Core Instructions",
    "instructionName": "CVTPS2DQ\n\t\t— Convert Packed Single Precision Floating-Point Values to Packed SignedDoubleword Integer Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert four packed single precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 5B /r CVTPS2DQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert four packed single precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 5B /r VCVTPS2DQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert eight packed single precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 5B /r VCVTPS2DQ ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 5B /r VCVTPS2DQ xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 5B /r VCVTPS2DQ ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert sixteen packed single precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 5B /r VCVTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Converts four, eight or sixteen packed single precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.\nEVEX encoded versions: The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] :=\n            Convert_Single_Precision_Floating_Point_To_Integer(SRC[i+31:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO 15\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+31:i] :=\n            Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0])\n                ELSE\n                    DEST[i+31:i] :=\n            Convert_Single_Precision_Floating_Point_To_Integer(SRC[i+31:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0])\nDEST[63:32] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[63:32])\nDEST[95:64] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[95:64])\nDEST[127:96] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[127:96)\nDEST[159:128] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[159:128])\nDEST[191:160] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[191:160])\nDEST[223:192] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[223:192])\nDEST[255:224] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[255:224])\nDEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0])\nDEST[63:32] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[63:32])\nDEST[95:64] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[95:64])\nDEST[127:96] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[127:96])\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0])\nDEST[63:32] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[63:32])\nDEST[95:64] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[95:64])\nDEST[127:96] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[127:96])\nDEST[MAXVL-1:128] (unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movntdqa",
    "category": "Core Instructions",
    "instructionName": "MOVNTDQA\n\t\t— Load Double Quadword Non-Temporal Aligned Hint",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Move double quadword from m128 to xmm1 using non-temporal hint if WC memory type.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 38 2A /r MOVNTDQA xmm1, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move double quadword from m128 to xmm using non-temporal hint if WC memory type.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 2A /r VMOVNTDQA xmm1, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 2A /r VMOVNTDQA ymm1, m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move 128-bit data from m128 to xmm using non-temporal hint if WC memory type.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 2A /r VMOVNTDQA xmm1, m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 2A /r VMOVNTDQA ymm1, m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move 512-bit data from m512 to zmm using non-temporal hint if WC memory type.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 2A /r VMOVNTDQA zmm1, m512"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "MOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first operand) using a non-temporal hint if the memory source is WC (write combining) memory type. For WC memory type, the nontemporal hint may be implemented by loading a temporary internal buffer with the equivalent of an aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped and flushed. Subsequent MOVNTDQA reads to unread portions of the WC cache line will receive data from the temporary internal buffer if data is available. The temporary internal buffer may be flushed by the processor at any time for any reason, for example:\na mis-speculation condition, and various fault conditions\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when reading the data from memory. Using this protocol, the processor does not read the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being read can override the non-temporal hint, if the memory address specified for the non-temporal read is not a WC memory region. Information on non-temporal reads and writes can be found in “Caching of Temporal vs. NonTemporal Data” in Chapter 10 in the Intel® 64 and IA-32 Architecture Software Developer’s Manual, Volume 3A.\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with a MFENCE instruction should be used in conjunction with MOVNTDQA instructions if multiple processors might use different memory types for the referenced memory locations or to synchronize reads of a processor with writes by other agents in the system. A processor’s implementation of the streaming load hint does not override the effective memory type, but the implementation of the hint is processor dependent. For example, a processor implementa-\ntion may choose to ignore the hint and process the instruction as a normal MOVDQA for any memory type. Alternatively, another implementation may optimize cache reads generated by MOVNTDQA on WB memory type to reduce cache evictions.\nThe 128-bit (V)MOVNTDQA addresses must be 16-byte aligned or the instruction will cause a #GP.\nThe 256-bit VMOVNTDQA addresses must be 32-byte aligned or the instruction will cause a #GP.\nThe 512-bit VMOVNTDQA addresses must be 64-byte aligned or the instruction will cause a #GP.",
    "operationText": "DEST := SRC\nDEST[MAXVL-1:128] (Unmodified)\nDEST := SRC\nDEST[MAXVL-1:128] := 0\nDEST[255:0] := SRC[255:0]\nDEST[MAXVL-1:256] := 0\nDEST[511:0] := SRC[511:0]\nDEST[MAXVL-1:512] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-18, “Type 1 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-45, “Type E1NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/psrldq",
    "category": "Core Instructions",
    "instructionName": "PSRLDQ\n\t\t— Shift Double Quadword Right Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift xmm1 right by imm8 while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 73 /3 ib PSRLDQ xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift xmm2 right by imm8 bytes while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift ymm1 right by imm8 bytes while shifting in 0s.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 73 /3 ib VPSRLDQ ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift xmm2/m128 right by imm8 bytes while shifting in 0s and store result in xmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift ymm2/m256 right by imm8 bytes while shifting in 0s and store result in ymm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 73 /3 ib VPSRLDQ ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift zmm2/m512 right by imm8 bytes while shifting in 0s and store result in zmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 73 /3 ib VPSRLDQ zmm1, zmm2/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "EVEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand (second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The count operand applies to both the low and high 128-bit lanes.\nVEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.\nNote: VEX.vvvv/EVEX.vvvv encodes the destination register.",
    "operationText": "TEMP := COUNT\nIF (TEMP > 15) THEN TEMP := 16; FI\nDEST[127:0] := SRC[127:0] >> (TEMP * 8)\nDEST[255:128] := SRC[255:128] >> (TEMP * 8)\nDEST[383:256] := SRC[383:256] >> (TEMP * 8)\nDEST[511:384] := SRC[511:384] >> (TEMP * 8)\nDEST[MAXVL-1:512] := 0;\nTEMP := COUNT\nIF (TEMP > 15) THEN TEMP := 16; FI\nDEST[127:0] := SRC[127:0] >> (TEMP * 8)\nDEST[255:128] := SRC[255:128] >> (TEMP * 8)\nDEST[MAXVL-1:256] := 0;\nTEMP := COUNT\nIF (TEMP > 15) THEN TEMP := 16; FI\nDEST := SRC >> (TEMP * 8)\nDEST[MAXVL-1:128] := 0;\nTEMP := COUNT\nIF (TEMP > 15) THEN TEMP := 16; FI\nDEST := DEST >> (TEMP * 8)\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-24, “Type 7 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/xtest",
    "category": "Core Instructions",
    "instructionName": "XTEST\n\t\t— Test if in Transactional Execution",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "HLE or RTM",
        "Description": "Test if executing in a transactional region.",
        "Op/En": "ZO",
        "Opcode/Instruction": "NP 0F 01 D6 XTEST"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand2": "N/A",
        "Operand3": "N/A",
        "Operand4": "N/A"
      }
    ],
    "descriptionText": "The XTEST instruction queries the transactional execution status. If the instruction executes inside a transactionally executing RTM region or a transactionally executing HLE region, then the ZF flag is cleared, else it is set.",
    "operationText": "IF (RTM_ACTIVE = 1 OR HLE_ACTIVE = 1)\n    THEN\n        ZF := 0\n    ELSE\n        ZF := 1\nFI;",
    "flagsAffectedText": "The ZF flag is cleared if the instruction is executed transactionally; otherwise it is set to 1. The CF, OF, SF, PF, and AF, flags are cleared.",
    "exceptions": {
      "other¶": [
        "column_1: If LOCK prefix is used.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmresume",
    "category": "VMX Instructions",
    "instructionName": "VMRESUME\n\t\t— Resume Virtual Machine",
    "detailsTable": null,
    "operandEncodingTable": null,
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movsx:movsxd",
    "category": "Core Instructions",
    "instructionName": "MOVSX/MOVSXD\n\t\t— Move With Sign-Extension",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move byte to word with sign-extension.",
        "Instruction": "MOVSX r16, r/m8",
        "Op/En": "RM",
        "Opcode": "0F BE /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move byte to doubleword with sign-extension.",
        "Instruction": "MOVSX r32, r/m8",
        "Op/En": "RM",
        "Opcode": "0F BE /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move byte to quadword with sign-extension.",
        "Instruction": "MOVSX r64, r/m8",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F BE /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move word to doubleword, with sign-extension.",
        "Instruction": "MOVSX r32, r/m16",
        "Op/En": "RM",
        "Opcode": "0F BF /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move word to quadword with sign-extension.",
        "Instruction": "MOVSX r64, r/m16",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F BF /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move word to word with sign-extension.",
        "Instruction": "MOVSXD r16, r/m16",
        "Op/En": "RM",
        "Opcode": "63 /r1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move doubleword to doubleword with sign-extension.",
        "Instruction": "MOVSXD r32, r/m32",
        "Op/En": "RM",
        "Opcode": "63 /r1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move doubleword to quadword with sign-extension.",
        "Instruction": "MOVSXD r64, r/m32",
        "Op/En": "RM",
        "Opcode": "REX.W + 63 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits (see Figure 7-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). The size of the converted value depends on the operand-size attribute.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := SignExtend(SRC);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/emms",
    "category": "Core Instructions",
    "instructionName": "EMMS\n\t\t— Empty MMX Technology State",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set the x87 FPU tag word to empty.",
        "Instruction": "EMMS",
        "Op/En": "ZO",
        "Opcode": "NP 0F 77"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instructions. (See Figure 8-7 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for the format of the x87 FPU tag word.) All other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s).\nThe EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions. If a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will result in an x87 floating-point exception or incorrect result.\nEMMS operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "x87FPUTagWord := FFFFH;",
    "flagsAffectedText": "None",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pminsb:pminsw",
    "category": "Core Instructions",
    "instructionName": "PMINSB/PMINSW\n\t\t— Minimum of Packed Signed Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Compare signed word integers in mm2/m64 and mm1 and return minimum values.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F EA /r1 PMINSW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 38 38 /r PMINSB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed signed word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F EA /r PMINSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38 38 /r VPMINSB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F EA /r VPMINSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38 38 /r VPMINSB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F EA /r VPMINSW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 38 /r VPMINSB xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 38 /r VPMINSB ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 38 /r VPMINSB zmm1{k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed word integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG EA /r VPMINSW xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed word integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG EA /r VPMINSW ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed signed word integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG EA /r VPMINSW zmm1{k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\nLegacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "IF DEST[15:0] < SRC[15:0] THEN\n    DEST[15:0] := DEST[15:0];\nELSE\n    DEST[15:0] := SRC[15:0]; FI;\n(* Repeat operation for 2nd and 3rd words in source and destination operands *)\nIF DEST[63:48] < SRC[63:48] THEN\n    DEST[63:48] := DEST[63:48];\nELSE\n    DEST[63:48] := SRC[63:48]; FI;\nIF DEST[7:0] < SRC[7:0] THEN\n        DEST[7:0] := DEST[7:0];\n    ELSE\n        DEST[15:0] := SRC[7:0]; FI;\n    (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n    IF DEST[127:120] < SRC[127:120] THEN\n        DEST[127:120] := DEST[127:120];\n    ELSE\n        DEST[127:120] := SRC[127:120]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[7:0] < SRC2[7:0] THEN\n        DEST[7:0] := SRC1[7:0];\n    ELSE\n        DEST[7:0] := SRC2[7:0]; FI;\n    (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n    IF SRC1[127:120] < SRC2[127:120] THEN\n        DEST[127:120] := SRC1[127:120];\n    ELSE\n        DEST[127:120] := SRC2[127:120]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[7:0] < SRC2[7:0] THEN\n        DEST[7:0] := SRC1[7:0];\n    ELSE\n        DEST[15:0] := SRC2[7:0]; FI;\n    (* Repeat operation for 2nd through 31st bytes in source and destination operands *)\n    IF SRC1[255:248] < SRC2[255:248] THEN\n        DEST[255:248] := SRC1[255:248];\n    ELSE\n        DEST[255:248] := SRC2[255:248]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask* THEN\n        IF SRC1[i+7:i] < SRC2[i+7:i]\n            THEN DEST[i+7:i] := SRC1[i+7:i];\n            ELSE DEST[i+7:i] := SRC2[i+7:i];\n        FI;\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nIF DEST[15:0] < SRC[15:0] THEN\n        DEST[15:0] := DEST[15:0];\n    ELSE\n        DEST[15:0] := SRC[15:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF DEST[127:112] < SRC[127:112] THEN\n        DEST[127:112] := DEST[127:112];\n    ELSE\n        DEST[127:112] := SRC[127:112]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[15:0] < SRC2[15:0] THEN\n        DEST[15:0] := SRC1[15:0];\n    ELSE\n        DEST[15:0] := SRC2[15:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF SRC1[127:112] < SRC2[127:112] THEN\n        DEST[127:112] := SRC1[127:112];\n    ELSE\n        DEST[127:112] := SRC2[127:112]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[15:0] < SRC2[15:0] THEN\n        DEST[15:0] := SRC1[15:0];\n    ELSE\n        DEST[15:0] := SRC2[15:0]; FI;\n    (* Repeat operation for 2nd through 15th words in source and destination operands *)\n    IF SRC1[255:240] < SRC2[255:240] THEN\n        DEST[255:240] := SRC1[255:240];\n    ELSE\n        DEST[255:240] := SRC2[255:240]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask* THEN\n        IF SRC1[i+15:i] < SRC2[i+15:i]\n            THEN DEST[i+15:i] := SRC1[i+15:i];\n            ELSE DEST[i+15:i] := SRC2[i+15:i];\n        FI;\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtsi2sh",
    "category": "Core Instructions",
    "instructionName": "VCVTSI2SH\n\t\t— Convert a Signed Doubleword/Quadword Integer to an FP16 Value",
    "detailsTable": [
      {
        "Description": "Convert the signed doubleword integer in r32/m32 to an FP16 value and store the result in xmm1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 2A /r VCVTSI2SH xmm1, xmm2, r32/m32 {er}",
        "Support": "V/V1",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Convert the signed quadword integer in r64/m64 to an FP16 value and store the result in xmm1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W1 2A /r VCVTSI2SH xmm1, xmm2, r64/m64 {er}",
        "Support": "V/N.E.",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/tdpbf16ps",
    "category": "Core Instructions",
    "instructionName": "TDPBF16PS\n\t\t— Dot Product of BF16 Tiles Accumulated into Packed Single Precision Tile",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-BF16",
        "Description": "Matrix multiply BF16 elements from tmm2 and tmm3, and accumulate the packed single precision elements in tmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F38.W0 5C 11:rrr:bbb TDPBF16PS tmm1, tmm2, tmm3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "VEX.vvvv (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "This instruction performs a set of SIMD dot-products of two BF16 elements and accumulates the results into a packed single precision tile. Each dword element in input tiles tmm2 and tmm3 is interpreted as a BF16 pair. For each possible combination of (row of tmm2, column of tmm3), the instruction performs a set of SIMD dot-products on all corresponding BF16 pairs (one pair from tmm2 and one pair from tmm3), adds the results of those dot-products, and then accumulates the result into the corresponding row and column of tmm1.\n“Round to nearest even” rounding mode is used when doing each accumulation of the FMA. Output denormals are always flushed to zero and input denormals are always treated as zero. MXCSR is not consulted nor updated.\nAny attempt to execute the TDPBF16PS instruction inside a TSX transaction will result in a transaction abort.",
    "operationText": "define make_fp32(x):\n    // The x parameter is bfloat16. Pack it in to upper 16b of a dword.\n    // The bit pattern is a legal fp32 value. Return that bit pattern.\n    dword: = 0\n    dword[31:16] := x\nreturn dword\n// C = m x n (tsrcdest), A = m x k (tsrc1), B = k x n (tsrc2)\n# src1 and src2 elements are pairs of bfloat16\nelements_src1 := tsrc1.colsb / 4\nelements_src2 := tsrc2.colsb / 4\nelements_dest := tsrcdest.colsb / 4\nelements_temp := tsrcdest.colsb / 2\nfor m in 0 ... tsrcdest.rows-1:\n    temp1[ 0 ... elements_temp-1 ] := 0\n    for k in 0 ... elements_src1-1:\n        for n in 0 ... elements_dest-1:\n            // FP32 FMA with DAZ=FTZ=1, RNE rounding.\n            // MXCSR is neither consulted nor updated.\n            // No exceptions raised or denoted.\n            temp1.fp32[2*n+0] += make_fp32(tsrc1.row[m].bfloat16[2*k+0]) * make_fp32(tsrc2.row[k].bfloat16[2*n+0])\n            temp1.fp32[2*n+1] += make_fp32(tsrc1.row[m].bfloat16[2*k+1]) * make_fp32(tsrc2.row[k].bfloat16[2*n+1])\n    for n in 0 ... elements_dest-1:\n        // DAZ=FTZ=1, RNE rounding.\n        // MXCSR is neither consulted nor updated.\n        // No exceptions raised or denoted.\n        tmpf32 := temp1.fp32[2*n] + temp1.fp32[2*n+1]\n        tsrcdest.row[m].fp32[n] := tsrcdest.row[m].fp32[n] + tmpf32\n    write_row_and_zero(tsrcdest, m, tmp, tsrcdest.colsb)\nzero_upper_rows(tsrcdest, tsrcdest.rows)\nzero_tilecfg_start()",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "AMX-E4; see Section 2.10, “Intel® AMX Instruction Exception Classes,” for details."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/blsr",
    "category": "Core Instructions",
    "instructionName": "BLSR\n\t\t— Reset Lowest Set Bit",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI1",
        "Description": "Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32.",
        "Op/En": "VM",
        "Opcode/Instruction": "VEX.LZ.0F38.W0 F3 /1 BLSR r32, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI1",
        "Description": "Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64.",
        "Op/En": "VM",
        "Opcode/Instruction": "VEX.LZ.0F38.W1 F3 /1 BLSR r64, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "VM",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destination operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets CF.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "temp := (SRC-1) bitwiseAND ( SRC );\nSF := temp[OperandSize -1];\nZF := (temp = 0);\nIF SRC = 0\n    CF := 1;\nELSE\n    CF := 0;\nFI\nDEST := temp;",
    "flagsAffectedText": "ZF and SF flags are updated based on the result. CF is set if the source is zero. OF flag is cleared. AF and PF flags are undefined.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsubadd132pd:vfmsubadd213pd:vfmsubadd231pd",
    "category": "Core Instructions",
    "instructionName": "VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD\n\t\t— Fused Multiply-AlternatingSubtract/Add of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 97 /r VFMSUBADD132PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 A7 /r VFMSUBADD213PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 B7 /r VFMSUBADD231PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 97 /r VFMSUBADD132PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 A7 /r VFMSUBADD213PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 B7 /r VFMSUBADD231PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 97 /r VFMSUBADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 A7 /r VFMSUBADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 B7 /r VFMSUBADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 97 /r VFMSUBADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 A7 /r VFMSUBADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 B7 /r VFMSUBADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 97 /r VFMSUBADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 A7 /r VFMSUBADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 B7 /r VFMSUBADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/invlpg",
    "category": "Core Instructions",
    "instructionName": "INVLPG\n\t\t— Invalidate TLB Entries",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Invalidate TLB entries for page containing m.",
        "Instruction": "",
        "Op/En": "",
        "column_1": "0F 01/7"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Invalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes all TLB entries for that page.1\nThe INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL must be 0 to execute this instruction.\nThe INVLPG instruction normally flushes TLB entries only for the specified page; however, in some cases, it may flush more entries, even the entire TLB. The instruction invalidates TLB entries associated with the current PCID and may or may not do so for TLB entries associated with other PCIDs. (If PCIDs are disabled — CR4.PCIDE = 0 — the current PCID is 000H.) The instruction also invalidates any global TLB entries for the specified page, regardless of PCID.\nFor more details on operations that flush the TLB, see “MOV—Move to/from Control Registers” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, and Section 4.10.4.1, “Operations that Invalidate TLBs and Paging-Structure Caches,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\nThis instruction’s operation is the same in all non-64-bit modes. It also operates the same in 64-bit mode, except if the memory address is in non-canonical form. In this case, INVLPG is the same as a NOP.",
    "operationText": "Invalidate(RelevantTLBEntries);\nContinue; (* Continue execution *)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: Operand is a register.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "protectedMode": [
        "column_1: #UD; column_2: Operand is a register.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcmpph",
    "category": "Core Instructions",
    "instructionName": "VCMPPH\n\t\t— Compare Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Compare packed FP16 values in xmm3/m128/m16bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate subject to writemask k2, and store the result in mask register k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.0F3A.W0 C2 /r /ib VCMPPH k1{k2}, xmm2, xmm3/m128/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Compare packed FP16 values in ymm3/m256/m16bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate subject to writemask k2, and store the result in mask register k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.0F3A.W0 C2 /r /ib VCMPPH k1{k2}, ymm2, ymm3/m256/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Compare packed FP16 values in zmm3/m512/m16bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate subject to writemask k2, and store the result in mask register k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.0F3A.W0 C2 /r /ib VCMPPH k1{k2}, zmm2, zmm3/m512/m16bcst {sae}, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfixupimmss",
    "category": "Core Instructions",
    "instructionName": "VFIXUPIMMSS\n\t\t— Fix Up Special Scalar Float32 Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Fix up a float32 number in the low doubleword element in xmm2 using scalar int32 table in xmm3/m32 and store the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W0 55 /r ib VFIXUPIMMSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/eincvirtchild",
    "category": "SGX Instructions",
    "instructionName": "EINCVIRTCHILD\n\t\t— Increment VIRTCHILDCNT in SECS",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "EAX[5]",
        "Description": "This leaf function increments the SECS VIRTCHILDCNT field.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 01H ENCLV[EINCVIRTCHILD]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EINCVIRTCHILD (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Address of an enclave page (In)",
        "column_5": "Address of an SECS page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movhps",
    "category": "Core Instructions",
    "instructionName": "MOVHPS\n\t\t— Move High Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move two packed single precision floating-point values from m64 to high quadword of xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 16 /r MOVHPS xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge two packed single precision floating-point values from m64 and the low quadword of xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 16 /r VMOVHPS xmm2, xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Merge two packed single precision floating-point values from m64 and the low quadword of xmm1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.0F.W0 16 /r VMOVHPS xmm2, xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move two packed single precision floating-point values from high quadword of xmm1 to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "NP 0F 17 /r MOVHPS m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move two packed single precision floating-point values from high quadword of xmm1 to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "VEX.128.0F.WIG 17 /r VMOVHPS m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move two packed single precision floating-point values from high quadword of xmm1 to m64.",
        "Op / En": "E",
        "Opcode/Instruction": "EVEX.128.0F.W0 17 /r VMOVHPS m64, xmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple2"
      },
      {
        "Op/En": "E",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple2"
      }
    ],
    "descriptionText": "This instruction cannot be used for register to register or memory to memory moves.\n128-bit Legacy SSE load:\nMoves two packed single precision floating-point values from the source 64-bit memory operand and stores them in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.\nVEX.128 & EVEX encoded load:\nLoads two single precision floating-point values from the source 64-bit memory operand (the third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source operand (the second operand) are copied to the lower 64-bits of the destination. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n128-bit store:\nStores two packed single precision floating-point values from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).\nNote: VMOVHPS (store) (VEX.128.0F 17 /r) is legal and has the same behavior as the existing 0F 17 store. For VMOVHPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.\nIf VMOVHPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception.",
    "operationText": "DEST[63:0] (Unmodified)\nDEST[127:64] := SRC[63:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := SRC1[63:0]\nDEST[127:64] := SRC2[63:0]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC[127:64]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movsd",
    "category": "Core Instructions",
    "instructionName": "MOVSD\n\t\t— Move or Merge Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move scalar double precision floating-point value from xmm2 to xmm1 register.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 10 /r MOVSD xmm1, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Load scalar double precision floating-point value from m64 to xmm1 register.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 10 /r MOVSD xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move scalar double precision floating-point value from xmm2 register to xmm1/m64.",
        "Op / En": "C",
        "Opcode/Instruction": "F2 0F 11 /r MOVSD xmm1/m64, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge scalar double precision floating-point value from xmm2 and xmm3 to xmm1 register.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 10 /r VMOVSD xmm1, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Load scalar double precision floating-point value from m64 to xmm1 register.",
        "Op / En": "D",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 10 /r VMOVSD xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge scalar double precision floating-point value from xmm2 and xmm3 registers to xmm1.",
        "Op / En": "E",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 11 /r VMOVSD xmm1, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Store scalar double precision floating-point value from xmm1 register to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 11 /r VMOVSD m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Merge scalar double precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 10 /r VMOVSD xmm1 {k1}{z}, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Load scalar double precision floating-point value from m64 to xmm1 register under writemask k1.",
        "Op / En": "F",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 10 /r VMOVSD xmm1 {k1}{z}, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Merge scalar double precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1.",
        "Op / En": "E",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 11 /r VMOVSD xmm1 {k1}{z}, xmm2, xmm3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Store scalar double precision floating-point value from xmm1 register to m64 under writemask k1.",
        "Op / En": "G",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 11 /r VMOVSD m64 {k1}, xmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "E",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:reg (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "F",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      },
      {
        "Op/En": "G",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Moves a scalar double precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 64-bit memory locations. This instruction can be used to move a double precision floating-point value to and from the low quadword of an XMM register and a 64-bit memory location, or to move a double precision floating-point value between the low quadwords of two XMM registers. The instruction cannot be used to transfer data between memory locations.\nLegacy version: When the source and destination operands are XMM registers, bits MAXVL:64 of the destination operand remains unchanged. When the source operand is a memory location and destination operand is an XMM\nregisters, the quadword at bits 127:64 of the destination operand is cleared to all 0s, bits MAXVL:128 of the destination operand remains unchanged.\nVEX and EVEX encoded register-register syntax: Moves a scalar double precision floating-point value from the second source operand (the third operand) to the low quadword element of the destination operand (the first operand). Bits 127:64 of the destination operand are copied from the first source operand (the second operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX and EVEX encoded memory store syntax: When the source operand is a memory location and destination operand is an XMM registers, bits MAXVL:64 of the destination operand is cleared to all 0s.\nEVEX encoded versions: The low quadword of the destination is updated according to the writemask.\nNote: For VMOVSD (memory store and load forms), VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instruction will #UD.",
    "operationText": "IF k1[0] or *no writemask*\n    THEN DEST[63:0] := SRC[63:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n        FI;\nFI;\nDEST[MAXVL-1:64] := 0\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := SRC[63:0]\n    ELSE *DEST[63:0] remains unchanged* ; merging-masking\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := SRC2[63:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] (Unmodified)\nDEST[63:0] := SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] := 0\nDEST[63:0] := SRC[63:0]\nDEST[63:0] := SRC[63:0]\nDEST[127:64] := 0\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-58, “Type E10 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/bts",
    "category": "Core Instructions",
    "instructionName": "BTS\n\t\t— Bit Test and Set",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and set.",
        "Instruction": "BTS r/m16, r16",
        "Op/En": "MR",
        "Opcode": "0F AB /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and set.",
        "Instruction": "BTS r/m32, r32",
        "Op/En": "MR",
        "Opcode": "0F AB /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store selected bit in CF flag and set.",
        "Instruction": "BTS r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 0F AB /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and set.",
        "Instruction": "BTS r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "0F BA /5 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store selected bit in CF flag and set.",
        "Instruction": "BTS r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "0F BA /5 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store selected bit in CF flag and set.",
        "Instruction": "BTS r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 0F BA /5 ib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:\nSee also: Bit(BitBase, BitOffset) on page 3-11.\nSome assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See “BT—Bit Test” in this chapter for more information on this addressing mechanism.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "CF := Bit(BitBase, BitOffset);\nBit(BitBase, BitOffset) := 1;",
    "flagsAffectedText": "The CF flag contains the value of the selected bit before it is set. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used but the destination is not a memory operand.; column_1: #UD;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sexit",
    "category": "SMX Instructions",
    "instructionName": "GETSEC[SEXIT]\n\t\t— Exit Measured Environment",
    "detailsTable": [
      {
        "Description": "Exit measured environment.",
        "Instruction": "GETSEC[SEXIT]",
        "Opcode": "NP 0F 37 (EAX=5)"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The GETSEC[SEXIT] instruction initiates an exit of a measured environment established by GETSEC[SENTER]. The SEXIT leaf of GETSEC is selected with EAX set to 5 at execution. This instruction leaf sends a message to all logical processors in the platform to signal the measured environment exit.\nThere are restrictions enforced by the processor for the execution of the GETSEC[SEXIT] instruction:\nFailure to abide by the above conditions results in the processor signaling a general protection violation.\nThis instruction initiates a sequence to rendezvous the RLPs with the ILP. It then clears the internal processor flag indicating the processor is operating in a measured environment.\nIn response to a message signaling the completion of rendezvous, all RLPs restart execution with the instruction that was to be executed at the time GETSEC[SEXIT] was recognized. This applies to all processor conditions, with the following exceptions:\nPrior to completion of the GETSEC[SEXIT] operation, both the ILP and any active RLPs unmask the response of the external event signals INIT#, A20M, NMI#, and SMI#. This unmasking is performed unconditionally to recognize pin events which are masked after a GETSEC[SENTER]. The state of A20M is unmasked, as the A20M pin is not recognized while the measured environment is active.\nOn a successful exit of the measured environment, the ILP re-locks the Intel® TXT-capable chipset private configuration space. GETSEC[SEXIT] does not affect the content of any PCR.\nAt completion of GETSEC[SEXIT] by the ILP, execution proceeds to the next instruction. Since EFLAGS and the debug register state are not modified by this instruction, a pending trap condition is free to be signaled if previously enabled.",
    "operationText": "",
    "flagsAffectedText": "ILP: None.\nRLPs: All flags are modified for an RLP. returning to wait-for-SIPI state, none otherwise.",
    "exceptions": {
      "64BitMode": [
        "All protected mode exceptions apply."
      ],
      "compatibilityMode": [
        "All protected mode exceptions apply."
      ],
      "protectedMode": [
        "column_1: If GETSEC[SEXIT] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: If CR0.PE = 0 or CPL > 0 or EFLAGS.VM = 1.; \ncolumn_1: If in VMX root operation.; \ncolumn_1: If the initiating processor is not designated via the MSR bit IA32_APIC_BASE.BSP.; \ncolumn_1: If an Intel® TXT-capable chipset is not present.; \ncolumn_1: If a protected partition is not already active or the processor is already in authenticated code mode.; \ncolumn_1: If the processor is in SMM.;"
      ],
      "realAddressMode": [
        "column_1: If GETSEC[SEXIT] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[SEXIT] is not recognized in real-address mode.;"
      ],
      "virtual8086Mode": [
        "column_1: If GETSEC[SEXIT] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[SEXIT] is not recognized in virtual-8086 mode.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/phaddsw",
    "category": "Core Instructions",
    "instructionName": "PHADDSW\n\t\t— Packed Horizontal Add and Saturate",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Add 16-bit signed integers horizontally, pack saturated integers to mm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 03 /r1 PHADDSW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Add 16-bit signed integers horizontally, pack saturated integers to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 03 /r PHADDSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add 16-bit signed integers horizontally, pack saturated integers to xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 03 /r VPHADDSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add 16-bit signed integers horizontally, pack saturated integers to ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 03 /r VPHADDSW ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand) When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nIn 64-bit mode, use the REX prefix to access additional registers.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
    "operationText": "mm1[15-0] = SaturateToSignedWord((mm1[31-16] + mm1[15-0]);\nmm1[31-16] = SaturateToSignedWord(mm1[63-48] + mm1[47-32]);\nmm1[47-32] = SaturateToSignedWord(mm2/m64[31-16] + mm2/m64[15-0]);\nmm1[63-48] = SaturateToSignedWord(mm2/m64[63-48] + mm2/m64[47-32]);\nxmm1[15-0]= SaturateToSignedWord(xmm1[31-16] + xmm1[15-0]);\nxmm1[31-16] = SaturateToSignedWord(xmm1[63-48] + xmm1[47-32]);\nxmm1[47-32] = SaturateToSignedWord(xmm1[95-80] + xmm1[79-64]);\nxmm1[63-48] = SaturateToSignedWord(xmm1[127-112] + xmm1[111-96]);\nxmm1[79-64] = SaturateToSignedWord(xmm2/m128[31-16] + xmm2/m128[15-0]);\nxmm1[95-80] = SaturateToSignedWord(xmm2/m128[63-48] + xmm2/m128[47-32]);\nxmm1[111-96] = SaturateToSignedWord(xmm2/m128[95-80] + xmm2/m128[79-64]);\nxmm1[127-112] = SaturateToSignedWord(xmm2/m128[127-112] + xmm2/m128[111-96]);\nDEST[15:0]= SaturateToSignedWord(SRC1[31:16] + SRC1[15:0])\nDEST[31:16] = SaturateToSignedWord(SRC1[63:48] + SRC1[47:32])\nDEST[47:32] = SaturateToSignedWord(SRC1[95:80] + SRC1[79:64])\nDEST[63:48] = SaturateToSignedWord(SRC1[127:112] + SRC1[111:96])\nDEST[79:64] = SaturateToSignedWord(SRC2[31:16] + SRC2[15:0])\nDEST[95:80] = SaturateToSignedWord(SRC2[63:48] + SRC2[47:32])\nDEST[111:96] = SaturateToSignedWord(SRC2[95:80] + SRC2[79:64])\nDEST[127:112] = SaturateToSignedWord(SRC2[127:112] + SRC2[111:96])\nDEST[MAXVL-1:128] := 0\nDEST[15:0]= SaturateToSignedWord(SRC1[31:16] + SRC1[15:0])\nDEST[31:16] = SaturateToSignedWord(SRC1[63:48] + SRC1[47:32])\nDEST[47:32] = SaturateToSignedWord(SRC1[95:80] + SRC1[79:64])\nDEST[63:48] = SaturateToSignedWord(SRC1[127:112] + SRC1[111:96])\nDEST[79:64] = SaturateToSignedWord(SRC2[31:16] + SRC2[15:0])\nDEST[95:80] = SaturateToSignedWord(SRC2[63:48] + SRC2[47:32])\nDEST[111:96] = SaturateToSignedWord(SRC2[95:80] + SRC2[79:64])\nDEST[127:112] = SaturateToSignedWord(SRC2[127:112] + SRC2[111:96])\nDEST[143:128]= SaturateToSignedWord(SRC1[159:144] + SRC1[143:128])\nDEST[159:144] = SaturateToSignedWord(SRC1[191:176] + SRC1[175:160])\nDEST[175:160] = SaturateToSignedWord( SRC1[223:208] + SRC1[207:192])\nDEST[191:176] = SaturateToSignedWord(SRC1[255:240] + SRC1[239:224])\nDEST[207:192] = SaturateToSignedWord(SRC2[127:112] + SRC2[143:128])\nDEST[223:208] = SaturateToSignedWord(SRC2[159:144] + SRC2[175:160])\nDEST[239:224] = SaturateToSignedWord(SRC2[191-160] + SRC2[159-128])\nDEST[255:240] = SaturateToSignedWord(SRC2[255:240] + SRC2[239:224])",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ucomiss",
    "category": "Core Instructions",
    "instructionName": "UCOMISS\n\t\t— Unordered Compare Scalar Single Precision Floating-Point Values and Set EFLAGS",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 2E /r UCOMISS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.0F.WIG 2E /r VUCOMISS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.0F.W0 2E /r VUCOMISS xmm1, xmm2/m32{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the single precision floating-point values in the low doublewords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).\nOperand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.\nThe UCOMISS instruction differs from the COMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) only if a source operand is an SNaN. The COMISS instruction signals an invalid operation exception when a source operand is either a QNaN or SNaN.\nThe EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "RESULT := UnorderedCompare(DEST[31:0] <> SRC[31:0]) {\n(* Set EFLAGS *) CASE (RESULT) OF\n    UNORDERED: ZF,PF,CF := 111;\n    GREATER_THAN: ZF,PF,CF := 000;\n    LESS_THAN: ZF,PF,CF := 001;\n    EQUAL: ZF,PF,CF := 100;\nESAC;\nOF, AF, SF := 0; }",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (if SNaN Operands), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/epa",
    "category": "SGX Instructions",
    "instructionName": "EPA\n\t\t— Add Version Array",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function adds a Version Array to the EPC.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 0AH ENCLS[EPA]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EPA (In)",
        "column_3": "PT_VA (In, Constant)",
        "column_4": "Effective address of the EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtsd2ss",
    "category": "Core Instructions",
    "instructionName": "CVTSD2SS\n\t\t— Convert Scalar Double Precision Floating-Point Value to Scalar Single PrecisionFloating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert one double precision floating-point value in xmm2/m64 to one single precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 5A /r CVTSD2SS xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one double precision floating-point value in xmm3/m64 to one single precision floating-point value and merge with high bits in xmm2.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 5A /r VCVTSD2SS xmm1,xmm2, xmm3/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value in xmm3/m64 to one single precision floating-point value and merge with high bits in xmm2 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 5A /r VCVTSD2SS xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Converts a double precision floating-point value in the “convert-from” source operand (the second operand in SSE2 version, otherwise the third operand) to a single precision floating-point value in the destination operand.\nWhen the “convert-from” operand is an XMM register, the double precision floating-point value is contained in the low quadword of the register. The result is stored in the low doubleword of the destination operand. When the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\n128-bit Legacy SSE version: The “convert-from” source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged. The destination operand is an XMM register.\nVEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: the converted result in written to the low doubleword element of the destination under the writemask.\nSoftware should ensure VCVTSD2SS is encoded with VEX.L=0. Encoding VCVTSD2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (SRC2 *is register*) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC2[63:0]);\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC2[63:0]);\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63:0]);\n(* DEST[MAXVL-1:32] Unmodified *)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/senter",
    "category": "SMX Instructions",
    "instructionName": "GETSEC[SENTER]\n\t\t— Enter a Measured Environment",
    "detailsTable": [
      {
        "Description": "Launch a measured environment. EBX holds the SINIT authenticated code module physical base address. ECX holds the SINIT authenticated code module size (bytes). EDX controls the level of functionality supported by the measured environment launch.",
        "Instruction": "GETSEC[SENTER]",
        "Opcode": "NP 0F 37 (EAX=4)"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The GETSEC[SENTER] instruction initiates the launch of a measured environment and places the initiating logical processor (ILP) into the authenticated code execution mode. The SENTER leaf of GETSEC is selected with EAX set to 4 at execution. The physical base address of the AC module to be loaded and authenticated is specified in EBX. The size of the module in bytes is specified in ECX. EDX controls the level of functionality supported by the measured environment launch. To enable the full functionality of the protected environment launch, EDX must be initialized to zero.\nThe authenticated code base address and size parameters (in bytes) are passed to the GETSEC[SENTER] instruction using EBX and ECX respectively. The ILP evaluates the contents of these registers according to the rules for the AC module address in GETSEC[ENTERACCS]. AC module execution follows the same rules, as set by GETSEC[ENTERACCS].\nThe launching software must ensure that the TPM.ACCESS_0.activeLocality bit is clear before executing the GETSEC[SENTER] instruction.\nThere are restrictions enforced by the processor for execution of the GETSEC[SENTER] instruction:\nFailure to abide by the above conditions results in the processor signaling a general protection violation.\nThis instruction leaf starts the launch of a measured environment by initiating a rendezvous sequence for all logical processors in the platform. The rendezvous sequence involves the initiating logical processor sending a message (by executing GETSEC[SENTER]) and other responding logical processors (RLPs) acknowledging the message, thus synchronizing the RLP(s) with the ILP.\nIn response to a message signaling the completion of rendezvous, RLPs clear the bootstrap processor indicator flag (IA32_APIC_BASE.BSP) and enter an SENTER sleep state. In this sleep state, RLPs enter an idle processor condition while waiting to be activated after a measured environment has been established by the system executive. RLPs in the SENTER sleep state can only be activated by the GETSEC leaf function WAKEUP in a measured environment.\nA successful launch of the measured environment results in the initiating logical processor entering the authenticated code execution mode. Prior to reaching this point, the ILP performs the following steps internally:\nAs an integrity check for proper processor hardware operation, execution of GETSEC[SENTER] will also check the contents of all the machine check status registers (as reported by the MSRs IA32_MCi_STATUS) for any valid uncorrectable error condition. In addition, the global machine check status register IA32_MCG_STATUS MCIP bit must be cleared and the IERR processor package pin (or its equivalent) must be not asserted, indicating that no machine check exception processing is currently in-progress. These checks are performed twice: once by the ILP prior to the broadcast of the rendezvous message to RLPs, and later in response to RLPs acknowledging the rendezvous message. Any outstanding valid uncorrectable machine check error condition present in the machine check status registers at the first check point will result in the ILP signaling a general protection violation. If an outstanding valid uncorrectable machine check error condition is present at the second check point, then this will result in the corresponding logical processor signaling the more severe TXT-shutdown condition with an error code of 12.\nBefore loading and authentication of the target code module is performed, the processor also checks that the current voltage and bus ratio encodings correspond to known good values supportable by the processor. The MSR IA32_PERF_STATUS values are compared against either the processor supported maximum operating target setting, system reset setting, or the thermal monitor operating target. If the current settings do not meet any of these criteria then the SENTER function will attempt to change the voltage and bus ratio select controls in a processor-specific manner. This adjustment may be to the thermal monitor, minimum (if different), or maximum operating target depending on the processor.\nThis implies that some thermal operating target parameters configured by BIOS may be overridden by SENTER. The measured environment software may need to take responsibility for restoring such settings that are deemed to be safe, but not necessarily recognized by SENTER. If an adjustment is not possible when an out of range setting is discovered, then the processor will abort the measured launch. This may be the case for chipset controlled settings of these values or if the controllability is not enabled on the processor. In this case it is the responsibility of the external software to program the chipset voltage ID and/or bus ratio select settings to known good values recognized by the processor, prior to executing SENTER.\nThe ILP and RLPs mask the response to the assertion of the external signals INIT#, A20M, NMI#, and SMI#. The purpose of this masking control is to prevent exposure to existing external event handlers until a protected handler has been put in place to directly handle these events. Masked external pin events may be unmasked conditionally or unconditionally via the GETSEC[EXITAC], GETSEC[SEXIT], GETSEC[SMCTRL] or for specific VMX related operations such as a VM entry or the VMXOFF instruction (see respective GETSEC leaves and Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more details). The state of the A20M pin is masked and forced internally to a de-asserted state so that external assertion is not recognized. A20M masking as set by\nGETSEC[SENTER] is undone only after taking down the measured environment with the GETSEC[SEXIT] instruction or processor reset. INTR is masked by simply clearing the EFLAGS.IF bit. It is the responsibility of system software to control the processor response to INTR through appropriate management of EFLAGS.\nTo prevent other (logical) processors from interfering with the ILP operating in authenticated code execution mode, memory (excluding implicit write-back transactions) and I/O activities originating from other processor agents are blocked. This protection starts when the ILP enters into authenticated code execution mode. Only memory and I/O transactions initiated from the ILP are allowed to proceed. Exiting authenticated code execution mode is done by executing GETSEC[EXITAC]. The protection of memory and I/O activities remains in effect until the ILP executes GETSEC[EXITAC].\nOnce the authenticated code module has been loaded into the authenticated code execution area, it is protected against further modification from external bus snoops. There is also a requirement that the memory type for the authenticated code module address range be WB (via initialization of the MTRRs prior to execution of this instruction). If this condition is not satisfied, it is a violation of security and the processor will force a TXT system reset (after writing an error code to the chipset LT.ERRORCODE register). This action is referred to as a Intel® TXT reset condition. It is performed when it is considered unreliable to signal an error through the conventional exception reporting mechanism.\nTo conform to the minimum granularity of MTRR MSRs for specifying the memory type, authenticated code RAM (ACRAM) is allocated to the processor in 4096 byte granular blocks. If an AC module size as specified in ECX is not a multiple of 4096 then the processor will allocate up to the next 4096 byte boundary for mapping as ACRAM with indeterminate data. This pad area will not be visible to the authenticated code module as external memory nor can it depend on the value of the data used to fill the pad area.\nOnce successful authentication has been completed by the ILP, the computed hash is stored in a trusted storage facility in the platform. The following trusted storage facility are supported:\nAfter successful execution of SENTER, either PCR17 (if FTM is not enabled) or the FTM (if enabled) contains the measurement of AC code and the SENTER launching parameters.\nAfter authentication is completed successfully, the private configuration space of the Intel® TXT-capable chipset is unlocked so that the authenticated code module and measured environment software can gain access to this normally restricted chipset state. The Intel® TXT-capable chipset private configuration space can be locked later by software writing to the chipset LT.CMD.CLOSE-PRIVATE register or unconditionally using the GETSEC[SEXIT] instruction.\nThe SENTER leaf function also initializes some processor architecture state for the ILP from contents held in the header of the authenticated code module. Since the authenticated code module is relocatable, all address references are relative to the base address passed in via EBX. The ILP GDTR base value is initialized to EBX + [GDTBasePtr] and GDTR limit set to [GDTLimit]. The CS selector is initialized to the value held in the AC module header field SegSel, while the DS, SS, and ES selectors are initialized to CS+8. The segment descriptor fields are initialized implicitly with BASE=0, LIMIT=FFFFFh, G=1, D=1, P=1, S=1, read/write/accessed for DS, SS, and ES, while execute/read/accessed for CS. Execution in the authenticated code module for the ILP begins with the EIP set to EBX + [EntryPoint]. AC module defined fields used for initializing processor state are consistency checked with a failure resulting in an TXT-shutdown condition.\nTable 7-6 provides a summary of processor state initialization for the ILP and RLP(s) after successful completion of GETSEC[SENTER]. For both ILP and RLP(s), paging is disabled upon entry to the measured environment. It is up to the ILP to establish a trusted paging environment, with appropriate mappings, to meet protection requirements established during the launch of the measured environment. RLP state initialization is not completed until a subsequent wake-up has been signaled by execution of the GETSEC[WAKEUP] function by the ILP.\nmust be reestablished with a valid machine check exception handler to otherwise avoid an TXT-shutdown under such conditions.\nThe MSR IA32_EFER is also unconditionally cleared as part of the processor state initialized by SENTER for both the ILP and RLP. Since paging is disabled upon entering authenticated code execution mode, a new paging environment will have to be re-established if it is desired to enable IA-32e mode while operating in authenticated code execution mode.\nThe miscellaneous feature control MSR, IA32_MISC_ENABLE, is initialized as part of the measured environment launch. Certain bits of this MSR are preserved because preserving these bits may be important to maintain previously established platform settings. See the footnote for Table 7-5 The remaining bits are cleared for the purpose of establishing a more consistent environment for the execution of authenticated code modules. Among the impact of initializing this MSR, any previous condition established by the MONITOR instruction will be cleared.\nEffect of MSR IA32_FEATURE_CONTROL MSR\nBits 15:8 of the IA32_FEATURE_CONTROL MSR affect the execution of GETSEC[SENTER]. These bits consist of two fields:\nThe layout of these fields in the IA32_FEATURE_CONTROL MSR is shown in Table 7-1.\nPrior to the execution of GETSEC[SENTER], the lock bit of IA32_FEATURE_CONTROL MSR must be bit set to affirm the settings to be used. Once the lock bit is set, only a power-up reset condition will clear this MSR. The IA32_FEA-TURE_CONTROL MSR must be configured in accordance to the intended usage at platform initialization. Note that this MSR is only available on SMX or VMX enabled processors. Otherwise, IA32_FEATURE_CONTROL is treated as reserved.\nThe Intel® Trusted Execution Technology Measured Launched Environment Programming Guide provides additional details and requirements for programming measured environment software to launch in an Intel TXT platform.",
    "operationText": "",
    "flagsAffectedText": "All flags are cleared.",
    "exceptions": {
      "64BitMode": [
        "All protected mode exceptions apply.",
        ""
      ],
      "compatibilityMode": [
        "All protected mode exceptions apply.",
        ""
      ],
      "protectedMode": [
        "column_1: If GETSEC[SENTER] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_2: IfCR0.CD=1orCR0.NW=1orCR0.NE=0orCR0.PE=0orCPL>0orEFLAGS.VM=1.; column_1: #GP(0); \ncolumn_1: If in VMX root operation.; \ncolumn_1: If the initiating processor is not designated as the bootstrap processor via the MSR bit IA32_APIC_BASE.BSP.; \ncolumn_1: If an Intel® TXT-capable chipset is not present.; \ncolumn_1: If an Intel® TXT-capable chipset interface to TPM is not detected as present.; \ncolumn_1: If a protected partition is already active or the processor is already in authenticated code mode.; \ncolumn_1: If the processor is in SMM.; \ncolumn_1: If a valid uncorrectable machine check error is logged in IA32_MC[I]_STATUS.; \ncolumn_1: If the authenticated code base is not on a 4096 byte boundary.; \ncolumn_1: If the authenticated code size > processor's authenticated code execution area storage capacity.; \ncolumn_1: If the authenticated code size is not modulo 64.;"
      ],
      "realAddressMode": [
        "column_1: If GETSEC[SENTER] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[SENTER] is not recognized in real-address mode.;"
      ],
      "virtual8086Mode": [
        "column_1: If GETSEC[SENTER] is not reported as supported by GETSEC[CAPABILITIES].; \ncolumn_1: #GP(0); column_2: GETSEC[SENTER] is not recognized in virtual-8086 mode.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmovqd:vpmovsqd:vpmovusqd",
    "category": "Core Instructions",
    "instructionName": "VPMOVQD/VPMOVSQD/VPMOVUSQD\n\t\t— Down Convert QWord to DWord",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 2 packed quad-word integers from xmm2 into 2 packed double-word integers in xmm1/m128 with truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 35 /r VPMOVQD xmm1/m128 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed double-word integers in xmm1/m64 using signed saturation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 25 /r VPMOVSQD xmm1/m64 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned double-word integers in xmm1/m64 using unsigned saturation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 15 /r VPMOVUSQD xmm1/m64 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed quad-word integers from ymm2 into 4 packed double-word integers in xmm1/m128 with truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 35 /r VPMOVQD xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed double-word integers in xmm1/m128 using signed saturation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 25 /r VPMOVSQD xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned double-word integers in xmm1/m128 using unsigned saturation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 15 /r VPMOVUSQD xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed quad-word integers from zmm2 into 8 packed double-word integers in ymm1/m256 with truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 35 /r VPMOVQD ymm1/m256 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed double-word integers in ymm1/m256 using signed saturation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 25 /r VPMOVSQD ymm1/m256 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned double-word integers in ymm1/m256 using unsigned saturation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 15 /r VPMOVUSQD ymm1/m256 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmovqw:vpmovsqw:vpmovusqw",
    "category": "Core Instructions",
    "instructionName": "VPMOVQW/VPMOVSQW/VPMOVUSQW\n\t\t— Down Convert QWord to Word",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 2 packed quad-word integers from xmm2 into 2 packed word integers in xmm1/m32 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 34 /r VPMOVQW xmm1/m32 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m32 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 24 /r VPMOVSQW xmm1/m32 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned word integers in xmm1/m32 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 14 /r VPMOVUSQW xmm1/m32 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed quad-word integers from ymm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 34 /r VPMOVQW xmm1/m64 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed word integers in xmm1/m64 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 24 /r VPMOVSQW xmm1/m64 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 14 /r VPMOVUSQW xmm1/m64 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed quad-word integers from zmm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 34 /r VPMOVQW xmm1/m128 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 24 /r VPMOVSQW xmm1/m128 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 14 /r VPMOVUSQW xmm1/m128 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Quarter Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vsubph",
    "category": "Core Instructions",
    "instructionName": "VSUBPH\n\t\t— Subtract Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Subtract packed FP16 values from xmm3/m128/m16bcst to xmm2, and store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 5C /r VSUBPH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Subtract packed FP16 values from ymm3/m256/m16bcst to ymm2, and store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 5C /r VSUBPH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Subtract packed FP16 values from zmm3/m512/m16bcst to zmm2, and store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 5C /r VSUBPH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/psadbw",
    "category": "Core Instructions",
    "instructionName": "PSADBW\n\t\t— Compute Sum of Absolute Differences",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F F6 /r1 PSADBW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F F6 /r PSADBW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG F6 /r VPSADBW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG F6 /r VPSADBW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; then each consecutive 8 differences are summed separately to produce two unsigned word integer results.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG F6 /r VPSADBW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG F6 /r VPSADBW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Computes the absolute differences of the packed unsigned byte integers from zmm3 /m512 and zmm2; then each consecutive 8 differences are summed separately to produce eight unsigned word integer results.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG F6 /r VPSADBW zmm1, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second operand) and from the destination operand (first operand). These 8 differences are then summed to produce an unsigned word integer result that is stored in the destination operand. Figure 4-14 shows the operation of the PSADBW instruction when using 64-bit operands.\nWhen operating on 64-bit operands, the word integer result is stored in the low word of the destination operand, and the remaining bytes in the destination operand are cleared to all 0s.\nWhen operating on 128-bit operands, two packed results are computed. Here, the 8 low-order bytes of the source and destination operands are operated on to produce a word result that is stored in the low word of the destination operand, and the 8 high-order bytes are operated on to produce a word result that is stored in bits 64 through 79 of the destination operand. The remaining bytes of the destination operand are cleared.\nFor 256-bit version, the third group of 8 differences are summed to produce an unsigned word in bits[143:128] of the destination register and the fourth group of 8 differences are summed to produce an unsigned word in bits[207:192] of the destination register. The remaining words of the destination are set to 0.\nFor 512-bit version, the fifth group result is stored in bits [271:256] of the destination. The result from the sixth group is stored in bits [335:320]. The results for the seventh and eighth group are stored respectively in bits [399:384] and bits [463:447], respectively. The remaining bits in the destination are set to 0.\nIn 64-bit mode and not encoded by VEX/EVEX prefix, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.\nVEX.128 and EVEX.128 encoded versions: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\nVEX.256 and EVEX.256 encoded versions: The first source operand and destination register are YMM registers. The second source operand is an YMM register or a 256-bit memory location. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX.512 encoded version: The first source operand and destination register are ZMM registers. The second source operand is a ZMM register or a 512-bit memory location.",
    "operationText": "VL = 128, 256, 512\nTEMP0 := ABS(SRC1[7:0] - SRC2[7:0])\n(* Repeat operation for bytes 1 through 15 *)\nTEMP15 := ABS(SRC1[127:120] - SRC2[127:120])\nDEST[15:0] := SUM(TEMP0:TEMP7)\nDEST[63:16] := 000000000000H\nDEST[79:64] := SUM(TEMP8:TEMP15)\nDEST[127:80] := 00000000000H\nIF VL >= 256\n    (* Repeat operation for bytes 16 through 31*)\n    TEMP31 := ABS(SRC1[255:248] - SRC2[255:248])\n    DEST[143:128] := SUM(TEMP16:TEMP23)\n    DEST[191:144] := 000000000000H\n    DEST[207:192] := SUM(TEMP24:TEMP31)\n    DEST[223:208] := 00000000000H\nFI;\nIF VL >= 512\n(* Repeat operation for bytes 32 through 63*)\n    TEMP63 := ABS(SRC1[511:504] - SRC2[511:504])\n    DEST[271:256] := SUM(TEMP0:TEMP7)\n    DEST[319:272] := 000000000000H\n    DEST[335:320] := SUM(TEMP8:TEMP15)\n    DEST[383:336] := 00000000000H\n    DEST[399:384] := SUM(TEMP16:TEMP23)\n    DEST[447:400] := 000000000000H\n    DEST[463:448] := SUM(TEMP24:TEMP31)\n    DEST[511:464] := 00000000000H\nFI;\nDEST[MAXVL-1:VL] := 0\nTEMP0 := ABS(SRC1[7:0] - SRC2[7:0])\n(* Repeat operation for bytes 2 through 30*)\nTEMP31 := ABS(SRC1[255:248] - SRC2[255:248])\nDEST[15:0] := SUM(TEMP0:TEMP7)\nDEST[63:16] := 000000000000H\nDEST[79:64] := SUM(TEMP8:TEMP15)\nDEST[127:80] := 00000000000H\nDEST[143:128] := SUM(TEMP16:TEMP23)\nDEST[191:144] := 000000000000H\nDEST[207:192] := SUM(TEMP24:TEMP31)\nDEST[223:208] := 00000000000H\nDEST[MAXVL-1:256] := 0\nTEMP0 := ABS(SRC1[7:0] - SRC2[7:0])\n(* Repeat operation for bytes 2 through 14 *)\nTEMP15 := ABS(SRC1[127:120] - SRC2[127:120])\nDEST[15:0] := SUM(TEMP0:TEMP7)\nDEST[63:16] := 000000000000H\nDEST[79:64] := SUM(TEMP8:TEMP15)\nDEST[127:80] := 00000000000H\nDEST[MAXVL-1:128] := 0\nTEMP0 := ABS(DEST[7:0] - SRC[7:0])\n(* Repeat operation for bytes 2 through 14 *)\nTEMP15 := ABS(DEST[127:120] - SRC[127:120])\nDEST[15:0] := SUM(TEMP0:TEMP7)\nDEST[63:16] := 000000000000H\nDEST[79:64] := SUM(TEMP8:TEMP15)\nDEST[127:80] := 00000000000\nDEST[MAXVL-1:128] (Unmodified)\nTEMP0 := ABS(DEST[7:0] - SRC[7:0])\n(* Repeat operation for bytes 2 through 6 *)\nTEMP7 := ABS(DEST[63:56] - SRC[63:56])\nDEST[15:0] := SUM(TEMP0:TEMP7)\nDEST[63:16] := 000000000000H",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/eresume",
    "category": "SGX Instructions",
    "instructionName": "ERESUME\n\t\t— Re-Enters an Enclave",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function is used to re-enter an enclave after an interrupt.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 03H ENCLU[ERESUME]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "ERESUME (In)",
        "column_3": "Address of a TCS (In)",
        "column_4": "Address of AEP (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/haddps",
    "category": "Core Instructions",
    "instructionName": "HADDPS\n\t\t— Packed Single Precision Floating-Point Horizontal Add",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Horizontal add packed single precision floating-point values from xmm2/m128 to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 7C /r HADDPS xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Horizontal add packed single precision floating-point values from xmm2 and xmm3/mem.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.F2.0F.WIG 7C /r VHADDPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Horizontal add packed single precision floating-point values from ymm2 and ymm3/mem.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.F2.0F.WIG 7C /r VHADDPS ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adds the single precision floating-point values in the first and second dwords of the destination operand and stores the result in the first dword of the destination operand.\nAdds single precision floating-point values in the third and fourth dword of the destination operand and stores the result in the second dword of the destination operand.\nAdds single precision floating-point values in the first and second dword of the source operand and stores the result in the third dword of the destination operand.\nAdds single precision floating-point values in the third and fourth dword of the source operand and stores the result in the fourth dword of the destination operand.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nSee Figure 3-19 for HADDPS; see Figure 3-20 for VHADDPS.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "DEST[31:0] := SRC1[63:32] + SRC1[31:0]\nDEST[63:32] := SRC1[127:96] + SRC1[95:64]\nDEST[95:64] := SRC2[63:32] + SRC2[31:0]\nDEST[127:96] := SRC2[127:96] + SRC2[95:64]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := SRC1[63:32] + SRC1[31:0]\nDEST[63:32] := SRC1[127:96] + SRC1[95:64]\nDEST[95:64] := SRC2[63:32] + SRC2[31:0]\nDEST[127:96] := SRC2[127:96] + SRC2[95:64]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[63:32] + SRC1[31:0]\nDEST[63:32] := SRC1[127:96] + SRC1[95:64]\nDEST[95:64] := SRC2[63:32] + SRC2[31:0]\nDEST[127:96] := SRC2[127:96] + SRC2[95:64]\nDEST[159:128] := SRC1[191:160] + SRC1[159:128]\nDEST[191:160] := SRC1[255:224] + SRC1[223:192]\nDEST[223:192] := SRC2[191:160] + SRC2[159:128]\nDEST[255:224] := SRC2[255:224] + SRC2[223:192]",
    "flagsAffectedText": "",
    "exceptions": {
      "exceptions¶": [
        "When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."
      ],
      "numeric¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ],
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdpkru",
    "category": "Core Instructions",
    "instructionName": "RDPKRU\n\t\t— Read Protection Key Rights for User Pages",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "OSPKE",
        "Description": "Reads PKRU into EAX.",
        "Instruction": "RDPKRU",
        "Op/En": "ZO",
        "Opcode*": "NP 0F 01 EE"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Reads the value of PKRU into EAX and clears EDX. ECX must be 0 when RDPKRU is executed; otherwise, a general-protection exception (#GP) occurs.\nRDPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].\nOn processors that support the Intel 64 Architecture, the high-order 32-bits of RCX are ignored and the high-order 32-bits of RDX and RAX are cleared.",
    "operationText": "IF (ECX = 0)\n    THEN\n        EAX := PKRU;\n        EDX := 0;\n    ELSE #GP(0);\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If CR4.PKE = 0.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vreducess",
    "category": "Core Instructions",
    "instructionName": "VREDUCESS\n\t\t— Perform a Reduction Transformation on a Scalar Float32 Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Perform a reduction transformation on a scalar single-precision floating-point value in xmm3/m32 by subtracting a number of fraction bits specified by the imm8 field. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]. Stores the result in xmm1 register.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W0 57 /r /ib VREDUCESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetmantsd",
    "category": "Core Instructions",
    "instructionName": "VGETMANTSD\n\t\t— Extract Float64 of Normalized Mantissa From Float64 Scalar",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Extract the normalized mantissa of the low float64 element in xmm3/m64 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W1 27 /r ib VGETMANTSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/blendps",
    "category": "Core Instructions",
    "instructionName": "BLENDPS\n\t\t— Blend Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A 0C /r ib BLENDPS xmm1, xmm2/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Select packed single precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 0C /r ib VBLENDPS xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Select packed single precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.256.66.0F3A.WIG 0C /r ib VBLENDPS ymm1, ymm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Packed single precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is “1”, then the single precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "IF (IMM8[0] = 0) THEN DEST[31:0] :=DEST[31:0]\n    ELSE DEST [31:0] := SRC[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] := DEST[63:32]\n    ELSE DEST [63:32] := SRC[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] := DEST[95:64]\n    ELSE DEST [95:64] := SRC[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] := DEST[127:96]\n    ELSE DEST [127:96] := SRC[127:96] FI\nDEST[MAXVL-1:128] (Unmodified)\nIF (IMM8[0] = 0) THEN DEST[31:0] :=SRC1[31:0]\n    ELSE DEST [31:0] := SRC2[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] := SRC1[63:32]\n    ELSE DEST [63:32] := SRC2[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] := SRC1[95:64]\n    ELSE DEST [95:64] := SRC2[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] := SRC1[127:96]\n    ELSE DEST [127:96] := SRC2[127:96] FI\nDEST[MAXVL-1:128] := 0\nIF (IMM8[0] = 0) THEN DEST[31:0] :=SRC1[31:0]\n    ELSE DEST [31:0] := SRC2[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] := SRC1[63:32]\n    ELSE DEST [63:32] := SRC2[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] := SRC1[95:64]\n    ELSE DEST [95:64] := SRC2[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] := SRC1[127:96]\n    ELSE DEST [127:96] := SRC2[127:96] FI\nIF (IMM8[4] = 0) THEN DEST[159:128] := SRC1[159:128]\n    ELSE DEST [159:128] := SRC2[159:128] FI\nIF (IMM8[5] = 0) THEN DEST[191:160] := SRC1[191:160]\n    ELSE DEST [191:160] := SRC2[191:160] FI\nIF (IMM8[6] = 0) THEN DEST[223:192] := SRC1[223:192]\n    ELSE DEST [223:192] := SRC2[223:192] FI\nIF (IMM8[7] = 0) THEN DEST[255:224] := SRC1[255:224]\n    ELSE DEST [255:224] := SRC2[255:224] FI.",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/dec",
    "category": "Core Instructions",
    "instructionName": "DEC\n\t\t— Decrement by 1",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Decrement r/m8 by 1.",
        "Instruction": "DEC r/m8",
        "Op/En": "M",
        "Opcode": "FE /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Decrement r/m8 by 1.",
        "Instruction": "DEC r/m8*",
        "Op/En": "M",
        "Opcode": "REX + FE /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Decrement r/m16 by 1.",
        "Instruction": "DEC r/m16",
        "Op/En": "M",
        "Opcode": "FF /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Decrement r/m32 by 1.",
        "Instruction": "DEC r/m32",
        "Op/En": "M",
        "Opcode": "FF /1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Decrement r/m64 by 1.",
        "Instruction": "DEC r/m64",
        "Op/En": "M",
        "Opcode": "REX.W + FF /1"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Decrement r16 by 1.",
        "Instruction": "DEC r16",
        "Op/En": "O",
        "Opcode": "48+rw"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Decrement r32 by 1.",
        "Instruction": "DEC r32",
        "Op/En": "O",
        "Opcode": "48+rd"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "O",
        "Operand 1": "opcode + rd (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.\nSee the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := DEST – 1;",
    "flagsAffectedText": "The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used but the destination is not a memory operand.; column_1: #UD;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pcmpestri",
    "category": "Core Instructions",
    "instructionName": "PCMPESTRI\n\t\t— Packed Compare Explicit Length Strings, Return Index",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_2",
        "Description": "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A 61 /r imm8 PCMPESTRI xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.",
        "Op/En": "RMI",
        "Opcode/Instruction": "VEX.128.66.0F3A 61 /r ib VPCMPESTRI xmm1, xmm2/m128, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction compares and processes data from two string fragments based on the encoded value in the imm8 control byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to the count register (ECX).\nEach string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.\nThe length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).\nThe comparison and aggregation operations are performed according to the encoded value of imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 (see Section 4.1.4) is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).\nNote that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:\nCFlag – Reset if IntRes2 is equal to zero, set otherwise\nZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise\nSFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise\nOFlag – IntRes2[0]\nAFlag – Reset\nPFlag – Reset",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally, this instruction does not cause #GP if the memory operand is not aligned to 16 Byte boundary, and:",
        "column_1: If VEX.vvvv ≠ 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtph2pd",
    "category": "Core Instructions",
    "instructionName": "VCVTPH2PD\n\t\t— Convert Packed FP16 Values to FP64 Values",
    "detailsTable": [
      {
        "Description": "Convert packed FP16 values in xmm2/m32/m16bcst to FP64 values, and store result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 5A /r VCVTPH2PD xmm1{k1}{z}, xmm2/m32/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert packed FP16 values in xmm2/m64/m16bcst to FP64 values, and store result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 5A /r VCVTPH2PD ymm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert packed FP16 values in xmm2/m128/m16bcst to FP64 values, and store result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 5A /r VCVTPH2PD zmm1{k1}{z}, xmm2/m128/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Quarter"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmaddubsw",
    "category": "Core Instructions",
    "instructionName": "PMADDUBSW\n\t\t— Multiply and Add Packed Signed and Unsigned Bytes",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 38 04 /r1 PMADDUBSW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 04 /r PMADDUBSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 04 /r VPMADDUBSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 04 /r VPMADDUBSW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 04 /r VPMADDUBSW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 04 /r VPMADDUBSW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 04 /r VPMADDUBSW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corresponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each adjacent pair of signed words is added and the saturated result is packed to the destination operand. For example, the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same operation is performed on the other pairs of adjacent bytes. Both operands can be MMX register or XMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nIn 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX.128 encoded versions: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 and EVEX.256 encoded versions: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX.512 encoded version: The second source operand can be an ZMM register or a 512-bit memory location. The first source and destination operands are ZMM registers.",
    "operationText": "DEST[15-0] = SaturateToSignedWord(SRC[15-8]*DEST[15-8]+SRC[7-0]*DEST[7-0]);\nDEST[31-16] = SaturateToSignedWord(SRC[31-24]*DEST[31-24]+SRC[23-16]*DEST[23-16]);\nDEST[47-32] = SaturateToSignedWord(SRC[47-40]*DEST[47-40]+SRC[39-32]*DEST[39-32]);\nDEST[63-48] = SaturateToSignedWord(SRC[63-56]*DEST[63-56]+SRC[55-48]*DEST[55-48]);\nDEST[15-0] = SaturateToSignedWord(SRC[15-8]* DEST[15-8]+SRC[7-0]*DEST[7-0]);\n// Repeat operation for 2nd through 7th word\nSRC1/DEST[127-112] = SaturateToSignedWord(SRC[127-120]*DEST[127-120]+ SRC[119-112]* DEST[119-112]);\nDEST[15:0] := SaturateToSignedWord(SRC2[15:8]* SRC1[15:8]+SRC2[7:0]*SRC1[7:0])\n// Repeat operation for 2nd through 7th word\nDEST[127:112] := SaturateToSignedWord(SRC2[127:120]*SRC1[127:120]+ SRC2[119:112]* SRC1[119:112])\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := SaturateToSignedWord(SRC2[15:8]* SRC1[15:8]+SRC2[7:0]*SRC1[7:0])\n// Repeat operation for 2nd through 15th word\nDEST[255:240] := SaturateToSignedWord(SRC2[255:248]*SRC1[255:248]+ SRC2[247:240]* SRC1[247:240])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SaturateToSignedWord(SRC2[i+15:i+8]* SRC1[i+15:i+8] + SRC2[i+7:i]*SRC1[i+7:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/stmxcsr",
    "category": "Core Instructions",
    "instructionName": "STMXCSR\n\t\t— Store MXCSR Register State",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Store contents of MXCSR register to m32.",
        "Op/En": "M",
        "Opcode*/Instruction": "NP 0F AE /3 STMXCSR m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Store contents of MXCSR register to m32.",
        "Op/En": "M",
        "Opcode*/Instruction": "VEX.LZ.0F.WIG AE /3 VSTMXCSR m32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.\nVEX.L must be 0, otherwise instructions will #UD.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "m32 := MXCSR;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "column_1: If VEX.vvvv ≠ 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fprem",
    "category": "Core Instructions",
    "instructionName": "FPREM\n\t\t— Partial Remainder",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1).",
        "Instruction": "FPREM",
        "Opcode": "D9 F8"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:\nRemainder := ST(0) − (Q ∗ ST(1))\nHere, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)] toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is less than that of the modulus, unless a partial remainder was computed (as described below).\nThis instruction produces an exact result; the inexact-result exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur.\nWhen the result is 0, its sign is the same as that of the dividend. When the modulus is ∞, the result is equal to the value in ST(0).\nThe FPREM instruction does not compute the remainder specified in IEEE Std 754. The IEEE specified remainder can be computed with the FPREM1 instruction. The FPREM instruction is provided for compatibility with the Intel 8087 and Intel287 math coprocessors.\nThe FPREM instruction gets its name “partial remainder” because of the way it computes the remainder. This instruction arrives at a remainder through iterative subtraction. It can, however, reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.)\nAn important use of the FPREM instruction is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU\nstatus word. This information is important in argument reduction for the tangent function (using a modulus of π/4), because it locates the original angle in the correct one of eight sectors of the unit circle.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "D := exponent(ST(0)) – exponent(ST(1));\nIF D < 64\n    THEN\n        Q := Integer(TruncateTowardZero(ST(0) / ST(1)));\n        ST(0) := ST(0) – (ST(1) ∗ Q);\n        C2 := 0;\n        C0, C3, C1 := LeastSignificantBits(Q); (* Q2, Q1, Q0 *)\n    ELSE\n        C2 := 1;\n        N := An implementation-dependent number between 32 and 63;\n        QQ := Integer(TruncateTowardZero((ST(0) / ST(1)) / 2(D − N)));\n        ST(0) := ST(0) – (ST(1) ∗ QQ ∗ 2(D − N));\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value, modulus is 0, dividend is ∞, or unsupported format.; \ncolumn_2: Source operand is a denormal value.; column_1: #D; \ncolumn_1: #U; column_2: Result is too small for destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ptwrite",
    "category": "Core Instructions",
    "instructionName": "PTWRITE\n\t\t— Write Data to a Processor Trace Packet",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E",
        "CPUID Feature Flag": "PTWRITE",
        "Description": "Reads the data from r64/m64 to encode into a PTW packet if dependencies are met (see details below).",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 REX.W 0F AE /4 PTWRITE r64/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "PTWRITE",
        "Description": "Reads the data from r32/m32 to encode into a PTW packet if dependencies are met (see details below).",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 0F AE /4 PTWRITE r32/m32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:rm (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "This instruction reads data in the source operand and sends it to the Intel Processor Trace hardware to be encoded in a PTW packet if TriggerEn, ContextEn, FilterEn, and PTWEn are all set to 1. For more details on these values, see Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, Section 33.2.2, “Software Trace Instrumentation with PTWRITE.” The size of data is 64-bit if using REX.W in 64-bit mode, otherwise 32-bits of data are copied from the source operand.\nNote: The instruction will #UD if prefix 66H is used.",
    "operationText": "IF (IA32_RTIT_STATUS.TriggerEn & IA32_RTIT_STATUS.ContextEn & IA32_RTIT_STATUS.FilterEn & IA32_RTIT_CTL.PTWEn) = 1\n    PTW.PayloadBytes := Encoded payload size;\n    PTW.IP := IA32_RTIT_CTL.FUPonPTW\n    IF IA32_RTIT_CTL.FUPonPTW = 1\n        Insert FUP packet with IP of PTWRITE;\n    FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If CPUID.(EAX=14H, ECX=0H):EBX.PTWRITE [Bit 4] = 0.; \ncolumn_1: If LOCK prefix is used.; \ncolumn_1: If 66H prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in Protected Mode."
      ],
      "protectedMode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.; \ncolumn_1: #UD; column_2: If CPUID.(EAX=14H, ECX=0H):EBX.PTWRITE [Bit 4] = 0.; \ncolumn_1: If LOCK prefix is used.; \ncolumn_1: If 66H prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If CPUID.(EAX=14H, ECX=0H):EBX.PTWRITE [Bit 4] = 0.; column_1: #UD; \ncolumn_1: If LOCK prefix is used.; \ncolumn_1: If 66H prefix is used.;"
      ],
      "virtual8086Mode¶": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while alignment checking is enabled.; \ncolumn_1: #UD; column_2: If CPUID.(EAX=14H, ECX=0H):EBX.PTWRITE [Bit 4] = 0.; \ncolumn_1: If LOCK prefix is used.; \ncolumn_1: If 66H prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fxch",
    "category": "Core Instructions",
    "instructionName": "FXCH\n\t\t— Exchange Register Contents",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange the contents of ST(0) and ST(i).",
        "Instruction": "FXCH ST(i)",
        "Opcode": "D9 C8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Exchange the contents of ST(0) and ST(1).",
        "Instruction": "FXCH",
        "Opcode": "D9 C9"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged.\nThis instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)], so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For example, the following instruction sequence takes the square root of the third register from the top of the register stack:\nFXCH ST(3);\nFSQRT;\nFXCH ST(3);\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF (Number-of-operands) is 1\n    THEN\n        temp := ST(0);\n        ST(0) := SRC;\n        SRC := temp;\n    ELSE\n        temp := ST(0);\n        ST(0) := ST(1);\n        ST(1) := temp;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        ""
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vdbpsadbw",
    "category": "Core Instructions",
    "instructionName": "VDBPSADBW\n\t\t— Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compute packed SAD word results of unsigned bytes in dword block from xmm2 with unsigned bytes of dword blocks transformed from xmm3/m128 using the shuffle controls in imm8. Results are written to xmm1 under the writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 42 /r ib VDBPSADBW xmm1 {k1}{z}, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compute packed SAD word results of unsigned bytes in dword block from ymm2 with unsigned bytes of dword blocks transformed from ymm3/m256 using the shuffle controls in imm8. Results are written to ymm1 under the writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 42 /r ib VDBPSADBW ymm1 {k1}{z}, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compute packed SAD word results of unsigned bytes in dword block from zmm2 with unsigned bytes of dword blocks transformed from zmm3/m512 using the shuffle controls in imm8. Results are written to zmm1 under the writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 42 /r ib VDBPSADBW zmm1 {k1}{z}, zmm2, zmm3/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcp28ss",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VRCP28SS\n\t\t— Approximation to the Reciprocal of Scalar Single Precision Floating-Point ValueWith Less Than 2^-28 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes the approximate reciprocal ( < 2^-28 relative error) of the scalar single-precision floating-point value in xmm3/m32 and stores the results in xmm1. Under writemask. Also, upper 3 single-precision floating-point values (bits[127:32]) from xmm2 is copied to xmm1[127:32].",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 CB /r VRCP28SS xmm1 {k1}{z}, xmm2, xmm3/m32 {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A Tuple1 Scalar ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pcmpistrm",
    "category": "Core Instructions",
    "instructionName": "PCMPISTRM\n\t\t— Packed Compare Implicit Length Strings, Return Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_2",
        "Description": "Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 3A 62 /r imm8 PCMPISTRM xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 62 /r ib VPCMPISTRM xmm1, xmm2/m128, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction compares data from two strings based on the encoded value in the imm8 byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”) generating a mask stored to XMM0.\nEach string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)\nThe comparison and aggregation operation are performed according to the encoded value of imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.\nNote that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:\nCFlag – Reset if IntRes2 is equal to zero, set otherwise\nZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise\nSFlag – Set if any byte/word of xmm1 is null, reset otherwise\nOFlag – IntRes2[0]\nAFlag – Reset\nPFlag – Reset\nNote: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally, this instruction does not cause #GP if the memory operand is not aligned to 16 Byte boundary, and:",
        "column_1: If VEX.vvvv ≠ 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/bndstx",
    "category": "Core Instructions",
    "instructionName": "BNDSTX\n\t\t— Store Extended Bounds Using Address Translation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MPX",
        "Description": "Store the bounds in bnd and the pointer value in the index register of mib to a bound table entry (BTE) with address translation using the base of mib.",
        "Op/En": "MR",
        "Opcode/Instruction": "NP 0F 1B /r BNDSTX mib, bnd"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "SIB.base (r): Address of pointer SIB.index(r)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "BNDSTX uses the linear address constructed from the displacement and base register of the SIB-addressing form of the memory operand (mib) to perform address translation to store to a bound table entry. The bounds in the source operand bnd are written to the lower and upper bounds in the BTE. The content of the index register of mib is written to the pointer value field in the BTE.\nThis instruction does not cause memory access to the linear address of mib nor the effective address referenced by the base, and does not read or write any flags.\nSegment overrides apply to the linear address computation with the base of mib, and are used during address translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be linear address. There are no segmentation checks performed on the base of mib.\nThe base of mib will not be checked for canonical address violation as it does not access memory.\nAny encoding of this instruction that does not specify base or index register will treat those registers as zero (constant). The reg-reg form of this instruction will remain a NOP.\nThe scale field of the SIB byte has no effect on these instructions and is ignored.\nThe bound register may be partially updated on memory faults. The order in which memory operands are loaded is implementation specific.",
    "operationText": "base := mib.SIB.base ? mib.SIB.base + Disp: 0;\nptr_value := mib.SIB.index ? mib.SIB.index : 0;\nA_BDE[31:0] := (Zero_extend32(base[31:12] « 2) + (BNDCFG[31:12] «12 );\nA_BT[31:0] := LoadFrom(A_BDE);\nIF A_BT[0] equal 0 Then\n    BNDSTATUS := A_BDE | 02H;\n    #BR;\nFI;\nA_DEST[31:0] := (Zero_extend32(base[11:2] « 4) + (A_BT[31:2] « 2 ); // address of Bound table entry\nA_DEST[8][31:0] := ptr_value;\nA_DEST[0][31:0] := BND.LB;\nA_DEST[4][31:0] := BND.UB;\nA_BDE[63:0] := (Zero_extend64(base[47+MAWA:20] « 3) + (BNDCFG[63:12] «12 );1\nA_BT[63:0] := LoadFrom(A_BDE);\nIF A_BT[0] equal 0 Then\n    BNDSTATUS := A_BDE | 02H;\n    #BR;\nFI;\nA_DEST[63:0] := (Zero_extend64(base[19:3] « 5) + (A_BT[63:3] « 3 ); // address of Bound table entry\nA_DEST[16][63:0] := ptr_value;\nA_DEST[0][63:0] := BND.LB;\nA_DEST[8][63:0] := BND.UB;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If ModRM is RIP relative.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m and REX encodes BND4-BND15 when Intel MPX is enabled.; \ncolumn_1: #GP(0); column_2: If the memory address (A_BDE or A_BTE) is in a non-canonical form.; \ncolumn_1: If the destination operand points to a non-writable segment; \ncolumn_1: #PF(fault; column_2: code) If a page fault occurs.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 67H prefix is not used and CS.D=0.; \ncolumn_1: If 67H prefix is used and CS.D=1.; \ncolumn_1: #GP(0); column_2: If a destination effective address of the Bound Table entry is outside the DS segment limit.; \ncolumn_1: If DS register contains a NULL segment selector.; \ncolumn_1: If the destination operand points to a non-writable segment; \ncolumn_1: #PF(fault; column_2: code) If a page fault occurs.;"
      ],
      "realAddressMode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.; \ncolumn_1: #GP(0); column_2: If a destination effective address of the Bound Table entry is outside the DS segment limit.;"
      ],
      "virtual8086Mode": [
        "column_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.; \ncolumn_1: #GP(0); column_2: If a destination effective address of the Bound Table entry is outside the DS segment limit.; \ncolumn_1: #PF(fault; column_2: code) If a page fault occurs.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/daa",
    "category": "Core Instructions",
    "instructionName": "DAA\n\t\t— Decimal Adjust AL After Addition",
    "detailsTable": [
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Decimal adjust AL after addition.",
        "Instruction": "DAA",
        "Op/En": "ZO",
        "Opcode": "27"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the CF and AF flags are set accordingly.\nThis instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        #UD;\n    ELSE\n        old_AL := AL;\n        old_CF := CF;\n        CF := 0;\n        IF (((AL AND 0FH) > 9) or AF = 1)\n                THEN\n                    AL := AL + 6;\n                    CF := old_CF or (Carry from AL := AL + 6);\n                    AF := 1;\n                ELSE\n                    AF := 0;\n        FI;\n        IF ((old_AL > 99H) or (old_CF = 1))\n            THEN\n                    AL := AL + 60H;\n                    CF := 1;\n            ELSE\n                    CF := 0;\n        FI;\nFI;",
    "flagsAffectedText": "The CF and AF flags are set if the adjustment of the value results in a decimal carry in either digit of the result (see the “Operation” section above). The SF, ZF, and PF flags are set according to the result. The OF flag is undefined.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sqrtps",
    "category": "Core Instructions",
    "instructionName": "SQRTPS\n\t\t— Square Root of Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Computes Square Roots of the packed single precision floating-point values in xmm2/m128 and stores the result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 51 /r SQRTPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes Square Roots of the packed single precision floating-point values in xmm2/m128 and stores the result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.0F.WIG 51 /r VSQRTPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes Square Roots of the packed single precision floating-point values in ymm2/m256 and stores the result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.0F.WIG 51/r VSQRTPS ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes Square Roots of the packed single precision floating-point values in xmm2/m128/m32bcst and stores the result in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.0F.W0 51 /r VSQRTPS xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes Square Roots of the packed single precision floating-point values in ymm2/m256/m32bcst and stores the result in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.0F.W0 51 /r VSQRTPS ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes Square Roots of the packed single precision floating-point values in zmm2/m512/m32bcst and stores the result in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.0F.W0 51/r VSQRTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD computation of the square roots of the four, eight or sixteen packed single precision floating-point values in the source operand (second operand) stores the packed single precision floating-point results in the destination operand.\nEVEX.512 encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF (VL = 512) AND (EVEX.b = 1) AND (SRC *is register*)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC *is memory*)\n                THEN DEST[i+31:i] := SQRT(SRC[31:0])\n                ELSE DEST[i+31:i] := SQRT(SRC[i+31:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SQRT(SRC[31:0])\nDEST[63:32] := SQRT(SRC[63:32])\nDEST[95:64] := SQRT(SRC[95:64])\nDEST[127:96] := SQRT(SRC[127:96])\nDEST[159:128] := SQRT(SRC[159:128])\nDEST[191:160] := SQRT(SRC[191:160])\nDEST[223:192] := SQRT(SRC[223:192])\nDEST[255:224] := SQRT(SRC[255:224])\nDEST[31:0] := SQRT(SRC[31:0])\nDEST[63:32] := SQRT(SRC[63:32])\nDEST[95:64] := SQRT(SRC[95:64])\nDEST[127:96] := SQRT(SRC[127:96])\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SQRT(SRC[31:0])\nDEST[63:32] := SQRT(SRC[63:32])\nDEST[95:64] := SQRT(SRC[95:64])\nDEST[127:96] := SQRT(SRC[127:96])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rorx",
    "category": "Core Instructions",
    "instructionName": "RORX\n\t\t— Rotate Right Logical Without Affecting Flags",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI2",
        "Description": "Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags.",
        "Op/En": "RMI",
        "Opcode/Instruction": "VEX.LZ.F2.0F3A.W0 F0 /r ib RORX r32, r/m32, imm8"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI2",
        "Description": "Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags.",
        "Op/En": "RMI",
        "Opcode/Instruction": "VEX.LZ.F2.0F3A.W1 F0 /r ib RORX r64, r/m64, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Rotates the bits of second operand right by the count value specified in imm8 without affecting arithmetic flags. The RORX instruction does not read or write the arithmetic flags.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "IF (OperandSize = 32)\n    y := imm8 AND 1FH;\n    DEST := (SRC >> y) | (SRC << (32-y));\nELSEIF (OperandSize = 64 )\n    y := imm8 AND 3FH;\n    DEST := (SRC >> y) | (SRC << (64-y));\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fist:fistp",
    "category": "Core Instructions",
    "instructionName": "FIST/FISTP\n\t\t— Store Integer",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store ST(0) in m16int.",
        "Instruction": "FIST m16int",
        "Opcode": "DF /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store ST(0) in m32int.",
        "Instruction": "FIST m32int",
        "Opcode": "DB /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store ST(0) in m16int and pop register stack.",
        "Instruction": "FISTP m16int",
        "Opcode": "DF /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store ST(0) in m32int and pop register stack.",
        "Instruction": "FISTP m32int",
        "Opcode": "DB /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store ST(0) in m64int and pop register stack.",
        "Instruction": "FISTP m64int",
        "Opcode": "DF /7"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand. Values can be stored in word or doubleword integer format. The destination operand specifies the address where the first byte of the destination value is to be stored.\nThe FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FISTP instruction also stores values in quadword integer format.\nThe following table shows the results obtained when storing various classes of numbers in integer format.\nIf the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode specified by the RC field of the FPU control word.\nIf the converted value is too large for the destination format, or if the source operand is an ∞, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the integer indefinite value is stored in memory.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "DEST := Integer(ST(0));\nIF Instruction = FISTP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; column_1: #NM; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Converted value is too large for the destination format.; \ncolumn_1: Source operand is an SNaN, QNaN, ±∞, or unsupported format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; column_1: #NM; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movq",
    "category": "Core Instructions",
    "instructionName": "MOVQ\n\t\t— Move Quadword",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Move quadword from mm/m64 to mm.",
        "Op/ En": "A",
        "Opcode/Instruction": "NP 0F 6F /r MOVQ mm, mm/m64"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Move quadword from mm to mm/m64.",
        "Op/ En": "B",
        "Opcode/Instruction": "NP 0F 7F /r MOVQ mm/m64, mm"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move quadword from xmm2/mem64 to xmm1.",
        "Op/ En": "A",
        "Opcode/Instruction": "F3 0F 7E /r MOVQ xmm1, xmm2/m64"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move quadword from xmm2 to xmm1.",
        "Op/ En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F.WIG 7E /r VMOVQ xmm1, xmm2/m64"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move quadword from xmm2/m64 to xmm1.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.128.F3.0F.W1 7E /r VMOVQ xmm1, xmm2/m64"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move quadword from xmm1 to xmm2/mem64.",
        "Op/ En": "B",
        "Opcode/Instruction": "66 0F D6 /r MOVQ xmm2/m64, xmm1"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move quadword from xmm2 register to xmm1/m64.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D6 /r VMOVQ xmm1/m64, xmm2"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move quadword from xmm2 register to xmm1/m64.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 D6 /r VMOVQ xmm1/m64, xmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Copies a quadword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. This instruction can be used to move a quadword between two MMX technology registers or between an MMX technology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations.\nWhen the source operand is an XMM register, the low quadword is moved; when the destination operand is an XMM register, the quadword is stored to the low quadword of the register, and the high quadword is cleared to all 0s.\nIn 64-bit mode and if not encoded using VEX/EVEX, use of the REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nIf VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
    "operationText": "DEST := SRC;\nDEST[63:0] := SRC[63:0];\nDEST[127:64] := 0000000000000000H;\noperand is memory location:\n    DEST := SRC[63:0];\noperand is XMM register:\n    DEST[63:0] := SRC;\n    DEST[127:64] := 0000000000000000H;\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] := 0\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] := 0\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] := 0\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] := 0\nDEST[63:0] := SRC[63:0]\nDEST[MAXVL-1:64] := 0\nDEST[63:0] := SRC[63:0]\nDEST[:MAXVL-1:64] := 0\nDEST[63:0] := SRC2[63:0]",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 23-8, “Exception Conditions for Legacy SIMD/MMX Instructions without FP Exception,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ldtilecfg",
    "category": "Core Instructions",
    "instructionName": "LDTILECFG\n\t\t— Load Tile Configuration",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-TILE",
        "Description": "Load tile configuration as specified in m512.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.NP.0F38.W0 49 !(11):000:bbb LDTILECFG m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pextrw",
    "category": "Core Instructions",
    "instructionName": "PEXTRW\n\t\t— Extract Word",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F C5 /r ib1 PEXTRW reg, mm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F C5 /r ib PEXTRW reg, xmm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 3A 15 /r ib PEXTRW reg/m16, xmm, imm8"
      },
      {
        "64/32 bit Mode Support": "V2/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.W0 C5 /r ib VPEXTRW reg, xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 15 /r ib VPEXTRW reg/m16, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG C5 /r ib VPEXTRW reg, xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.WIG 15 /r ib VPEXTRW reg/m16, xmm2, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Copies the word in the source operand (second operand) specified by the count operand (third operand) to the destination operand (first operand). The source operand can be an MMX technology register or an XMM register. The destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location. The content of the destination register above bit 16 is cleared (set to all 0s).\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). If the destination operand is a general-purpose register, the default operand size is 64-bits in 64-bit mode.\nNote: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRW is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
    "operationText": "IF (DEST = Mem16)\nTHEN\n    SEL := COUNT[2:0];\n    TEMP := (Src >> SEL*16) AND FFFFH;\n    Mem16 := TEMP[15:0];\nELSE IF (64-Bit Mode and destination is a general-purpose register)\n    THEN\n        FOR (PEXTRW instruction with 64-bit source operand)\n                { SEL := COUNT[1:0];\n                    TEMP := (SRC >> (SEL ∗ 16)) AND FFFFH;\n                    r64[15:0] := TEMP[15:0];\n                    r64[63:16] := ZERO_FILL; };\n        FOR (PEXTRW instruction with 128-bit source operand)\n                { SEL := COUNT[2:0];\n                    TEMP := (SRC >> (SEL ∗ 16)) AND FFFFH;\n                    r64[15:0] := TEMP[15:0];\n                    r64[63:16] := ZERO_FILL; }\n    ELSE\n        FOR (PEXTRW instruction with 64-bit source operand)\n            { SEL := COUNT[1:0];\n                    TEMP := (SRC >> (SEL ∗ 16)) AND FFFFH;\n                    r32[15:0] := TEMP[15:0];\n                    r32[31:16] := ZERO_FILL; };\n        FOR (PEXTRW instruction with 128-bit source operand)\n            { SEL := COUNT[2:0];\n                    TEMP := (SRC >> (SEL ∗ 16)) AND FFFFH;\n                    r32[15:0] := TEMP[15:0];\n                    r32[31:16] := ZERO_FILL; };\n    FI;\nFI;\nSRC_Offset := imm8[2:0]\nMem16 := (Src >> Src_Offset*16)\nIF (64-Bit Mode )\nTHEN\n    SRC_Offset := imm8[2:0]\n    DEST[15:0] := ((Src >> Src_Offset*16) AND 0FFFFh)\n    DEST[63:16] := ZERO_FILL;\nELSE\n    SRC_Offset := imm8[2:0]\n    DEST[15:0] := ((Src >> Src_Offset*16) AND 0FFFFh)\n    DEST[31:16] := ZERO_FILL;\nFI",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”",
        "Additionally:",
        "column_1: If VEX.vvvv != 1111B or EVEX.vvvv != 1111B.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetmantsh",
    "category": "Core Instructions",
    "instructionName": "VGETMANTSH\n\t\t— Extract FP16 of Normalized Mantissa from FP16 Scalar",
    "detailsTable": [
      {
        "Description": "Extract the normalized mantissa of the low FP16 element in xmm3/m16 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 subject to writemask k1 and merge with the other elements of xmm2. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.NP.0F3A.W0 27 /r /ib VGETMANTSH xmm1{k1}{z}, xmm2, xmm3/m16 {sae}, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/std",
    "category": "Core Instructions",
    "instructionName": "STD\n\t\t— Set Direction Flag",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set DF flag.",
        "Instruction": "STD",
        "Op/En": "ZO",
        "Opcode": "FD"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Sets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index registers (ESI and/or EDI). Operation is the same in all modes.",
    "operationText": "DF := 1;",
    "flagsAffectedText": "The DF flag is set. The CF, OF, ZF, SF, AF, and PF flags are unaffected.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrt28pd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VRSQRT28PD\n\t\t— Approximation to the Reciprocal Square Root of Packed Double PrecisionFloating-Point Values With Less Than 2^-28 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes approximations to the Reciprocal square root (<2^-28 relative error) of the packed double precision floating-point values from zmm2/m512/m64bcst and stores result in zmm1with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 CC /r VRSQRT28PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A",
        "column_2": "Full ModRM:reg (w) ModRM:r/m (r) N/A N/A",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpshrdv",
    "category": "Core Instructions",
    "instructionName": "VPSHRDV\n\t\t— Concatenate and Variable Shift Packed Data Right Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 72 /r VPSHRDVW xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 72 /r VPSHRDVW ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 72 /r VPSHRDVW zmm1{k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 73 /r VPSHRDVD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 73 /r VPSHRDVD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 73 /r VPSHRDVD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate xmm1 and xmm2, extract result shifted to the right by value in xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 73 /r VPSHRDVQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate ymm1 and ymm2, extract result shifted to the right by value in xmm3/m256 into ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 73 /r VPSHRDVQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate zmm1 and zmm2, extract result shifted to the right by value in zmm3/m512 into zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 73 /r VPSHRDVQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrt28sd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VRSQRT28SD\n\t\t— Approximation to the Reciprocal Square Root of Scalar Double PrecisionFloating-Point Value With Less Than 2^-28 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes approximate reciprocal square root (<2^-28 relative error) of the scalar double precision floating-point value from xmm3/m64 and stores result in xmm1with writemask k1. Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 CD /r VRSQRT28SD xmm1 {k1}{z}, xmm2, xmm3/m64 {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A Tuple1 Scalar ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/paddsb:paddsw",
    "category": "Core Instructions",
    "instructionName": "PADDSB/PADDSW\n\t\t— Add Packed Signed Integers with Signed Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Add packed signed byte integers from mm/m64 and mm and saturate the results.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F EC /r1 PADDSB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F EC /r PADDSB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Add packed signed word integers from mm/m64 and mm and saturate the results.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F ED /r1 PADDSW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F ED /r PADDSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG EC /r VPADDSB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG ED /r VPADDSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG EC /r VPADDSB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG ED /r VPADDSW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed signed byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG EC /r VPADDSB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG EC /r VPADDSB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Add packed signed byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG EC /r VPADDSB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed signed word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG ED /r VPADDSW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG ED /r VPADDSW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Add packed signed word integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG ED /r VPADDSW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.\n(V)PADDSB performs a SIMD add of the packed signed integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.\n(V)PADDSW performs a SIMD add of the packed signed word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.\nEVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a memory location. The destination operand is an ZMM/YMM/XMM register.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "DEST[7:0] := SaturateToSignedByte(DEST[7:0] + SRC (7:0]);\n(* Repeat add operation for 2nd through 7th bytes *)\nDEST[63:56] := SaturateToSignedByte(DEST[63:56] + SRC[63:56] );\nDEST[7:0] := SaturateToSignedByte (DEST[7:0] + SRC[7:0]);\n(* Repeat add operation for 2nd through 14th bytes *)\nDEST[127:120] := SaturateToSignedByte (DEST[111:120] + SRC[127:120]);\nDEST[7:0] := SaturateToSignedByte (SRC1[7:0] + SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 14th bytes *)\nDEST[127:120] := SaturateToSignedByte (SRC1[111:120] + SRC2[127:120]);\nDEST[MAXVL-1:128] := 0\nDEST[7:0] := SaturateToSignedByte (SRC1[7:0] + SRC2[7:0]);\n(* Repeat add operation for 2nd through 31st bytes *)\nDEST[255:248] := SaturateToSignedByte (SRC1[255:248] + SRC2[255:248]);\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := SaturateToSignedByte (SRC1[i+7:i] + SRC2[i+7:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nPADDSW (with 64-bit operands)\n    DEST[15:0] := SaturateToSignedWord(DEST[15:0] + SRC[15:0] );\n    (* Repeat add operation for 2nd and 7th words *)\n    DEST[63:48] := SaturateToSignedWord(DEST[63:48] + SRC[63:48] );\nPADDSW (with 128-bit operands)\n    DEST[15:0] := SaturateToSignedWord (DEST[15:0] + SRC[15:0]);\n    (* Repeat add operation for 2nd through 7th words *)\n    DEST[127:112] := SaturateToSignedWord (DEST[127:112] + SRC[127:112]);\nDEST[15:0] := SaturateToSignedWord (SRC1[15:0] + SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 7th words *)\nDEST[127:112] := SaturateToSignedWord (SRC1[127:112] + SRC2[127:112]);\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := SaturateToSignedWord (SRC1[15:0] + SRC2[15:0]);\n(* Repeat add operation for 2nd through 15th words *)\nDEST[255:240] := SaturateToSignedWord (SRC1[255:240] + SRC2[255:240])\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SaturateToSignedWord (SRC1[i+15:i] + SRC2[i+15:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesenclast",
    "category": "Core Instructions",
    "instructionName": "AESENCLAST\n\t\t— Perform Last Round of an AES Encryption Flow",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES",
        "Description": "Perform the last round of an AES encryption flow, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 DD /r AESENCLAST xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES AVX",
        "Description": "Perform the last round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG DD /r VAESENCLAST xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES",
        "Description": "Perform the last round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG DD /r VAESENCLAST ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512VL",
        "Description": "Perform the last round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG DD /r VAESENCLAST xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512VL",
        "Description": "Perform the last round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG DD /r VAESENCLAST ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512F",
        "Description": "Perform the last round of an AES encryption flow, using four 128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG DD /r VAESENCLAST zmm1, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      }
    ],
    "descriptionText": "This instruction performs the last round of an AES encryption flow using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\nThe EVEX encoded form of this instruction does not support memory fault suppression.",
    "operationText": "STATE := SRC1;\nRoundKey := SRC2;\nSTATE := ShiftRows( STATE );\nSTATE := SubBytes( STATE );\nDEST[127:0] := STATE XOR RoundKey;\nDEST[MAXVL-1:128] (Unmodified)\n(KL, VL) = (1,128), (2,256)\nFOR I=0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := ShiftRows( STATE )\n    STATE := SubBytes( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n(KL,VL) = (1,128), (2,256), (4,512)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := ShiftRows( STATE )\n    STATE := SubBytes( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded: See Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscatterpf0dps:vscatterpf0qps:vscatterpf0dpd:vscatterpf0qpd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VSCATTERPF0DPS/VSCATTERPF0QPS/VSCATTERPF0DPD/VSCATTERPF0QPD\n\t\t— Sparse PrefetchPacked SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint With Intentto Write",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T0 hint with intent to write.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C6 /5 /vsib VSCATTERPF0DPS vm32z {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using writemask k1 and T0 hint with intent to write.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C7 /5 /vsib VSCATTERPF0QPS vm64z {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed dword indices, prefetch sparse byte memory locations containing double precision data using writemask k1 and T0 hint with intent to write.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C6 /5 /vsib VSCATTERPF0DPD vm32y {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed qword indices, prefetch sparse byte memory locations containing double precision data using writemask k1 and T0 hint with intent to write.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C7 /5 /vsib VSCATTERPF0QPD vm64z {k1}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/andnpd",
    "category": "Core Instructions",
    "instructionName": "ANDNPD\n\t\t— Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Return the bitwise logical AND NOT of packed double precision floating-point values in xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 55 /r ANDNPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical AND NOT of packed double precision floating-point values in xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F 55 /r VANDNPD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical AND NOT of packed double precision floating-point values in ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F 55/r VANDNPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical AND NOT of packed double precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 55 /r VANDNPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical AND NOT of packed double precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 55 /r VANDNPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Return the bitwise logical AND NOT of packed double precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 55 /r VANDNPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical AND NOT of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := (NOT(SRC1[i+63:i])) BITWISE AND SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := (NOT(SRC1[i+63:i])) BITWISE AND SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] = 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := (NOT(SRC1[63:0])) BITWISE AND SRC2[63:0]\nDEST[127:64] := (NOT(SRC1[127:64])) BITWISE AND SRC2[127:64]\nDEST[191:128] := (NOT(SRC1[191:128])) BITWISE AND SRC2[191:128]\nDEST[255:192] := (NOT(SRC1[255:192])) BITWISE AND SRC2[255:192]\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := (NOT(SRC1[63:0])) BITWISE AND SRC2[63:0]\nDEST[127:64] := (NOT(SRC1[127:64])) BITWISE AND SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := (NOT(DEST[63:0])) BITWISE AND SRC[63:0]\nDEST[127:64] := (NOT(DEST[127:64])) BITWISE AND SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pusha:pushad",
    "category": "Core Instructions",
    "instructionName": "PUSHA/PUSHAD\n\t\t— Push All General-Purpose Registers",
    "detailsTable": [
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push AX, CX, DX, BX, original SP, BP, SI, and DI.",
        "Instruction": "PUSHA",
        "Op/En": "ZO",
        "Opcode": "60"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.",
        "Instruction": "PUSHAD",
        "Op/En": "ZO",
        "Opcode": "60"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the following order: EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). These instructions perform the reverse operation of the POPA/POPAD instructions. The value pushed for the ESP or SP register is its value before prior to pushing the first register (see the “Operation” section below).\nThe PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same opcode. The PUSHA instruction is intended for use when the operand-size attribute is 16 and the PUSHAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHA is used and to 32 when PUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.\nIn the real-address mode, if the ESP or SP register is 1, 3, or 5 when PUSHA/PUSHAD executes: an #SS exception is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.",
    "operationText": "IF 64-bit Mode\n    THEN #UD\nFI;\nIF OperandSize = 32 (* PUSHAD instruction *)\n    THEN\n        Temp := (ESP);\n        Push(EAX);\n        Push(ECX);\n        Push(EDX);\n        Push(EBX);\n        Push(Temp);\n        Push(EBP);\n        Push(ESI);\n        Push(EDI);\n    ELSE (* OperandSize = 16, PUSHA instruction *)\n        Temp := (SP);\n        Push(AX);\n        Push(CX);\n        Push(DX);\n        Push(BX);\n        Push(Temp);\n        Push(BP);\n        Push(SI);\n        Push(DI);\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/eenter",
    "category": "SGX Instructions",
    "instructionName": "EENTER\n\t\t— Enters an Enclave",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function is used to enter an enclave.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 02H ENCLU[EENTER]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EENTER (In)",
        "column_3": "Content of RBX.CSSA (Out)",
        "column_4": "Address of a TCS (In)",
        "column_5": "Address of AEP (In)",
        "column_6": "Address of IP following EENTER (Out)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xgetbv",
    "category": "Core Instructions",
    "instructionName": "XGETBV\n\t\t— Get Value of Extended Control Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Reads an XCR specified by ECX into EDX:EAX.",
        "Instruction": "XGETBV",
        "Op/En": "ZO",
        "Opcode": "NP 0F 01 D0"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Reads the contents of the extended control register (XCR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the XCR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the XCR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.\nXCR0 is supported on any processor that supports the XGETBV instruction. If CPUID.(EAX=0DH,ECX=1):EAX.XG1[bit 2] = 1, executing XGETBV with ECX = 1 returns in EDX:EAX the logicalAND of XCR0 and the current value of the XINUSE state-component bitmap. This allows software to discover the state of the init optimization used by XSAVEOPT and XSAVES. See Chapter 13, “Managing State Using the XSAVE Feature Set‚” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nUse of any other value for ECX results in a general-protection (#GP) exception.",
    "operationText": "EDX:EAX := XCR[ECX];",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcp14ps",
    "category": "Core Instructions",
    "instructionName": "VRCP14PS\n\t\t— Compute Approximate Reciprocals of Packed Float32 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 4C /r VRCP14PS xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes the approximate reciprocals of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 4C /r VRCP14PS ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes the approximate reciprocals of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 4C /r VRCP14PS zmm1 {k1}{z}, zmm2/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdrand",
    "category": "Core Instructions",
    "instructionName": "RDRAND\n\t\t— Read Random Number",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "RDRAND",
        "Description": "Read a 16-bit random number and store in the destination register.",
        "Op/En": "M",
        "Opcode*/Instruction": "NFx 0F C7 /6 RDRAND r16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "RDRAND",
        "Description": "Read a 32-bit random number and store in the destination register.",
        "Op/En": "M",
        "Opcode*/Instruction": "NFx 0F C7 /6 RDRAND r32"
      },
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "RDRAND",
        "Description": "Read a 64-bit random number and store in the destination register.",
        "Op/En": "M",
        "Opcode*/Instruction": "NFx REX.W + 0F C7 /6 RDRAND r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads a hardware generated random value and store it in the destination register. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random value has been returned, otherwise it is expected to loop and retry execution of RDRAND (see Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, Section 7.3.17, “Random Number Generator Instructions”).\nThis instruction is available at all privilege levels.\nIn 64-bit mode, the instruction's default operand size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF HW_RND_GEN.ready = 1\n    THEN\n        CASE of\n            operand size is 64: DEST[63:0] := HW_RND_GEN.data;\n            operand size is 32: DEST[31:0] := HW_RND_GEN.data;\n            operand size is 16: DEST[15:0] := HW_RND_GEN.data;\n        ESAC\n        CF := 1;\n    ELSE\n        CASE of\n            operand size is 64: DEST[63:0] := 0;\n            operand size is 32: DEST[31:0] := 0;\n            operand size is 16: DEST[15:0] := 0;\n        ESAC\n        CF := 0;\nFI\nOF, SF, ZF, AF, PF := 0;",
    "flagsAffectedText": "The CF flag is set according to the result (see the “Operation” section above). The OF, SF, ZF, AF, and PF flags are set to 0.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CPUID.01H:ECX.RDRAND[bit 30] = 0.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/tdpbssd:tdpbsud:tdpbusd:tdpbuud",
    "category": "Core Instructions",
    "instructionName": "TDPBSSD/TDPBSUD/TDPBUSD/TDPBUUD\n\t\t— Dot Product of Signed/Unsigned Bytes with DwordAccumulation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-INT8",
        "Description": "Matrix multiply signed byte elements from tmm2 by signed byte elements from tmm3 and accumulate the dword elements in tmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F2.0F38.W0 5E 11:rrr:bbb TDPBSSD tmm1, tmm2, tmm3"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-INT8",
        "Description": "Matrix multiply signed byte elements from tmm2 by unsigned byte elements from tmm3 and accumulate the dword elements in tmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F38.W0 5E 11:rrr:bbb TDPBSUD tmm1, tmm2, tmm3"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-INT8",
        "Description": "Matrix multiply unsigned byte elements from tmm2 by signed byte elements from tmm3 and accumulate the dword elements in tmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 5E 11:rrr:bbb TDPBUSD tmm1, tmm2, tmm3"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-INT8",
        "Description": "Matrix multiply unsigned byte elements from tmm2 by unsigned byte elements from tmm3 and accumulate the dword elements in tmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.NP.0F38.W0 5E 11:rrr:bbb TDPBUUD tmm1, tmm2, tmm3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "VEX.vvvv (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "For each possible combination of (row of tmm2, column of tmm3), the instruction performs a set of SIMD dot-products on all corresponding four byte elements, one from tmm2 and one from tmm3, adds the results of those dot-products, and then accumulates the result into the corresponding row and column of tmm1. Each dword in input tiles tmm2 and tmm3 is interpreted as four byte elements. These may be signed or unsigned. Each letter in the two-letter pattern SU, US, SS, UU indicates the signed/unsigned nature of the values in tmm2 and tmm3, respectively.\nAny attempt to execute the TDPBSSD/TDPBSUD/TDPBUSD/TDPBUUD instructions inside an Intel TSX transaction will result in a transaction abort.",
    "operationText": "define DPBD(c,x,y):// arguments are dwords\n    if *x operand is signed*:\n        extend_src1 := SIGN_EXTEND\n    else:\n        extend_src1 := ZERO_EXTEND\n    if *y operand is signed*:\n        extend_src2 := SIGN_EXTEND\n    else:\n        extend_src2 := ZERO_EXTEND\n    p0dword := extend_src1(x.byte[0]) * extend_src2(y.byte[0])\n    p1dword := extend_src1(x.byte[1]) * extend_src2(y.byte[1])\n    p2dword := extend_src1(x.byte[2]) * extend_src2(y.byte[2])\n    p3dword := extend_src1(x.byte[3]) * extend_src2(y.byte[3])\n    c := c + p0dword + p1dword + p2dword + p3dword\n// C = m x n (tsrcdest), A = m x k (tsrc1), B = k x n (tsrc2)\ntsrc1_elements_per_row := tsrc1.colsb / 4\ntsrc2_elements_per_row := tsrc2.colsb / 4\ntsrcdest_elements_per_row := tsrcdest.colsb / 4\nfor m in 0 ... tsrcdest.rows-1:\n    tmp := tsrcdest.row[m]\n    for k in 0 ... tsrc1_elements_per_row-1:\n        for n in 0 ... tsrcdest_elements_per_row-1:\n            DPBD( tmp.dword[n], tsrc1.row[m].dword[k], tsrc2.row[k].dword[n] )\n    write_row_and_zero(tsrcdest, m, tmp, tsrcdest.colsb)\nzero_upper_rows(tsrcdest, tsrcdest.rows)\nzero_tilecfg_start()",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "AMX-E4; see Section 2.10, “Intel® AMX Instruction Exception Classes,” for details."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtps2pi",
    "category": "Core Instructions",
    "instructionName": "CVTPS2PI\n\t\t— Convert Packed Single Precision Floating-Point Values to Packed Dword Integers",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Convert two packed single precision floating-point values from xmm/m64 to two packed signed doubleword integers in mm.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 2D /r CVTPS2PI mm, xmm/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Converts two packed single precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).\nThe source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single precision floating-point values are contained in the low quadword of the register. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nCVTPS2PI causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPS2PI instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[31:0]);\nDEST[63:32] := Convert_Single_Precision_Floating_Point_To_Integer(SRC[63:32]);",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 23-5, “Exception Conditions for Legacy SIMD/MMX Instructions with XMM and FP Exception,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pextrb:pextrd:pextrq",
    "category": "Core Instructions",
    "instructionName": "PEXTRB/PEXTRD/PEXTRQ\n\t\t— Extract Byte/Dword/Qword",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r32 or r64 are zeroed.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F 3A 14 /r ib PEXTRB reg/m8, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F 3A 16 /r ib PEXTRD r/m32, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 REX.W 0F 3A 16 /r ib PEXTRQ r/m64, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V1/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros.",
        "Op/ En": "A",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 14 /r ib VPEXTRB reg/m8, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32.",
        "Op/ En": "A",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 16 /r ib VPEXTRD r32/m32, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/I2",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64.",
        "Op/ En": "A",
        "Opcode/Instruction": "VEX.128.66.0F3A.W1 16 /r ib VPEXTRQ r64/m64, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros.",
        "Op/ En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.WIG 14 /r ib VPEXTRB reg/m8, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32.",
        "Op/ En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 16 /r ib VPEXTRD r32/m32, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64.",
        "Op/ En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 16 /r ib VPEXTRQ r64/m64, xmm2, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.\nIn legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.\nNote: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L”L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
    "operationText": "CASE of\n    PEXTRB: SEL := COUNT[3:0];\n        TEMP := (Src >> SEL*8) AND FFH;\n        IF (DEST = Mem8)\n            THEN\n            Mem8 := TEMP[7:0];\n        ELSE IF (64-Bit Mode and 64-bit register selected)\n            THEN\n                R64[7:0] := TEMP[7:0];\n                r64[63:8] := ZERO_FILL; };\n        ELSE\n                R32[7:0] := TEMP[7:0];\n                r32[31:8] := ZERO_FILL; };\n        FI;\n    PEXTRD:SEL := COUNT[1:0];\n        TEMP := (Src >> SEL*32) AND FFFF_FFFFH;\n        DEST := TEMP;\n    PEXTRQ: SEL := COUNT[0];\n        TEMP := (Src >> SEL*64);\n        DEST := TEMP;\nEASC:\nIF (64-Bit Mode and 64-bit dest operand)\nTHEN\n    Src_Offset := imm8[0]\n    r64/m64 := (Src >> Src_Offset * 64)\nELSE\n    Src_Offset := imm8[1:0]\n    r32/m32 := ((Src >> Src_Offset *32) AND 0FFFFFFFFh);\nFI\nSRC_Offset := imm8[3:0]\nMem8 := (Src >> Src_Offset*8)\nIF (64-Bit Mode )\nTHEN\n    SRC_Offset := imm8[3:0]\n    DEST[7:0] := ((Src >> Src_Offset*8) AND 0FFh)\n    DEST[63:8] := ZERO_FILL;\nELSE\n    SRC_Offset := imm8[3:0];\n    DEST[7:0] := ((Src >> Src_Offset*8) AND 0FFh);\n    DEST[31:8] := ZERO_FILL;\nFI",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”",
        "Additionally:",
        "column_1: If VEX.vvvv != 1111B or EVEX.vvvv != 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfpclassps",
    "category": "Core Instructions",
    "instructionName": "VFPCLASSPS\n\t\t— Tests Types of Packed Float32 Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 66 /r ib VFPCLASSPS k2 {k1}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 66 /r ib VFPCLASSPS k2 {k1}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 66 /r ib VFPCLASSPS k2 {k1}, zmm2/m512/m32bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/haddpd",
    "category": "Core Instructions",
    "instructionName": "HADDPD\n\t\t— Packed Double Precision Floating-Point Horizontal Add",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Horizontal add packed double precision floating-point values from xmm2/m128 to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 7C /r HADDPD xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Horizontal add packed double precision floating-point values from xmm2 and xmm3/mem.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 7C /r VHADDPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Horizontal add packed double precision floating-point values from ymm2 and ymm3/mem.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 7C /r VHADDPD ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adds the double precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand.\nAdds the double precision floating-point values in the high and low quadwords of the source operand and stores the result in the high quadword of the destination operand.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nSee Figure 3-17 for HADDPD; see Figure 3-18 for VHADDPD.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "DEST[63:0] := SRC1[127:64] + SRC1[63:0]\nDEST[127:64] := SRC2[127:64] + SRC2[63:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := SRC1[127:64] + SRC1[63:0]\nDEST[127:64] := SRC2[127:64] + SRC2[63:0]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[127:64] + SRC1[63:0]\nDEST[127:64] := SRC2[127:64] + SRC2[63:0]\nDEST[191:128] := SRC1[255:192] + SRC1[191:128]\nDEST[255:192] := SRC2[255:192] + SRC2[191:128]",
    "flagsAffectedText": "",
    "exceptions": {
      "exceptions¶": [
        "When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."
      ],
      "numeric¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ],
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vblendmpd:vblendmps",
    "category": "Core Instructions",
    "instructionName": "VBLENDMPD/VBLENDMPS\n\t\t— Blend Float64/Float32 Vectors Using an OpMask Control",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Blend double precision vector xmm2 and double precision vector xmm3/m128/m64bcst and store the result in xmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 65 /r VBLENDMPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Blend double precision vector ymm2 and double precision vector ymm3/m256/m64bcst and store the result in ymm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 65 /r VBLENDMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Blend double precision vector zmm2 and double precision vector zmm3/m512/m64bcst and store the result in zmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 65 /r VBLENDMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Blend single precision vector xmm2 and single precision vector xmm3/m128/m32bcst and store the result in xmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 65 /r VBLENDMPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Blend single precision vector ymm2 and single precision vector ymm3/m256/m32bcst and store the result in ymm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 65 /r VBLENDMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Blend single precision vector zmm2 and single precision vector zmm3/m512/m32bcst using k1 as select control and store the result in zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 65 /r VBLENDMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/mov-1",
    "category": "Core Instructions",
    "instructionName": "MOV\n\t\t— Move to/from Control Registers",
    "detailsTable": [
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Move control register to r32.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F 20/r MOV r32, CR0–CR7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move extended control register to r64.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F 20/r MOV r64, CR0–CR7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move extended CR8 to r64.1",
        "Op/En": "MR",
        "Opcode/Instruction": "REX.R + 0F 20 /0 MOV r64, CR8"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Move r32 to control register.",
        "Op/En": "RM",
        "Opcode/Instruction": "0F 22 /r MOV CR0–CR7, r32"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move r64 to extended control register.",
        "Op/En": "RM",
        "Opcode/Instruction": "0F 22 /r MOV CR0–CR7, r64"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move r64 to extended CR8.1",
        "Op/En": "RM",
        "Opcode/Instruction": "REX.R + 0F 22 /0 MOV CR8, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Moves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) to a general-purpose register or the contents of a general-purpose register to a control register. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. On a 64-bit capable processor, an execution of MOV to CR outside of 64-bit mode zeros the upper 32 bits of the control register. (See “Control Registers” in Chapter 2 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for a detailed description of the flags and fields in the control registers.) This instruction can be executed only when the current privilege level is 0.\nAt the opcode level, the reg field within the ModR/M byte specifies which of the control registers is loaded or read. The 2 bits in the mod field are ignored. The r/m field specifies the general-purpose register loaded or read. Some of the bits in CR0, CR3, and CR4 are reserved and must be written with zeros. Attempting to set any reserved bits in CR0[31:0] is ignored. Attempting to set any reserved bits in CR0[63:32] results in a general-protection exception, #GP(0). When PCIDs are not enabled, bits 2:0 and bits 11:5 of CR3 are not used and attempts to set them are ignored. Attempting to set any reserved bits in CR3[63:MAXPHYADDR] results in #GP(0). Attempting to set any reserved bits in CR4 results in #GP(0). On Pentium 4, Intel Xeon and P6 family processors, CR0.ET remains set after any load of CR0; attempts to clear this bit have no impact.\nIn certain cases, these instructions have the side effect of invalidating entries in the TLBs and the paging-structure caches. See Section 4.10.4.1, “Operations that Invalidate TLBs and Paging-Structure Caches,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for details.\nThe following side effects are implementation-specific for the Pentium 4, Intel Xeon, and P6 processor family: when modifying PE or PG in register CR0, or PSE or PAE in register CR4, all TLB entries are flushed, including global entries. Software should not depend on this functionality in all Intel 64 or IA-32 processors.\nIn 64-bit mode, the instruction’s default operation size is 64 bits. The REX.R prefix must be used to access CR8. Use of REX.B permits access to additional registers (R8-R15). Use of the REX.W prefix or 66H prefix is ignored. Use\nof the REX.R prefix to specify a register other than CR8 causes an invalid-opcode exception. See the summary chart at the beginning of this section for encoding data and limits.\nIf CR4.PCIDE = 1, bit 63 of the source operand to MOV to CR3 determines whether the instruction invalidates entries in the TLBs and the paging-structure caches (see Section 4.10.4.1, “Operations that Invalidate TLBs and Paging-Structure Caches,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A). The instruction does not modify bit 63 of CR3, which is reserved and always 0.\nSee “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 26 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
    "operationText": "DEST := SRC;",
    "flagsAffectedText": "The OF, SF, ZF, AF, PF, and CF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: If an attempt is made to write invalid bit combinations in CR0 (such as setting the PG flag to 1 when the PE flag is set to 0, or setting the CD flag to 0 when the NW flag is set to 1).; \ncolumn_1: If an attempt is made to change CR4.PCIDE from 0 to 1 while CR3[11:0] ≠ 000H.; \ncolumn_1: If an attempt is made to clear CR0.PG[bit 31].; \ncolumn_1: If an attempt is made to write a 1 to any reserved bit in CR4.; \ncolumn_1: If an attempt is made to write a 1 to any reserved bit in CR8.; \ncolumn_1: If an attempt is made to write a 1 to any reserved bit in CR3[63:MAXPHYADDR].; \ncolumn_1: If an attempt is made to leave IA-32e mode by clearing CR4.PAE[bit 5].; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If an attempt is made to access CR1, CR5, CR6, CR7, or CR9–CR15.; \ncolumn_1: If the REX.R prefix is used to specify a register other than CR8.;"
      ],
      "compatibilityMode": [
        "column_1: If an attempt is made to write invalid bit combinations in CR0 (such as setting the PG flag to 1 when the PE flag is set to 0, or setting the CD flag to 0 when the NW flag is set to 1).; \ncolumn_1: If an attempt is made to change CR4.PCIDE from 0 to 1 while CR3[11:0] ≠ 000H.; \ncolumn_1: If an attempt is made to clear CR0.PG[bit 31] while CR4.PCIDE = 1.; \ncolumn_1: If an attempt is made to leave IA-32e mode by clearing CR4.PAE[bit 5].; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If an attempt is made to access CR1, CR5, CR6, CR7, or CR9–CR15.;"
      ],
      "protectedMode": [
        "column_1: If an attempt is made to write invalid bit combinations in CR0 (such as setting the PG flag to 1 when the PE flag is set to 0, or setting the CD flag to 0 when the NW flag is set to 1).; \ncolumn_1: If an attempt is made to write a 1 to any reserved bit in CR4.; \ncolumn_1: If an attempt is made to write 1 to CR4.PCIDE.; \ncolumn_1: If any of the reserved bits are set in the page-directory pointers table (PDPT) and the loading of a control register causes the PDPT to be loaded into the processor.; \ncolumn_1: If an attempt is made to activate IA-32e mode and either the current CS has the L-bit set or the TR references a 16-bit TSS.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If an attempt is made to access CR1, CR5, CR6, CR7, or CR9–CR15.;"
      ],
      "realAddressMode": [
        "column_1: If an attempt is made to write 1 to CR4.PCIDE.; \ncolumn_1: If an attempt is made to write invalid bit combinations in CR0 (such as setting the PG flag to 1 when the PE flag is set to 0).; \ncolumn_1: If an attempt is made to activate IA-32e mode and either the current CS has the L-bit set or the TR references a 16-bit TSS.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If an attempt is made to access CR1, CR5, CR6, CR7, or CR9–CR15.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/testui",
    "category": "Core Instructions",
    "instructionName": "TESTUI\n\t\t— Determine User Interrupt Flag",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "UINTR",
        "Description": "Copies the current value of UIF into EFLAGS.CF.",
        "Op/En": "ZO",
        "Opcode/Instruction": "F3 0F 01 ED TESTUI"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "CF := UIF;\nZF := AF := OF := PF := SF := 0;",
    "flagsAffectedText": "The ZF, OF, AF, PF, SF flags are cleared and the CF flags to the value of the user interrupt flag.",
    "exceptions": {
      "64BitMode": [
        "column_1: If executed inside an enclave.; \ncolumn_1: If CR4.UINTR = 0.; \ncolumn_1: If CPUID.07H.0H:EDX.UINTR[bit 5] = 0.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/insertps",
    "category": "Core Instructions",
    "instructionName": "INSERTPS\n\t\t— Insert Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 3A 21 /r ib INSERTPS xmm1, xmm2/m32, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Insert a single precision floating-point value selected by imm8 from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by imm8 and write out the result and zero out destination elements in xmm1 as indicated in imm8.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 21 /r ib VINSERTPS xmm1, xmm2, xmm3/m32, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Insert a single precision floating-point value selected by imm8 from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by imm8 and write out the result and zero out destination elements in xmm1 as indicated in imm8.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 21 /r ib VINSERTPS xmm1, xmm2, xmm3/m32, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "(register source form)\nCopy a single precision scalar floating-point element into a 128-bit vector register. The immediate operand has three fields, where the ZMask bits specify which elements of the destination will be set to zero, the Count_D bits specify which element of the destination will be overwritten with the scalar value, and for vector register sources the Count_S bits specify which element of the source will be copied. When the scalar source is a memory operand the Count_S bits are ignored.\n(memory source form)\nLoad a floating-point element from a 32-bit memory location and destination operand it into the first source at the location indicated by the Count_D bits of the immediate operand. Store in the destination and zero out destination elements based on the ZMask bits of the immediate operand.\n128-bit Legacy SSE version: The first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.\nVEX.128 and EVEX encoded version: The destination and first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\nIf VINSERTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
    "operationText": "IF (SRC = REG) THEN COUNT_S := imm8[7:6]\n    ELSE COUNT_S := 0\nCOUNT_D := imm8[5:4]\nZMASK := imm8[3:0]\nCASE (COUNT_S) OF\n    0: TMP := SRC2[31:0]\n    1: TMP := SRC2[63:32]\n    2: TMP := SRC2[95:64]\n    3: TMP := SRC2[127:96]\nESAC;\nCASE (COUNT_D) OF\n    0: TMP2[31:0] := TMP\n        TMP2[127:32] := SRC1[127:32]\n    1: TMP2[63:32] := TMP\n        TMP2[31:0] := SRC1[31:0]\n        TMP2[127:64] := SRC1[127:64]\n    2: TMP2[95:64] := TMP\n        TMP2[63:0] := SRC1[63:0]\n        TMP2[127:96] := SRC1[127:96]\n    3: TMP2[127:96] := TMP\n        TMP2[95:0] := SRC1[95:0]\nESAC;\nIF (ZMASK[0] = 1) THEN DEST[31:0] := 00000000H\n    ELSE DEST[31:0] := TMP2[31:0]\nIF (ZMASK[1] = 1) THEN DEST[63:32] := 00000000H\n    ELSE DEST[63:32] := TMP2[63:32]\nIF (ZMASK[2] = 1) THEN DEST[95:64] := 00000000H\n    ELSE DEST[95:64] := TMP2[95:64]\nIF (ZMASK[3] = 1) THEN DEST[127:96] := 00000000H\n    ELSE DEST[127:96] := TMP2[127:96]\nDEST[MAXVL-1:128] := 0\nIF (SRC = REG) THEN COUNT_S :=imm8[7:6]\n    ELSE COUNT_S :=0\nCOUNT_D := imm8[5:4]\nZMASK := imm8[3:0]\nCASE (COUNT_S) OF\n    0: TMP := SRC[31:0]\n    1: TMP := SRC[63:32]\n    2: TMP := SRC[95:64]\n    3: TMP := SRC[127:96]\nESAC;\nCASE (COUNT_D) OF\n    0: TMP2[31:0] := TMP\n        TMP2[127:32] := DEST[127:32]\n    1: TMP2[63:32] := TMP\n        TMP2[31:0] := DEST[31:0]\n        TMP2[127:64] := DEST[127:64]\n    2: TMP2[95:64] := TMP\n        TMP2[63:0] := DEST[63:0]\n        TMP2[127:96] := DEST[127:96]\n    3: TMP2[127:96] := TMP\n        TMP2[95:0] := DEST[95:0]\nESAC;\nIF (ZMASK[0] = 1) THEN DEST[31:0] := 00000000H\n    ELSE DEST[31:0] := TMP2[31:0]\nIF (ZMASK[1] = 1) THEN DEST[63:32] := 00000000H\n    ELSE DEST[63:32] := TMP2[63:32]\nIF (ZMASK[2] = 1) THEN DEST[95:64] := 00000000H\n    ELSE DEST[95:64] := TMP2[95:64]\nIF (ZMASK[3] = 1) THEN DEST[127:96] := 00000000H\n    ELSE DEST[127:96] := TMP2[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sal:sar:shl:shr",
    "category": "Core Instructions",
    "instructionName": "SAL/SAR/SHL/SHR\n\t\t— Shift",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m8 by 2, once.",
        "Instruction": "SAL r/m8, 1",
        "Op/En": "M1",
        "column_1": "D0 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m8 by 2, once.",
        "Instruction": "SAL r/m82, 1",
        "Op/En": "M1",
        "column_1": "REX + D0 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m8 by 2, CL times.",
        "Instruction": "SAL r/m8, CL",
        "Op/En": "MC",
        "column_1": "D2 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m8 by 2, CL times.",
        "Instruction": "SAL r/m82, CL",
        "Op/En": "MC",
        "column_1": "REX + D2 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m8 by 2, imm8 times.",
        "Instruction": "SAL r/m8, imm8",
        "Op/En": "MI",
        "column_1": "C0 /4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m8 by 2, imm8 times.",
        "Instruction": "SAL r/m82, imm8",
        "Op/En": "MI",
        "column_1": "REX + C0 /4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m16 by 2, once.",
        "Instruction": "SAL r/m16, 1",
        "Op/En": "M1",
        "column_1": "D1 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m16 by 2, CL times.",
        "Instruction": "SAL r/m16, CL",
        "Op/En": "MC",
        "column_1": "D3 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m16 by 2, imm8 times.",
        "Instruction": "SAL r/m16, imm8",
        "Op/En": "MI",
        "column_1": "C1 /4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m32 by 2, once.",
        "Instruction": "SAL r/m32, 1",
        "Op/En": "M1",
        "column_1": "D1 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m64 by 2, once.",
        "Instruction": "SAL r/m64, 1",
        "Op/En": "M1",
        "column_1": "REX.W + D1 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m32 by 2, CL times.",
        "Instruction": "SAL r/m32, CL",
        "Op/En": "MC",
        "column_1": "D3 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m64 by 2, CL times.",
        "Instruction": "SAL r/m64, CL",
        "Op/En": "MC",
        "column_1": "REX.W + D3 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m32 by 2, imm8 times.",
        "Instruction": "SAL r/m32, imm8",
        "Op/En": "MI",
        "column_1": "C1 /4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m64 by 2, imm8 times.",
        "Instruction": "SAL r/m64, imm8",
        "Op/En": "MI",
        "column_1": "REX.W + C1 /4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m8 by 2, once.",
        "Instruction": "SAR r/m8, 1",
        "Op/En": "M1",
        "column_1": "D0 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Signed divide3 r/m8 by 2, once.",
        "Instruction": "SAR r/m82, 1",
        "Op/En": "M1",
        "column_1": "REX + D0 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m8 by 2, CL times.",
        "Instruction": "SAR r/m8, CL",
        "Op/En": "MC",
        "column_1": "D2 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Signed divide3 r/m8 by 2, CL times.",
        "Instruction": "SAR r/m82, CL",
        "Op/En": "MC",
        "column_1": "REX + D2 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m8 by 2, imm8 times.",
        "Instruction": "SAR r/m8, imm8",
        "Op/En": "MI",
        "column_1": "C0 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Signed divide3 r/m8 by 2, imm8 times.",
        "Instruction": "SAR r/m82, imm8",
        "Op/En": "MI",
        "column_1": "REX + C0 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m16 by 2, once.",
        "Instruction": "SAR r/m16,1",
        "Op/En": "M1",
        "column_1": "D1 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m16 by 2, CL times.",
        "Instruction": "SAR r/m16, CL",
        "Op/En": "MC",
        "column_1": "D3 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m16 by 2, imm8 times.",
        "Instruction": "SAR r/m16, imm8",
        "Op/En": "MI",
        "column_1": "C1 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m32 by 2, once.",
        "Instruction": "SAR r/m32, 1",
        "Op/En": "M1",
        "column_1": "D1 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Signed divide3 r/m64 by 2, once.",
        "Instruction": "SAR r/m64, 1",
        "Op/En": "M1",
        "column_1": "REX.W + D1 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m32 by 2, CL times.",
        "Instruction": "SAR r/m32, CL",
        "Op/En": "MC",
        "column_1": "D3 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Signed divide3 r/m64 by 2, CL times.",
        "Instruction": "SAR r/m64, CL",
        "Op/En": "MC",
        "column_1": "REX.W + D3 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide3 r/m32 by 2, imm8 times.",
        "Instruction": "SAR r/m32, imm8",
        "Op/En": "MI",
        "column_1": "C1 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Signed divide3 r/m64 by 2, imm8 times",
        "Instruction": "SAR r/m64, imm8",
        "Op/En": "MI",
        "column_1": "REX.W + C1 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m8 by 2, once.",
        "Instruction": "SHL r/m8, 1",
        "Op/En": "M1",
        "column_1": "D0 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m8 by 2, once.",
        "Instruction": "SHL r/m82, 1",
        "Op/En": "M1",
        "column_1": "REX + D0 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m8 by 2, CL times.",
        "Instruction": "SHL r/m8, CL",
        "Op/En": "MC",
        "column_1": "D2 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m8 by 2, CL times.",
        "Instruction": "SHL r/m82, CL",
        "Op/En": "MC",
        "column_1": "REX + D2 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m8 by 2, imm8 times.",
        "Instruction": "SHL r/m8, imm8",
        "Op/En": "MI",
        "column_1": "C0 /4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Multiply r/m8 by 2, imm8 times.",
        "Instruction": "SHL r/m82, imm8",
        "Op/En": "MI",
        "column_1": "REX + C0 /4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m16 by 2, once.",
        "Instruction": "SHL r/m16,1",
        "Op/En": "M1",
        "column_1": "D1 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m16 by 2, CL times.",
        "Instruction": "SHL r/m16, CL",
        "Op/En": "MC",
        "column_1": "D3 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m16 by 2, imm8 times.",
        "Instruction": "SHL r/m16, imm8",
        "Op/En": "MI",
        "column_1": "C1 /4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multiply r/m32 by 2, once.",
        "Instruction": "SHL r/m32,1",
        "Op/En": "M1",
        "column_1": "D1 /4"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M1",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "1",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MC",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "CL",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.\nThe destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits with a 64-bit operand). The count range is limited to 0 to 31 (or 63 with a 64-bit operand). A special opcode encoding is provided for a count of 1.\nThe shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see Figure 7-7 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).\nThe shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction type. The SHR instruction clears the most significant bit (see Figure 7-8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1); the SAR instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills the empty bit position’s shifted value with the sign of the unshifted value (see Figure 7-9 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).\nThe SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2.\nUsing the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction. The quotient from the IDIV instruction is rounded toward zero, whereas the “quotient” of the SAR instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to shift -9 right by two bits, the result is -3 and the “remainder” is +3; however, the SAR instruction stores only the most significant bit of the remainder (in the CF flag).\nThe OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is set to 0 if the most-significant bit of the result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set to the most-significant bit of the original operand.\nIn 64-bit mode, the instruction’s default operation size is 32 bits and the mask width for CL is 5 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64-bits and sets the mask width for CL to 6 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF OperandSize = 64\n    THEN\n        countMASK := 3FH;\n    ELSE\n        countMASK := 1FH;\nFI\ntempCOUNT := (COUNT AND countMASK);\ntempDEST := DEST;\nWHILE (tempCOUNT ≠ 0)\nDO\n    IF instruction is SAL or SHL\n        THEN\n            CF := MSB(DEST);\n        ELSE (* Instruction is SAR or SHR *)\n            CF := LSB(DEST);\n    FI;\n    IF instruction is SAL or SHL\n        THEN\n            DEST := DEST ∗ 2;\n        ELSE\n            IF instruction is SAR\n                THEN\n                    DEST := DEST / 2; (* Signed divide, rounding toward negative infinity *)\n                ELSE (* Instruction is SHR *)\n                    DEST := DEST / 2 ; (* Unsigned divide *)\n            FI;\n    FI;\n    tempCOUNT := tempCOUNT – 1;\nOD;\n(* Determine overflow for the various instructions *)\nIF (COUNT and countMASK) = 1\n    THEN\n        IF instruction is SAL or SHL\n            THEN\n                OF := MSB(DEST) XOR CF;\n            ELSE\n                IF instruction is SAR\n                    THEN\n                        OF := 0;\n                    ELSE (* Instruction is SHR *)\n                        OF := MSB(tempDEST);\n                FI;\n        FI;\n    ELSE IF (COUNT AND countMASK) = 0\n        THEN\n            All flags unchanged;\n        ELSE (* COUNT not 1 or 0 *)\n            OF := undefined;\n    FI;\nFI;",
    "flagsAffectedText": "The CF flag contains the value of the last bit shifted out of the destination operand; it is undefined for SHL and SHR instructions where the count is greater than or equal to the size (in bits) of the destination operand. The OF flag is affected only for 1-bit shifts (see “Description” above); otherwise, it is undefined. The SF, ZF, and PF flags are set according to the result. If the count is 0, the flags are not affected. For a non-zero count, the AF flag is undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/jcc",
    "category": "Core Instructions",
    "instructionName": "Jcc\n\t\t— Jump if Condition Is Met",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if above (CF=0 and ZF=0).",
        "Instruction": "JA rel8",
        "Op/En": "D",
        "Opcode": "77 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if above or equal (CF=0).",
        "Instruction": "JAE rel8",
        "Op/En": "D",
        "Opcode": "73 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if below (CF=1).",
        "Instruction": "JB rel8",
        "Op/En": "D",
        "Opcode": "72 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if below or equal (CF=1 or ZF=1).",
        "Instruction": "JBE rel8",
        "Op/En": "D",
        "Opcode": "76 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if carry (CF=1).",
        "Instruction": "JC rel8",
        "Op/En": "D",
        "Opcode": "72 cb"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if CX register is 0.",
        "Instruction": "JCXZ rel8",
        "Op/En": "D",
        "Opcode": "E3 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if ECX register is 0.",
        "Instruction": "JECXZ rel8",
        "Op/En": "D",
        "Opcode": "E3 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Jump short if RCX register is 0.",
        "Instruction": "JRCXZ rel8",
        "Op/En": "D",
        "Opcode": "E3 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if equal (ZF=1).",
        "Instruction": "JE rel8",
        "Op/En": "D",
        "Opcode": "74 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if greater (ZF=0 and SF=OF).",
        "Instruction": "JG rel8",
        "Op/En": "D",
        "Opcode": "7F cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if greater or equal (SF=OF).",
        "Instruction": "JGE rel8",
        "Op/En": "D",
        "Opcode": "7D cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if less (SF≠ OF).",
        "Instruction": "JL rel8",
        "Op/En": "D",
        "Opcode": "7C cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if less or equal (ZF=1 or SF≠ OF).",
        "Instruction": "JLE rel8",
        "Op/En": "D",
        "Opcode": "7E cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not above (CF=1 or ZF=1).",
        "Instruction": "JNA rel8",
        "Op/En": "D",
        "Opcode": "76 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not above or equal (CF=1).",
        "Instruction": "JNAE rel8",
        "Op/En": "D",
        "Opcode": "72 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not below (CF=0).",
        "Instruction": "JNB rel8",
        "Op/En": "D",
        "Opcode": "73 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not below or equal (CF=0 and ZF=0).",
        "Instruction": "JNBE rel8",
        "Op/En": "D",
        "Opcode": "77 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not carry (CF=0).",
        "Instruction": "JNC rel8",
        "Op/En": "D",
        "Opcode": "73 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not equal (ZF=0).",
        "Instruction": "JNE rel8",
        "Op/En": "D",
        "Opcode": "75 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not greater (ZF=1 or SF≠ OF).",
        "Instruction": "JNG rel8",
        "Op/En": "D",
        "Opcode": "7E cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not greater or equal (SF≠ OF).",
        "Instruction": "JNGE rel8",
        "Op/En": "D",
        "Opcode": "7C cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not less (SF=OF).",
        "Instruction": "JNL rel8",
        "Op/En": "D",
        "Opcode": "7D cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not less or equal (ZF=0 and SF=OF).",
        "Instruction": "JNLE rel8",
        "Op/En": "D",
        "Opcode": "7F cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not overflow (OF=0).",
        "Instruction": "JNO rel8",
        "Op/En": "D",
        "Opcode": "71 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not parity (PF=0).",
        "Instruction": "JNP rel8",
        "Op/En": "D",
        "Opcode": "7B cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not sign (SF=0).",
        "Instruction": "JNS rel8",
        "Op/En": "D",
        "Opcode": "79 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if not zero (ZF=0).",
        "Instruction": "JNZ rel8",
        "Op/En": "D",
        "Opcode": "75 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if overflow (OF=1).",
        "Instruction": "JO rel8",
        "Op/En": "D",
        "Opcode": "70 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if parity (PF=1).",
        "Instruction": "JP rel8",
        "Op/En": "D",
        "Opcode": "7A cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if parity even (PF=1).",
        "Instruction": "JPE rel8",
        "Op/En": "D",
        "Opcode": "7A cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if parity odd (PF=0).",
        "Instruction": "JPO rel8",
        "Op/En": "D",
        "Opcode": "7B cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if sign (SF=1).",
        "Instruction": "JS rel8",
        "Op/En": "D",
        "Opcode": "78 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short if zero (ZF = 1).",
        "Instruction": "JZ rel8",
        "Op/En": "D",
        "Opcode": "74 cb"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if above (CF=0 and ZF=0). Not supported in 64-bit mode.",
        "Instruction": "JA rel16",
        "Op/En": "D",
        "Opcode": "0F 87 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if above (CF=0 and ZF=0).",
        "Instruction": "JA rel32",
        "Op/En": "D",
        "Opcode": "0F 87 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if above or equal (CF=0). Not supported in 64-bit mode.",
        "Instruction": "JAE rel16",
        "Op/En": "D",
        "Opcode": "0F 83 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if above or equal (CF=0).",
        "Instruction": "JAE rel32",
        "Op/En": "D",
        "Opcode": "0F 83 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if below (CF=1). Not supported in 64-bit mode.",
        "Instruction": "JB rel16",
        "Op/En": "D",
        "Opcode": "0F 82 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if below (CF=1).",
        "Instruction": "JB rel32",
        "Op/En": "D",
        "Opcode": "0F 82 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if below or equal (CF=1 or ZF=1). Not supported in 64-bit mode.",
        "Instruction": "JBE rel16",
        "Op/En": "D",
        "Opcode": "0F 86 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if below or equal (CF=1 or ZF=1).",
        "Instruction": "JBE rel32",
        "Op/En": "D",
        "Opcode": "0F 86 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if carry (CF=1). Not supported in 64-bit mode.",
        "Instruction": "JC rel16",
        "Op/En": "D",
        "Opcode": "0F 82 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if carry (CF=1).",
        "Instruction": "JC rel32",
        "Op/En": "D",
        "Opcode": "0F 82 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if equal (ZF=1). Not supported in 64-bit mode.",
        "Instruction": "JE rel16",
        "Op/En": "D",
        "Opcode": "0F 84 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if equal (ZF=1).",
        "Instruction": "JE rel32",
        "Op/En": "D",
        "Opcode": "0F 84 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if 0 (ZF=1). Not supported in 64-bit mode.",
        "Instruction": "JZ rel16",
        "Op/En": "D",
        "Opcode": "0F 84 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if 0 (ZF=1).",
        "Instruction": "JZ rel32",
        "Op/En": "D",
        "Opcode": "0F 84 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if greater (ZF=0 and SF=OF). Not supported in 64-bit mode.",
        "Instruction": "JG rel16",
        "Op/En": "D",
        "Opcode": "0F 8F cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if greater (ZF=0 and SF=OF).",
        "Instruction": "JG rel32",
        "Op/En": "D",
        "Opcode": "0F 8F cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if greater or equal (SF=OF). Not supported in 64-bit mode.",
        "Instruction": "JGE rel16",
        "Op/En": "D",
        "Opcode": "0F 8D cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if greater or equal (SF=OF).",
        "Instruction": "JGE rel32",
        "Op/En": "D",
        "Opcode": "0F 8D cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if less (SF≠ OF). Not supported in 64-bit mode.",
        "Instruction": "JL rel16",
        "Op/En": "D",
        "Opcode": "0F 8C cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if less (SF≠ OF).",
        "Instruction": "JL rel32",
        "Op/En": "D",
        "Opcode": "0F 8C cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if less or equal (ZF=1 or SF≠ OF). Not supported in 64-bit mode.",
        "Instruction": "JLE rel16",
        "Op/En": "D",
        "Opcode": "0F 8E cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if less or equal (ZF=1 or SF≠ OF).",
        "Instruction": "JLE rel32",
        "Op/En": "D",
        "Opcode": "0F 8E cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not above (CF=1 or ZF=1). Not supported in 64-bit mode.",
        "Instruction": "JNA rel16",
        "Op/En": "D",
        "Opcode": "0F 86 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not above (CF=1 or ZF=1).",
        "Instruction": "JNA rel32",
        "Op/En": "D",
        "Opcode": "0F 86 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not above or equal (CF=1). Not supported in 64-bit mode.",
        "Instruction": "JNAE rel16",
        "Op/En": "D",
        "Opcode": "0F 82 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not above or equal (CF=1).",
        "Instruction": "JNAE rel32",
        "Op/En": "D",
        "Opcode": "0F 82 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not below (CF=0). Not supported in 64-bit mode.",
        "Instruction": "JNB rel16",
        "Op/En": "D",
        "Opcode": "0F 83 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not below (CF=0).",
        "Instruction": "JNB rel32",
        "Op/En": "D",
        "Opcode": "0F 83 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not below or equal (CF=0 and ZF=0). Not supported in 64-bit mode.",
        "Instruction": "JNBE rel16",
        "Op/En": "D",
        "Opcode": "0F 87 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not below or equal (CF=0 and ZF=0).",
        "Instruction": "JNBE rel32",
        "Op/En": "D",
        "Opcode": "0F 87 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not carry (CF=0). Not supported in 64-bit mode.",
        "Instruction": "JNC rel16",
        "Op/En": "D",
        "Opcode": "0F 83 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not carry (CF=0).",
        "Instruction": "JNC rel32",
        "Op/En": "D",
        "Opcode": "0F 83 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not equal (ZF=0). Not supported in 64-bit mode.",
        "Instruction": "JNE rel16",
        "Op/En": "D",
        "Opcode": "0F 85 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not equal (ZF=0).",
        "Instruction": "JNE rel32",
        "Op/En": "D",
        "Opcode": "0F 85 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not greater (ZF=1 or SF≠ OF). Not supported in 64-bit mode.",
        "Instruction": "JNG rel16",
        "Op/En": "D",
        "Opcode": "0F 8E cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not greater (ZF=1 or SF≠ OF).",
        "Instruction": "JNG rel32",
        "Op/En": "D",
        "Opcode": "0F 8E cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not greater or equal (SF≠ OF). Not supported in 64-bit mode.",
        "Instruction": "JNGE rel16",
        "Op/En": "D",
        "Opcode": "0F 8C cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not greater or equal (SF≠ OF).",
        "Instruction": "JNGE rel32",
        "Op/En": "D",
        "Opcode": "0F 8C cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not less (SF=OF). Not supported in 64-bit mode.",
        "Instruction": "JNL rel16",
        "Op/En": "D",
        "Opcode": "0F 8D cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not less (SF=OF).",
        "Instruction": "JNL rel32",
        "Op/En": "D",
        "Opcode": "0F 8D cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not less or equal (ZF=0 and SF=OF). Not supported in 64-bit mode.",
        "Instruction": "JNLE rel16",
        "Op/En": "D",
        "Opcode": "0F 8F cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not less or equal (ZF=0 and SF=OF).",
        "Instruction": "JNLE rel32",
        "Op/En": "D",
        "Opcode": "0F 8F cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not overflow (OF=0). Not supported in 64-bit mode.",
        "Instruction": "JNO rel16",
        "Op/En": "D",
        "Opcode": "0F 81 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not overflow (OF=0).",
        "Instruction": "JNO rel32",
        "Op/En": "D",
        "Opcode": "0F 81 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not parity (PF=0). Not supported in 64-bit mode.",
        "Instruction": "JNP rel16",
        "Op/En": "D",
        "Opcode": "0F 8B cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not parity (PF=0).",
        "Instruction": "JNP rel32",
        "Op/En": "D",
        "Opcode": "0F 8B cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not sign (SF=0). Not supported in 64-bit mode.",
        "Instruction": "JNS rel16",
        "Op/En": "D",
        "Opcode": "0F 89 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not sign (SF=0).",
        "Instruction": "JNS rel32",
        "Op/En": "D",
        "Opcode": "0F 89 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not zero (ZF=0). Not supported in 64-bit mode.",
        "Instruction": "JNZ rel16",
        "Op/En": "D",
        "Opcode": "0F 85 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if not zero (ZF=0).",
        "Instruction": "JNZ rel32",
        "Op/En": "D",
        "Opcode": "0F 85 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if overflow (OF=1). Not supported in 64-bit mode.",
        "Instruction": "JO rel16",
        "Op/En": "D",
        "Opcode": "0F 80 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if overflow (OF=1).",
        "Instruction": "JO rel32",
        "Op/En": "D",
        "Opcode": "0F 80 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if parity (PF=1). Not supported in 64-bit mode.",
        "Instruction": "JP rel16",
        "Op/En": "D",
        "Opcode": "0F 8A cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if parity (PF=1).",
        "Instruction": "JP rel32",
        "Op/En": "D",
        "Opcode": "0F 8A cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if parity even (PF=1). Not supported in 64-bit mode.",
        "Instruction": "JPE rel16",
        "Op/En": "D",
        "Opcode": "0F 8A cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if parity even (PF=1).",
        "Instruction": "JPE rel32",
        "Op/En": "D",
        "Opcode": "0F 8A cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if parity odd (PF=0). Not supported in 64-bit mode.",
        "Instruction": "JPO rel16",
        "Op/En": "D",
        "Opcode": "0F 8B cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if parity odd (PF=0).",
        "Instruction": "JPO rel32",
        "Op/En": "D",
        "Opcode": "0F 8B cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if sign (SF=1). Not supported in 64-bit mode.",
        "Instruction": "JS rel16",
        "Op/En": "D",
        "Opcode": "0F 88 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if sign (SF=1).",
        "Instruction": "JS rel32",
        "Op/En": "D",
        "Opcode": "0F 88 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if 0 (ZF=1). Not supported in 64-bit mode.",
        "Instruction": "JZ rel16",
        "Op/En": "D",
        "Opcode": "0F 84 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near if 0 (ZF=1).",
        "Instruction": "JZ rel32",
        "Op/En": "D",
        "Opcode": "0F 84 cd"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "D",
        "Operand 1": "Offset",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.\nThe conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.\nBecause a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.\nThe Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:\nJZ FARLABEL;\nTo accomplish this far jump, use the following two instructions:\nJNZ BEYOND;\nJMP FARLABEL;\nBEYOND:\nThe JRCXZ, JECXZ, and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).\nAll conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.\nIn 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
    "operationText": "IF condition\n    THEN\n        tempEIP := EIP + SignExtend(DEST);\n        IF OperandSize = 16\n            THEN tempEIP := tempEIP AND 0000FFFFH;\n        FI;\n    IF tempEIP is not within code segment limit\n        THEN #GP(0);\n        ELSE EIP := tempEIP\n    FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/shufps",
    "category": "Core Instructions",
    "instructionName": "SHUFPS\n\t\t— Packed Interleave Shuffle of Quadruplets of Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Select from quadruplet of single precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F C6 /r ib SHUFPS xmm1, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Select from quadruplet of single precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG C6 /r ib VSHUFPS xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Select from quadruplet of single precision floating-point values in ymm2 and ymm3/m256 using imm8, interleaved result pairs are stored in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG C6 /r ib VSHUFPS ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Select from quadruplet of single precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1, subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 C6 /r ib VSHUFPS xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Select from quadruplet of single precision floating-point values in ymm2 and ymm3/m256 using imm8, interleaved result pairs are stored in ymm1, subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 C6 /r ib VSHUFPS ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Select from quadruplet of single precision floating-point values in zmm2 and zmm3/m512 using imm8, interleaved result pairs are stored in zmm1, subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 C6 /r ib VSHUFPS zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Selects a single precision floating-point value of an input quadruplet using a two-bit control and move to a designated element of the destination operand. Each 64-bit element-pair of a 128-bit lane of the destination operand is interleaved between the corresponding lane of the first source operand and the second source operand at the granularity 128 bits. Each two bits in the imm8 byte, starting from bit 0, is the select control of the corresponding element of a 128-bit lane of the destination to received the shuffled result of an input quadruplet. The two lower elements of a 128-bit lane in the destination receives shuffle results from the quadruple of the first source operand. The next two elements of the destination receives shuffle results from the quadruple of the second source operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask. imm8[7:0] provides 4 select controls for each applicable 128-bit lane of the destination.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Imm8[7:0] provides 4 select controls for the high and low 128-bit of the destination.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed. Imm8[7:0] provides 4 select controls for each element of the destination.\n128-bit Legacy SSE version: The source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. Imm8[7:0] provides 4 select controls for each element of the destination.",
    "operationText": "Select4(SRC, control) {\nCASE (control[1:0]) OF\n    0: TMP := SRC[31:0];\n    1: TMP := SRC[63:32];\n    2: TMP := SRC[95:64];\n    3: TMP := SRC[127:96];\nESAC;\nRETURN TMP\n}\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nTMP_DEST[31:0] := Select4(SRC1[127:0], imm8[1:0]);\nTMP_DEST[63:32] := Select4(SRC1[127:0], imm8[3:2]);\nTMP_DEST[95:64] := Select4(SRC2[127:0], imm8[5:4]);\nTMP_DEST[127:96] := Select4(SRC2[127:0], imm8[7:6]);\nIF VL >= 256\n    TMP_DEST[159:128] := Select4(SRC1[255:128], imm8[1:0]);\n    TMP_DEST[191:160] := Select4(SRC1[255:128], imm8[3:2]);\n    TMP_DEST[223:192] := Select4(SRC2[255:128], imm8[5:4]);\n    TMP_DEST[255:224] := Select4(SRC2[255:128], imm8[7:6]);\nFI;\nIF VL >= 512\n    TMP_DEST[287:256] := Select4(SRC1[383:256], imm8[1:0]);\n    TMP_DEST[319:288] := Select4(SRC1[383:256], imm8[3:2]);\n    TMP_DEST[351:320] := Select4(SRC2[383:256], imm8[5:4]);\n    TMP_DEST[383:352] := Select4(SRC2[383:256], imm8[7:6]);\n    TMP_DEST[415:384] := Select4(SRC1[511:384], imm8[1:0]);\n    TMP_DEST[447:416] := Select4(SRC1[511:384], imm8[3:2]);\n    TMP_DEST[479:448] := Select4(SRC2[511:384], imm8[5:4]);\n    TMP_DEST[511:480] := Select4(SRC2[511:384], imm8[7:6]);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF (EVEX.b = 1)\n        THEN TMP_SRC2[i+31:i] := SRC2[31:0]\n        ELSE TMP_SRC2[i+31:i] := SRC2[i+31:i]\n    FI;\nENDFOR;\nTMP_DEST[31:0] := Select4(SRC1[127:0], imm8[1:0]);\nTMP_DEST[63:32] := Select4(SRC1[127:0], imm8[3:2]);\nTMP_DEST[95:64] := Select4(TMP_SRC2[127:0], imm8[5:4]);\nTMP_DEST[127:96] := Select4(TMP_SRC2[127:0], imm8[7:6]);\nIF VL >= 256\n    TMP_DEST[159:128] := Select4(SRC1[255:128], imm8[1:0]);\n    TMP_DEST[191:160] := Select4(SRC1[255:128], imm8[3:2]);\n    TMP_DEST[223:192] := Select4(TMP_SRC2[255:128], imm8[5:4]);\n    TMP_DEST[255:224] := Select4(TMP_SRC2[255:128], imm8[7:6]);\nFI;\nIF VL >= 512\n    TMP_DEST[287:256] := Select4(SRC1[383:256], imm8[1:0]);\n    TMP_DEST[319:288] := Select4(SRC1[383:256], imm8[3:2]);\n    TMP_DEST[351:320] := Select4(TMP_SRC2[383:256], imm8[5:4]);\n    TMP_DEST[383:352] := Select4(TMP_SRC2[383:256], imm8[7:6]);\n    TMP_DEST[415:384] := Select4(SRC1[511:384], imm8[1:0]);\n    TMP_DEST[447:416] := Select4(SRC1[511:384], imm8[3:2]);\n    TMP_DEST[479:448] := Select4(TMP_SRC2[511:384], imm8[5:4]);\n    TMP_DEST[511:480] := Select4(TMP_SRC2[511:384], imm8[7:6]);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := Select4(SRC1[127:0], imm8[1:0]);\nDEST[63:32] := Select4(SRC1[127:0], imm8[3:2]);\nDEST[95:64] := Select4(SRC2[127:0], imm8[5:4]);\nDEST[127:96] := Select4(SRC2[127:0], imm8[7:6]);\nDEST[159:128] := Select4(SRC1[255:128], imm8[1:0]);\nDEST[191:160] := Select4(SRC1[255:128], imm8[3:2]);\nDEST[223:192] := Select4(SRC2[255:128], imm8[5:4]);\nDEST[255:224] := Select4(SRC2[255:128], imm8[7:6]);\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := Select4(SRC1[127:0], imm8[1:0]);\nDEST[63:32] := Select4(SRC1[127:0], imm8[3:2]);\nDEST[95:64] := Select4(SRC2[127:0], imm8[5:4]);\nDEST[127:96] := Select4(SRC2[127:0], imm8[7:6]);\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Select4(SRC1[127:0], imm8[1:0]);\nDEST[63:32] := Select4(SRC1[127:0], imm8[3:2]);\nDEST[95:64] := Select4(SRC2[127:0], imm8[5:4]);\nDEST[127:96] := Select4(SRC2[127:0], imm8[7:6]);\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pop",
    "category": "Core Instructions",
    "instructionName": "POP\n\t\t— Pop a Value From the Stack",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into m16; increment stack pointer.",
        "Instruction": "POP r/m16",
        "Op/En": "M",
        "Opcode": "8F /0"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into m32; increment stack pointer.",
        "Instruction": "POP r/m32",
        "Op/En": "M",
        "Opcode": "8F /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size.",
        "Instruction": "POP r/m64",
        "Op/En": "M",
        "Opcode": "8F /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into r16; increment stack pointer.",
        "Instruction": "POP r16",
        "Op/En": "O",
        "Opcode": "58+ rw"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into r32; increment stack pointer.",
        "Instruction": "POP r32",
        "Op/En": "O",
        "Opcode": "58+ rd"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size.",
        "Instruction": "POP r64",
        "Op/En": "O",
        "Opcode": "58+ rd"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into DS; increment stack pointer.",
        "Instruction": "POP DS",
        "Op/En": "ZO",
        "Opcode": "1F"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into ES; increment stack pointer.",
        "Instruction": "POP ES",
        "Op/En": "ZO",
        "Opcode": "07"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into SS; increment stack pointer.",
        "Instruction": "POP SS",
        "Op/En": "ZO",
        "Opcode": "17"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into FS; increment stack pointer by 16 bits.",
        "Instruction": "POP FS",
        "Op/En": "ZO",
        "Opcode": "0F A1"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into FS; increment stack pointer by 32 bits.",
        "Instruction": "POP FS",
        "Op/En": "ZO",
        "Opcode": "0F A1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Pop top of stack into FS; increment stack pointer by 64 bits.",
        "Instruction": "POP FS",
        "Op/En": "ZO",
        "Opcode": "0F A1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into GS; increment stack pointer by 16 bits.",
        "Instruction": "POP GS",
        "Op/En": "ZO",
        "Opcode": "0F A9"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Pop top of stack into GS; increment stack pointer by 32 bits.",
        "Instruction": "POP GS",
        "Op/En": "ZO",
        "Opcode": "0F A9"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Pop top of stack into GS; increment stack pointer by 64 bits.",
        "Instruction": "POP GS",
        "Op/En": "ZO",
        "Opcode": "0F A9"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "O",
        "Operand 1": "opcode + rd (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode) and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.\nAddress and operand sizes are determined and used as follows:\nThe address size is used only when writing to a destination operand in memory.\nThe operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is incremented (2, 4 or 8).\nThe stack-address size determines the width of the stack pointer when reading from the stack in memory and when incrementing the stack pointer. (As stated above, the amount by which the stack pointer is incremented is determined by the operand size.)\nIf the destination operand is one of the segment registers DS, ES, FS, GS, or SS, the value loaded into the register must be a valid segment selector. In protected mode, popping a segment selector into a segment register automat-\nically causes the descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register and causes the selector and the descriptor information to be validated (see the “Operation” section below).\nA NULL value (0000-0003) may be popped into the DS, ES, FS, or GS register without causing a general protection fault. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a NULL value causes a general protection exception (#GP). In this situation, no memory reference occurs and the saved value of the segment register is NULL.\nThe POP instruction cannot pop a value into the CS register. To load the CS register from the stack, use the RET instruction.\nIf the ESP register is used as a base register for addressing a destination operand in memory, the POP instruction computes the effective address of the operand after it increments the ESP register. For the case of a 16-bit stack where ESP wraps to 0H as a result of the POP instruction, the resulting location of the memory write is processor-family-specific.\nThe POP ESP instruction increments the stack pointer (ESP) before data at the old top of stack is written into the destination.\nLoading the SS register with a POP instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the ESP register with the next instruction (POP ESP) before an event can be delivered. See Section 6.8.3, “Masking Exceptions and Interrupts When Switching Stacks,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. Intel recommends that software use the LSS instruction to load the SS register and ESP together.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). When in 64-bit mode, POPs using 32-bit operands are not encodable and POPs to DS, ES, SS are not valid. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF StackAddrSize = 32\n    THEN\n        IF OperandSize = 32\n                THEN\n                    DEST := SS:ESP; (* Copy a doubleword *)\n                    ESP := ESP + 4;\n                ELSE (* OperandSize = 16*)\n                    DEST := SS:ESP; (* Copy a word *)\n                    ESP := ESP + 2;\n        FI;\n    ELSE IF StackAddrSize = 64\n        THEN\n                IF OperandSize = 64\n                    THEN\n                        DEST := SS:RSP; (* Copy quadword *)\n                        RSP := RSP + 8;\n                    ELSE (* OperandSize = 16*)\n                        DEST := SS:RSP; (* Copy a word *)\n                        RSP := RSP + 2;\n                FI;\n        FI;\n    ELSE StackAddrSize = 16\n        THEN\n                IF OperandSize = 16\n                    THEN\n                        DEST := SS:SP; (* Copy a word *)\n                        SP := SP + 2;\n                    ELSE (* OperandSize = 32 *)\n                        DEST := SS:SP; (* Copy a doubleword *)\n                        SP := SP + 4;\n                FI;\nFI;\nLoading a segment register while in protected mode results in special actions, as described in the following listing.\nThese checks are performed on the segment selector and the segment descriptor it points to.\n64-BIT_MODE\nIF FS, or GS is loaded with non-NULL selector;\n    THEN\n        IF segment selector index is outside descriptor table limits\n                OR segment is not a data or readable code segment\n                OR ((segment is a data or nonconforming code segment)\n                    AND ((RPL > DPL) or (CPL > DPL))\n                        THEN #GP(selector);\n                IF segment not marked present\n                    THEN #NP(selector);\n        ELSE\n                SegmentRegister := segment selector;\n                SegmentRegister := segment descriptor;\n        FI;\nFI;\nIF FS, or GS is loaded with a NULL selector;\n        THEN\n                SegmentRegister := segment selector;\n                SegmentRegister := segment descriptor;\nFI;\nPREOTECTED MODE OR COMPATIBILITY MODE;\nIF SS is loaded;\n    THEN\n        IF segment selector is NULL\n                THEN #GP(0);\n        FI;\n        IF segment selector index is outside descriptor table limits\n                or segment selector's RPL ≠ CPL\n                or segment is not a writable data segment\n                or DPL ≠ CPL\n                    THEN #GP(selector);\n        FI;\n        IF segment not marked present\n                THEN #SS(selector);\n                ELSE\n                    SS := segment selector;\n                    SS := segment descriptor;\n        FI;\nFI;\nIF DS, ES, FS, or GS is loaded with non-NULL selector;\n    THEN\n        IF segment selector index is outside descriptor table limits\n                or segment is not a data or readable code segment\n                or ((segment is a data or nonconforming code segment)\n                and ((RPL > DPL) or (CPL > DPL))\n                    THEN #GP(selector);\n        FI;\n        IF segment not marked present\n                THEN #NP(selector);\n                ELSE\n                    SegmentRegister := segment selector;\n                    SegmentRegister := segment descriptor;\n            FI;\nFI;\nIF DS, ES, FS, or GS is loaded with a NULL selector\n    THEN\n        SegmentRegister := segment selector;\n        SegmentRegister := segment descriptor;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_2: If the stack address is in a non-canonical form.; column_1: #SS(0); \ncolumn_1: #GP(selector); column_2: If the descriptor is outside the descriptor table limit.; \ncolumn_1: If the FS or GS register is being loaded and the segment pointed to is not a data or readable code segment.; \ncolumn_1: If the FS or GS register is being loaded and the segment pointed to is a data or nonconforming code segment, but both the RPL and the CPL are greater than the DPL.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while alignment checking is enabled.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NP; column_2: If the FS or GS register is being loaded and the segment pointed to is marked not present.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If the DS, ES, or SS register is being loaded.;"
      ],
      "compatibilityMode": [
        "Same as for protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: If the destination operand is in a non-writable segment.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #GP(selector); column_2: If segment selector index is outside descriptor table limits.; \ncolumn_1: If the SS register is being loaded and the segment selector's RPL and the segment descriptor’s DPL are not equal to the CPL.; \ncolumn_1: If the SS register is being loaded and the segment pointed to is a non-writable data segment.; \ncolumn_1: If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable code segment.; \ncolumn_1: If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment, but both the RPL and the CPL are greater than the DPL.; \ncolumn_1: #SS(0); column_2: If the current top of stack is not within the stack segment.; \ncolumn_1: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #SS(selector); column_2: If the SS register is being loaded and the segment pointed to is marked not present.; \ncolumn_1: #NP; column_2: If the DS, ES, FS, or GS register is being loaded and the segment pointed to is marked not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmovmskb",
    "category": "Core Instructions",
    "instructionName": "PMOVMSKB\n\t\t— Move Byte Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F D7 /r1 PMOVMSKB reg, mm"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F D7 /r PMOVMSKB reg, xmm"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move a byte mask of xmm1 to reg. The upper bits of r32 or r64 are filled with zeros.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D7 /r VPMOVMSKB reg, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Move a 32-bit mask of ymm1 to reg. The upper bits of r64 are filled with zeros.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D7 /r VPMOVMSKB reg, ymm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores the result in the low byte or word of the destination operand (first operand).\nThe byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit source operand and 32 bits for 256-bit source operand. The destination operand is a general-purpose register.\nIn 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.\nLegacy SSE version: The source operand is an MMX technology register.\n128-bit Legacy SSE version: The source operand is an XMM register.\nVEX.128 encoded version: The source operand is an XMM register.\nVEX.256 encoded version: The source operand is a YMM register.\nNote: VEX.vvvv is reserved and must be 1111b.",
    "operationText": "r32[0] := SRC[7];\nr32[1] := SRC[15];\n(* Repeat operation for bytes 2 through 6 *)\nr32[7] := SRC[63];\nr32[31:8] := ZERO_FILL;\nr32[0] := SRC[7];\nr32[1] := SRC[15];\n(* Repeat operation for bytes 2 through 14 *)\nr32[15] := SRC[127];\nr32[31:16] := ZERO_FILL;\nr32[0] := SRC[7];\nr32[1] := SRC[15];\n(* Repeat operation for bytes 3rd through 31*)\nr32[31] := SRC[255];\nr64[0] := SRC[7];\nr64[1] := SRC[15];\n(* Repeat operation for bytes 2 through 6 *)\nr64[7] := SRC[63];\nr64[63:8] := ZERO_FILL;\nr64[0] := SRC[7];\nr64[1] := SRC[15];\n(* Repeat operation for bytes 2 through 14 *)\nr64[15] := SRC[127];\nr64[63:16] := ZERO_FILL;\nr64[0] := SRC[7];\nr64[1] := SRC[15];\n(* Repeat operation for bytes 2 through 31*)\nr64[31] := SRC[255];\nr64[63:32] := ZERO_FILL;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "See Table 2-24, “Type 7 Class Exception Conditions,” additionally:",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrangepd",
    "category": "Core Instructions",
    "instructionName": "VRANGEPD\n\t\t— Range Restriction Calculation for Packed Pairs of Float64 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Calculate two RANGE operation output value from 2 pairs of double precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 50 /r ib VRANGEPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Calculate four RANGE operation output value from 4pairs of double precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 50 /r ib VRANGEPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Calculate eight RANGE operation output value from 8 pairs of double precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 50 /r ib VRANGEPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pminsd:pminsq",
    "category": "Core Instructions",
    "instructionName": "PMINSD/PMINSQ\n\t\t— Minimum of Packed Signed Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
        "Op/E n": "A",
        "Opcode/Instruction": "66 0F 38 39 /r PMINSD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.",
        "Op/E n": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 39 /r VPMINSD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1.",
        "Op/E n": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 39 /r VPMINSD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 39 /r VPMINSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 39 /r VPMINSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 39 /r VPMINSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed qword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 39 /r VPMINSQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed qword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 39 /r VPMINSQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 39 /r VPMINSQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed signed dword or qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "IF DEST[31:0] < SRC[31:0] THEN\n        DEST[31:0] := DEST[31:0];\n    ELSE\n        DEST[31:0] := SRC[31:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF DEST[127:96] < SRC[127:96] THEN\n        DEST[127:96] := DEST[127:96];\n    ELSE\n        DEST[127:96] := SRC[127:96]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[31:0] < SRC2[31:0] THEN\n        DEST[31:0] := SRC1[31:0];\n    ELSE\n        DEST[31:0] := SRC2[31:0]; FI;\n    (* Repeat operation for 2nd through 3rd dwords in source and destination operands *)\n    IF SRC1[127:96] < SRC2[127:96] THEN\n        DEST[127:96] := SRC1[127:96];\n    ELSE\n        DEST[127:96] := SRC2[127:96]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[31:0] < SRC2[31:0] THEN\n        DEST[31:0] := SRC1[31:0];\n    ELSE\n        DEST[31:0] := SRC2[31:0]; FI;\n    (* Repeat operation for 2nd through 7th dwords in source and destination operands *)\n    IF SRC1[255:224] < SRC2[255:224] THEN\n        DEST[255:224] := SRC1[255:224];\n    ELSE\n        DEST[255:224] := SRC2[255:224]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n        IF (EVEX.b = 1) AND (SRC2 *is memory*)\n            THEN\n                IF SRC1[i+31:i] < SRC2[31:0]\n                    THEN DEST[i+31:i] := SRC1[i+31:i];\n                    ELSE DEST[i+31:i] := SRC2[31:0];\n                FI;\n            ELSE\n                IF SRC1[i+31:i] < SRC2[i+31:i]\n                    THEN DEST[i+31:i] := SRC1[i+31:i];\n                    ELSE DEST[i+31:i] := SRC2[i+31:i];\n            FI;\n        FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n        IF (EVEX.b = 1) AND (SRC2 *is memory*)\n            THEN\n                IF SRC1[i+63:i] < SRC2[63:0]\n                    THEN DEST[i+63:i] := SRC1[i+63:i];\n                    ELSE DEST[i+63:i] := SRC2[63:0];\n                FI;\n            ELSE\n                IF SRC1[i+63:i] < SRC2[i+63:i]\n                    THEN DEST[i+63:i] := SRC1[i+63:i];\n                    ELSE DEST[i+63:i] := SRC2[i+63:i];\n            FI;\n        FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ewb",
    "category": "SGX Instructions",
    "instructionName": "EWB\n\t\t— Invalidate an EPC Page and Write out to Main Memory",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function invalidates an EPC page and writes it out to main memory.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 0BH ENCLS[EWB]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EWB (In)",
        "column_3": "Error code (Out)",
        "column_4": "Address of an PAGEINFO (In)",
        "column_5": "Address of the EPC page (In)",
        "column_6": "Address of a VA slot (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmultishiftqb",
    "category": "Core Instructions",
    "instructionName": "VPMULTISHIFTQB\n\t\t— Select Packed Unaligned Bytes From Quadword Sources",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI AVX512VL",
        "Description": "Select unaligned bytes from qwords in xmm3/m128/m64bcst using control bytes in xmm2, write byte results to xmm1 under k1.",
        "Op/En": "A",
        "Opcode / Instruction": "EVEX.128.66.0F38.W1 83 /r VPMULTISHIFTQB xmm1 {k1}{z}, xmm2,xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI AVX512VL",
        "Description": "Select unaligned bytes from qwords in ymm3/m256/m64bcst using control bytes in ymm2, write byte results to ymm1 under k1.",
        "Op/En": "A",
        "Opcode / Instruction": "EVEX.256.66.0F38.W1 83 /r VPMULTISHIFTQB ymm1 {k1}{z}, ymm2,ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI",
        "Description": "Select unaligned bytes from qwords in zmm3/m512/m64bcst using control bytes in zmm2, write byte results to zmm1 under k1.",
        "Op/En": "A",
        "Opcode / Instruction": "EVEX.512.66.0F38.W1 83 /r VPMULTISHIFTQB zmm1 {k1}{z}, zmm2,zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fsub:fsubp:fisub",
    "category": "Core Instructions",
    "instructionName": "FSUB/FSUBP/FISUB\n\t\t— Subtract",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract m32fp from ST(0) and store result in ST(0).",
        "Instruction": "FSUB m32fp",
        "Opcode": "D8 /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract m64fp from ST(0) and store result in ST(0).",
        "Instruction": "FSUB m64fp",
        "Opcode": "DC /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(i) from ST(0) and store result in ST(0).",
        "Instruction": "FSUB ST(0), ST(i)",
        "Opcode": "D8 E0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(0) from ST(i) and store result in ST(i).",
        "Instruction": "FSUB ST(i), ST(0)",
        "Opcode": "DC E8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(0) from ST(i), store result in ST(i), and pop register stack.",
        "Instruction": "FSUBP ST(i), ST(0)",
        "Opcode": "DE E8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract ST(0) from ST(1), store result in ST(1), and pop register stack.",
        "Instruction": "FSUBP",
        "Opcode": "DE E9"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract m32int from ST(0) and store result in ST(0).",
        "Instruction": "FISUB m32int",
        "Opcode": "DA /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Subtract m16int from ST(0) and store result in ST(0).",
        "Instruction": "FISUB m16int",
        "Opcode": "DE /4"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Subtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format or in word or doubleword integer format.\nThe no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.\nThe FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.\nThe FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.\nTable 3-38 shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST − SRC = result).\nWhen the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.\nWhen one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalidoperation exception is generated.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF Instruction = FISUB\n    THEN\n        DEST := DEST − ConvertToDoubleExtendedPrecisionFP(SRC);\n    ELSE (* Source operand is floating-point value *)\n        DEST := DEST − SRC;\nFI;\nIF Instruction = FSUBP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Operand is an SNaN value or unsupported format.; \ncolumn_1: Operands are infinities of like sign.; \ncolumn_1: #D; column_2: Source operand is a denormal value.; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_2: Value cannot be represented exactly in destination format.; column_1: #P;"
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttps2udq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPS2UDQ\n\t\t— Convert With Truncation Packed Single Precision Floating-Point Values toPacked Unsigned Doubleword Integer Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.0F.W0 78 /r VCVTTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.0F.W0 78 /r VCVTTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert sixteen packed single precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.0F.W0 78 /r VCVTTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/monitor",
    "category": "Core Instructions",
    "instructionName": "MONITOR\n\t\t— Set Up Monitor Address",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is DS:RAX/EAX/AX.",
        "Instruction": "MONITOR",
        "Op/En": "ZO",
        "Opcode": "0F 01 C8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The MONITOR instruction arms address monitoring hardware using an address specified in EAX (the address range that the monitoring hardware checks for store operations can be determined by using CPUID). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by MWAIT.\nThe address is specified in RAX/EAX/AX and the size is based on the effective address size of the encoded instruction. By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used.\nECX and EDX are also used. They communicate other information to MONITOR. ECX specifies optional extensions. EDX specifies optional hints; it does not change the architectural behavior of the instruction. For the Pentium 4 processor (family 15, model 3), no extensions or hints are defined. Undefined hints in EDX are ignored by the processor; undefined extensions in ECX raises a general protection fault.\nThe address range must use memory of the write-back type. Only write-back memory will correctly trigger the monitoring hardware. Additional information on determining what address range to use in order to prevent false wake-ups is described in Chapter 9, “Multiple-Processor Management‚” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\nThe MONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, MONITOR sets the A-bit but not the D-bit in page tables.\nCPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set, MONITOR may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling MONITOR clears the CPUID feature flag and causes execution to generate an invalid-opcode exception.\nThe instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "MONITOR sets up an address range for the monitor hardware using the content of EAX (RAX in 64-bit mode) as an effective address\nand puts the monitor hardware in armed state. Always use memory of the write-back caching type. A store to the specified address\nrange will trigger the monitor hardware. The content of ECX and EDX are used to communicate other information to the monitor\nhardware.",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: If RCX ≠ 0.; \ncolumn_2: If the SS register is used to access memory and the value in EAX is in a non-canonical form.; column_1: #SS(0); \ncolumn_2: For a page fault.; column_1: #PF(fault-code); \ncolumn_2: If the current privilege level is not 0.; column_1: #UD; \ncolumn_1: If CPUID.01H:ECX.MONITOR[bit 3] = 0.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "numeric¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If ECX ≠ 0.; \ncolumn_1: #SS(0); column_2: If the value in EAX is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.MONITOR[bit 3] = 0.; \ncolumn_1: If current privilege level is not 0.;"
      ],
      "realAddressMode¶": [
        "column_1: If ECX ≠ 0.; \ncolumn_1: #SS; column_2: If the SS register is used to access memory and the value in EAX is outside of the effective address space from 0 to FFFFH.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.MONITOR[bit 3] = 0.;"
      ],
      "virtual8086Mode¶": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fdecstp",
    "category": "Core Instructions",
    "instructionName": "FDECSTP\n\t\t— Decrement Stack-Top Pointer",
    "detailsTable": [
      {
        "Description": "Decrement TOP field in FPU status word.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 F6",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF TOP = 0\n    THEN TOP := 7;\n    ELSE TOP := TOP – 1;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/lahf",
    "category": "Core Instructions",
    "instructionName": "LAHF\n\t\t— Load Status Flags Into AH Register",
    "detailsTable": [
      {
        "Description": "Load: AH := EFLAGS(SF:ZF:0:AF:0:PF:1:CF).",
        "En": "",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "9F",
        "column_2": ""
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        IF CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1;\n            THEN AH := RFLAGS(SF:ZF:0:AF:0:PF:1:CF);\n            ELSE #UD;\n        FI;\n    ELSE\n        AH := EFLAGS(SF:ZF:0:AF:0:PF:1:CF);\nFI;",
    "flagsAffectedText": "None. The state of the flags in the EFLAGS register is not affected.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/punpckhbw:punpckhwd:punpckhdq:punpckhqdq",
    "category": "Core Instructions",
    "instructionName": "PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ\n\t\t— Unpack High Data",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Unpack and interleave high-order bytes from mm and mm/m64 into mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 68 /r1 PUNPCKHBW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 68 /r PUNPCKHBW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Unpack and interleave high-order words from mm and mm/m64 into mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 69 /r1 PUNPCKHWD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 69 /r PUNPCKHWD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Unpack and interleave high-order doublewords from mm and mm/m64 into mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 6A /r1 PUNPCKHDQ mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 6A /r PUNPCKHDQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 6D /r PUNPCKHQDQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 68/r VPUNPCKHBW xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Interleave high-order words from xmm2 and xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 69/r VPUNPCKHWD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 6A/r VPUNPCKHDQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 6D/r VPUNPCKHQDQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 68 /r VPUNPCKHBW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 69 /r VPUNPCKHWD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 6A /r VPUNPCKHDQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 6D /r VPUNPCKHQDQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1 register using k1 write mask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 68 /r VPUNPCKHBW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Interleave high-order words from xmm2 and xmm3/m128 into xmm1 register using k1 write mask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 69 /r VPUNPCKHWD xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Interleave high-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register using k1 write mask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 6A /r VPUNPCKHDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Interleave high-order quadword from xmm2 and xmm3/m128/m64bcst into xmm1 register using k1 write mask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 6D /r VPUNPCKHQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register using k1 write mask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 68 /r VPUNPCKHBW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register using k1 write mask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 69 /r VPUNPCKHWD ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Interleave high-order doublewords from ymm2 and ymm3/m256/m32bcst into ymm1 register using k1 write mask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 6A /r VPUNPCKHDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Interleave high-order quadword from ymm2 and ymm3/m256/m64bcst into ymm1 register using k1 write mask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 6D /r VPUNPCKHQDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Interleave high-order bytes from zmm2 and zmm3/m512 into zmm1 register.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 68/r VPUNPCKHBW zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Interleave high-order words from zmm2 and zmm3/m512 into zmm1 register.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 69/r VPUNPCKHWD zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Interleave high-order doublewords from zmm2 and zmm3/m512/m32bcst into zmm1 register using k1 write mask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 6A /r VPUNPCKHDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Interleave high-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register using k1 write mask.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 6D /r VPUNPCKHQDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.\n255 31 0 255 31 0\nWhen the source data comes from a 64-bit memory operand, the full 64-bit operand is accessed from memory, but the instruction uses only the high-order 32 bits. When the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.\nThe (V)PUNPCKHBW instruction interleaves the high-order bytes of the source and destination operands, the (V)PUNPCKHWD instruction interleaves the high-order words of the source and destination operands, the (V)PUNPCKHDQ instruction interleaves the high-order doubleword (or doublewords) of the source and destination operands, and the (V)PUNPCKHQDQ instruction interleaves the high-order quadwords of the source and destination operands.\nThese instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. For example, with the (V)PUNPCKHBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKHWD instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE versions 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers.\nEVEX encoded VPUNPCKHDQ/QDQ: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.\nEVEX encoded VPUNPCKHWD/BW: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
    "operationText": "DEST[7:0] := DEST[39:32];\nDEST[15:8] := SRC[39:32];\nDEST[23:16] := DEST[47:40];\nDEST[31:24] := SRC[47:40];\nDEST[39:32] := DEST[55:48];\nDEST[47:40] := SRC[55:48];\nDEST[55:48] := DEST[63:56];\nDEST[63:56] := SRC[63:56];\nDEST[15:0] := DEST[47:32];\nDEST[31:16] := SRC[47:32];\nDEST[47:32] := DEST[63:48];\nDEST[63:48] := SRC[63:48];\nDEST[31:0] := DEST[63:32];\n    DEST[63:32] := SRC[63:32];\nINTERLEAVE_HIGH_BYTES_512b (SRC1, SRC2)\nTMP_DEST[255:0] := INTERLEAVE_HIGH_BYTES_256b(SRC1[255:0], SRC[255:0])\nTMP_DEST[511:256] := INTERLEAVE_HIGH_BYTES_256b(SRC1[511:256], SRC[511:256])\nINTERLEAVE_HIGH_BYTES_256b (SRC1, SRC2)\nDEST[7:0] := SRC1[71:64]\nDEST[15:8] := SRC2[71:64]\nDEST[23:16] := SRC1[79:72]\nDEST[31:24] := SRC2[79:72]\nDEST[39:32] := SRC1[87:80]\nDEST[47:40] := SRC2[87:80]\nDEST[55:48] := SRC1[95:88]\nDEST[63:56] := SRC2[95:88]\nDEST[71:64] := SRC1[103:96]\nDEST[79:72] := SRC2[103:96]\nDEST[87:80] := SRC1[111:104]\nDEST[95:88] := SRC2[111:104]\nDEST[103:96] := SRC1[119:112]\nDEST[111:104] := SRC2[119:112]\nDEST[119:112] := SRC1[127:120]\nDEST[127:120] := SRC2[127:120]\nDEST[135:128] := SRC1[199:192]\nDEST[143:136] := SRC2[199:192]\nDEST[151:144] := SRC1[207:200]\nDEST[159:152] := SRC2[207:200]\nDEST[167:160] := SRC1[215:208]\nDEST[175:168] := SRC2[215:208]\nDEST[183:176] := SRC1[223:216]\nDEST[191:184] := SRC2[223:216]\nDEST[199:192] := SRC1[231:224]\nDEST[207:200] := SRC2[231:224]\nDEST[215:208] := SRC1[239:232]\nDEST[223:216] := SRC2[239:232]\nDEST[231:224] := SRC1[247:240]\nDEST[239:232] := SRC2[247:240]\nDEST[247:240] := SRC1[255:248]\nDEST[255:248] := SRC2[255:248]\nINTERLEAVE_HIGH_BYTES (SRC1, SRC2)\nDEST[7:0] := SRC1[71:64]\nDEST[15:8] := SRC2[71:64]\nDEST[23:16] := SRC1[79:72]\nDEST[31:24] := SRC2[79:72]\nDEST[39:32] := SRC1[87:80]\nDEST[47:40] := SRC2[87:80]\nDEST[55:48] := SRC1[95:88]\nDEST[63:56] := SRC2[95:88]\nDEST[71:64] := SRC1[103:96]\nDEST[79:72] := SRC2[103:96]\nDEST[87:80] := SRC1[111:104]\nDEST[95:88] := SRC2[111:104]\nDEST[103:96] := SRC1[119:112]\nDEST[111:104] := SRC2[119:112]\nDEST[119:112] := SRC1[127:120]\nDEST[127:120] := SRC2[127:120]\nINTERLEAVE_HIGH_WORDS_512b (SRC1, SRC2)\nTMP_DEST[255:0] := INTERLEAVE_HIGH_WORDS_256b(SRC1[255:0], SRC[255:0])\nTMP_DEST[511:256] := INTERLEAVE_HIGH_WORDS_256b(SRC1[511:256], SRC[511:256])\nINTERLEAVE_HIGH_WORDS_256b(SRC1, SRC2)\nDEST[15:0] := SRC1[79:64]\nDEST[31:16] := SRC2[79:64]\nDEST[47:32] := SRC1[95:80]\nDEST[63:48] := SRC2[95:80]\nDEST[79:64] := SRC1[111:96]\nDEST[95:80] := SRC2[111:96]\nDEST[111:96] := SRC1[127:112]\nDEST[127:112] := SRC2[127:112]\nDEST[143:128] := SRC1[207:192]\nDEST[159:144] := SRC2[207:192]\nDEST[175:160] := SRC1[223:208]\nDEST[191:176] := SRC2[223:208]\nDEST[207:192] := SRC1[239:224]\nDEST[223:208] := SRC2[239:224]\nDEST[239:224] := SRC1[255:240]\nDEST[255:240] := SRC2[255:240]\nINTERLEAVE_HIGH_WORDS (SRC1, SRC2)\nDEST[15:0] := SRC1[79:64]\nDEST[31:16] := SRC2[79:64]\nDEST[47:32] := SRC1[95:80]\nDEST[63:48] := SRC2[95:80]\nDEST[79:64] := SRC1[111:96]\nDEST[95:80] := SRC2[111:96]\nDEST[111:96] := SRC1[127:112]\nDEST[127:112] := SRC2[127:112]\nINTERLEAVE_HIGH_DWORDS_512b (SRC1, SRC2)\nTMP_DEST[255:0] := INTERLEAVE_HIGH_DWORDS_256b(SRC1[255:0], SRC2[255:0])\nTMP_DEST[511:256] := INTERLEAVE_HIGH_DWORDS_256b(SRC1[511:256], SRC2[511:256])\nINTERLEAVE_HIGH_DWORDS_256b(SRC1, SRC2)\nDEST[31:0] := SRC1[95:64]\nDEST[63:32] := SRC2[95:64]\nDEST[95:64] := SRC1[127:96]\nDEST[127:96] := SRC2[127:96]\nDEST[159:128] := SRC1[223:192]\nDEST[191:160] := SRC2[223:192]\nDEST[223:192] := SRC1[255:224]\nDEST[255:224] := SRC2[255:224]\nINTERLEAVE_HIGH_DWORDS(SRC1, SRC2)\nDEST[31:0] := SRC1[95:64]\nDEST[63:32] := SRC2[95:64]\nDEST[95:64] := SRC1[127:96]\nDEST[127:96] := SRC2[127:96]\nINTERLEAVE_HIGH_QWORDS_512b (SRC1, SRC2)\nTMP_DEST[255:0] := INTERLEAVE_HIGH_QWORDS_256b(SRC1[255:0], SRC2[255:0])\nTMP_DEST[511:256] := INTERLEAVE_HIGH_QWORDS_256b(SRC1[511:256], SRC2[511:256])\nINTERLEAVE_HIGH_QWORDS_256b(SRC1, SRC2)\nDEST[63:0] := SRC1[127:64]\nDEST[127:64] := SRC2[127:64]\nDEST[191:128] := SRC1[255:192]\nDEST[255:192] := SRC2[255:192]\nINTERLEAVE_HIGH_QWORDS(SRC1, SRC2)\nDEST[63:0] := SRC1[127:64]\nDEST[127:64] := SRC2[127:64]\nDEST[127:0] := INTERLEAVE_HIGH_BYTES(DEST, SRC)\nDEST[255:127] (Unmodified)\nDEST[127:0] := INTERLEAVE_HIGH_BYTES(SRC1, SRC2)\nDEST[MAXVL-1:127] := 0\nDEST[255:0] := INTERLEAVE_HIGH_BYTES_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nIF VL = 128\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_BYTES(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nIF VL = 256\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_BYTES_256b(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nIF VL = 512\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_BYTES_512b(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := TMP_DEST[i+7:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[127:0] := INTERLEAVE_HIGH_WORDS(DEST, SRC)\nDEST[255:127] (Unmodified)\nDEST[127:0] := INTERLEAVE_HIGH_WORDS(SRC1, SRC2)\nDEST[MAXVL-1:127] := 0\nDEST[255:0] := INTERLEAVE_HIGH_WORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL = 128\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_WORDS(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nIF VL = 256\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_WORDS_256b(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nIF VL = 512\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_WORDS_512b(SRC1[VL-1:0], SRC2[VL-1:0])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[127:0] := INTERLEAVE_HIGH_DWORDS(DEST, SRC)\nDEST[255:127] (Unmodified)\nDEST[127:0] := INTERLEAVE_HIGH_DWORDS(SRC1, SRC2)\nDEST[MAXVL-1:127] := 0\nDEST[255:0] := INTERLEAVE_HIGH_DWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF (EVEX.b = 1) AND (SRC2 *is memory*)\n        THEN TMP_SRC2[i+31:i] := SRC2[31:0]\n        ELSE TMP_SRC2[i+31:i] := SRC2[i+31:i]\n    FI;\nENDFOR;\nIF VL = 128\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_DWORDS(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nIF VL = 256\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_DWORDS_256b(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nIF VL = 512\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_DWORDS_512b(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking* ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[127:0] := INTERLEAVE_HIGH_QWORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := INTERLEAVE_HIGH_QWORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[255:0] := INTERLEAVE_HIGH_QWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF (EVEX.b = 1) AND (SRC2 *is memory*)\n        THEN TMP_SRC2[i+63:i] := SRC2[63:0]\n        ELSE TMP_SRC2[i+63:i] := SRC2[i+63:i]\n    FI;\nENDFOR;\nIF VL = 128\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_QWORDS(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nIF VL = 256\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_QWORDS_256b(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nIF VL = 512\n    TMP_DEST[VL-1:0] := INTERLEAVE_HIGH_QWORDS_512b(SRC1[VL-1:0], TMP_SRC2[VL-1:0])\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPUNPCKHQDQ/QDQ, see Table 2-50, “Type E4NF Class Exception Conditions.”",
        "EVEX-encoded VPUNPCKHBW/WD, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmaddsub132ph:vfmaddsub213ph:vfmaddsub231ph",
    "category": "Core Instructions",
    "instructionName": "VFMADDSUB132PH/VFMADDSUB213PH/VFMADDSUB231PH\n\t\t— Fused Multiply-AlternatingAdd/Subtract of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm3/m128/m16bcst, add/subtract elements in xmm2, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 96 /r VFMADDSUB132PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm3/m256/m16bcst, add/subtract elements in ymm2, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 96 /r VFMADDSUB132PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm3/m512/m16bcst, add/subtract elements in zmm2, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 96 /r VFMADDSUB132PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m16bcst, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 A6 /r VFMADDSUB213PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m16bcst, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 A6 /r VFMADDSUB213PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm1 and zmm2, add/subtract elements in zmm3/m512/m16bcst, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 A6 /r VFMADDSUB213PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply packed FP16 values from xmm2 and xmm3/m128/m16bcst, add/subtract elements in xmm1, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 B6 /r VFMADDSUB231PH xmm1{k1}{z}, xmm2, xmm3/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from ymm2 and ymm3/m256/m16bcst, add/subtract elements in ymm1, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 B6 /r VFMADDSUB231PH ymm1{k1}{z}, ymm2, ymm3/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Multiply packed FP16 values from zmm2 and zmm3/m512/m16bcst, add/subtract elements in zmm1, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 B6 /r VFMADDSUB231PH zmm1{k1}{z}, zmm2, zmm3/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpexpandq",
    "category": "Core Instructions",
    "instructionName": "VPEXPANDQ\n\t\t— Load Sparse Packed Quadword Integer Values From Dense Memory/Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Expand packed quad-word integer values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 89 /r VPEXPANDQ xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Expand packed quad-word integer values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 89 /r VPEXPANDQ ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Expand packed quad-word integer values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 89 /r VPEXPANDQ zmm1 {k1}{z}, zmm2/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/setssbsy",
    "category": "Core Instructions",
    "instructionName": "SETSSBSY\n\t\t— Mark Shadow Stack Busy",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Set busy flag in supervisor shadow stack token reference by IA32_PL0_SSP.",
        "Op/En": "ZO",
        "Opcode/Instruction": "F3 0F 01 E8 SETSSBSY"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The SETSSBSY instruction verifies the presence of a non-busy supervisor shadow stack token at the address in the IA32_PL0_SSP MSR and marks it busy. Following successful execution of the instruction, the SSP is set to the value of the IA32_PL0_SSP MSR.",
    "operationText": "IF (CR4.CET = 0)\n    THEN #UD; FI;\nIF (IA32_S_CET.SH_STK_EN = 0)\n    THEN #UD; FI;\nIF CPL > 0\n    THEN GP(0); FI;\nSSP_LA = IA32_PL0_SSP\nIf SSP_LA not aligned to 8 bytes\n    THEN #GP(0); FI;\nexpected_token_value = SSP_LA\nnew_token_value = SSP_LA | BUSY_BIT\nIF shadow_stack_lock_cmpxchg8B(SSP_LA, new_token_value, expected_token_value) != expected_token_value\n    THEN #CP(SETSSBSY); FI;\nSSP = SSP_LA",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same as protected mode exceptions."
      ],
      "compatibilityMode": [
        "Same as protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: IF IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: #GP(0); column_2: If IA32_PL0_SSP not aligned to 8 bytes.; \ncolumn_1: If CPL is not 0.; \ncolumn_1: #CP(setssbsy); column_2: If busy bit in token is set.; \ncolumn_1: If in 32-bit or compatibility mode, and the address in token is not below 4G.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmp",
    "category": "Core Instructions",
    "instructionName": "CMP\n\t\t— Compare Two Operands",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare imm8 with AL.",
        "Instruction": "CMP AL, imm8",
        "Op/En": "I",
        "Opcode": "3C ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare imm16 with AX.",
        "Instruction": "CMP AX, imm16",
        "Op/En": "I",
        "Opcode": "3D iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare imm32 with EAX.",
        "Instruction": "CMP EAX, imm32",
        "Op/En": "I",
        "Opcode": "3D id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare imm32 sign-extended to 64-bits with RAX.",
        "Instruction": "CMP RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + 3D id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare imm8 with r/m8.",
        "Instruction": "CMP r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "80 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare imm8 with r/m8.",
        "Instruction": "CMP r/m8*, imm8",
        "Op/En": "MI",
        "Opcode": "REX + 80 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare imm16 with r/m16.",
        "Instruction": "CMP r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "81 /7 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare imm32 with r/m32.",
        "Instruction": "CMP r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "81 /7 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare imm32 sign-extended to 64-bits with r/m64.",
        "Instruction": "CMP r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + 81 /7 id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare imm8 with r/m16.",
        "Instruction": "CMP r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "83 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare imm8 with r/m32.",
        "Instruction": "CMP r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "83 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare imm8 with r/m64.",
        "Instruction": "CMP r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 83 /7 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare r8 with r/m8.",
        "Instruction": "CMP r/m8, r8",
        "Op/En": "MR",
        "Opcode": "38 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare r8 with r/m8.",
        "Instruction": "CMP r/m8*, r8*",
        "Op/En": "MR",
        "Opcode": "REX + 38 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare r16 with r/m16.",
        "Instruction": "CMP r/m16, r16",
        "Op/En": "MR",
        "Opcode": "39 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare r32 with r/m32.",
        "Instruction": "CMP r/m32, r32",
        "Op/En": "MR",
        "Opcode": "39 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare r64 with r/m64.",
        "Instruction": "CMP r/m64,r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 39 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare r/m8 with r8.",
        "Instruction": "CMP r8, r/m8",
        "Op/En": "RM",
        "Opcode": "3A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare r/m8 with r8.",
        "Instruction": "CMP r8*, r/m8*",
        "Op/En": "RM",
        "Opcode": "REX + 3A /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare r/m16 with r16.",
        "Instruction": "CMP r16, r/m16",
        "Op/En": "RM",
        "Opcode": "3B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare r/m32 with r32.",
        "Instruction": "CMP r32, r/m32",
        "Op/En": "RM",
        "Opcode": "3B /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare r/m64 with r64.",
        "Instruction": "CMP r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 3B /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX (r)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as an operand, it is sign-extended to the length of the first operand.\nThe condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the relationship of the status flags and the condition codes.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "temp := SRC1 − SignExtend(SRC2);\nModifyStatusFlags; (* Modify status flags in the same manner as the SUB instruction*)",
    "flagsAffectedText": "The CF, OF, SF, ZF, AF, and PF flags are set according to the result.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvttpd2pi",
    "category": "Core Instructions",
    "instructionName": "CVTTPD2PI\n\t\t— Convert With Truncation Packed Double Precision Floating-Point Values to PackedDword Integers",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Convert two packer double precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 2C /r CVTTPD2PI mm, xmm/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Converts two packed double precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer32_Truncate(SRC[63:0]);\nDEST[63:32] := Convert_Double_Precision_Floating_Point_To_Integer32_Truncate(SRC[127:64]);",
    "flagsAffectedText": "",
    "exceptions": {
      "otherMode¶": [
        "See Table 23-4, “Exception Conditions for Legacy SIMD/MMX Instructions with FP Exception and 16-Byte Alignment,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtpi2ps",
    "category": "Core Instructions",
    "instructionName": "CVTPI2PS\n\t\t— Convert Packed Dword Integers to Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Convert two signed doubleword integers from mm/m64 to two single precision floating-point values in xmm.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 2A /r CVTPI2PS xmm, mm/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Converts two packed signed doubleword integers in the source operand (second operand) to two packed single precision floating-point values in the destination operand (first operand).\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. The results are stored in the low quadword of the destination operand, and the high quadword remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0]);\nDEST[63:32] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:32]);\n(* High quadword of destination unchanged *)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 23-5, “Exception Conditions for Legacy SIMD/MMX Instructions with XMM and FP Exception” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ],
      "simdFloating-Point¶": [
        "Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/kaddw:kaddb:kaddq:kaddd",
    "category": "Core Instructions",
    "instructionName": "KADDW/KADDB/KADDQ/KADDD\n\t\t— ADD Two Masks",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Add 16 bits masks in k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W0 4A /r KADDW k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Add 8 bits masks in k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W0 4A /r KADDB k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Add 64 bits masks in k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W1 4A /r KADDQ k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Add 32 bits masks in k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W1 4A /r KADDD k1, k2, k3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.1vvv (r)",
        "Operand 3": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
    "operationText": "DEST[15:0] := SRC1[15:0] + SRC2[15:0]\nDEST[MAX_KL-1:16] := 0\nDEST[7:0] := SRC1[7:0] + SRC2[7:0]\nDEST[MAX_KL-1:8] := 0\nDEST[63:0] := SRC1[63:0] + SRC2[63:0]\nDEST[MAX_KL-1:64] := 0\nDEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[MAX_KL-1:32] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movapd",
    "category": "Core Instructions",
    "instructionName": "MOVAPD\n\t\t— Move Aligned Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move aligned packed double precision floating-point values from xmm2/mem to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 28 /r MOVAPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move aligned packed double precision floating-point values from xmm1 to xmm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 29 /r MOVAPD xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed double precision floating-point values from xmm2/mem to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 28 /r VMOVAPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed double precision floating-point values from xmm1 to xmm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 29 /r VMOVAPD xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed double precision floating-point values from ymm2/mem to ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 28 /r VMOVAPD ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move aligned packed double precision floating-point values from ymm1 to ymm2/mem.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 29 /r VMOVAPD ymm2/m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed double precision floating-point values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 28 /r VMOVAPD xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed double precision floating-point values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 28 /r VMOVAPD ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move aligned packed double precision floating-point values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 28 /r VMOVAPD zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed double precision floating-point values from xmm1 to xmm2/m128 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 29 /r VMOVAPD xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move aligned packed double precision floating-point values from ymm1 to ymm2/m256 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 29 /r VMOVAPD ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move aligned packed double precision floating-point values from zmm1 to zmm2/m512 using writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 29 /r VMOVAPD zmm2/m512 {k1}{z}, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Moves 2, 4 or 8 double precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.\nWhen the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit versions), 32-byte (256-bit version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection\nexception (#GP) will be generated. For EVEX encoded versions, the operand must be aligned to the size of the memory operand. To move double precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.\nEVEX.512 encoded version:\nMoves 512 bits of packed double precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float64 memory location, to store the contents of a ZMM register into a 512-bit float64 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 64-byte boundary or a general-protection exception (#GP) will be generated. To move single precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.\nVEX.256 and EVEX.256 encoded versions:\nMoves 256 bits of packed double precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move double precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.\n128-bit versions:\nMoves 128 bits of packed double precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.\n(E)VEX.128 encoded version: Bits (MAXVL-1:128) of the destination ZMM register destination are zeroed.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n        ELSE *DEST[i+63:i] remains unchanged*\n            ; merging-masking\n    FI;\nENDFOR;\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := SRC[255:0]\nDEST[MAXVL-1:256] := 0\nDEST[255:0] := SRC[255:0]\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := SRC[127:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Exceptions Type1.SSE2 in Table 2-18, “Type 1 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-44, “Type E1 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpcompressq",
    "category": "Core Instructions",
    "instructionName": "VPCOMPRESSQ\n\t\t— Store Sparse Packed Quadword Integer Values Into Dense Memory/Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compress packed quadword integer values from xmm2 to xmm1/m128 using control mask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 8B /r VPCOMPRESSQ xmm1/m128 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compress packed quadword integer values from ymm2 to ymm1/m256 using control mask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 8B /r VPCOMPRESSQ ymm1/m256 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compress packed quadword integer values from zmm2 to zmm1/m512 using control mask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 8B /r VPCOMPRESSQ zmm1/m512 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pxor",
    "category": "Core Instructions",
    "instructionName": "PXOR\n\t\t— Logical Exclusive OR",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Bitwise XOR of mm/m64 and mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F EF /r1 PXOR mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Bitwise XOR of xmm2/m128 and xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F EF /r PXOR xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Bitwise XOR of xmm3/m128 and xmm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG EF /r VPXOR xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Bitwise XOR of ymm3/m256 and ymm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG EF /r VPXOR ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise XOR of packed doubleword integers in xmm2 and xmm3/m128 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 EF /r VPXORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise XOR of packed doubleword integers in ymm2 and ymm3/m256 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 EF /r VPXORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise XOR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 EF /r VPXORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise XOR of packed quadword integers in xmm2 and xmm3/m128 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 EF /r VPXORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise XOR of packed quadword integers in ymm2 and ymm3/m256 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 EF /r VPXORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise XOR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 EF /r VPXORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1.",
    "operationText": "DEST := DEST XOR SRC\nDEST := DEST XOR SRC\nDEST[MAXVL-1:128] (Unmodified)\nDEST := SRC1 XOR SRC2\nDEST[MAXVL-1:128] := 0\nDEST := SRC1 XOR SRC2\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+31:i] := SRC1[i+31:i] BITWISE XOR SRC2[31:0]\n                ELSE DEST[i+31:i] := SRC1[i+31:i] BITWISE XOR SRC2[i+31:i]\n            FI;\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE\n                    ; zeroing-masking\n                DEST[31:0] := 0\n        FI;\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+63:i] := SRC1[i+63:i] BITWISE XOR SRC2[63:0]\n                ELSE DEST[i+63:i] := SRC1[i+63:i] BITWISE XOR SRC2[i+63:i]\n            FI;\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                DEST[63:0] := 0\n        FI;\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/psubq",
    "category": "Core Instructions",
    "instructionName": "PSUBQ\n\t\t— Subtract Packed Quadword Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract quadword integer in mm1 from mm2 /m64.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F FB /r1 PSUBQ mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed quadword integers in xmm1 from xmm2 /m128.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F FB /r PSUBQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed quadword integers in xmm3/m128 from xmm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG FB/r VPSUBQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract packed quadword integers in ymm3/m256 from ymm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG FB /r VPSUBQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Subtract packed quadword integers in xmm3/m128/m64bcst from xmm2 and store in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 FB /r VPSUBQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Subtract packed quadword integers in ymm3/m256/m64bcst from ymm2 and store in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 FB /r VPSUBQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Subtract packed quadword integers in zmm3/m512/m64bcst from zmm2 and store in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 FB/r VPSUBQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).\nNote that the (V)PSUBQ instruction can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values upon which it operates.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded VPSUBQ: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
    "operationText": "DEST[63:0] := DEST[63:0] − SRC[63:0];\nDEST[63:0] := DEST[63:0] − SRC[63:0];\nDEST[127:64] := DEST[127:64] − SRC[127:64];\nDEST[63:0] := SRC1[63:0]-SRC2[63:0]\nDEST[127:64] := SRC1[127:64]-SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0]-SRC2[63:0]\nDEST[127:64] := SRC1[127:64]-SRC2[127:64]\nDEST[191:128] := SRC1[191:128]-SRC2[191:128]\nDEST[255:192] := SRC1[255:192]-SRC2[255:192]\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+63:i] := SRC1[i+63:i] - SRC2[63:0]\n                ELSE DEST[i+63:i] := SRC1[i+63:i] - SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPSUBQ, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmovdw:vpmovsdw:vpmovusdw",
    "category": "Core Instructions",
    "instructionName": "VPMOVDW/VPMOVSDW/VPMOVUSDW\n\t\t— Down Convert DWord to Word",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed double-word integers from xmm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 33 /r VPMOVDW xmm1/m64 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed signed double-word integers from xmm2 into 4 packed signed word integers in ymm1/m64 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 23 /r VPMOVSDW xmm1/m64 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 13 /r VPMOVUSDW xmm1/m64 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 8 packed double-word integers from ymm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 33 /r VPMOVDW xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 8 packed signed double-word integers from ymm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 23 /r VPMOVSDW xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 13 /r VPMOVUSDW xmm1/m128 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 16 packed double-word integers from zmm2 into 16 packed word integers in ymm1/m256 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 33 /r VPMOVDW ymm1/m256 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 16 packed signed double-word integers from zmm2 into 16 packed signed word integers in ymm1/m256 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 23 /r VPMOVSDW ymm1/m256 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned word integers in ymm1/m256 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 13 /r VPMOVUSDW ymm1/m256 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fldenv",
    "category": "Core Instructions",
    "instructionName": "FLDENV\n\t\t— Load x87 FPU Environment",
    "detailsTable": [
      {
        "Description": "Load FPU environment from m14byte or m28byte.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 /4",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand specifies the first byte of the operating-environment data in memory. This data is typically written to the specified memory location by a FSTENV or FNSTENV instruction.\nThe FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the loaded environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.\nThe FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction.\nIf one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled “Software Exception Handling” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). To avoid generating exceptions when loading a new environment, clear all the exception flags in the FPU status word that is being loaded.\nIf a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by the fault handler may be different than the state being loaded from memory. In such situations, the fault handler should ignore the status of the x87 FPU registers, handle the fault, and return. The FLDENV instruction will then complete the loading of the x87 FPU registers with no resulting context inconsistency.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "FPUControlWord := SRC[FPUControlWord];\nFPUStatusWord := SRC[FPUStatusWord];\nFPUTagWord := SRC[FPUTagWord];\nFPUDataPointer := SRC[FPUDataPointer];\nFPUInstructionPointer := SRC[FPUInstructionPointer];\nFPULastInstructionOpcode := SRC[FPULastInstructionOpcode];",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None; however, if an unmasked exception is loaded in the status word, it is generated upon execution of the next “waiting” floating-point instruction."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pcmpgtq",
    "category": "Core Instructions",
    "instructionName": "PCMPGTQ\n\t\t— Compare Packed Data for Greater Than",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_2",
        "Description": "Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 37 /r PCMPGTQ xmm1,xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed signed qwords in xmm2 and xmm3/m128 for greater than.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 37 /r VPCMPGTQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed signed qwords in ymm2 and ymm3/m256 for greater than.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 37 /r VPCMPGTQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare Greater between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 37 /r VPCMPGTQ k1 {k2}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare Greater between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 37 /r VPCMPGTQ k1 {k2}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare Greater between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 37 /r VPCMPGTQ k1 {k2}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the source operand (second operand). If the data element in the first (destination) operand is greater than the corresponding element in the second (source) operand, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX encoded VPCMPGTD/Q: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
    "operationText": "IF SRC1[63:0] > SRC2[63:0]\nTHEN DEST[63:0] := FFFFFFFFFFFFFFFFH;\nELSE DEST[63:0] := 0; FI;\nIF SRC1[127:64] > SRC2[127:64]\nTHEN DEST[127:64] := FFFFFFFFFFFFFFFFH;\nELSE DEST[127:64] := 0; FI;\nDEST[127:0] := COMPARE_QWORDS_GREATER(SRC1,SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := COMPARE_QWORDS_GREATER(SRC1[127:0],SRC2[127:0])\nDEST[255:128] := COMPARE_QWORDS_GREATER(SRC1[255:128],SRC2[255:128])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k2[j] OR *no writemask*\n        THEN\n            /* signed comparison */\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN CMP := SRC1[i+63:i] > SRC2[63:0];\n                ELSE CMP := SRC1[i+63:i] > SRC2[i+63:i];\n            FI;\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                    ; zeroing-masking only\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPCMPGTQ, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtneps2bf16",
    "category": "Core Instructions",
    "instructionName": "VCVTNEPS2BF16\n\t\t— Convert Packed Single Data to Packed BF16 Data",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_BF16",
        "Description": "Convert packed single data from xmm2/m128 to packed BF16 data in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 72 /r VCVTNEPS2BF16 xmm1{k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_BF16",
        "Description": "Convert packed single data from ymm2/m256 to packed BF16 data in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 72 /r VCVTNEPS2BF16 xmm1{k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F AVX512_BF16",
        "Description": "Convert packed single data from zmm2/m512 to packed BF16 data in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 72 /r VCVTNEPS2BF16 ymm1{k1}{z}, zmm2/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtph2udq",
    "category": "Core Instructions",
    "instructionName": "VCVTPH2UDQ\n\t\t— Convert Packed FP16 Values to Unsigned Doubleword Integers",
    "detailsTable": [
      {
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four unsigned doubleword integers, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 79 /r VCVTPH2UDQ xmm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned doubleword integers, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 79 /r VCVTPH2UDQ ymm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen unsigned doubleword integers, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 79 /r VCVTPH2UDQ zmm1{k1}{z}, ymm2/m256/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfnmsub132pd:vfnmsub213pd:vfnmsub231pd",
    "category": "Core Instructions",
    "instructionName": "VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD\n\t\t— Fused Negative Multiply-Subtract ofPacked Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 9E /r VFNMSUB132PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 AE /r VFNMSUB213PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 BE /r VFNMSUB231PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 9E /r VFNMSUB132PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 AE /r VFNMSUB213PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 BE /r VFNMSUB231PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 9E /r VFNMSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m64bcst and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 AE /r VFNMSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 BE /r VFNMSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm2 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 9E /r VFNMSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m64bcst and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 AE /r VFNMSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm1 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 BE /r VFNMSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm2 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 9E /r VFNMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m64bcst and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 AE /r VFNMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm1 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 BE /r VFNMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpgatherdd:vpgatherdq",
    "category": "Core Instructions",
    "instructionName": "VPGATHERDD/VPGATHERDQ\n\t\t— Gather Packed Dword, Packed Qword With Signed Dword Indices",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 90 /vsib VPGATHERDD xmm1 {k1}, vm32x"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 90 /vsib VPGATHERDD ymm1 {k1}, vm32y"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 90 /vsib VPGATHERDD zmm1 {k1}, vm32z"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 90 /vsib VPGATHERDQ xmm1 {k1}, vm32x"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 90 /vsib VPGATHERDQ ymm1 {k1}, vm32x"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 90 /vsib VPGATHERDQ zmm1 {k1}, vm32y"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpblendmd:vpblendmq",
    "category": "Core Instructions",
    "instructionName": "VPBLENDMD/VPBLENDMQ\n\t\t— Blend Int32/Int64 Vectors Using an OpMask Control",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Blend doubleword integer vector xmm2 and doubleword vector xmm3/m128/m32bcst and store the result in xmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 64 /r VPBLENDMD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Blend doubleword integer vector ymm2 and doubleword vector ymm3/m256/m32bcst and store the result in ymm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 64 /r VPBLENDMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Blend doubleword integer vector zmm2 and doubleword vector zmm3/m512/m32bcst and store the result in zmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 64 /r VPBLENDMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Blend quadword integer vector xmm2 and quadword vector xmm3/m128/m64bcst and store the result in xmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 64 /r VPBLENDMQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Blend quadword integer vector ymm2 and quadword vector ymm3/m256/m64bcst and store the result in ymm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 64 /r VPBLENDMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Blend quadword integer vector zmm2 and quadword vector zmm3/m512/m64bcst and store the result in zmm1, under control mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 64 /r VPBLENDMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/call",
    "category": "Core Instructions",
    "instructionName": "CALL\n\t\t— Call Procedure",
    "detailsTable": [
      {
        "64-bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Call near, relative, displacement relative to next instruction.",
        "Instruction": "CALL rel16",
        "Op/En": "D",
        "Opcode": "E8 cw"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.",
        "Instruction": "CALL rel32",
        "Op/En": "D",
        "Opcode": "E8 cd"
      },
      {
        "64-bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Call near, absolute indirect, address given in r/m16.",
        "Instruction": "CALL r/m16",
        "Op/En": "M",
        "Opcode": "FF /2"
      },
      {
        "64-bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Call near, absolute indirect, address given in r/m32.",
        "Instruction": "CALL r/m32",
        "Op/En": "M",
        "Opcode": "FF /2"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Call near, absolute indirect, address given in r/m64.",
        "Instruction": "CALL r/m64",
        "Op/En": "M",
        "Opcode": "FF /2"
      },
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Call far, absolute, address given in operand.",
        "Instruction": "CALL ptr16:16",
        "Op/En": "D",
        "Opcode": "9A cd"
      },
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Call far, absolute, address given in operand.",
        "Instruction": "CALL ptr16:32",
        "Op/En": "D",
        "Opcode": "9A cp"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16-bit offset from far pointer referenced in the instruction.",
        "Instruction": "CALL m16:16",
        "Op/En": "M",
        "Opcode": "FF /3"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction.",
        "Instruction": "CALL m16:32",
        "Op/En": "M",
        "Opcode": "FF /3"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction.",
        "Instruction": "CALL m16:64",
        "Op/En": "M",
        "Opcode": "REX.W FF /3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "D",
        "Operand 1": "Offset",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Saves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an immediate value, a general-purpose register, or a memory location.\nThis instruction can be used to execute four types of calls:\nThe latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See “Calling Procedures Using Call and RET” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for additional information on near, far, and inter-privilege-level calls. See Chapter 8, “Task Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on performing task switches with the CALL instruction.\nNear Call. When executing a near call, the processor pushes the value of the EIP register (which contains the offset of the instruction following the CALL instruction) on the stack (for use later as a return-instruction pointer). The processor then branches to the address in the current code segment specified by the target operand. The target operand specifies either an absolute offset in the code segment (an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register; this value points to the instruction following the CALL instruction). The CS register is not changed on near calls.\nFor a near call absolute, an absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16, r/m32, or r/m64). The operand-size attribute determines the size of the target operand (16, 32 or 64 bits). When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits. Absolute offsets are loaded directly into the EIP(RIP) register. If the operand size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits. When accessing an absolute offset indirectly using the stack pointer [ESP] as the base register, the base value used is the value of the ESP before the instruction executes.\nA relative offset (rel16 or rel32) is generally specified as a label in assembly code. But at the machine code level, it is encoded as a signed, 16- or 32-bit immediate value. This value is added to the value in the EIP(RIP) register. In 64-bit mode the relative offset is always a 32-bit immediate value which is sign extended to 64-bits before it is added to the value in the RIP register for the target calculation. As with absolute offsets, the operand-size attribute determines the size of the target operand (16, 32, or 64 bits). In 64-bit mode the target operand will always be 64-bits because the operand size is forced to 64-bits for near branches.\nFar Calls in Real-Address or Virtual-8086 Mode. When executing a far call in real- address or virtual-8086 mode, the processor pushes the current value of both the CS and EIP registers on the stack for use as a return-instruction pointer. The processor then performs a “far branch” to the code segment and offset specified with the target operand for the called procedure. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the segment and offset of the called procedure is encoded in the instruction using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.\nFar Calls in Protected Mode. When the processor is operating in protected mode, the CALL instruction can be used to perform the following types of far calls:\nIn protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of call operation to be performed.\nIf the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand- size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register; the offset from the instruction is loaded into the EIP register.\nA call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making calls between 16-bit and 32-bit code segments.\nWhen executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a call gate. The segment selector specified by the target operand identifies the call gate. The target operand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)\nOn inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack, an optional set of parameters from the calling procedures stack, and the segment selector and instruction pointer for the calling procedure’s code segment. (A value in the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor branches to the address of the procedure being called within the new code segment.\nExecuting a task switch with the CALL instruction is similar to executing a call through a call gate. The target operand specifies the segment selector of the task gate for the new task activated by the switch (the offset in the target operand is ignored). The task gate in turn points to the TSS for the new task, which contains the segment selectors for the task’s code and stack segments. Note that the TSS also contains the EIP value for the next instruction that was to be executed before the calling task was suspended. This instruction pointer value is loaded into the EIP register to re-start the calling task.\nThe CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 8, “Task Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on the mechanics of a task switch.\nWhen you execute at task switch with a CALL instruction, the nested task flag (NT) is set in the EFLAGS register and the new TSS’s previous task link field is loaded with the old task’s TSS selector. Code is expected to suspend this nested task by executing an IRET instruction which, because the NT flag is set, automatically uses the previous task link to return to the calling task. (See “Task Linking” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on nested tasks.) Switching tasks with the CALL instruction differs in this regard from JMP instruction. JMP does not set the NT flag and therefore does not expect an IRET instruction to suspend the task.\nMixing 16-Bit and 32-Bit Calls. When making far calls between 16-bit and 32-bit code segments, use a call gate. If the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64 KBytes of the 32-bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only a 16-bit return address offset can be saved. Also, the call should be made using a 16-bit call gate so that 16-bit values can be pushed on the stack. See Chapter 22, “Mixing 16-Bit and 32-Bit Code,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, for more information.\nFar Calls in Compatibility Mode. When the processor is operating in compatibility mode, the CALL instruction can be used to perform the following types of far calls:\nNote that a CALL instruction can not be used to cause a task switch in compatibility mode since task switches are not supported in IA-32e mode.\nIn compatibility mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.\nIf the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in compatibility mode is very similar to one carried out in protected mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register and the offset from the instruction is loaded into the EIP register. The difference is that 64-bit mode may be entered. This specified by the L bit in the new code segment descriptor.\nNote that a 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the L bit set, causing an entry to 64-bit mode.\nWhen executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target\noperand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)\nOn inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. The full value of RSP is used for the offset, of which the upper 32-bits are undefined.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack and the segment selector and instruction pointer for the calling procedure’s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.\nNear/(Far) Calls in 64-bit Mode. When the processor is operating in 64-bit mode, the CALL instruction can be used to perform the following types of far calls:\nNote that in this mode the CALL instruction can not be used to cause a task switch in 64-bit mode since task switches are not supported in IA-32e mode.\nIn 64-bit mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.\nIf the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in 64-bit mode is very similar to one carried out in compatibility mode. The target operand specifies an absolute far address indirectly with a memory location (m16:16, m16:32 or m16:64). The form of CALL with a direct specification of absolute far address is not defined in 64-bit mode. The operand-size attribute determines the size of the offset (16, 32, or 64 bits) in the far address. The new code segment selector and its descriptor are loaded into the CS register; the offset from the instruction is loaded into the EIP register. The new code segment may specify entry either into compatibility or 64-bit mode, based on the L bit value.\nA 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the L bit set.\nWhen executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target operand can only specify the call gate segment selector indirectly with a memory location (m16:16, m16:32 or m16:64). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)\nOn inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch.\nNote that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. (The full value of RSP is used for the offset.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack and the segment selector and instruction pointer for the calling procedure’s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.\nRefer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions‚” and Chapter 17, “Control-flow Enforcement Technology (CET)‚” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for CET details.\nInstruction ordering. Instructions following a far call may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far call have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).\nInstructions sequentially following a near indirect CALL instruction (i.e., those not at the target) may be executed speculatively. If software needs to prevent this (e.g., in order to prevent a speculative execution side channel), then an LFENCE instruction opcode can be placed after the near indirect CALL in order to block speculative execution.",
    "operationText": "IF near call\n    THEN IF near relative call\n        THEN\n            IF OperandSize = 64\n                THEN\n                    tempDEST := SignExtend(DEST); (* DEST is rel32 *)\n                    tempRIP := RIP + tempDEST;\n                    IF stack not large enough for a 8-byte return address\n                        THEN #SS(0); FI;\n                    Push(RIP);\n                    IF ShadowStackEnabled(CPL) AND DEST != 0\n                        ShadowStackPush8B(RIP);\n                    FI;\n                    RIP := tempRIP;\n            FI;\n            IF OperandSize = 32\n                THEN\n                    tempEIP := EIP + DEST; (* DEST is rel32 *)\n                    IF tempEIP is not within code segment limit THEN #GP(0); FI;\n                    IF stack not large enough for a 4-byte return address\n                        THEN #SS(0); FI;\n                    Push(EIP);\n                    IF ShadowStackEnabled(CPL) AND DEST != 0\n                        ShadowStackPush4B(EIP);\n                    FI;\n                    EIP := tempEIP;\n            FI;\n            IF OperandSize = 16\n                THEN\n                    tempEIP := (EIP + DEST) AND 0000FFFFH; (* DEST is rel16 *)\n                    IF tempEIP is not within code segment limit THEN #GP(0); FI;\n                    IF stack not large enough for a 2-byte return address\n                        THEN #SS(0); FI;\n                    Push(IP);\n                    IF ShadowStackEnabled(CPL) AND DEST != 0\n                        (* IP is zero extended and pushed as a 32 bit value on shadow stack *)\n                        ShadowStackPush4B(IP);\n                    FI;\n                    EIP := tempEIP;\n            FI;\n        ELSE (* Near absolute call *)\n            IF OperandSize = 64\n                THEN\n                    tempRIP := DEST; (* DEST is r/m64 *)\n                    IF stack not large enough for a 8-byte return address\n                        THEN #SS(0); FI;\n                    Push(RIP);\n                    IF ShadowStackEnabled(CPL)\n                        ShadowStackPush8B(RIP);\n                    FI;\n                    RIP := tempRIP;\n            FI;\n            IF OperandSize = 32\n                THEN\n                    tempEIP := DEST; (* DEST is r/m32 *)\n                    IF tempEIP is not within code segment limit THEN #GP(0); FI;\n                    IF stack not large enough for a 4-byte return address\n                        THEN #SS(0); FI;\n                    Push(EIP);\n                    IF ShadowStackEnabled(CPL)\n                        ShadowStackPush4B(EIP);\n                    FI;\n                    EIP := tempEIP;\n            FI;\n            IF OperandSize = 16\n                THEN\n                    tempEIP := DEST AND 0000FFFFH; (* DEST is r/m16 *)\n                    IF tempEIP is not within code segment limit THEN #GP(0); FI;\n                    IF stack not large enough for a 2-byte return address\n                        THEN #SS(0); FI;\n                    Push(IP);\n                    IF ShadowStackEnabled(CPL)\n                        (* IP is zero extended and pushed as a 32 bit value on shadow stack *)\n                        ShadowStackPush4B(IP);\n                    FI;\n                    EIP := tempEIP;\n            FI;\n    FI;rel/abs\n    IF (Call near indirect, absolute indirect)\n        IF EndbranchEnabledAndNotSuppressed(CPL)\n            IF CPL = 3\n                THEN\n                    IF ( no 3EH prefix OR IA32_U_CET.NO_TRACK_EN == 0 )\n                        THEN\n                            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                    FI;\n                ELSE\n                    IF ( no 3EH prefix OR IA32_S_CET.NO_TRACK_EN == 0 )\n                        THEN\n                            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                    FI;\n            FI;\n        FI;\n    FI;\nFI; near\nIF far call and (PE = 0 or (PE = 1 and VM = 1)) (* Real-address or virtual-8086 mode *)\n    THEN\n        IF OperandSize = 32\n            THEN\n                IF stack not large enough for a 6-byte return address\n                    THEN #SS(0); FI;\n                IF DEST[31:16] is not zero THEN #GP(0); FI;\n                Push(CS); (* Padded with 16 high-order bits *)\n                Push(EIP);\n                CS := DEST[47:32]; (* DEST is ptr16:32 or [m16:32] *)\n                EIP := DEST[31:0]; (* DEST is ptr16:32 or [m16:32] *)\n            ELSE (* OperandSize = 16 *)\n                IF stack not large enough for a 4-byte return address\n                    THEN #SS(0); FI;\n                Push(CS);\n                Push(IP);\n                CS := DEST[31:16]; (* DEST is ptr16:16 or [m16:16] *)\n                EIP := DEST[15:0]; (* DEST is ptr16:16 or [m16:16]; clear upper 16 bits *)\n        FI;\nFI;\nIF far call and (PE = 1 and VM = 0) (* Protected mode or IA-32e Mode, not virtual-8086 mode*)\n    THEN\n        IF segment selector in target operand NULL\n            THEN #GP(0); FI;\n        IF segment selector index not within descriptor table limits\n            THEN #GP(new code segment selector); FI;\n        Read type and access rights of selected segment descriptor;\n        IF IA32_EFER.LMA = 0\n            THEN\n                IF segment type is not a conforming or nonconforming code segment, call\n                gate, task gate, or TSS\n                    THEN #GP(segment selector); FI;\n            ELSE\n                IF segment type is not a conforming or nonconforming code segment or\n                64-bit call gate,\n                    THEN #GP(segment selector); FI;\n        FI;\n        Depending on type and access rights:\n            GO TO CONFORMING-CODE-SEGMENT;\n            GO TO NONCONFORMING-CODE-SEGMENT;\n            GO TO CALL-GATE;\n            GO TO TASK-GATE;\n            GO TO TASK-STATE-SEGMENT;\nFI;\nCONFORMING-CODE-SEGMENT:\n    IF L bit = 1 and D bit = 1 and IA32_EFER.LMA = 1\n        THEN GP(new code segment selector); FI;\n    IF DPL > CPL\n        THEN #GP(new code segment selector); FI;\n    IF segment not present\n        THEN #NP(new code segment selector); FI;\n    IF stack not large enough for return address\n        THEN #SS(0); FI;\n    tempEIP := DEST(Offset);\n    IF target mode = Compatibility mode\n        THEN tempEIP := tempEIP AND 00000000_FFFFFFFFH; FI;\n    IF OperandSize = 16\n        THEN\n            tempEIP := tempEIP AND 0000FFFFH; FI; (* Clear upper 16 bits *)\n    IF (IA32_EFER.LMA = 0 or target mode = Compatibility mode) and (tempEIP outside new code segment limit)\n        THEN #GP(0); FI;\n    IF tempEIP is non-canonical\n        THEN #GP(0); FI;\n    IF ShadowStackEnabled(CPL)\n        IF OperandSize = 32\n            THEN\n                tempPushLIP = CSBASE + EIP;\n            ELSE\n                IF OperandSize = 16\n                    THEN\n                        tempPushLIP = CSBASE + IP;\n                    ELSE (* OperandSize = 64 *)\n                        tempPushLIP = RIP;\n                FI;\n        FI;\n        tempPushCS = CS;\n    FI;\n    IF OperandSize = 32\n        THEN\n            Push(CS); (* Padded with 16 high-order bits *)\n            Push(EIP);\n            CS := DEST(CodeSegmentSelector);\n            (* Segment descriptor information also loaded *)\n            CS(RPL) := CPL;\n            EIP := tempEIP;\n        ELSE\n            IF OperandSize = 16\n                THEN\n                    Push(CS);\n                    Push(IP);\n                    CS := DEST(CodeSegmentSelector);\n                    (* Segment descriptor information also loaded *)\n                    CS(RPL) := CPL;\n                    EIP := tempEIP;\n                ELSE (* OperandSize = 64 *)\n                    Push(CS); (* Padded with 48 high-order bits *)\n                    Push(RIP);\n                    CS := DEST(CodeSegmentSelector);\n                    (* Segment descriptor information also loaded *)\n                    CS(RPL) := CPL;\n                    RIP := tempEIP;\n            FI;\n    FI;\n    IF ShadowStackEnabled(CPL)\n        IF (IA32_EFER.LMA and DEST(CodeSegmentSelector).L) = 0\n            (* If target is legacy or compatibility mode then the SSP must be in low 4GB *)\n            IF (SSP & 0xFFFFFFFF00000000 != 0)\n                THEN #GP(0); FI;\n        FI;\n        (* align to 8 byte boundary if not already aligned *)\n        tempSSP = SSP;\n        Shadow_stack_store 4 bytes of 0 to (SSP – 4)\n        SSP = SSP & 0xFFFFFFFFFFFFFFF8H\n        ShadowStackPush8B(tempPushCS); (* Padded with 48 high-order bits of 0 *)\n        ShadowStackPush8B(tempPushLIP); (* Padded with 32 high-order bits of 0 for 32 bit LIP*)\n        ShadowStackPush8B(tempSSP);\n    FI;\n    IF EndbranchEnabled(CPL)\n        IF CPL = 3\n            THEN\n                IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                IA32_U_CET.SUPPRESS = 0\n            ELSE\n                IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                IA32_S_CET.SUPPRESS = 0\n        FI;\n    FI;\nEND;\nNONCONFORMING-CODE-SEGMENT:\n    IF L-Bit = 1 and D-BIT = 1 and IA32_EFER.LMA = 1\n        THEN GP(new code segment selector); FI;\n    IF (RPL > CPL) or (DPL ≠ CPL)\n        THEN #GP(new code segment selector); FI;\n    IF segment not present\n        THEN #NP(new code segment selector); FI;\n    IF stack not large enough for return address\n        THEN #SS(0); FI;\n    tempEIP := DEST(Offset);\n    IF target mode = Compatibility mode\n        THEN tempEIP := tempEIP AND 00000000_FFFFFFFFH; FI;\n    IF OperandSize = 16\n        THEN tempEIP := tempEIP AND 0000FFFFH; FI; (* Clear upper 16 bits *)\n    IF (IA32_EFER.LMA = 0 or target mode = Compatibility mode) and (tempEIP outside new code segment limit)\n        THEN #GP(0); FI;\n    IF tempEIP is non-canonical\n        THEN #GP(0); FI;\n    IF ShadowStackEnabled(CPL)\n        IF IA32_EFER.LMA & CS.L\n            tempPushLIP = RIP\n        ELSE\n            tempPushLIP = CSBASE + EIP;\n        FI;\n        tempPushCS = CS;\n    FI;\n    IF OperandSize = 32\n        THEN\n            Push(CS); (* Padded with 16 high-order bits *)\n            Push(EIP);\n            CS := DEST(CodeSegmentSelector);\n            (* Segment descriptor information also loaded *)\n            CS(RPL) := CPL;\n            EIP := tempEIP;\n        ELSE\n            IF OperandSize = 16\n                THEN\n                    Push(CS);\n                    Push(IP);\n                    CS := DEST(CodeSegmentSelector);\n                    (* Segment descriptor information also loaded *)\n                    CS(RPL) := CPL;\n                    EIP := tempEIP;\n                ELSE (* OperandSize = 64 *)\n                    Push(CS); (* Padded with 48 high-order bits *)\n                    Push(RIP);\n                    CS := DEST(CodeSegmentSelector);\n                    (* Segment descriptor information also loaded *)\n                    CS(RPL) := CPL;\n                    RIP := tempEIP;\n            FI;\n    FI;\n    IF ShadowStackEnabled(CPL)\n        IF (IA32_EFER.LMA and DEST(CodeSegmentSelector).L) = 0\n            (* If target is legacy or compatibility mode then the SSP must be in low 4GB *)\n            IF (SSP & 0xFFFFFFFF00000000 != 0)\n                THEN #GP(0); FI;\n        FI;\n    (* align to 8 byte boundary if not already aligned *)\n    tempSSP = SSP;\n    Shadow_stack_store 4 bytes of 0 to (SSP – 4)\n    SSP = SSP & 0xFFFFFFFFFFFFFFF8H\n    ShadowStackPush8B(tempPushCS); (* Padded with 48 high-order 0 bits *)\n    ShadowStackPush8B(tempPushLIP); (* Padded 32 high-order bits of 0 for 32 bit LIP*)\n    ShadowStackPush8B(tempSSP);\n    FI;\n    IF EndbranchEnabled(CPL)\n        IF CPL = 3\n            THEN\n                IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                IA32_U_CET.SUPPRESS = 0\n            ELSE\n                IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                IA32_S_CET.SUPPRESS = 0\n        FI;\n    FI;\nEND;\nCALL-GATE:\n    IF call gate (DPL < CPL) or (RPL > DPL)\n        THEN #GP(call-gate selector); FI;\n    IF call gate not present\n        THEN #NP(call-gate selector); FI;\n    IF call-gate code-segment selector is NULL\n        THEN #GP(0); FI;\n    IF call-gate code-segment selector index is outside descriptor table limits\n        THEN #GP(call-gate code-segment selector); FI;\n    Read call-gate code-segment descriptor;\n    IF call-gate code-segment descriptor does not indicate a code segment\n    or call-gate code-segment descriptor DPL > CPL\n        THEN #GP(call-gate code-segment selector); FI;\n    IF IA32_EFER.LMA = 1 AND (call-gate code-segment descriptor is\n    not a 64-bit code segment or call-gate code-segment descriptor has both L-bit and D-bit set)\n        THEN #GP(call-gate code-segment selector); FI;\n    IF call-gate code segment not present\n        THEN #NP(call-gate code-segment selector); FI;\n    IF call-gate code segment is non-conforming and DPL < CPL\n        THEN go to MORE-PRIVILEGE;\n        ELSE go to SAME-PRIVILEGE;\n    FI;\nEND;\nMORE-PRIVILEGE:\n    IF current TSS is 32-bit\n        THEN\n            TSSstackAddress := (new code-segment DPL ∗ 8) + 4;\n            IF (TSSstackAddress + 5) > current TSS limit\n                THEN #TS(current TSS selector); FI;\n            NewSS := 2 bytes loaded from (TSS base + TSSstackAddress + 4);\n            NewESP := 4 bytes loaded from (TSS base + TSSstackAddress);\n        ELSE\n            IF current TSS is 16-bit\n                THEN\n                    TSSstackAddress := (new code-segment DPL ∗ 4) + 2\n                    IF (TSSstackAddress + 3) > current TSS limit\n                        THEN #TS(current TSS selector); FI;\n                    NewSS := 2 bytes loaded from (TSS base + TSSstackAddress + 2);\n                    NewESP := 2 bytes loaded from (TSS base + TSSstackAddress);\n                ELSE (* current TSS is 64-bit *)\n                    TSSstackAddress := (new code-segment DPL ∗ 8) + 4;\n                    IF (TSSstackAddress + 7) > current TSS limit\n                        THEN #TS(current TSS selector); FI;\n                    NewSS := new code-segment DPL; (* NULL selector with RPL = new CPL *)\n                    NewRSP := 8 bytes loaded from (current TSS base + TSSstackAddress);\n            FI;\n    FI;\n    IF IA32_EFER.LMA = 0 and NewSS is NULL\n        THEN #TS(NewSS); FI;\n    Read new stack-segment descriptor;\n    IF IA32_EFER.LMA = 0 and (NewSS RPL ≠ new code-segment DPL\n    or new stack-segment DPL ≠ new code-segment DPL or new stack segment is not a\n    writable data segment)\n        THEN #TS(NewSS); FI\n    IF IA32_EFER.LMA = 0 and new stack segment not present\n        THEN #SS(NewSS); FI;\n    IF CallGateSize = 32\n        THEN\n            IF new stack does not have room for parameters plus 16 bytes\n                THEN #SS(NewSS); FI;\n            IF CallGate(InstructionPointer) not within new code-segment limit\n                THEN #GP(0); FI;\n            SS:=newSS; (*Segmentdescriptorinformationalsoloaded*)\n            ESP := newESP;\n            CS:EIP := CallGate(CS:InstructionPointer);\n            (* Segment descriptor information also loaded *)\n            Push(oldSS:oldESP); (* From calling procedure *)\n            temp := parameter count from call gate, masked to 5 bits;\n            Push(parameters from calling procedure’s stack, temp)\n            Push(oldCS:oldEIP); (* Return address to calling procedure *)\n        ELSE\n            IF CallGateSize = 16\n                THEN\n                    IF new stack does not have room for parameters plus 8 bytes\n                        THEN #SS(NewSS); FI;\n                    IF (CallGate(InstructionPointer) AND FFFFH) not in new code-segment limit\n                        THEN #GP(0); FI;\n                    SS:=newSS; (*Segmentdescriptorinformationalsoloaded*)\n                    ESP := newESP;\n                    CS:IP := CallGate(CS:InstructionPointer);\n                    (* Segment descriptor information also loaded *)\n                    Push(oldSS:oldESP); (* From calling procedure *)\n                    temp := parameter count from call gate, masked to 5 bits;\n                    Push(parameters from calling procedure’s stack, temp)\n                    Push(oldCS:oldEIP); (* Return address to calling procedure *)\n                ELSE (* CallGateSize = 64 *)\n                    IF pushing 32 bytes on the stack would use a non-canonical address\n                        THEN #SS(NewSS); FI;\n                    IF (CallGate(InstructionPointer) is non-canonical)\n                        THEN #GP(0); FI;\n                    SS := NewSS; (* NewSS is NULL)\n                    RSP := NewESP;\n                    CS:IP := CallGate(CS:InstructionPointer);\n                    (* Segment descriptor information also loaded *)\n                    Push(oldSS:oldESP); (* From calling procedure *)\n                    Push(oldCS:oldEIP); (* Return address to calling procedure *)\n            FI;\n    FI;\n    IF ShadowStackEnabled(CPL) AND CPL = 3\n        THEN\n            IF IA32_EFER.LMA = 0\n                THEN IA32_PL3_SSP := SSP;\n                ELSE (* adjust so bits 63:N get the value of bit N–1, where N is the CPU’s maximum linear-address width *)\n                    IA32_PL3_SSP := LA_adjust(SSP);\n            FI;\n    FI;\n    CPL := CodeSegment(DPL)\n    CS(RPL) := CPL\n    IF ShadowStackEnabled(CPL)\n        oldSSP := SSP\n        SSP := IA32_PLi_SSP; (* where i is the CPL *)\n        IF SSP & 0x07 != 0 (* if SSP not aligned to 8 bytes then #GP *)\n            THEN #GP(0); FI;\n        (* Token and CS:LIP:oldSSP pushed on shadow stack must be contained in a naturally aligned 32-byte region*)\n        IF (SSP & ~0x1F) != ((SSP – 24) & ~0x1F)\n            #GP(0); FI;\n        IF ((IA32_EFER.LMA and CS.L) = 0 AND SSP[63:32] != 0)\n            THEN #GP(0); FI;\n        expected_token_value = SSP (* busy bit - bit position 0 - must be clear *)\n        new_token_value = SSP | BUSY_BIT (* Set the busy bit *)\n        IF shadow_stack_lock_cmpxchg8b(SSP, new_token_value, expected_token_value) != expected_token_value\n            THEN #GP(0); FI;\n        IF oldSS.DPL != 3\n            ShadowStackPush8B(oldCS); (* Padded with 48 high-order bits of 0 *)\n            ShadowStackPush8B(oldCSBASE+oldRIP); (* Padded with 32 high-order bits of 0 for 32 bit LIP*)\n            ShadowStackPush8B(oldSSP);\n        FI;\n    FI;\n    IF EndbranchEnabled (CPL)\n        IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n        IA32_S_CET.SUPPRESS = 0\n    FI;\nEND;\nSAME-PRIVILEGE:\n    IF CallGateSize = 32\n        THEN\n            IF stack does not have room for 8 bytes\n                THEN #SS(0); FI;\n            IF CallGate(InstructionPointer) not within code segment limit\n                THEN #GP(0); FI;\n            CS:EIP := CallGate(CS:EIP) (* Segment descriptor information also loaded *)\n            Push(oldCS:oldEIP); (* Return address to calling procedure *)\n        ELSE\n            If CallGateSize = 16\n                THEN\n                    IF stack does not have room for 4 bytes\n                        THEN #SS(0); FI;\n                    IF CallGate(InstructionPointer) not within code segment limit\n                        THEN #GP(0); FI;\n                    CS:IP := CallGate(CS:instruction pointer);\n                    (* Segment descriptor information also loaded *)\n                    Push(oldCS:oldIP); (* Return address to calling procedure *)\n                ELSE (* CallGateSize = 64)\n                    IF pushing 16 bytes on the stack touches non-canonical addresses\n                        THEN #SS(0); FI;\n                    IF RIP non-canonical\n                        THEN #GP(0); FI;\n                    CS:IP := CallGate(CS:instruction pointer);\n                    (* Segment descriptor information also loaded *)\n                    Push(oldCS:oldIP); (* Return address to calling procedure *)\n            FI;\n    FI;\n    CS(RPL) := CPL\n    IF ShadowStackEnabled(CPL)\n        (* Align to next 8 byte boundary *)\n        tempSSP = SSP;\n        Shadow_stack_store 4 bytes of 0 to (SSP – 4)\n        SSP = SSP & 0xFFFFFFFFFFFFFFF8H;\n        (* push cs:lip:ssp on shadow stack *)\n        ShadowStackPush8B(oldCS); (* Padded with 48 high-order bits of 0 *)\n        ShadowStackPush8B(oldCSBASE + oldRIP); (* Padded with 32 high-order bits of 0 for 32 bit LIP*)\n        ShadowStackPush8B(tempSSP);\n    FI;\n    IF EndbranchEnabled (CPL)\n        IF CPL = 3\n            THEN\n                IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;\n                IA32_U_CET.SUPPRESS = 0\n            ELSE\n                IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;\n                IA32_S_CET.SUPPRESS = 0\n        FI;\n    FI;\nEND;\nTASK-GATE:\n    IF task gate DPL < CPL or RPL\n        THEN #GP(task gate selector); FI;\n    IF task gate not present\n        THEN #NP(task gate selector); FI;\n    Read the TSS segment selector in the task-gate descriptor;\n    IF TSS segment selector local/global bit is set to local\n    or index not within GDT limits\n        THEN #GP(TSS selector); FI;\n    Access TSS descriptor in GDT;\n    IF descriptor is not a TSS segment\n        THEN #GP(TSS selector); FI;\n    IF TSS descriptor specifies that the TSS is busy\n        THEN #GP(TSS selector); FI;\n    IF TSS not present\n        THEN #NP(TSS selector); FI;\n    SWITCH-TASKS (with nesting) to TSS;\n    IF EIP not within code segment limit\n        THEN #GP(0); FI;\nEND;\nTASK-STATE-SEGMENT:\n    IF TSS DPL < CPL or RPL\n    or TSS descriptor indicates TSS not available\n        THEN #GP(TSS selector); FI;\n    IF TSS is not present\n        THEN #NP(TSS selector); FI;\n    SWITCH-TASKS (with nesting) to TSS;\n    IF EIP not within code segment limit\n        THEN #GP(0); FI;\nEND;",
    "flagsAffectedText": "All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.",
    "exceptions": {
      "64BitMode": [
        "column_1: If target offset in destination operand is non-canonical.; \ncolumn_1: If the segment selector in the destination operand is NULL.; \ncolumn_1: If the code segment selector in the 64-bit gate is NULL.; \ncolumn_1: If target mode is compatibility mode and SSP is not in low 4GB.; \ncolumn_1: If SSP in IA32_PLi_SSP (where i is the new CPL) is not 8 byte aligned.; \ncolumn_1: If the token and the stack frame to be pushed on shadow stack are not contained in a naturally aligned 32-byte region of the shadow stack.; \ncolumn_1: If “supervisor Shadow Stack” token on new shadow stack is marked busy.; \ncolumn_1: If destination mode is 32-bit mode or compatibility mode, but SSP address in “super-visor shadow” stack token is beyond 4GB.; \ncolumn_1: If SSP address in “supervisor shadow stack” token does not match SSP address in IA32_PLi_SSP (where i is the new CPL).; \ncolumn_1: #GP(selector); column_2: If code segment or 64-bit call gate is outside descriptor table limits.; \ncolumn_1: If code segment or 64-bit call gate overlaps non-canonical space.; \ncolumn_1: If the segment descriptor pointed to by the segment selector in the destination operand is not for a conforming-code segment, nonconforming-code segment, or 64-bit call gate.; \ncolumn_1: If the segment descriptor pointed to by the segment selector in the destination operand is a code segment and has both the D-bit and the L- bit set.; \ncolumn_1: If the DPL for a nonconforming-code segment is not equal to the CPL, or the RPL for the segment’s segment selector is greater than the CPL.; \ncolumn_1: If the DPL for a conforming-code segment is greater than the CPL.; \ncolumn_1: If the DPL from a 64-bit call-gate is less than the CPL or than the RPL of the 64-bit call-gate.; \ncolumn_1: If the upper type field of a 64-bit call gate is not 0x0.; \ncolumn_1: If the segment selector from a 64-bit call gate is beyond the descriptor table limits.; \ncolumn_1: If the DPL for a code-segment obtained from a 64-bit call gate is greater than the CPL.; \ncolumn_1: If the code segment descriptor pointed to by the selector in the 64-bit gate doesn't have the L-bit set and the D-bit clear.; \ncolumn_1: If the segment descriptor for a segment selector from the 64-bit call gate does not indicate it is a code segment.; \ncolumn_2: If pushing the return offset or CS selector onto the stack exceeds the bounds of the stack segment when no stack switch occurs.; column_1: #SS(0); \ncolumn_1: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: If the stack address is in a non-canonical form.; \ncolumn_1: #SS(selector); column_2: If pushing the old values of SS selector, stack pointer, EFLAGS, CS selector, offset, or error code onto the stack violates the canonical boundary when a stack switch occurs.; \ncolumn_1: #NP(selector); column_2: If a code segment or 64-bit call gate is not present.; \ncolumn_1: #TS(selector); column_2: If the load of the new RSP exceeds the limit of the TSS.; \ncolumn_1: #UD; column_2: (64-bit mode only) If a far call is direct to an absolute address in memory.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode.",
        "column_2: If the target offset in the destination operand is non-canonical.; column_1: #GP(0);"
      ],
      "protectedMode": [
        "column_1: If the segment selector in the destination operand is NULL.; \ncolumn_1: If the code segment selector in the gate is NULL.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If target mode is compatibility mode and SSP is not in low 4GB.; \ncolumn_1: If SSP in IA32_PLi_SSP (where i is the new CPL) is not 8 byte aligned.; \ncolumn_1: If the token and the stack frame to be pushed on shadow stack are not contained in a naturally aligned 32-byte region of the shadow stack.; \ncolumn_1: If “supervisor Shadow Stack” token on new shadow stack is marked busy.; \ncolumn_1: If destination mode is 32-bit or compatibility mode, but SSP address in “supervisor shadow stack” token is beyond 4GB.; \ncolumn_1: If SSP address in “supervisor shadow stack” token does not match SSP address in IA32_PLi_SSP (where i is the new CPL).; \ncolumn_1: #GP(selector); column_2: If a code segment or gate or TSS selector index is outside descriptor table limits.; \ncolumn_1: If the segment descriptor pointed to by the segment selector in the destination operand is not for a conforming-code segment, nonconforming-code segment, call gate, task gate, or task state segment.; \ncolumn_1: If the DPL for a nonconforming-code segment is not equal to the CPL or the RPL for the segment’s segment selector is greater than the CPL.; \ncolumn_1: If the DPL for a conforming-code segment is greater than the CPL.; \ncolumn_1: If the DPL from a call-gate, task-gate, or TSS segment descriptor is less than the CPL or than the RPL of the call-gate, task-gate, or TSS’s segment selector.; \ncolumn_1: If the segment descriptor for a segment selector from a call gate does not indicate it is a code segment.; \ncolumn_1: If the segment selector from a call gate is beyond the descriptor table limits.; \ncolumn_1: If the DPL for a code-segment obtained from a call gate is greater than the CPL.; \ncolumn_1: If the segment selector for a TSS has its local/global bit set for local.; \ncolumn_1: If a TSS segment descriptor specifies that the TSS is busy or not available.; \ncolumn_1: #SS(0); column_2: If pushing the return address, parameters, or stack segment pointer onto the stack exceeds the bounds of the stack segment, when no stack switch occurs.; \ncolumn_1: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #SS(selector); column_2: If pushing the return address, parameters, or stack segment pointer onto the stack exceeds the bounds of the stack segment, when a stack switch occurs.; \ncolumn_1: If the SS register is being loaded as part of a stack switch and the segment pointed to is marked not present.; \ncolumn_1: If stack segment does not have room for the return address, parameters, or stack segment pointer, when stack switch occurs.; \ncolumn_1: #NP(selector); column_2: If a code segment, data segment, call gate, task gate, or TSS is not present.; \ncolumn_2: If the new stack segment selector and ESP are beyond the end of the TSS.; column_1: #TS(selector); \ncolumn_1: If the new stack segment selector is NULL.; \ncolumn_1: If the RPL of the new stack segment selector in the TSS is not equal to the DPL of the code segment being accessed.; \ncolumn_1: If DPL of the stack segment descriptor for the new stack segment is not equal to the DPL of the code segment descriptor.; \ncolumn_1: If the new stack segment is not a writable data segment.; \ncolumn_1: If segment-selector index for stack segment is outside descriptor table limits.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: If the target offset is beyond the code segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If the target offset is beyond the code segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/imul",
    "category": "Core Instructions",
    "instructionName": "IMUL\n\t\t— Signed Multiply",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "AX:= AL ∗ r/m byte.",
        "Instruction": "IMUL r/m81",
        "Op/En": "M",
        "Opcode": "F6 /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "DX:AX := AX ∗ r/m word.",
        "Instruction": "IMUL r/m16",
        "Op/En": "M",
        "Opcode": "F7 /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "EDX:EAX := EAX ∗ r/m32.",
        "Instruction": "IMUL r/m32",
        "Op/En": "M",
        "Opcode": "F7 /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "RDX:RAX := RAX ∗ r/m64.",
        "Instruction": "IMUL r/m64",
        "Op/En": "M",
        "Opcode": "REX.W + F7 /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "word register := word register ∗ r/m16.",
        "Instruction": "IMUL r16, r/m16",
        "Op/En": "RM",
        "Opcode": "0F AF /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "doubleword register := doubleword register ∗ r/m32.",
        "Instruction": "IMUL r32, r/m32",
        "Op/En": "RM",
        "Opcode": "0F AF /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Quadword register := Quadword register ∗ r/m64.",
        "Instruction": "IMUL r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 0F AF /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "word register := r/m16 ∗ sign-extended immediate byte.",
        "Instruction": "IMUL r16, r/m16, imm8",
        "Op/En": "RMI",
        "Opcode": "6B /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "doubleword register := r/m32 ∗ sign-extended immediate byte.",
        "Instruction": "IMUL r32, r/m32, imm8",
        "Op/En": "RMI",
        "Opcode": "6B /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Quadword register := r/m64 ∗ sign-extended immediate byte.",
        "Instruction": "IMUL r64, r/m64, imm8",
        "Op/En": "RMI",
        "Opcode": "REX.W + 6B /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "word register := r/m16 ∗ immediate word.",
        "Instruction": "IMUL r16, r/m16, imm16",
        "Op/En": "RMI",
        "Opcode": "69 /r iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "doubleword register := r/m32 ∗ immediate doubleword.",
        "Instruction": "IMUL r32, r/m32, imm32",
        "Op/En": "RMI",
        "Opcode": "69 /r id"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Quadword register := r/m64 ∗ immediate doubleword.",
        "Instruction": "IMUL r64, r/m64, imm32",
        "Op/En": "RMI",
        "Opcode": "REX.W + 69 /r id"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8/16/32",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.\nWhen an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\nThe CF and OF flags are set when the signed integer value of the intermediate product differs from the sign extended operand-size-truncated product, otherwise the CF and OF flags are cleared.\nThe three forms of the IMUL instruction are similar in that the length of the product is calculated to twice the length of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and three- operand forms, however, the result is truncated to the length of the destination before it is stored in the destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits are lost.\nThe two- and three-operand forms may also be used with unsigned operands because the lower half of the product is the same regardless if the operands are signed or unsigned. The CF and OF flags, however, cannot be used to determine if the upper half of the result is non-zero.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. Use of REX.W modifies the three forms of the instruction as follows.",
    "operationText": "IF (NumberOfOperands = 1)\n    THEN IF (OperandSize = 8)\n        THEN\n            TMP_XP := AL ∗ SRC (* Signed multiplication; TMP_XP is a signed integer at twice the width of the SRC *);\n            AX := TMP_XP[15:0];\n            IF SignExtend(TMP_XP[7:0]) = TMP_XP\n                THEN CF := 0; OF := 0;\n                ELSE CF := 1; OF := 1; FI;\n        ELSE IF OperandSize = 16\n            THEN\n                TMP_XP := AX ∗ SRC (* Signed multiplication; TMP_XP is a signed integer at twice the width of the SRC *)\n                DX:AX := TMP_XP[31:0];\n                IF SignExtend(TMP_XP[15:0]) = TMP_XP\n                    THEN CF := 0; OF := 0;\n                    ELSE CF := 1; OF := 1; FI;\n            ELSE IF OperandSize = 32\n                THEN\n                    TMP_XP := EAX ∗ SRC (* Signed multiplication; TMP_XP is a signed integer at twice the width of the SRC*)\n                    EDX:EAX := TMP_XP[63:0];\n                    IF SignExtend(TMP_XP[31:0]) = TMP_XP\n                        THEN CF := 0; OF := 0;\n                        ELSE CF := 1; OF := 1; FI;\n                ELSE (* OperandSize = 64 *)\n                    TMP_XP := RAX ∗ SRC (* Signed multiplication; TMP_XP is a signed integer at twice the width of the SRC *)\n                    EDX:EAX := TMP_XP[127:0];\n                    IF SignExtend(TMP_XP[63:0]) = TMP_XP\n                        THEN CF := 0; OF := 0;\n                        ELSE CF := 1; OF := 1; FI;\n                FI;\n        FI;\n    ELSE IF (NumberOfOperands = 2)\n        THEN\n            TMP_XP := DEST ∗ SRC (* Signed multiplication; TMP_XP is a signed integer at twice the width of the SRC *)\n            DEST := TruncateToOperandSize(TMP_XP);\n            IF SignExtend(DEST) ≠ TMP_XP\n                THEN CF := 1; OF := 1;\n                ELSE CF := 0; OF := 0; FI;\n        ELSE (* NumberOfOperands = 3 *)\n            TMP_XP := SRC1 ∗ SRC2 (* Signed multiplication; TMP_XP is a signed integer at twice the width of the SRC1 *)\n            DEST := TruncateToOperandSize(TMP_XP);\n            IF SignExtend(DEST) ≠ TMP_XP\n                THEN CF := 1; OF := 1;\n                ELSE CF := 0; OF := 0; FI;\n    FI;\nFI;",
    "flagsAffectedText": "For the one operand form of the instruction, the CF and OF flags are set when significant bits are carried into the upper half of the result and cleared when the result fits exactly in the lower half of the result. For the two- and three-operand forms of the instruction, the CF and OF flags are set when the result must be truncated to fit in the destination operand size and cleared when the result fits exactly in the destination operand size. The SF, ZF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcp28sd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VRCP28SD\n\t\t— Approximation to the Reciprocal of Scalar Double Precision Floating-Point ValueWith Less Than 2^-28 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes the approximate reciprocal ( < 2^-28 relative error) of the scalar double precision floating-point value in xmm3/m64 and stores the results in xmm1. Under writemask. Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 CB /r VRCP28SD xmm1 {k1}{z}, xmm2, xmm3/m64 {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A Tuple1 Scalar ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/senduipi",
    "category": "Core Instructions",
    "instructionName": "SENDUIPI\n\t\t— Send User Interprocessor Interrupt",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "UINTR",
        "Description": "Send interprocessor user interrupt.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F C7 /6 SENDUIPI reg"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The SENDUIPI instruction sends the user interprocessor interrupt (IPI) indicated by its register operand. (The operand always has 64 bits; operand-size overrides such as the prefix 66 are ignored.)\nSENDUIPI uses a data structure called the user-interrupt target table (UITT). This table is located at the linear address UITTADDR (in the IA32_UINTR_TT MSR); it comprises UITTSZ+1 16-byte entries, where UITTSZ = IA32_UINT_MISC[31:0]. SENDUIPI uses the UITT entry (UITTE) indexed by the instruction's register operand. Each UITTE has the following format:\nEach UPID has the following format (fields and bits not referenced are reserved):\nAlthough SENDUIPI may be executed at any privilege level, all of the instruction’s memory accesses (to a UITTE and a UPID) are performed with supervisor privilege.\nSENDUIPI sends a user interrupt by posting a user interrupt with vector V in the UPID referenced by UPIDADDR and then sending, as an ordinary IPI, any notification interrupt specified in that UPID.",
    "operationText": "IF reg > UITTSZ;\n    THEN #GP(0);\nFI;\nread tempUITTE from 16 bytes at UITTADDR+ (reg « 4);\nIF tempUITTE.V = 0 or tempUITTE sets any reserved bit\n    THEN #GP(0);\nFI;\nread tempUPID from 16 bytes at tempUITTE.UPIDADDR;// under lock\nIF tempUPID sets any reserved bits or bits that must be zero\n    THEN #GP(0); // release lock\nFI;\ntempUPID.PIR[tempUITTE.UV] := 1;\nIF tempUPID.SN = tempUPID.ON = 0\n    THEN\n        tempUPID.ON := 1;\n        sendNotify := 1;\n    ELSE sendNotify := 0;\nFI;\nwrite tempUPID to 16 bytes at tempUITTE.UPIDADDR;// release lock\nIF sendNotify = 1\n    THEN\n        IF local APIC is in x2APIC mode\n            THEN send ordinary IPI with vector tempUPID.NV\n                to 32-bit physical APIC ID tempUPID.NDST;\n            ELSE send ordinary IPI with vector tempUPID.NV\n                to 8-bit physical APIC ID tempUPID.NDST[15:8];\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If executed inside an enclave.; \ncolumn_1: If CR4.UINTR = 0.; \ncolumn_1: If IA32_UINTR_TT[0] = 0.; \ncolumn_1: If CPUID.07H.0H:EDX.UINTR[bit 5] = 0.; \ncolumn_1: #PF; column_2: If a page fault occurs.; \ncolumn_1: #GP; column_2: If the value of the register operand exceeds UITTSZ.; \ncolumn_1: If the selected UITTE is not valid or sets any reserved bits.; \ncolumn_1: If the selected UPID sets any reserved bits.; \ncolumn_1: If there is an attempt to access memory using a linear address that is not canonical relative to the current paging mode.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscalefpd",
    "category": "Core Instructions",
    "instructionName": "VSCALEFPD\n\t\t— Scale Packed Float64 Values With Float64 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Scale the packed double precision floating-point values in xmm2 using values from xmm3/m128/m64bcst. Under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 2C /r VSCALEFPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Scale the packed double precision floating-point values in ymm2 using values from ymm3/m256/m64bcst. Under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 2C /r VSCALEFPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Scale the packed double precision floating-point values in zmm2 using values from zmm3/m512/m64bcst. Under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 2C /r VSCALEFPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xorpd",
    "category": "Core Instructions",
    "instructionName": "XORPD\n\t\t— Bitwise Logical XOR of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Return the bitwise logical XOR of packed double precision floating-point values in xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 57/r XORPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical XOR of packed double precision floating-point values in xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 57 /r VXORPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical XOR of packed double precision floating-point values in ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 57 /r VXORPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical XOR of packed double precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 57 /r VXORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical XOR of packed double precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 57 /r VXORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Return the bitwise logical XOR of packed double precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 57 /r VXORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtuqq2ps",
    "category": "Core Instructions",
    "instructionName": "VCVTUQQ2PS\n\t\t— Convert Packed Unsigned Quadword Integers to Packed Single PrecisionFloating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to packed single precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F2.0F.W1 7A /r VCVTUQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed single precision floating-point values in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F2.0F.W1 7A /r VCVTUQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed single precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F2.0F.W1 7A /r VCVTUQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscalefsh",
    "category": "Core Instructions",
    "instructionName": "VSCALEFSH\n\t\t— Scale Scalar FP16 Values with FP16 Values",
    "detailsTable": [
      {
        "Description": "Scale the FP16 values in xmm2 using the value from xmm3/m16 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 2D /r VSCALEFSH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/minpd",
    "category": "Core Instructions",
    "instructionName": "MINPD\n\t\t— Minimum of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Return the minimum double precision floating-point values between xmm1 and xmm2/mem",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 5D /r MINPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the minimum double precision floating-point values between xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 5D /r VMINPD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the minimum packed double precision floating-point values between ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 5D /r VMINPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Return the minimum packed double precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 5D /r VMINPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Return the minimum packed double precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 5D /r VMINPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Return the minimum packed double precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 5D /r VMINPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed double precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.\nIf the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "MIN(SRC1, SRC2)\n{\n    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;\n        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC1 < SRC2) THEN DEST := SRC1;\n        ELSE DEST := SRC2;\n    FI;\n}\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := MIN(SRC1[i+63:i], SRC2[63:0])\n                ELSE\n                    DEST[i+63:i] := MIN(SRC1[i+63:i], SRC2[i+63:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE DEST[i+63:i] := 0\n                        ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := MIN(SRC1[63:0], SRC2[63:0])\nDEST[127:64] := MIN(SRC1[127:64], SRC2[127:64])\nDEST[191:128] := MIN(SRC1[191:128], SRC2[191:128])\nDEST[255:192] := MIN(SRC1[255:192], SRC2[255:192])\nDEST[63:0] := MIN(SRC1[63:0], SRC2[63:0])\nDEST[127:64] := MIN(SRC1[127:64], SRC2[127:64])\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := MIN(SRC1[63:0], SRC2[63:0])\nDEST[127:64] := MIN(SRC1[127:64], SRC2[127:64])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (including QNaN Source Operand), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/clflush",
    "category": "Core Instructions",
    "instructionName": "CLFLUSH\n\t\t— Flush Cache Line",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Flushes cache line containing m8.",
        "Op/En": "M",
        "Opcode / Instruction": "NP 0F AE /7 CLFLUSH m8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand. If that cache line contains modified data at any level of the cache hierarchy, that data is written back to memory. The source operand is a byte memory location.\nThe availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH (CPUID.01H:EDX[bit 19]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references the cache line).\nExecutions of the CLFLUSH instruction are ordered with respect to each other and with respect to writes, locked read-modify-write instructions, and fence instructions.1 They are not ordered with respect to executions of CLFLUSHOPT and CLWB. Software can use the SFENCE instruction to order an execution of CLFLUSH relative to one of those operations.\nThe CLFLUSH instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load (and in addition, a CLFLUSH instruction is allowed to flush a linear address in an execute-only segment). Like a load, the CLFLUSH instruction sets the A bit but not the D bit in the page tables.\nIn some implementations, the CLFLUSH instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX). The CLFLUSH instruction is not expected to be commonly used inside typical transactional regions. However, programmers must not rely on CLFLUSH instruction to force a transactional abort, since whether they cause transactional abort is implementation dependent.\nThe CLFLUSH instruction was introduced with the SSE2 extensions; however, because it has its own CPUID feature flag, it can be implemented in IA-32 processors that do not include the SSE2 extensions. Also, detecting the presence of the SSE2 extensions with the CPUID instruction does not guarantee that the CLFLUSH instruction is implemented in the processor.\nCLFLUSH operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "Flush_Cache_Line(SRC);",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.01H:EDX.CLFSH[bit 19] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_2: For a page fault.; column_1: #PF(fault-code); \ncolumn_1: #UD; column_2: If CPUID.01H:EDX.CLFSH[bit 19] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If CPUID.01H:EDX.CLFSH[bit 19] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode.",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpcmpq:vpcmpuq",
    "category": "Core Instructions",
    "instructionName": "VPCMPQ/VPCMPUQ\n\t\t— Compare Packed Integer Values Into Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 1F /r ib VPCMPQ k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed signed quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 1F /r ib VPCMPQ k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed signed quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 1F /r ib VPCMPQ k1 {k2}, zmm2, zmm3/m512/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 1E /r ib VPCMPUQ k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 1E /r ib VPCMPUQ k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed unsigned quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 1E /r ib VPCMPUQ k1 {k2}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/rep:repe:repz:repne:repnz",
    "category": "Core Instructions",
    "instructionName": "REP/REPE/REPZ/REPNE/REPNZ\n\t\t— Repeat String Operation Prefix",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input (E)CX bytes from port DX into ES:[(E)DI].",
        "Instruction": "REP INS m8, DX",
        "Op/En": "ZO",
        "Opcode": "F3 6C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Input RCX bytes from port DX into [RDI].",
        "Instruction": "REP INS m8, DX",
        "Op/En": "ZO",
        "Opcode": "F3 6C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input (E)CX words from port DX into ES:[(E)DI.]",
        "Instruction": "REP INS m16, DX",
        "Op/En": "ZO",
        "Opcode": "F3 6D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input (E)CX doublewords from port DX into ES:[(E)DI].",
        "Instruction": "REP INS m32, DX",
        "Op/En": "ZO",
        "Opcode": "F3 6D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Input RCX default size from port DX into [RDI].",
        "Instruction": "REP INS r/m32, DX",
        "Op/En": "ZO",
        "Opcode": "F3 6D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI].",
        "Instruction": "REP MOVS m8, m8",
        "Op/En": "ZO",
        "Opcode": "F3 A4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move RCX bytes from [RSI] to [RDI].",
        "Instruction": "REP MOVS m8, m8",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W A4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI].",
        "Instruction": "REP MOVS m16, m16",
        "Op/En": "ZO",
        "Opcode": "F3 A5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI].",
        "Instruction": "REP MOVS m32, m32",
        "Op/En": "ZO",
        "Opcode": "F3 A5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Move RCX quadwords from [RSI] to [RDI].",
        "Instruction": "REP MOVS m64, m64",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W A5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output (E)CX bytes from DS:[(E)SI] to port DX.",
        "Instruction": "REP OUTS DX, r/m8",
        "Op/En": "ZO",
        "Opcode": "F3 6E"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Output RCX bytes from [RSI] to port DX.",
        "Instruction": "REP OUTS DX, r/m81",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W 6E"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output (E)CX words from DS:[(E)SI] to port DX.",
        "Instruction": "REP OUTS DX, r/m16",
        "Op/En": "ZO",
        "Opcode": "F3 6F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Output (E)CX doublewords from DS:[(E)SI] to port DX.",
        "Instruction": "REP OUTS DX, r/m32",
        "Op/En": "ZO",
        "Opcode": "F3 6F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Output RCX default size from [RSI] to port DX.",
        "Instruction": "REP OUTS DX, r/m32",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W 6F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load (E)CX bytes from DS:[(E)SI] to AL.",
        "Instruction": "REP LODS AL",
        "Op/En": "ZO",
        "Opcode": "F3 AC"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load RCX bytes from [RSI] to AL.",
        "Instruction": "REP LODS AL",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W AC"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load (E)CX words from DS:[(E)SI] to AX.",
        "Instruction": "REP LODS AX",
        "Op/En": "ZO",
        "Opcode": "F3 AD"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Load (E)CX doublewords from DS:[(E)SI] to EAX.",
        "Instruction": "REP LODS EAX",
        "Op/En": "ZO",
        "Opcode": "F3 AD"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Load RCX quadwords from [RSI] to RAX.",
        "Instruction": "REP LODS RAX",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W AD"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Fill (E)CX bytes at ES:[(E)DI] with AL.",
        "Instruction": "REP STOS m8",
        "Op/En": "ZO",
        "Opcode": "F3 AA"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Fill RCX bytes at [RDI] with AL.",
        "Instruction": "REP STOS m8",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W AA"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Fill (E)CX words at ES:[(E)DI] with AX.",
        "Instruction": "REP STOS m16",
        "Op/En": "ZO",
        "Opcode": "F3 AB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Fill (E)CX doublewords at ES:[(E)DI] with EAX.",
        "Instruction": "REP STOS m32",
        "Op/En": "ZO",
        "Opcode": "F3 AB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Fill RCX quadwords at [RDI] with RAX.",
        "Instruction": "REP STOS m64",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W AB"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI].",
        "Instruction": "REPE CMPS m8, m8",
        "Op/En": "ZO",
        "Opcode": "F3 A6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Find non-matching bytes in [RDI] and [RSI].",
        "Instruction": "REPE CMPS m8, m8",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W A6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI].",
        "Instruction": "REPE CMPS m16, m16",
        "Op/En": "ZO",
        "Opcode": "F3 A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI].",
        "Instruction": "REPE CMPS m32, m32",
        "Op/En": "ZO",
        "Opcode": "F3 A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Find non-matching quadwords in [RDI] and [RSI].",
        "Instruction": "REPE CMPS m64, m64",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find non-AL byte starting at ES:[(E)DI].",
        "Instruction": "REPE SCAS m8",
        "Op/En": "ZO",
        "Opcode": "F3 AE"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Find non-AL byte starting at [RDI].",
        "Instruction": "REPE SCAS m8",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W AE"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find non-AX word starting at ES:[(E)DI].",
        "Instruction": "REPE SCAS m16",
        "Op/En": "ZO",
        "Opcode": "F3 AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find non-EAX doubleword starting at ES:[(E)DI].",
        "Instruction": "REPE SCAS m32",
        "Op/En": "ZO",
        "Opcode": "F3 AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Find non-RAX quadword starting at [RDI].",
        "Instruction": "REPE SCAS m64",
        "Op/En": "ZO",
        "Opcode": "F3 REX.W AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find matching bytes in ES:[(E)DI] and DS:[(E)SI].",
        "Instruction": "REPNE CMPS m8, m8",
        "Op/En": "ZO",
        "Opcode": "F2 A6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Find matching bytes in [RDI] and [RSI].",
        "Instruction": "REPNE CMPS m8, m8",
        "Op/En": "ZO",
        "Opcode": "F2 REX.W A6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find matching words in ES:[(E)DI] and DS:[(E)SI].",
        "Instruction": "REPNE CMPS m16, m16",
        "Op/En": "ZO",
        "Opcode": "F2 A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI].",
        "Instruction": "REPNE CMPS m32, m32",
        "Op/En": "ZO",
        "Opcode": "F2 A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Find matching doublewords in [RDI] and [RSI].",
        "Instruction": "REPNE CMPS m64, m64",
        "Op/En": "ZO",
        "Opcode": "F2 REX.W A7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find AL, starting at ES:[(E)DI].",
        "Instruction": "REPNE SCAS m8",
        "Op/En": "ZO",
        "Opcode": "F2 AE"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Find AL, starting at [RDI].",
        "Instruction": "REPNE SCAS m8",
        "Op/En": "ZO",
        "Opcode": "F2 REX.W AE"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find AX, starting at ES:[(E)DI].",
        "Instruction": "REPNE SCAS m16",
        "Op/En": "ZO",
        "Opcode": "F2 AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Find EAX, starting at ES:[(E)DI].",
        "Instruction": "REPNE SCAS m32",
        "Op/En": "ZO",
        "Opcode": "F2 AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Find RAX, starting at [RDI].",
        "Instruction": "REPNE SCAS m64",
        "Op/En": "ZO",
        "Opcode": "F2 REX.W AF"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:\nThe REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be repeated until the count in register is decremented to 0. See Table 4-17.\nThe REPE, REPNE, REPZ, and REPNZ prefixes also check the state of the ZF flag after each iteration and terminate the repeat loop if the ZF flag is not in the specified state. When both termination conditions are tested, the cause of a repeat termination can be determined either by testing the count register with a JECXZ instruction or by testing the ZF flag (with a JZ, JNZ, or JNE instruction).\nWhen the REPE/REPZ and REPNE/REPNZ prefixes are used, the ZF flag does not require initialization because both the CMPS and SCAS instructions affect the ZF flag according to the results of the comparisons they make.\nA repeating string operation can be suspended by an exception or interrupt. When this happens, the state of the registers is preserved to allow the string operation to be resumed upon a return from the exception or interrupt handler. The source and destination registers point to the next string elements to be operated on, the EIP register points to the string instruction, and the ECX register has the value it held following the last successful iteration of the instruction. This mechanism allows long string operations to proceed without affecting the interrupt response time of the system.\nWhen a fault occurs during the execution of a CMPS or SCAS instruction that is prefixed with REPE or REPNE, the EFLAGS value is restored to the state prior to the execution of the instruction. Since the SCAS and CMPS instructions do not use EFLAGS as an input, the processor can resume the instruction after the page fault handler.\nUse the REP INS and REP OUTS instructions with caution. Not all I/O ports can handle the rate at which these instructions execute. Note that a REP STOS instruction is the fastest way to initialize a large block of memory.\nIn 64-bit mode, the operand size of the count register is associated with the address size attribute. Thus the default count register is RCX; REX.W has no effect on the address size and the count register. In 64-bit mode, if 67H is used to override address size attribute, the count register is ECX and any implicit source/destination operand will use the corresponding 32-bit index register. See the summary chart at the beginning of this section for encoding data and limits.\nREP INS may read from the I/O port without writing to the memory location if an exception or VM exit occurs due to the write (e.g., #PF). If this would be problematic, for example because the I/O port read has side-effects, software should ensure the write to the memory location does not cause an exception or VM exit.",
    "operationText": "IF AddressSize = 16\n    THEN\n            Use CX for CountReg;\n            Implicit Source/Dest operand for memory use of SI/DI;\n    ELSE IF AddressSize = 64\n            THEN Use RCX for CountReg;\n            Implicit Source/Dest operand for memory use of RSI/RDI;\n    ELSE\n            Use ECX for CountReg;\n            Implicit Source/Dest operand for memory use of ESI/EDI;\nFI;\nWHILE CountReg ≠ 0\n        DO\n                Service pending interrupts (if any);\n                Execute associated string instruction;\n                CountReg := (CountReg – 1);\n                IF CountReg = 0\n                    THEN exit WHILE loop; FI;\n                IF (Repeat prefix is REPZ or REPE) and (ZF = 0)\n                or (Repeat prefix is REPNZ or REPNE) and (ZF = 1)\n                    THEN exit WHILE loop; FI;\n        OD;",
    "flagsAffectedText": "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register.",
    "exceptions": {
      "64BitMode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sha1rnds4",
    "category": "Core Instructions",
    "instructionName": "SHA1RNDS4\n\t\t— Perform Four Rounds of SHA1 Operation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SHA",
        "Description": "Performs four rounds of SHA1 operation operating on SHA1 state (A,B,C,D) from xmm1, with a pre-computed sum of the next 4 round message dwords and state variable E from xmm2/m128. The immediate byte controls logic functions and round constants.",
        "Op/En": "RMI",
        "Opcode/Instruction": "NP 0F 3A CC /r ib SHA1RNDS4 xmm1, xmm2/m128, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8"
      }
    ],
    "descriptionText": "The SHA1RNDS4 instruction performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D) from the first operand (which is a source operand and the destination operand) and some pre-computed sum of the next 4 round message dwords, and state variable E from the second operand (a source operand). The updated SHA1 state (A,B,C,D) after four rounds of processing is stored in the destination operand.",
    "operationText": "The function f() and Constant K are dependent on the value of the immediate.\nIF ( imm8[1:0] = 0 )\n    THEN f() := f0(),\n        K := K0;\nELSE IF ( imm8[1:0]\n        = 1 )\n    THEN f() := f1(),\n        K := K1;\nELSE IF ( imm8[1:0]\n        = 2 )\n    THEN f() := f2(),\n        K := K2;\nELSE IF ( imm8[1:0]\n        = 3 )\n    THEN f() := f3(),\n        K := K3;\nFI;\nA := SRC1[127:96];\nB := SRC1[95:64];\nC := SRC1[63:32];\nD := SRC1[31:0];\nW0E := SRC2[127:96];\nW1 := SRC2[95:64];\nW2 := SRC2[63:32];\nW3 := SRC2[31:0];\nRound i = 0 operation:\nA_1 := f (B, C, D) + (A ROL 5) +W0E +K;\nB_1 := A;\nC_1 := B ROL 30;\nD_1 := C;\nE_1 := D;\nFOR i = 1 to 3\n    A_(i +1) := f (B_i, C_i, D_i) + (A_i ROL 5) +Wi+ E_i +K;\n    B_(i +1) := A_i;\n    C_(i +1) := B_i ROL 30;\n    D_(i +1) := C_i;\n    E_(i +1) := D_i;\nENDFOR\nDEST[127:96] := A_4;\nDEST[95:64] := B_4;\nDEST[63:32] := C_4;\nDEST[31:0] := D_4;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/hsubpd",
    "category": "Core Instructions",
    "instructionName": "HSUBPD\n\t\t— Packed Double Precision Floating-Point Horizontal Subtract",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Horizontal subtract packed double precision floating-point values from xmm2/m128 to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 7D /r HSUBPD xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Horizontal subtract packed double precision floating-point values from xmm2 and xmm3/mem.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 7D /r VHSUBPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Horizontal subtract packed double precision floating-point values from ymm2 and ymm3/mem.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 7D /r VHSUBPD ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The HSUBPD instruction subtracts horizontally the packed double precision floating-point numbers of both operands.\nSubtracts the double precision floating-point value in the high quadword of the destination operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.\nSubtracts the double precision floating-point value in the high quadword of the source operand from the low quadword of the source operand and stores the result in the high quadword of the destination operand.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).\nSee Figure 3-21 for HSUBPD; see Figure 3-22 for VHSUBPD.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "DEST[63:0] := SRC1[63:0] - SRC1[127:64]\nDEST[127:64] := SRC2[63:0] - SRC2[127:64]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := SRC1[63:0] - SRC1[127:64]\nDEST[127:64] := SRC2[63:0] - SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0] - SRC1[127:64]\nDEST[127:64] := SRC2[63:0] - SRC2[127:64]\nDEST[191:128] := SRC1[191:128] - SRC1[255:192]\nDEST[255:192] := SRC2[191:128] - SRC2[255:192]",
    "flagsAffectedText": "",
    "exceptions": {
      "exceptions¶": [
        "When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."
      ],
      "numeric¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ],
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/eaug",
    "category": "SGX Instructions",
    "instructionName": "EAUG\n\t\t— Add a Page to an Initialized Enclave",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX2",
        "Description": "This leaf function adds a page to an initialized enclave.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 0DH ENCLS[EAUG]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EAUG (In)",
        "column_3": "Address of a PAGEINFO (In)",
        "column_4": "Address of the destination EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movups",
    "category": "Core Instructions",
    "instructionName": "MOVUPS\n\t\t— Move Unaligned Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move unaligned packed single precision floating-point from xmm2/mem to xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 10 /r MOVUPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Move unaligned packed single precision floating-point from xmm1 to xmm2/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "NP 0F 11 /r MOVUPS xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed single precision floating-point from xmm2/mem to xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.0F.WIG 10 /r VMOVUPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed single precision floating-point from xmm1 to xmm2/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 11 /r VMOVUPS xmm2/m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed single precision floating-point from ymm2/mem to ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.0F.WIG 10 /r VMOVUPS ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move unaligned packed single precision floating-point from ymm1 to ymm2/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 11 /r VMOVUPS ymm2/m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed single precision floating-point values from xmm2/m128 to xmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 10 /r VMOVUPS xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed single precision floating-point values from ymm2/m256 to ymm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 10 /r VMOVUPS ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move unaligned packed single precision floating-point values from zmm2/m512 to zmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 10 /r VMOVUPS zmm1 {k1}{z}, zmm2/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed single precision floating-point values from xmm1 to xmm2/m128 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.0F.W0 11 /r VMOVUPS xmm2/m128 {k1}{z}, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move unaligned packed single precision floating-point values from ymm1 to ymm2/m256 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.0F.W0 11 /r VMOVUPS ymm2/m256 {k1}{z}, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move unaligned packed single precision floating-point values from zmm1 to zmm2/m512 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.0F.W0 11 /r VMOVUPS zmm2/m512 {k1}{z}, zmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Note: VEX.vvvv and EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\nEVEX.512 encoded version:\nMoves 512 bits of packed single precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float32 memory location, to store the contents of a ZMM register into memory. The destination operand is updated according to the writemask.\nVEX.256 and EVEX.256 encoded versions:\nMoves 256 bits of packed single precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. Bits (MAXVL-1:256) of the destination register are zeroed.\n128-bit versions:\nMoves 128 bits of packed single precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nWhen the source or destination operand is a memory operand, the operand may be unaligned without causing a general-protection exception (#GP) to be generated.\nVEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the destination register are zeroed.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE *DEST[i+31:i] remains unchanged*\n            ; merging-masking\n    FI;\nENDFOR;\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE DEST[i+31:i] := 0 ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := SRC[255:0]\nDEST[MAXVL-1:256] := 0\nDEST[255:0] := SRC[255:0]\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := SRC[127:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := SRC[127:0]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "Note treatment of #AC varies.",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rdfsbase:rdgsbase",
    "category": "Core Instructions",
    "instructionName": "RDFSBASE/RDGSBASE\n\t\t— Read FS/GS Segment Base",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/I",
        "CPUID Feature Flag": "FSGSBASE",
        "Description": "Load the 32-bit destination register with the FS base address.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 0F AE /0 RDFSBASE r32"
      },
      {
        "64/32-bit Mode": "V/I",
        "CPUID Feature Flag": "FSGSBASE",
        "Description": "Load the 64-bit destination register with the FS base address.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 REX.W 0F AE /0 RDFSBASE r64"
      },
      {
        "64/32-bit Mode": "V/I",
        "CPUID Feature Flag": "FSGSBASE",
        "Description": "Load the 32-bit destination register with the GS base address.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 0F AE /1 RDGSBASE r32"
      },
      {
        "64/32-bit Mode": "V/I",
        "CPUID Feature Flag": "FSGSBASE",
        "Description": "Load the 64-bit destination register with the GS base address.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 REX.W 0F AE /1 RDGSBASE r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the general-purpose register indicated by the ModR/M:r/m field with the FS or GS segment base address.\nThe destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.\nThis instruction is supported only in 64-bit mode.",
    "operationText": "DEST := FS/GS segment base address;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CR4.FSGSBASE[bit 16] = 0.; \ncolumn_1: If CPUID.07H.0H:EBX.FSGSBASE[bit 0] = 0.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/scas:scasb:scasw:scasd",
    "category": "Core Instructions",
    "instructionName": "SCAS/SCASB/SCASW/SCASD\n\t\t— Scan String",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare AL with byte at ES:(E)DI or RDI, then set status flags.1",
        "Instruction": "SCAS m8",
        "Op/En": "ZO",
        "Opcode": "AE"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare AX with word at ES:(E)DI or RDI, then set status flags.1",
        "Instruction": "SCAS m16",
        "Op/En": "ZO",
        "Opcode": "AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare EAX with doubleword at ES(E)DI or RDI then set status flags.1",
        "Instruction": "SCAS m32",
        "Op/En": "ZO",
        "Opcode": "AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare RAX with quadword at RDI or EDI then set status flags.",
        "Instruction": "SCAS m64",
        "Op/En": "ZO",
        "Opcode": "REX.W + AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare AL with byte at ES:(E)DI or RDI then set status flags.1",
        "Instruction": "SCASB",
        "Op/En": "ZO",
        "Opcode": "AE"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare AX with word at ES:(E)DI or RDI then set status flags.1",
        "Instruction": "SCASW",
        "Op/En": "ZO",
        "Opcode": "AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.1",
        "Instruction": "SCASD",
        "Op/En": "ZO",
        "Opcode": "AF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare RAX with quadword at RDI or EDI then set status flags.",
        "Instruction": "SCASQ",
        "Op/En": "ZO",
        "Opcode": "REX.W + AF"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.\nAt the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-operands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be specified explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (AL register for byte comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided to allow documentation. Note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it does not have to specify the correct location. The location is always specified by ES:(E)DI.\nThe no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).\nAfter the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.\nSCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes, words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of status flags. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.\nIn 64-bit mode, the instruction’s default address size is 64-bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The 64-bit no-operand mnemonic is SCASQ. Address of the memory operand is specified in either RDI or EDI, and AL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination register is incremented or decremented by the current operand size (depending on the value of the DF flag). See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF (Byte comparison)\n    THEN\n        temp := AL − SRC;\n        SetStatusFlags(temp);\n            THEN IF DF = 0\n                THEN (E)DI := (E)DI + 1;\n                ELSE (E)DI := (E)DI – 1; FI;\n    ELSE IF (Word comparison)\n        THEN\n            temp := AX − SRC;\n            SetStatusFlags(temp);\n            IF DF = 0\n                THEN (E)DI := (E)DI + 2;\n                ELSE (E)DI := (E)DI – 2; FI;\n        FI;\n    ELSE IF (Doubleword comparison)\n        THEN\n            temp := EAX – SRC;\n            SetStatusFlags(temp);\n            IF DF = 0\n                THEN (E)DI := (E)DI + 4;\n                ELSE (E)DI := (E)DI – 4; FI;\n        FI;\nFI;\nIF (Byte comparison)\n    THEN\n        temp := AL − SRC;\n        SetStatusFlags(temp);\n            THEN IF DF = 0\n                THEN (R|E)DI := (R|E)DI + 1;\n                ELSE (R|E)DI := (R|E)DI – 1; FI;\n    ELSE IF (Word comparison)\n        THEN\n            temp := AX − SRC;\n            SetStatusFlags(temp);\n            IF DF = 0\n                THEN (R|E)DI := (R|E)DI + 2;\n                ELSE (R|E)DI := (R|E)DI – 2; FI;\n        FI;\n    ELSE IF (Doubleword comparison)\n        THEN\n            temp := EAX – SRC;\n            SetStatusFlags(temp);\n            IF DF = 0\n                THEN (R|E)DI := (R|E)DI + 4;\n                ELSE (R|E)DI := (R|E)DI – 4; FI;\n        FI;\n    ELSE IF (Quadword comparison using REX.W )\n        THEN\n            temp := RAX − SRC;\n            SetStatusFlags(temp);\n            IF DF = 0\n                THEN (R|E)DI := (R|E)DI + 8;\n                ELSE (R|E)DI := (R|E)DI – 8;\n            FI;\n    FI;\nFI;",
    "flagsAffectedText": "The OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result of the comparison.",
    "exceptions": {
      "64BitMode": [
        "column_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the ES register contains a NULL segment selector.; \ncolumn_1: If an illegal memory operand effective address in the ES segment is given.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcmpsh",
    "category": "Core Instructions",
    "instructionName": "VCMPSH\n\t\t— Compare Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Compare low FP16 values in xmm3/m16 and xmm2 using bits 4:0 of imm8 as a comparison predicate subject to writemask k2, and store the result in mask register k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.0F3A.W0 C2 /r /ib VCMPSH k1{k2}, xmm2, xmm3/m16 {sae}, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtusi2ss",
    "category": "Core Instructions",
    "instructionName": "VCVTUSI2SS\n\t\t— Convert Unsigned Integer to Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one signed doubleword integer from r/m32 to one single precision floating-point value in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 7B /r VCVTUSI2SS xmm1, xmm2, r/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one signed quadword integer from r/m64 to one single precision floating-point value in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W1 7B /r VCVTUSI2SS xmm1, xmm2, r/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vreducepd",
    "category": "Core Instructions",
    "instructionName": "VREDUCEPD\n\t\t— Perform Reduction Transformation on Packed Float64 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Perform reduction transformation on packed double precision floating-point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 56 /r ib VREDUCEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Perform reduction transformation on packed double precision floating-point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 56 /r ib VREDUCEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Perform reduction transformation on double precision floating-point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 56 /r ib VREDUCEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpdpwssd",
    "category": "Core Instructions",
    "instructionName": "VPDPWSSD\n\t\t— Multiply and Add Signed Word Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX-VNNI",
        "Description": "Multiply groups of 2 pairs signed words in xmm3/m128 with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 52 /r VPDPWSSD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX-VNNI",
        "Description": "Multiply groups of 2 pairs signed words in ymm3/m256 with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 52 /r VPDPWSSD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI AVX512VL",
        "Description": "Multiply groups of 2 pairs signed words in xmm3/m128/m32bcst with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 52 /r VPDPWSSD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI AVX512VL",
        "Description": "Multiply groups of 2 pairs signed words in ymm3/m256/m32bcst with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 52 /r VPDPWSSD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI",
        "Description": "Multiply groups of 2 pairs signed words in zmm3/m512/m32bcst with corresponding signed words of zmm2, summing those products and adding them to doubleword result in zmm1, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 52 /r VPDPWSSD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/lzcnt",
    "category": "Core Instructions",
    "instructionName": "LZCNT\n\t\t— Count the Number of Leading Zero Bits",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "LZCNT",
        "Description": "Count the number of leading zero bits in r/m16, return result in r16.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 0F BD /r LZCNT r16, r/m16"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "LZCNT",
        "Description": "Count the number of leading zero bits in r/m32, return result in r32.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 0F BD /r LZCNT r32, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "LZCNT",
        "Description": "Count the number of leading zero bits in r/m64, return result in r64.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 REX.W 0F BD /r LZCNT r64, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Counts the number of leading most significant zero bits in a source operand (second operand) returning the result into a destination (first operand).\nLZCNT differs from BSR. For example, LZCNT will produce the operand size when the input operand is zero. It should be noted that on processors that do not support LZCNT, the instruction byte encoding is executed as BSR.\nIn 64-bit mode 64-bit operand size requires REX.W=1.",
    "operationText": "temp := OperandSize - 1\nDEST := 0\nWHILE (temp >= 0) AND (Bit(SRC, temp) = 0)\nDO\n    temp := temp - 1\n    DEST := DEST+ 1\nOD\nIF DEST = OperandSize\n    CF := 1\nELSE\n    CF := 0\nFI\nIF DEST = 0\n    ZF := 1\nELSE\n    ZF := 0\nFI",
    "flagsAffectedText": "ZF flag is set to 1 in case of zero output (most significant bit of the source is set), and to 0 otherwise, CF flag is set to 1 if input was zero and cleared otherwise. OF, SF, PF, and AF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in Protected Mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.; \ncolumn_2: For an illegal address in the SS segment.; column_1: #SS(0); \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_2: For an illegal address in the SS segment.; column_1: #SS(0); \ncolumn_1: #UD; column_2: If LOCK prefix is used.;"
      ],
      "virtual8086Mode¶": [
        "column_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmptrld",
    "category": "VMX Instructions",
    "instructionName": "VMPTRLD\n\t\t— Load Pointer to Virtual-Machine Control Structure",
    "detailsTable": [
      {
        "Description": "Loads the current VMCS pointer from memory.",
        "Op/En": "M",
        "Opcode/Instruction": "NP 0F C7 /6 VMPTRLD m64"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "M",
        "column_2": "ModRM:r/m (r)",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Marks the current-VMCS pointer valid and loads it with the physical address in the instruction operand. The instruction fails if its operand is not properly aligned, sets unsupported physical-address bits, or is equal to the VMXON pointer. In addition, the instruction fails if the 32 bits in memory referenced by the operand do not match the VMCS revision identifier supported by this processor.1\nThe operand of this instruction is always 64 bits and is always in memory.",
    "operationText": "IF (register operand) or (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation\n    THEN VMexit;\nELSIF CPL > 0\n    THEN #GP(0);\n    ELSE\n        addr := contents of 64-bit in-memory source operand;\n        IF addr is not 4KB-aligned OR\n        addr sets any bits beyond the physical-address width2\n            THEN VMfail(VMPTRLD with invalid physical address);\n        ELSIF addr = VMXON pointer\n            THEN VMfail(VMPTRLD with VMXON pointer);\n            ELSE\n                rev := 32 bits located at physical address addr;\n                IF rev[30:0] ≠ VMCS revision identifier supported by processor OR\n                rev[31] = 1 AND processor does not support 1-setting of “VMCS shadowing”\n                    THEN VMfail(VMPTRLD with incorrect VMCS revision identifier);\n                    ELSE\n                        current-VMCS pointer := addr;\n                        VMsucceed;\n                FI;\n        FI;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the source operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory source operand.; \ncolumn_1: #SS(0); column_2: If the source operand is in the SS segment and the memory address is in a non-canonical form.; \ncolumn_1: #UD; column_2: If operand is a register.; \ncolumn_1: If not in VMX operation.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: If the memory source operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the source operand is located in an execute-only code segment.; \ncolumn_2: If a page fault occurs in accessing the memory source operand.; column_1: #PF(fault-code); \ncolumn_1: #SS(0); column_2: If the memory source operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_1: #UD; column_2: If operand is a register.; \ncolumn_1: If not in VMX operation.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vexpandps",
    "category": "Core Instructions",
    "instructionName": "VEXPANDPS\n\t\t— Load Sparse Packed Single Precision Floating-Point Values From Dense Memory",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Expand packed single precision floating-point values from xmm2/m128 to xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 88 /r VEXPANDPS xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Expand packed single precision floating-point values from ymm2/m256 to ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 88 /r VEXPANDPS ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Expand packed single precision floating-point values from zmm2/m512 to zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 88 /r VEXPANDPS zmm1 {k1}{z}, zmm2/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtuw2ph",
    "category": "Core Instructions",
    "instructionName": "VCVTUW2PH\n\t\t— Convert Packed Unsigned Word Integers to FP16 Values",
    "detailsTable": [
      {
        "Description": "Convert eight packed unsigned word integers from xmm2/m128/m16bcst to FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F2.MAP5.W0 7D /r VCVTUW2PH xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed unsigned word integers from ymm2/m256/m16bcst to FP16 values, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F2.MAP5.W0 7D /r VCVTUW2PH ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert thirty-two packed unsigned word integers from zmm2/m512/m16bcst to FP16 values, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F2.MAP5.W0 7D /r VCVTUW2PH zmm1{k1}{z}, zmm2/m512/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/gf2p8affineqb",
    "category": "Core Instructions",
    "instructionName": "GF2P8AFFINEQB\n\t\t— Galois Field Affine Transformation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "GFNI",
        "Description": "Computes affine transformation in the finite field GF(2^8).",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F3A CE /r /ib GF2P8AFFINEQB xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX GFNI",
        "Description": "Computes affine transformation in the finite field GF(2^8).",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.W1 CE /r /ib VGF2P8AFFINEQB xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX GFNI",
        "Description": "Computes affine transformation in the finite field GF(2^8).",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F3A.W1 CE /r /ib VGF2P8AFFINEQB ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL GFNI",
        "Description": "Computes affine transformation in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 CE /r /ib VGF2P8AFFINEQB xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL GFNI",
        "Description": "Computes affine transformation in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 CE /r /ib VGF2P8AFFINEQB ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F GFNI",
        "Description": "Computes affine transformation in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 CE /r /ib VGF2P8AFFINEQB zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8 (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttsh2usi",
    "category": "Core Instructions",
    "instructionName": "VCVTTSH2USI\n\t\t— Convert with Truncation Low FP16 Value to an Unsigned Integer",
    "detailsTable": [
      {
        "Description": "Convert FP16 value in the low element of xmm1/m16 to an unsigned integer and store the result in r32 using truncation.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 78 /r VCVTTSH2USI r32, xmm1/m16 {sae}",
        "Support": "V/V1",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Convert FP16 value in the low element of xmm1/m16 to an unsigned integer and store the result in r64 using truncation.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W1 78 /r VCVTTSH2USI r64, xmm1/m16 {sae}",
        "Support": "V/N.E.",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/push",
    "category": "Core Instructions",
    "instructionName": "PUSH\n\t\t— Push Word, Doubleword, or Quadword Onto the Stack",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push r/m16.",
        "Instruction": "PUSH r/m16",
        "Op/En": "M",
        "column_1": "FF /6"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Push r/m32.",
        "Instruction": "PUSH r/m32",
        "Op/En": "M",
        "column_1": "FF /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Push r/m64.",
        "Instruction": "PUSH r/m64",
        "Op/En": "M",
        "column_1": "FF /6"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push r16.",
        "Instruction": "PUSH r16",
        "Op/En": "O",
        "column_1": "50+rw"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Push r32.",
        "Instruction": "PUSH r32",
        "Op/En": "O",
        "column_1": "50+rd"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Push r64.",
        "Instruction": "PUSH r64",
        "Op/En": "O",
        "column_1": "50+rd"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push imm8.",
        "Instruction": "PUSH imm8",
        "Op/En": "I",
        "column_1": "6A ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push imm16.",
        "Instruction": "PUSH imm16",
        "Op/En": "I",
        "column_1": "68 iw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push imm32.",
        "Instruction": "PUSH imm32",
        "Op/En": "I",
        "column_1": "68 id"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push CS.",
        "Instruction": "PUSH CS",
        "Op/En": "ZO",
        "column_1": "0E"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push SS.",
        "Instruction": "PUSH SS",
        "Op/En": "ZO",
        "column_1": "16"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push DS.",
        "Instruction": "PUSH DS",
        "Op/En": "ZO",
        "column_1": "1E"
      },
      {
        "64-Bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push ES.",
        "Instruction": "PUSH ES",
        "Op/En": "ZO",
        "column_1": "06"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push FS.",
        "Instruction": "PUSH FS",
        "Op/En": "ZO",
        "column_1": "0F A0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push GS.",
        "Instruction": "PUSH GS",
        "Op/En": "ZO",
        "column_1": "0F A8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "O",
        "Operand 1": "opcode + rd (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "I",
        "Operand 1": "imm8/16/32",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand sizes are determined and used as follows:\nThe address size is used only when referencing a source operand in memory.\nThe operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is decremented (2, 4 or 8).\nIf the source operand is an immediate of size less than the operand size, a sign-extended value is pushed on the stack. If the source operand is a segment register (16 bits) and the operand size is 64-bits, a zero-extended value is pushed on the stack; if the operand size is 32-bits, either a zero-extended value is pushed on the stack or the segment selector is written on the stack using a 16-bit move. For the last case, all recent Intel Core and Intel Atom processors perform a 16-bit move, leaving the upper portion of the stack location unmodified.\nThe stack-address size determines the width of the stack pointer when writing to the stack in memory and when decrementing the stack pointer. (As stated above, the amount by which the stack pointer is decremented is determined by the operand size.)\nIf the operand size is less than the stack-address size, the PUSH instruction may result in a misaligned stack pointer (a stack pointer that is not aligned on a doubleword or quadword boundary).\nThe PUSH ESP instruction pushes the value of the ESP register as it existed before the instruction was executed. If a PUSH instruction uses a memory operand in which the ESP register is used for computing the operand address, the address of the operand is computed before the ESP register is decremented.\nIf the ESP or SP register is 1 when the PUSH instruction is executed in real-address mode, a stack-fault exception (#SS) is generated (because the limit of the stack segment is violated). Its delivery encounters a second stack-fault exception (for the same reason), causing generation of a double-fault exception (#DF). Delivery of the double-fault exception encounters a third stack-fault exception, and the logical processor enters shutdown mode. See the discussion of the double-fault exception in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
    "operationText": "(* See Description section for possible sign-extension or zero-extension of source operand and for *)\n(* a case in which the size of the memory store may be\n                    smaller than the instruction’s operand size *)\nIF StackAddrSize = 64\n    THEN\n        IF OperandSize = 64\n            THEN\n                RSP := RSP – 8;\n                Memory[SS:RSP] := SRC;\n                    (* push quadword *)\n        ELSE IF OperandSize = 32\n            THEN\n                RSP := RSP – 4;\n                Memory[SS:RSP] := SRC;\n                    (* push dword *)\n            ELSE (* OperandSize = 16 *)\n                RSP := RSP – 2;\n                Memory[SS:RSP] := SRC;\n                    (* push word *)\n        FI;\nELSE IF StackAddrSize = 32\n    THEN\n        IF OperandSize = 64\n            THEN\n                ESP := ESP – 8;\n                Memory[SS:ESP] := SRC;\n                    (* push quadword *)\n        ELSE IF OperandSize = 32\n            THEN\n                ESP := ESP – 4;\n                Memory[SS:ESP] := SRC;\n                    (* push dword *)\n            ELSE (* OperandSize = 16 *)\n                ESP := ESP – 2;\n                Memory[SS:ESP] := SRC;\n                    (* push word *)\n        FI;\n    ELSE (* StackAddrSize = 16 *)\n        IF OperandSize = 32\n            THEN\n                SP := SP – 4;\n                Memory[SS:SP] := SRC;\n                    (* push dword *)\n            ELSE (* OperandSize = 16 *)\n                SP := SP – 2;\n                Memory[SS:SP] := SRC;\n                    (* push word *)\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If the stack address is in a non-canonical form.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD; \ncolumn_1: If the PUSH is of CS, SS, DS, or ES.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: If the new value of the SP or ESP register is outside the stack segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrangesd",
    "category": "Core Instructions",
    "instructionName": "VRANGESD\n\t\t— Range Restriction Calculation From a Pair of Scalar Float64 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Calculate a RANGE operation output value from 2 double precision floating-point values in xmm2 and xmm3/m64, store the output to xmm1 under writemask. Imm8 specifies the comparison and sign of the range operation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W1 51 /r VRANGESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/frstor",
    "category": "Core Instructions",
    "instructionName": "FRSTOR\n\t\t— Restore x87 FPU State",
    "detailsTable": [
      {
        "Description": "Load FPU state from m94byte or m108byte.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "DD /4",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Loads the FPU state (operating environment and register stack) from the memory area specified with the source operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruction.\nThe FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately following the operating environment image.\nThe FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE instruction.\nIf one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled “Software Exception Handling” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). To avoid raising exceptions when loading a new operating environment, clear all the exception flags in the FPU status word that is being loaded.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "FPUControlWord := SRC[FPUControlWord];\nFPUStatusWord := SRC[FPUStatusWord];\nFPUTagWord := SRC[FPUTagWord];\nFPUDataPointer := SRC[FPUDataPointer];\nFPUInstructionPointer := SRC[FPUInstructionPointer];\nFPULastInstructionOpcode := SRC[FPULastInstructionOpcode];\nST(0) := SRC[ST(0)];\nST(1) := SRC[ST(1)];\nST(2) := SRC[ST(2)];\nST(3) := SRC[ST(3)];\nST(4) := SRC[ST(4)];\nST(5) := SRC[ST(5)];\nST(6) := SRC[ST(6)];\nST(7) := SRC[ST(7)];",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None; however, if an unmasked exception is loaded in the status word, it is generated upon execution of the next “waiting” floating-point instruction."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; column_1: #NM; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/str",
    "category": "Core Instructions",
    "instructionName": "STR\n\t\t— Store Task Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Stores segment selector from TR in r/m16.",
        "Instruction": "STR r/m16",
        "Op/En": "M",
        "Opcode": "0F 00 /1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stores the segment selector from the task register (TR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the task state segment (TSS) for the currently running task.\nWhen the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower 16 bits of the register and the upper 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of operand size.\nIn 64-bit mode, operation is the same. The size of the memory operand is fixed at 16 bits. In register stores, the 2-byte TR is zero extended if stored to a 64-bit register.\nThe STR instruction is useful only in operating-system software. It can only be executed in protected mode.",
    "operationText": "DEST := TR(SegmentSelector);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #SS(0); column_2: If the stack address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/addsubpd",
    "category": "Core Instructions",
    "instructionName": "ADDSUBPD\n\t\t— Packed Double Precision Floating-Point Add/Subtract",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Add/subtract double precision floating-point values from xmm2/m128 to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F D0 /r ADDSUBPD xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add/subtract packed double precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F.WIG D0 /r VADDSUBPD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add / subtract packed double precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F.WIG D0 /r VADDSUBPD ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adds odd-numbered double precision floating-point values of the first source operand (second operand) with the corresponding double precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered double precision floating-point values from the second source operand from the corresponding double precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See Figure 3-3.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "DEST[63:0] := DEST[63:0] - SRC[63:0]\nDEST[127:64] := DEST[127:64] + SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := SRC1[63:0] - SRC2[63:0]\nDEST[127:64] := SRC1[127:64] + SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0] - SRC2[63:0]\nDEST[127:64] := SRC1[127:64] + SRC2[127:64]\nDEST[191:128] := SRC1[191:128] - SRC2[191:128]\nDEST[255:192] := SRC1[255:192] + SRC2[255:192]",
    "flagsAffectedText": "",
    "exceptions": {
      "exceptions¶": [
        "When the source operand is a memory operand, it must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."
      ],
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/f2xm1",
    "category": "Core Instructions",
    "instructionName": "F2XM1\n\t\t— Compute 2x–1",
    "detailsTable": [
      {
        "Description": "Replace ST(0) with (2ST(0) – 1).",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 F0",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range –1.0 to +1.0. If the source value is outside this range, the result is undefined.\nThe following table shows the results obtained when computing the exponential value of various classes of numbers, assuming that neither overflow nor underflow occurs.\nValues other than 2 can be exponentiated using the following formula:\nxy := 2(y ∗ log2x)\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "ST(0) := (2ST(0) − 1);",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value or unsupported format.; \ncolumn_1: #D; column_2: Source is a denormal value.; \ncolumn_2: Result is too small for destination format.; column_1: #U; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermq",
    "category": "Core Instructions",
    "instructionName": "VPERMQ\n\t\t— Qwords Element Permutation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Permute qwords in ymm2/m256 using indices in imm8 and store the result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F3A.W1 00 /r ib VPERMQ ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute qwords in ymm2/m256/m64bcst using indexes in imm8 and store the result in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 00 /r ib VPERMQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute qwords in zmm2/m512/m64bcst using indices in imm8 and store the result in zmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 00 /r ib VPERMQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute qwords in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 36 /r VPERMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute qwords in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 36 /r VPERMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmsub132sh:vfnmsub132sh:vfmsub213sh:vfnmsub213sh:vfmsub231sh:vfnmsub231sh",
    "category": "Core Instructions",
    "instructionName": "VFMSUB132SH/VFNMSUB132SH/VFMSUB213SH/VFNMSUB213SH/VFMSUB231SH/VFNMSUB231SH\n\t\t— Fused Multiply-Subtract of Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Multiply FP16 values from xmm1 and xmm3/m16, subtract xmm2, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 9B /r VFMSUB132SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm1 and xmm2, subtract xmm3/m16, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 AB /r VFMSUB213SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm2 and xmm3/m16, subtract xmm1, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 BB /r VFMSUB231SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm1 and xmm3/m16, and negate the value. Subtract xmm2 from this value, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 9F /r VFNMSUB132SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm1 and xmm2, and negate the value. Subtract xmm3/m16 from this value, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 AF /r VFNMSUB213SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm2 and xmm3/m16, and negate the value. Subtract xmm1 from this value, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 BF /r VFNMSUB231SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtdq2ps",
    "category": "Core Instructions",
    "instructionName": "CVTDQ2PS\n\t\t— Convert Packed Doubleword Integers to Packed Single Precision Floating-PointValues",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert four packed signed doubleword integers from xmm2/mem to four packed single precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode Instruction": "NP 0F 5B /r CVTDQ2PS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert four packed signed doubleword integers from xmm2/mem to four packed single precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode Instruction": "VEX.128.0F.WIG 5B /r VCVTDQ2PS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert eight packed signed doubleword integers from ymm2/mem to eight packed single precision floating-point values in ymm1.",
        "Op / En": "A",
        "Opcode Instruction": "VEX.256.0F.WIG 5B /r VCVTDQ2PS ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed signed doubleword integers from xmm2/m128/m32bcst to four packed single precision floating-point values in xmm1with writemask k1.",
        "Op / En": "B",
        "Opcode Instruction": "EVEX.128.0F.W0 5B /r VCVTDQ2PS xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed single precision floating-point values in ymm1with writemask k1.",
        "Op / En": "B",
        "Opcode Instruction": "EVEX.256.0F.W0 5B /r VCVTDQ2PS ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert sixteen packed signed doubleword integers from zmm2/m512/m32bcst to sixteen packed single precision floating-point values in zmm1with writemask k1.",
        "Op / En": "B",
        "Opcode Instruction": "EVEX.512.0F.W0 5B /r VCVTDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Converts four, eight or sixteen packed signed doubleword integers in the source operand to four, eight or sixteen packed single precision floating-point values in the destination operand.\nEVEX encoded versions: The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC); ; refer to Table 15-4 in the Intel® 64 and IA-32 Architectures\nSoftware Developer’s Manual, Volume 1\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC); ; refer to Table 15-4 in the Intel® 64 and IA-32 Architectures\nSoftware Developer’s Manual, Volume 1\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] :=\n            Convert_Integer_To_Single_Precision_Floating_Point(SRC[i+31:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+31:i] :=\n            Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0])\n                ELSE\n                    DEST[i+31:i] :=\n            Convert_Integer_To_Single_Precision_Floating_Point(SRC[i+31:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0])\nDEST[63:32] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:32])\nDEST[95:64] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[95:64])\nDEST[127:96] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[127:96)\nDEST[159:128] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[159:128])\nDEST[191:160] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[191:160])\nDEST[223:192] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[223:192])\nDEST[255:224] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[255:224)\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0])\nDEST[63:32] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:32])\nDEST[95:64] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[95:64])\nDEST[127:96] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[127z:96)\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0])\nDEST[63:32] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:32])\nDEST[95:64] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[95:64])\nDEST[127:96] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[127z:96)\nDEST[MAXVL-1:128] (unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/packsswb:packssdw",
    "category": "Core Instructions",
    "instructionName": "PACKSSWB/PACKSSDW\n\t\t— Pack With Signed Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 63 /r1 PACKSSWB mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Converts 8 packed signed word integers from xmm1 and from xmm2/m128 into 16 packed signed byte integers in xmm1 using signed saturation.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 63 /r PACKSSWB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 6B /r1 PACKSSDW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Converts 4 packed signed doubleword integers from xmm1 and from xmm2/m128 into 8 packed signed word integers in xmm1 using signed saturation.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 6B /r PACKSSDW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 63 /r VPACKSSWB xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 6B /r VPACKSSDW xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 63 /r VPACKSSWB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 6B /r VPACKSSDW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts packed signed word integers from xmm2 and from xmm3/m128 into packed signed byte integers in xmm1 using signed saturation under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 63 /r VPACKSSWB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts packed signed word integers from ymm2 and from ymm3/m256 into packed signed byte integers in ymm1 using signed saturation under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 63 /r VPACKSSWB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Converts packed signed word integers from zmm2 and from zmm3/m512 into packed signed byte integers in zmm1 using signed saturation under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 63 /r VPACKSSWB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts packed signed doubleword integers from xmm2 and from xmm3/m128/m32bcst into packed signed word integers in xmm1 using signed saturation under writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 6B /r VPACKSSDW xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts packed signed doubleword integers from ymm2 and from ymm3/m256/m32bcst into packed signed word integers in ymm1 using signed saturation under writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 6B /r VPACKSSDW ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Converts packed signed doubleword integers from zmm2 and from zmm3/m512/m32bcst into packed signed word integers in zmm1 using signed saturation under writemask k1.",
        "Op/En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 6B /r VPACKSSDW zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions. See Figure 4-6 for an example of the packing operation.\nPACKSSWB converts packed signed word integers in the first and second source operands into packed signed byte integers using signed saturation to handle overflow conditions beyond the range of signed byte integers. If the signed word value is beyond the range of a signed byte value (i.e., greater than 7FH or less than 80H), the saturated signed byte integer value of 7FH or 80H, respectively, is stored in the destination. PACKSSDW converts packed signed doubleword integers in the first and second source operands into packed signed word integers using signed saturation to handle overflow conditions beyond 7FFFH and 8000H.\nEVEX encoded PACKSSWB: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register, updated conditional under the writemask k1.\nEVEX encoded PACKSSDW: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-\nbit memory location. The destination operand is a ZMM/YMM/XMM register, updated conditional under the write-mask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM destination register destination are unmodified.",
    "operationText": "DEST[7:0] := SaturateSignedWordToSignedByte (DEST[15:0]);\nDEST[15:8] := SaturateSignedWordToSignedByte (DEST[31:16]);\nDEST[23:16] := SaturateSignedWordToSignedByte (DEST[47:32]);\nDEST[31:24] := SaturateSignedWordToSignedByte (DEST[63:48]);\nDEST[39:32] := SaturateSignedWordToSignedByte (DEST[79:64]);\nDEST[47:40] := SaturateSignedWordToSignedByte (DEST[95:80]);\nDEST[55:48] := SaturateSignedWordToSignedByte (DEST[111:96]);\nDEST[63:56] := SaturateSignedWordToSignedByte (DEST[127:112]);\nDEST[71:64] := SaturateSignedWordToSignedByte (SRC[15:0]);\nDEST[79:72] := SaturateSignedWordToSignedByte (SRC[31:16]);\nDEST[87:80] := SaturateSignedWordToSignedByte (SRC[47:32]);\nDEST[95:88] := SaturateSignedWordToSignedByte (SRC[63:48]);\nDEST[103:96] := SaturateSignedWordToSignedByte (SRC[79:64]);\nDEST[111:104] := SaturateSignedWordToSignedByte (SRC[95:80]);\nDEST[119:112] := SaturateSignedWordToSignedByte (SRC[111:96]);\nDEST[127:120] := SaturateSignedWordToSignedByte (SRC[127:112]);\nDEST[MAXVL-1:128] (Unmodified)\nDEST[15:0] := SaturateSignedDwordToSignedWord (DEST[31:0]);\nDEST[31:16] := SaturateSignedDwordToSignedWord (DEST[63:32]);\nDEST[47:32] := SaturateSignedDwordToSignedWord (DEST[95:64]);\nDEST[63:48] := SaturateSignedDwordToSignedWord (DEST[127:96]);\nDEST[79:64] := SaturateSignedDwordToSignedWord (SRC[31:0]);\nDEST[95:80] := SaturateSignedDwordToSignedWord (SRC[63:32]);\nDEST[111:96] := SaturateSignedDwordToSignedWord (SRC[95:64]);\nDEST[127:112] := SaturateSignedDwordToSignedWord (SRC[127:96]);\nDEST[MAXVL-1:128] (Unmodified)\nDEST[7:0] := SaturateSignedWordToSignedByte (SRC1[15:0]);\nDEST[15:8] := SaturateSignedWordToSignedByte (SRC1[31:16]);\nDEST[23:16] := SaturateSignedWordToSignedByte (SRC1[47:32]);\nDEST[31:24] := SaturateSignedWordToSignedByte (SRC1[63:48]);\nDEST[39:32] := SaturateSignedWordToSignedByte (SRC1[79:64]);\nDEST[47:40] := SaturateSignedWordToSignedByte (SRC1[95:80]);\nDEST[55:48] := SaturateSignedWordToSignedByte (SRC1[111:96]);\nDEST[63:56] := SaturateSignedWordToSignedByte (SRC1[127:112]);\nDEST[71:64] := SaturateSignedWordToSignedByte (SRC2[15:0]);\nDEST[79:72] := SaturateSignedWordToSignedByte (SRC2[31:16]);\nDEST[87:80] := SaturateSignedWordToSignedByte (SRC2[47:32]);\nDEST[95:88] := SaturateSignedWordToSignedByte (SRC2[63:48]);\nDEST[103:96] := SaturateSignedWordToSignedByte (SRC2[79:64]);\nDEST[111:104] := SaturateSignedWordToSignedByte (SRC2[95:80]);\nDEST[119:112] := SaturateSignedWordToSignedByte (SRC2[111:96]);\nDEST[127:120] := SaturateSignedWordToSignedByte (SRC2[127:112]);\nDEST[MAXVL-1:128] := 0;\nDEST[15:0] := SaturateSignedDwordToSignedWord (SRC1[31:0]);\nDEST[31:16] := SaturateSignedDwordToSignedWord (SRC1[63:32]);\nDEST[47:32] := SaturateSignedDwordToSignedWord (SRC1[95:64]);\nDEST[63:48] := SaturateSignedDwordToSignedWord (SRC1[127:96]);\nDEST[79:64] := SaturateSignedDwordToSignedWord (SRC2[31:0]);\nDEST[95:80] := SaturateSignedDwordToSignedWord (SRC2[63:32]);\nDEST[111:96] := SaturateSignedDwordToSignedWord (SRC2[95:64]);\nDEST[127:112] := SaturateSignedDwordToSignedWord (SRC2[127:96]);\nDEST[MAXVL-1:128] := 0;\nDEST[7:0] := SaturateSignedWordToSignedByte (SRC1[15:0]);\nDEST[15:8] := SaturateSignedWordToSignedByte (SRC1[31:16]);\nDEST[23:16] := SaturateSignedWordToSignedByte (SRC1[47:32]);\nDEST[31:24] := SaturateSignedWordToSignedByte (SRC1[63:48]);\nDEST[39:32] := SaturateSignedWordToSignedByte (SRC1[79:64]);\nDEST[47:40] := SaturateSignedWordToSignedByte (SRC1[95:80]);\nDEST[55:48] := SaturateSignedWordToSignedByte (SRC1[111:96]);\nDEST[63:56] := SaturateSignedWordToSignedByte (SRC1[127:112]);\nDEST[71:64] := SaturateSignedWordToSignedByte (SRC2[15:0]);\nDEST[79:72] := SaturateSignedWordToSignedByte (SRC2[31:16]);\nDEST[87:80] := SaturateSignedWordToSignedByte (SRC2[47:32]);\nDEST[95:88] := SaturateSignedWordToSignedByte (SRC2[63:48]);\nDEST[103:96] := SaturateSignedWordToSignedByte (SRC2[79:64]);\nDEST[111:104] := SaturateSignedWordToSignedByte (SRC2[95:80]);\nDEST[119:112] := SaturateSignedWordToSignedByte (SRC2[111:96]);\nDEST[127:120] := SaturateSignedWordToSignedByte (SRC2[127:112]);\nDEST[135:128] := SaturateSignedWordToSignedByte (SRC1[143:128]);\nDEST[143:136] := SaturateSignedWordToSignedByte (SRC1[159:144]);\nDEST[151:144] := SaturateSignedWordToSignedByte (SRC1[175:160]);\nDEST[159:152] := SaturateSignedWordToSignedByte (SRC1[191:176]);\nDEST[167:160] := SaturateSignedWordToSignedByte (SRC1[207:192]);\nDEST[175:168] := SaturateSignedWordToSignedByte (SRC1[223:208]);\nDEST[183:176] := SaturateSignedWordToSignedByte (SRC1[239:224]);\nDEST[191:184] := SaturateSignedWordToSignedByte (SRC1[255:240]);\nDEST[199:192] := SaturateSignedWordToSignedByte (SRC2[143:128]);\nDEST[207:200] := SaturateSignedWordToSignedByte (SRC2[159:144]);\nDEST[215:208] := SaturateSignedWordToSignedByte (SRC2[175:160]);\nDEST[223:216] := SaturateSignedWordToSignedByte (SRC2[191:176]);\nDEST[231:224] := SaturateSignedWordToSignedByte (SRC2[207:192]);\nDEST[239:232] := SaturateSignedWordToSignedByte (SRC2[223:208]);\nDEST[247:240] := SaturateSignedWordToSignedByte (SRC2[239:224]);\nDEST[255:248] := SaturateSignedWordToSignedByte (SRC2[255:240]);\nDEST[MAXVL-1:256] := 0;\nDEST[15:0] := SaturateSignedDwordToSignedWord (SRC1[31:0]);\nDEST[31:16] := SaturateSignedDwordToSignedWord (SRC1[63:32]);\nDEST[47:32] := SaturateSignedDwordToSignedWord (SRC1[95:64]);\nDEST[63:48] := SaturateSignedDwordToSignedWord (SRC1[127:96]);\nDEST[79:64] := SaturateSignedDwordToSignedWord (SRC2[31:0]);\nDEST[95:80] := SaturateSignedDwordToSignedWord (SRC2[63:32]);\nDEST[111:96] := SaturateSignedDwordToSignedWord (SRC2[95:64]);\nDEST[127:112] := SaturateSignedDwordToSignedWord (SRC2[127:96]);\nDEST[143:128] := SaturateSignedDwordToSignedWord (SRC1[159:128]);\nDEST[159:144] := SaturateSignedDwordToSignedWord (SRC1[191:160]);\nDEST[175:160] := SaturateSignedDwordToSignedWord (SRC1[223:192]);\nDEST[191:176] := SaturateSignedDwordToSignedWord (SRC1[255:224]);\nDEST[207:192] := SaturateSignedDwordToSignedWord (SRC2[159:128]);\nDEST[223:208] := SaturateSignedDwordToSignedWord (SRC2[191:160]);\nDEST[239:224] := SaturateSignedDwordToSignedWord (SRC2[223:192]);\nDEST[255:240] := SaturateSignedDwordToSignedWord (SRC2[255:224]);\nDEST[MAXVL-1:256] := 0;\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nTMP_DEST[7:0] := SaturateSignedWordToSignedByte (SRC1[15:0]);\nTMP_DEST[15:8] := SaturateSignedWordToSignedByte (SRC1[31:16]);\nTMP_DEST[23:16] := SaturateSignedWordToSignedByte (SRC1[47:32]);\nTMP_DEST[31:24] := SaturateSignedWordToSignedByte (SRC1[63:48]);\nTMP_DEST[39:32] := SaturateSignedWordToSignedByte (SRC1[79:64]);\nTMP_DEST[47:40] := SaturateSignedWordToSignedByte (SRC1[95:80]);\nTMP_DEST[55:48] := SaturateSignedWordToSignedByte (SRC1[111:96]);\nTMP_DEST[63:56] := SaturateSignedWordToSignedByte (SRC1[127:112]);\nTMP_DEST[71:64] := SaturateSignedWordToSignedByte (SRC2[15:0]);\nTMP_DEST[79:72] := SaturateSignedWordToSignedByte (SRC2[31:16]);\nTMP_DEST[87:80] := SaturateSignedWordToSignedByte (SRC2[47:32]);\nTMP_DEST[95:88] := SaturateSignedWordToSignedByte (SRC2[63:48]);\nTMP_DEST[103:96] := SaturateSignedWordToSignedByte (SRC2[79:64]);\nTMP_DEST[111:104] := SaturateSignedWordToSignedByte (SRC2[95:80]);\nTMP_DEST[119:112] := SaturateSignedWordToSignedByte (SRC2[111:96]);\nTMP_DEST[127:120] := SaturateSignedWordToSignedByte (SRC2[127:112]);\nIF VL >= 256\n    TMP_DEST[135:128] := SaturateSignedWordToSignedByte (SRC1[143:128]);\n    TMP_DEST[143:136] := SaturateSignedWordToSignedByte (SRC1[159:144]);\n    TMP_DEST[151:144] := SaturateSignedWordToSignedByte (SRC1[175:160]);\n    TMP_DEST[159:152] := SaturateSignedWordToSignedByte (SRC1[191:176]);\n    TMP_DEST[167:160] := SaturateSignedWordToSignedByte (SRC1[207:192]);\n    TMP_DEST[175:168] := SaturateSignedWordToSignedByte (SRC1[223:208]);\n    TMP_DEST[183:176] := SaturateSignedWordToSignedByte (SRC1[239:224]);\n    TMP_DEST[191:184] := SaturateSignedWordToSignedByte (SRC1[255:240]);\n    TMP_DEST[199:192] := SaturateSignedWordToSignedByte (SRC2[143:128]);\n    TMP_DEST[207:200] := SaturateSignedWordToSignedByte (SRC2[159:144]);\n    TMP_DEST[215:208] := SaturateSignedWordToSignedByte (SRC2[175:160]);\n    TMP_DEST[223:216] := SaturateSignedWordToSignedByte (SRC2[191:176]);\n    TMP_DEST[231:224] := SaturateSignedWordToSignedByte (SRC2[207:192]);\n    TMP_DEST[239:232] := SaturateSignedWordToSignedByte (SRC2[223:208]);\n    TMP_DEST[247:240] := SaturateSignedWordToSignedByte (SRC2[239:224]);\n    TMP_DEST[255:248] := SaturateSignedWordToSignedByte (SRC2[255:240]);\nFI;\nIF VL >= 512\n    TMP_DEST[263:256] := SaturateSignedWordToSignedByte (SRC1[271:256]);\n    TMP_DEST[271:264] := SaturateSignedWordToSignedByte (SRC1[287:272]);\n    TMP_DEST[279:272] := SaturateSignedWordToSignedByte (SRC1[303:288]);\n    TMP_DEST[287:280] := SaturateSignedWordToSignedByte (SRC1[319:304]);\n    TMP_DEST[295:288] := SaturateSignedWordToSignedByte (SRC1[335:320]);\n    TMP_DEST[303:296] := SaturateSignedWordToSignedByte (SRC1[351:336]);\n    TMP_DEST[311:304] := SaturateSignedWordToSignedByte (SRC1[367:352]);\n    TMP_DEST[319:312] := SaturateSignedWordToSignedByte (SRC1[383:368]);\n    TMP_DEST[327:320] := SaturateSignedWordToSignedByte (SRC2[271:256]);\n    TMP_DEST[335:328] := SaturateSignedWordToSignedByte (SRC2[287:272]);\n    TMP_DEST[343:336] := SaturateSignedWordToSignedByte (SRC2[303:288]);\n    TMP_DEST[351:344] := SaturateSignedWordToSignedByte (SRC2[319:304]);\n    TMP_DEST[359:352] := SaturateSignedWordToSignedByte (SRC2[335:320]);\n    TMP_DEST[367:360] := SaturateSignedWordToSignedByte (SRC2[351:336]);\n    TMP_DEST[375:368] := SaturateSignedWordToSignedByte (SRC2[367:352]);\n    TMP_DEST[383:376] := SaturateSignedWordToSignedByte (SRC2[383:368]);\n    TMP_DEST[391:384] := SaturateSignedWordToSignedByte (SRC1[399:384]);\n    TMP_DEST[399:392] := SaturateSignedWordToSignedByte (SRC1[415:400]);\n    TMP_DEST[407:400] := SaturateSignedWordToSignedByte (SRC1[431:416]);\n    TMP_DEST[415:408] := SaturateSignedWordToSignedByte (SRC1[447:432]);\n    TMP_DEST[423:416] := SaturateSignedWordToSignedByte (SRC1[463:448]);\n    TMP_DEST[431:424] := SaturateSignedWordToSignedByte (SRC1[479:464]);\n    TMP_DEST[439:432] := SaturateSignedWordToSignedByte (SRC1[495:480]);\n    TMP_DEST[447:440] := SaturateSignedWordToSignedByte (SRC1[511:496]);\n    TMP_DEST[455:448] := SaturateSignedWordToSignedByte (SRC2[399:384]);\n    TMP_DEST[463:456] := SaturateSignedWordToSignedByte (SRC2[415:400]);\n    TMP_DEST[471:464] := SaturateSignedWordToSignedByte (SRC2[431:416]);\n    TMP_DEST[479:472] := SaturateSignedWordToSignedByte (SRC2[447:432]);\n    TMP_DEST[487:480] := SaturateSignedWordToSignedByte (SRC2[463:448]);\n    TMP_DEST[495:488] := SaturateSignedWordToSignedByte (SRC2[479:464]);\n    TMP_DEST[503:496] := SaturateSignedWordToSignedByte (SRC2[495:480]);\n    TMP_DEST[511:504] := SaturateSignedWordToSignedByte (SRC2[511:496]);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN\n            DEST[i+7:i] := TMP_DEST[i+7:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO ((KL/2) - 1)\n    i := j * 32\n    IF (EVEX.b == 1) AND (SRC2 *is memory*)\n        THEN\n            TMP_SRC2[i+31:i] := SRC2[31:0]\n        ELSE\n            TMP_SRC2[i+31:i] := SRC2[i+31:i]\n    FI;\nENDFOR;\nTMP_DEST[15:0] := SaturateSignedDwordToSignedWord (SRC1[31:0]);\nTMP_DEST[31:16] := SaturateSignedDwordToSignedWord (SRC1[63:32]);\nTMP_DEST[47:32] := SaturateSignedDwordToSignedWord (SRC1[95:64]);\nTMP_DEST[63:48] := SaturateSignedDwordToSignedWord (SRC1[127:96]);\nTMP_DEST[79:64] := SaturateSignedDwordToSignedWord (TMP_SRC2[31:0]);\nTMP_DEST[95:80] := SaturateSignedDwordToSignedWord (TMP_SRC2[63:32]);\nTMP_DEST[111:96] := SaturateSignedDwordToSignedWord (TMP_SRC2[95:64]);\nTMP_DEST[127:112] := SaturateSignedDwordToSignedWord (TMP_SRC2[127:96]);\nIF VL >= 256\n    TMP_DEST[143:128] := SaturateSignedDwordToSignedWord (SRC1[159:128]);\n    TMP_DEST[159:144] := SaturateSignedDwordToSignedWord (SRC1[191:160]);\n    TMP_DEST[175:160] := SaturateSignedDwordToSignedWord (SRC1[223:192]);\n    TMP_DEST[191:176] := SaturateSignedDwordToSignedWord (SRC1[255:224]);\n    TMP_DEST[207:192] := SaturateSignedDwordToSignedWord (TMP_SRC2[159:128]);\n    TMP_DEST[223:208] := SaturateSignedDwordToSignedWord (TMP_SRC2[191:160]);\n    TMP_DEST[239:224] := SaturateSignedDwordToSignedWord (TMP_SRC2[223:192]);\n    TMP_DEST[255:240] := SaturateSignedDwordToSignedWord (TMP_SRC2[255:224]);\nFI;\nIF VL >= 512\n    TMP_DEST[271:256] := SaturateSignedDwordToSignedWord (SRC1[287:256]);\n    TMP_DEST[287:272] := SaturateSignedDwordToSignedWord (SRC1[319:288]);\n    TMP_DEST[303:288] := SaturateSignedDwordToSignedWord (SRC1[351:320]);\n    TMP_DEST[319:304] := SaturateSignedDwordToSignedWord (SRC1[383:352]);\n    TMP_DEST[335:320] := SaturateSignedDwordToSignedWord (TMP_SRC2[287:256]);\n    TMP_DEST[351:336] := SaturateSignedDwordToSignedWord (TMP_SRC2[319:288]);\n    TMP_DEST[367:352] := SaturateSignedDwordToSignedWord (TMP_SRC2[351:320]);\n    TMP_DEST[383:368] := SaturateSignedDwordToSignedWord (TMP_SRC2[383:352]);\n    TMP_DEST[399:384] := SaturateSignedDwordToSignedWord (SRC1[415:384]);\n    TMP_DEST[415:400] := SaturateSignedDwordToSignedWord (SRC1[447:416]);\n    TMP_DEST[431:416] := SaturateSignedDwordToSignedWord (SRC1[479:448]);\n    TMP_DEST[447:432] := SaturateSignedDwordToSignedWord (SRC1[511:480]);\n    TMP_DEST[463:448] := SaturateSignedDwordToSignedWord (TMP_SRC2[415:384]);\n    TMP_DEST[479:464] := SaturateSignedDwordToSignedWord (TMP_SRC2[447:416]);\n    TMP_DEST[495:480] := SaturateSignedDwordToSignedWord (TMP_SRC2[479:448]);\n    TMP_DEST[511:496] := SaturateSignedDwordToSignedWord (TMP_SRC2[511:480]);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPACKSSDW, see Table 2-50, “Type E4NF Class Exception Conditions.”",
        "EVEX-encoded VPACKSSWB, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermilpd",
    "category": "Core Instructions",
    "instructionName": "VPERMILPD\n\t\t— Permute In-Lane of Pairs of Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute double precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 0D /r VPERMILPD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute double precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 0D /r VPERMILPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point values in xmm2 using control from xmm3/m128/m64bcst and store the result in xmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 0D /r VPERMILPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point values in ymm2 using control from ymm3/m256/m64bcst and store the result in ymm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 0D /r VPERMILPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute double precision floating-point values in zmm2 using control from zmm3/m512/m64bcst and store the result in zmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 0D /r VPERMILPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute double precision floating-point values in xmm2/m128 using controls from imm8.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 05 /r ib VPERMILPD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute double precision floating-point values in ymm2/m256 using controls from imm8.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 05 /r ib VPERMILPD ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point values in xmm2/m128/m64bcst using controls from imm8 and store the result in xmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 05 /r ib VPERMILPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point values in ymm2/m256/m64bcst using controls from imm8 and store the result in ymm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 05 /r ib VPERMILPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute double precision floating-point values in zmm2/m512/m64bcst using controls from imm8 and store the result in zmm1 using writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 05 /r ib VPERMILPD zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/endbr64",
    "category": "Core Instructions",
    "instructionName": "ENDBR64\n\t\t— Terminate an Indirect Branch in 64-bit Mode",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_IBT",
        "Description": "Terminate indirect branch in 64-bit mode.",
        "Op / En": "ZO",
        "Opcode/Instruction": "F3 0F 1E FA ENDBR64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      }
    ],
    "descriptionText": "Terminate an indirect branch in 64 bit mode.",
    "operationText": "IF EndbranchEnabled(CPL) & IA32_EFER.LMA = 1 & CS.L = 1\n    IF CPL = 3\n        THEN\n            IA32_U_CET.TRACKER = IDLE\n            IA32_U_CET.SUPPRESS = 0\n        ELSE\n            IA32_S_CET.TRACKER = IDLE\n            IA32_S_CET.SUPPRESS = 0\n    FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmadd132pd:vfmadd213pd:vfmadd231pd",
    "category": "Core Instructions",
    "instructionName": "VFMADD132PD/VFMADD213PD/VFMADD231PD\n\t\t— Fused Multiply-Add of Packed DoublePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 98 /r VFMADD132PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 A8 /r VFMADD213PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 B8 /r VFMADD231PD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 98 /r VFMADD132PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 A8 /r VFMADD213PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 B8 /r VFMADD231PD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm3/m128/m64bcst, add to xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 98 /r VFMADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m64bcst and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 A8 /r VFMADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from xmm2 and xmm3/m128/m64bcst, add to xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 B8 /r VFMADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm3/m256/m64bcst, add to ymm2 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 98 /r VFMADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m64bcst and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 A8 /r VFMADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed double precision floating-point values from ymm2 and ymm3/m256/m64bcst, add to ymm1 and put result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 B8 /r VFMADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm3/m512/m64bcst, add to zmm2 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 98 /r VFMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m64bcst and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 A8 /r VFMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed double precision floating-point values from zmm2 and zmm3/m512/m64bcst, add to zmm1 and put result in zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 B8 /r VFMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pandn",
    "category": "Core Instructions",
    "instructionName": "PANDN\n\t\t— Logical AND NOT",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Bitwise AND NOT of mm/m64 and mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F DF /r1 PANDN mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Bitwise AND NOT of xmm2/m128 and xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F DF /r PANDN xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Bitwise AND NOT of xmm3/m128 and xmm2.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG DF /r VPANDN xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG DF /r VPANDN ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND NOT of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 DF /r VPANDND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND NOT of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 DF /r VPANDND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise AND NOT of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 DF /r VPANDND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND NOT of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 DF /r VPANDNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND NOT of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 DF /r VPANDNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise AND NOT of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 DF /r VPANDNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1 at 32/64-bit granularity.\nVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
    "operationText": "DEST := NOT(DEST) AND SRC\nDEST := NOT(DEST) AND SRC\nDEST[MAXVL-1:128] (Unmodified)\nDEST := NOT(SRC1) AND SRC2\nDEST[MAXVL-1:128] := 0\nDEST[255:0] := ((NOT SRC1[255:0]) AND SRC2[255:0])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+31:i] := ((NOT SRC1[i+31:i]) AND SRC2[31:0])\n                ELSE DEST[i+31:i] := ((NOT SRC1[i+31:i]) AND SRC2[i+31:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+63:i] := ((NOT SRC1[i+63:i]) AND SRC2[63:0])\n                ELSE DEST[i+63:i] := ((NOT SRC1[i+63:i]) AND SRC2[i+63:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cwd:cdq:cqo",
    "category": "Core Instructions",
    "instructionName": "CWD/CDQ/CQO\n\t\t— Convert Word to Doubleword/Convert Doubleword to Quadword",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "DX:AX := sign-extend of AX.",
        "Instruction": "CWD",
        "Op/En": "ZO",
        "Opcode": "99"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "EDX:EAX := sign-extend of EAX.",
        "Instruction": "CDQ",
        "Op/En": "ZO",
        "Opcode": "99"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "RDX:RAX:= sign-extend of RAX.",
        "Instruction": "CQO",
        "Op/En": "ZO",
        "Opcode": "REX.W + 99"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruction (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.\nThe CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO instruction can be used to produce a double quadword dividend from a quadword before a quadword division.\nThe CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.\nIn 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF OperandSize = 16 (* CWD instruction *)\n    THEN\n        DX := SignExtend(AX);\n    ELSE IF OperandSize = 32 (* CDQ instruction *)\n        EDX := SignExtend(EAX); FI;\n    ELSE IF 64-Bit Mode and OperandSize = 64 (* CQO instruction*)\n        RDX := SignExtend(RAX); FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pcmpeqb:pcmpeqw:pcmpeqd",
    "category": "Core Instructions",
    "instructionName": "PCMPEQB/PCMPEQW/PCMPEQD\n\t\t— Compare Packed Data for Equal",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Compare packed bytes in mm/m64 and mm for equality.",
        "Op/ En": "A",
        "Opcode/Instruction": "NP 0F 74 /r1 PCMPEQB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed bytes in xmm2/m128 and xmm1 for equality.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F 74 /r PCMPEQB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Compare packed words in mm/m64 and mm for equality.",
        "Op/ En": "A",
        "Opcode/Instruction": "NP 0F 75 /r1 PCMPEQW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed words in xmm2/m128 and xmm1 for equality.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F 75 /r PCMPEQW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Compare packed doublewords in mm/m64 and mm for equality.",
        "Op/ En": "A",
        "Opcode/Instruction": "NP 0F 76 /r1 PCMPEQD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed doublewords in xmm2/m128 and xmm1 for equality.",
        "Op/ En": "A",
        "Opcode/Instruction": "66 0F 76 /r PCMPEQD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed bytes in xmm3/m128 and xmm2 for equality.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 74 /r VPCMPEQB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed words in xmm3/m128 and xmm2 for equality.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 75 /r VPCMPEQW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed doublewords in xmm3/m128 and xmm2 for equality.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 76 /r VPCMPEQD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed bytes in ymm3/m256 and ymm2 for equality.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 74 /r VPCMPEQB ymm1, ymm2, ymm3 /m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed words in ymm3/m256 and ymm2 for equality.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 75 /r VPCMPEQW ymm1, ymm2, ymm3 /m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed doublewords in ymm3/m256 and ymm2 for equality.",
        "Op/ En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 76 /r VPCMPEQD ymm1, ymm2, ymm3 /m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare Equal between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 76 /r VPCMPEQD k1 {k2}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare Equal between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 76 /r VPCMPEQD k1 {k2}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare Equal between int32 vectors in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask k2.",
        "Op/ En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 76 /r VPCMPEQD k1 {k2}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed bytes in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 74 /r VPCMPEQB k1 {k2}, xmm2, xmm3 /m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed bytes in ymm3/m256 and ymm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 74 /r VPCMPEQB k1 {k2}, ymm2, ymm3 /m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed bytes in zmm3/m512 and zmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 74 /r VPCMPEQB k1 {k2}, zmm2, zmm3 /m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed words in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 75 /r VPCMPEQW k1 {k2}, xmm2, xmm3 /m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed words in ymm3/m256 and ymm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 75 /r VPCMPEQW k1 {k2}, ymm2, ymm3 /m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed words in zmm3/m512 and zmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask.",
        "Op/ En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 75 /r VPCMPEQW k1 {k2}, zmm2, zmm3 /m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.\nThe (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nEVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.\nEVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
    "operationText": "IF DEST[7:0] = SRC[7:0]\n    THEN DEST[7:0) := FFH;\n    ELSE DEST[7:0] := 0; FI;\n(* Continue comparison of 2nd through 7th bytes in DEST and SRC *)\nIF DEST[63:56] = SRC[63:56]\n    THEN DEST[63:56] := FFH;\n    ELSE DEST[63:56] := 0; FI;\nIF SRC1[7:0] = SRC2[7:0]\n    THEN DEST[7:0] := FFH;\n    ELSE DEST[7:0] := 0; FI;\n(* Continue comparison of 2nd through 15th bytes in SRC1 and SRC2 *)\n    IF SRC1[127:120] = SRC2[127:120]\n    THEN DEST[127:120] := FFH;\n    ELSE DEST[127:120] := 0; FI;\nIF SRC1[15:0] = SRC2[15:0]\n    THEN DEST[15:0] := FFFFH;\n    ELSE DEST[15:0] := 0; FI;\n(* Continue comparison of 2nd through 7th 16-bit words in SRC1 and SRC2 *)\n    IF SRC1[127:112] = SRC2[127:112]\n    THEN DEST[127:112] := FFFFH;\n    ELSE DEST[127:112] := 0; FI;\nIF SRC1[31:0] = SRC2[31:0]\n    THEN DEST[31:0] := FFFFFFFFH;\n    ELSE DEST[31:0] := 0; FI;\n(* Continue comparison of 2nd through 3rd 32-bit dwords in SRC1 and SRC2 *)\n    IF SRC1[127:96] = SRC2[127:96]\n    THEN DEST[127:96] := FFFFFFFFH;\n    ELSE DEST[127:96] := 0; FI;\nDEST[127:0] := COMPARE_BYTES_EQUAL(DEST[127:0],SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := COMPARE_BYTES_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := COMPARE_BYTES_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[255:128] := COMPARE_BYTES_EQUAL(SRC1[255:128],SRC2[255:128])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k2[j] OR *no writemask*\n        THEN\n            /* signed comparison */\n            CMP := SRC1[i+7:i] == SRC2[i+7:i];\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                    ; zeroing-masking onlyFI;\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0\nIF DEST[15:0] = SRC[15:0]\n    THEN DEST[15:0] := FFFFH;\n    ELSE DEST[15:0] := 0; FI;\n(* Continue comparison of 2nd and 3rd words in DEST and SRC *)\nIF DEST[63:48] = SRC[63:48]\n    THEN DEST[63:48] := FFFFH;\n    ELSE DEST[63:48] := 0; FI;\nDEST[127:0] := COMPARE_WORDS_EQUAL(DEST[127:0],SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := COMPARE_WORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := COMPARE_WORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[255:128] := COMPARE_WORDS_EQUAL(SRC1[255:128],SRC2[255:128])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k2[j] OR *no writemask*\n        THEN\n            /* signed comparison */\n            CMP := SRC1[i+15:i] == SRC2[i+15:i];\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                    ; zeroing-masking onlyFI;\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0\nIF DEST[31:0] = SRC[31:0]\n    THEN DEST[31:0] := FFFFFFFFH;\n    ELSE DEST[31:0] := 0; FI;\nIF DEST[63:32] = SRC[63:32]\n    THEN DEST[63:32] := FFFFFFFFH;\n    ELSE DEST[63:32] := 0; FI;\nDEST[127:0] := COMPARE_DWORDS_EQUAL(DEST[127:0],SRC[127:0])\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := COMPARE_DWORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := COMPARE_DWORDS_EQUAL(SRC1[127:0],SRC2[127:0])\nDEST[255:128] := COMPARE_DWORDS_EQUAL(SRC1[255:128],SRC2[255:128])\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k2[j] OR *no writemask*\n        THEN\n            /* signed comparison */\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN CMP := SRC1[i+31:i] = SRC2[31:0];\n                ELSE CMP := SRC1[i+31:i] = SRC2[i+31:i];\n            FI;\n            IF CMP = TRUE\n                THEN DEST[j] := 1;\n                ELSE DEST[j] := 0; FI;\n        ELSE DEST[j] := 0\n                    ; zeroing-masking only\n    FI;\nENDFOR\nDEST[MAX_KL-1:KL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded VPCMPEQD, see Table 2-49, “Type E4 Class Exception Conditions.”",
        "EVEX-encoded VPCMPEQB/W, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pslldq",
    "category": "Core Instructions",
    "instructionName": "PSLLDQ\n\t\t— Shift Double Quadword Left Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift xmm1 left by imm8 bytes while shifting in 0s.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 73 /7 ib PSLLDQ xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 73 /7 ib VPSLLDQ xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 73 /7 ib VPSLLDQ ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift xmm2/m128 left by imm8 bytes while shifting in 0s and store result in xmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 73 /7 ib VPSLLDQ xmm1,xmm2/ m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift ymm2/m256 left by imm8 bytes while shifting in 0s and store result in ymm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 73 /7 ib VPSLLDQ ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift zmm2/m512 left by imm8 bytes while shifting in 0s and store result in zmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 73 /7 ib VPSLLDQ zmm1, zmm2/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "EVEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand (second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.\n128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.",
    "operationText": "TEMP := COUNT\nIF (TEMP > 15) THEN TEMP := 16; FI\nDEST[127:0] := SRC[127:0] << (TEMP * 8)\nDEST[255:128] := SRC[255:128] << (TEMP * 8)\nDEST[383:256] := SRC[383:256] << (TEMP * 8)\nDEST[511:384] := SRC[511:384] << (TEMP * 8)\nDEST[MAXVL-1:512] := 0\nTEMP := COUNT\nIF (TEMP > 15) THEN TEMP := 16; FI\nDEST[127:0] := SRC[127:0] << (TEMP * 8)\nDEST[255:128] := SRC[255:128] << (TEMP * 8)\nDEST[MAXVL-1:256] := 0\nTEMP := COUNT\nIF (TEMP > 15) THEN TEMP := 16; FI\nDEST := SRC << (TEMP * 8)\nDEST[MAXVL-1:128] := 0\nTEMP := COUNT\nIF (TEMP > 15) THEN TEMP := 16; FI\nDEST := DEST << (TEMP * 8)\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-24, “Type 7 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtsi2ss",
    "category": "Core Instructions",
    "instructionName": "CVTSI2SS\n\t\t— Convert Doubleword Integer to Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Convert one signed doubleword integer from r/m32 to one single precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 2A /r CVTSI2SS xmm1, r/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "SSE",
        "Description": "Convert one signed quadword integer from r/m64 to one single precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 REX.W 0F 2A /r CVTSI2SS xmm1, r/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one signed doubleword integer from r/m32 to one single precision floating-point value in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.W0 2A /r VCVTSI2SS xmm1, xmm2, r/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one signed quadword integer from r/m64 to one single precision floating-point value in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.W1 2A /r VCVTSI2SS xmm1, xmm2, r/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one signed doubleword integer from r/m32 to one single precision floating-point value in xmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 2A /r VCVTSI2SS xmm1, xmm2, r/m32{er}"
      },
      {
        "64/32 bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one signed quadword integer from r/m64 to one single precision floating-point value in xmm1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W1 2A /r VCVTSI2SS xmm1, xmm2, r/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the “convert-from” source operand to a single precision floating-point value in the destination operand (first operand). The “convert-from” source operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand, and the upper three doublewords are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.\n128-bit Legacy SSE version: In 64-bit mode, Use of the REX.W prefix promotes the instruction to use 64-bit input value. The “convert-from” source operand (the second operand) is a general-purpose register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be a general-purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: the converted result in written to the low doubleword element of the destination under the writemask.\nSoftware should ensure VCVTSI2SS is encoded with VEX.L=0. Encoding VCVTSI2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (SRC2 *is register*) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n    DEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:0]);\nELSE\n    DEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0]);\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n    DEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:0]);\nELSE\n    DEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0]);\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nIF 64-Bit Mode And OperandSize = 64\nTHEN\n    DEST[31:0] := Convert_Integer_To_Single_Precision_Floating_Point(SRC[63:0]);\nELSE\n    DEST[31:0] :=Convert_Integer_To_Single_Precision_Floating_Point(SRC[31:0]);\nFI;\nDEST[MAXVL-1:32] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtsd2si",
    "category": "Core Instructions",
    "instructionName": "CVTSD2SI\n\t\t— Convert Scalar Double Precision Floating-Point Value to Doubleword Integer",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer r32.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 2D /r CVTSD2SI r32, xmm1/m64"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 REX.W 0F 2D /r CVTSD2SI r64, xmm1/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer r32.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.F2.0F.W0 2D /r 1 VCVTSD2SI r32, xmm1/m64"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.F2.0F.W1 2D /r 1 VCVTSD2SI r64, xmm1/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer r32.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W0 2D /r VCVTSD2SI r32, xmm1/m64{er}"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 2D /r VCVTSD2SI r64, xmm1/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Fixed"
      }
    ],
    "descriptionText": "Converts a double precision floating-point value in the source operand (the second operand) to a signed double-word integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double precision floating-point value is contained in the low quadword of the register.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.\nIf a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nIf a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.\nLegacy SSE instruction: Use of the REX.W prefix promotes the instruction to produce 64-bit data in 64-bit mode. See the summary chart at the beginning of this section for encoding data and limits.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCVTSD2SI is encoded with VEX.L=0. Encoding VCVTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF SRC *is register* AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF 64-Bit Mode and OperandSize = 64\n    THEN DEST[63:0] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0]);\n    ELSE DEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0]);\nFI\nIF 64-Bit Mode and OperandSize = 64\nTHEN\n    DEST[63:0] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0]);\nELSE\n    DEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0]);\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmulhuw",
    "category": "Core Instructions",
    "instructionName": "PMULHUW\n\t\t— Multiply Packed Unsigned Integers and Store High Result",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F E4 /r1 PMULHUW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F E4 /r PMULHUW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E4 /r VPMULHUW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E4 /r VPMULHUW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG E4 /r VPMULHUW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG E4 /r VPMULHUW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Multiply the packed unsigned word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG E4 /r VPMULHUW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
    "operationText": "TEMP0[31:0] := DEST[15:0] ∗ SRC[15:0]; (* Unsigned multiplication *)\nTEMP1[31:0] := DEST[31:16] ∗ SRC[31:16];\nTEMP2[31:0] := DEST[47:32] ∗ SRC[47:32];\nTEMP3[31:0] := DEST[63:48] ∗ SRC[63:48];\nDEST[15:0] := TEMP0[31:16];\nDEST[31:16] := TEMP1[31:16];\nDEST[47:32] := TEMP2[31:16];\nDEST[63:48] := TEMP3[31:16];\nTEMP0[31:0] := DEST[15:0] ∗ SRC[15:0]; (* Unsigned multiplication *)\nTEMP1[31:0] := DEST[31:16] ∗ SRC[31:16];\nTEMP2[31:0] := DEST[47:32] ∗ SRC[47:32];\nTEMP3[31:0] := DEST[63:48] ∗ SRC[63:48];\nTEMP4[31:0] := DEST[79:64] ∗ SRC[79:64];\nTEMP5[31:0] := DEST[95:80] ∗ SRC[95:80];\nTEMP6[31:0] := DEST[111:96] ∗ SRC[111:96];\nTEMP7[31:0] := DEST[127:112] ∗ SRC[127:112];\nDEST[15:0] := TEMP0[31:16];\nDEST[31:16] := TEMP1[31:16];\nDEST[47:32] := TEMP2[31:16];\nDEST[63:48] := TEMP3[31:16];\nDEST[79:64] := TEMP4[31:16];\nDEST[95:80] := TEMP5[31:16];\nDEST[111:96] := TEMP6[31:16];\nDEST[127:112] := TEMP7[31:16];\nTEMP0[31:0] := SRC1[15:0] * SRC2[15:0]\nTEMP1[31:0] := SRC1[31:16] * SRC2[31:16]\nTEMP2[31:0] := SRC1[47:32] * SRC2[47:32]\nTEMP3[31:0] := SRC1[63:48] * SRC2[63:48]\nTEMP4[31:0] := SRC1[79:64] * SRC2[79:64]\nTEMP5[31:0] := SRC1[95:80] * SRC2[95:80]\nTEMP6[31:0] := SRC1[111:96] * SRC2[111:96]\nTEMP7[31:0] := SRC1[127:112] * SRC2[127:112]\nDEST[15:0] := TEMP0[31:16]\nDEST[31:16] := TEMP1[31:16]\nDEST[47:32] := TEMP2[31:16]\nDEST[63:48] := TEMP3[31:16]\nDEST[79:64] := TEMP4[31:16]\nDEST[95:80] := TEMP5[31:16]\nDEST[111:96] := TEMP6[31:16]\nDEST[127:112] := TEMP7[31:16]\nDEST[MAXVL-1:128] := 0\nTEMP0[31:0] := SRC1[15:0] * SRC2[15:0]\nTEMP1[31:0] := SRC1[31:16] * SRC2[31:16]\nTEMP2[31:0] := SRC1[47:32] * SRC2[47:32]\nTEMP3[31:0] := SRC1[63:48] * SRC2[63:48]\nTEMP4[31:0] := SRC1[79:64] * SRC2[79:64]\nTEMP5[31:0] := SRC1[95:80] * SRC2[95:80]\nTEMP6[31:0] := SRC1[111:96] * SRC2[111:96]\nTEMP7[31:0] := SRC1[127:112] * SRC2[127:112]\nTEMP8[31:0] := SRC1[143:128] * SRC2[143:128]\nTEMP9[31:0] := SRC1[159:144] * SRC2[159:144]\nTEMP10[31:0] := SRC1[175:160] * SRC2[175:160]\nTEMP11[31:0] := SRC1[191:176] * SRC2[191:176]\nTEMP12[31:0] := SRC1[207:192] * SRC2[207:192]\nTEMP13[31:0] := SRC1[223:208] * SRC2[223:208]\nTEMP14[31:0] := SRC1[239:224] * SRC2[239:224]\nTEMP15[31:0] := SRC1[255:240] * SRC2[255:240]\nDEST[15:0] := TEMP0[31:16]\nDEST[31:16] := TEMP1[31:16]\nDEST[47:32] := TEMP2[31:16]\nDEST[63:48] := TEMP3[31:16]\nDEST[79:64] := TEMP4[31:16]\nDEST[95:80] := TEMP5[31:16]\nDEST[111:96] := TEMP6[31:16]\nDEST[127:112] := TEMP7[31:16]\nDEST[143:128] := TEMP8[31:16]\nDEST[159:144] := TEMP9[31:16]\nDEST[175:160] := TEMP10[31:16]\nDEST[191:176] := TEMP11[31:16]\nDEST[207:192] := TEMP12[31:16]\nDEST[223:208] := TEMP13[31:16]\nDEST[239:224] := TEMP14[31:16]\nDEST[255:240] := TEMP15[31:16]\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN\n            temp[31:0] := SRC1[i+15:i] * SRC2[i+15:i]\n            DEST[i+15:i] := tmp[31:16]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/enclu",
    "category": "SGX Instructions",
    "instructionName": "ENCLU\n\t\t— Execute an Enclave User Function of Specified Leaf Number",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "NA",
        "Description": "This instruction is used to execute non-privileged Intel SGX leaf functions.",
        "Op/En": "ZO",
        "Opcode/Instruction": "NP 0F 01 D7 ENCLU"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "ZO",
        "column_2": "NA",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "See Section 38.4"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/syscall",
    "category": "Core Instructions",
    "instructionName": "SYSCALL\n\t\t— Fast System Call",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Invalid",
        "Description": "Fast call to privilege level 0 system procedures.",
        "Instruction": "SYSCALL",
        "Op/En": "ZO",
        "Opcode": "0F 05"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX). (The WRMSR instruction ensures that the IA32_LSTAR MSR always contain a canonical address.)\nSYSCALL also saves RFLAGS into R11 and then masks RFLAGS using the IA32_FMASK MSR (MSR address C0000084H); specifically, the processor clears in RFLAGS every bit corresponding to a bit that is set in the IA32_FMASK MSR.\nSYSCALL loads the CS and SS selectors with values derived from bits 47:32 of the IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSCALL instruction does not ensure this correspondence.\nThe SYSCALL instruction does not save the stack pointer (RSP). If the OS system-call handler will change the stack pointer, it is the responsibility of software to save the previous value of the stack pointer. This might be done prior to executing SYSCALL, with software restoring the stack pointer with the instruction following SYSCALL (which will be executed after SYSRET). Alternatively, the OS system-call handler may save the stack pointer and restore it before executing SYSRET.\nWhen shadow stacks are enabled at a privilege level where the SYSCALL instruction is invoked, the SSP is saved to the IA32_PL3_SSP MSR. If shadow stacks are enabled at privilege level 0, the SSP is loaded with 0. Refer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions‚” and Chapter 17, “Control-flow Enforcement Technology (CET)‚” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for additional CET details.\nInstruction ordering. Instructions following a SYSCALL may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSCALL have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).",
    "operationText": "IF (CS.L ≠ 1 ) or (IA32_EFER.LMA ≠ 1) or (IA32_EFER.SCE ≠ 1)\n(* Not in 64-Bit Mode or SYSCALL/SYSRET not enabled in IA32_EFER *)\n    THEN #UD;\nFI;\nRCX := RIP; (* Will contain address of next instruction *)\nRIP := IA32_LSTAR;\nR11 := RFLAGS;\nRFLAGS := RFLAGS AND NOT(IA32_FMASK);\nCS.Selector := IA32_STAR[47:32] AND FFFCH (* Operating system provides CS; RPL forced to 0 *)\n(* Set rest of CS to a fixed value *)\nCS.Base := 0;\n                (* Flat segment *)\nCS.Limit := FFFFFH;\n                (* With 4-KByte granularity, implies a 4-GByte limit *)\nCS.Type := 11;\n                (* Execute/read code, accessed *)\nCS.S := 1;\nCS.DPL := 0;\nCS.P := 1;\nCS.L := 1;\n                (* Entry is to 64-bit mode *)\nCS.D := 0;\n                (* Required if CS.L = 1 *)\nCS.G := 1;\n                (* 4-KByte granularity *)\nIF ShadowStackEnabled(CPL)\n    THEN (* adjust so bits 63:N get the value of bit N–1, where N is the CPU’s maximum linear-address width *)\n        IA32_PL3_SSP := LA_adjust(SSP);\n            (* With shadow stacks enabled the system call is supported from Ring 3 to Ring 0 *)\n            (* OS supporting Ring 0 to Ring 0 system calls or Ring 1/2 to ring 0 system call *)\n            (* Must preserve the contents of IA32_PL3_SSP to avoid losing ring 3 state *)\nFI;\nCPL := 0;\nIF ShadowStackEnabled(CPL)\n    SSP := 0;\nFI;\nIF EndbranchEnabled(CPL)\n    IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n    IA32_S_CET.SUPPRESS = 0\nFI;\nSS.Selector := IA32_STAR[47:32] + 8;\n                (* SS just above CS *)\n(* Set rest of SS to a fixed value *)\nSS.Base := 0;\n                (* Flat segment *)\nSS.Limit := FFFFFH;\n                (* With 4-KByte granularity, implies a 4-GByte limit *)\nSS.Type := 3;\n                (* Read/write data, accessed *)\nSS.S := 1;\nSS.DPL := 0;\nSS.P := 1;\nSS.B := 1;\n                (* 32-bit stack segment *)\nSS.G := 1;\n                (* 4-KByte granularity *)",
    "flagsAffectedText": "All.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcp28pd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VRCP28PD\n\t\t— Approximation to the Reciprocal of Packed Double Precision Floating-Point ValuesWith Less Than 2^-28 Relative Error",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512ER",
        "Description": "Computes the approximate reciprocals ( < 2^-28 relative error) of the packed double precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 CA /r VRCP28PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4": "A Full ModRM:reg (w) ModRM:r/m (r) N/A N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/sha1msg1",
    "category": "Core Instructions",
    "instructionName": "SHA1MSG1\n\t\t— Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SHA",
        "Description": "Performs an intermediate calculation for the next four SHA1 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 C9 /r SHA1MSG1 xmm1, xmm2/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "The SHA1MSG1 instruction is one of two SHA1 message scheduling instructions. The instruction performs an intermediate calculation for the next four SHA1 message dwords.",
    "operationText": "W0 := SRC1[127:96] ;\nW1 := SRC1[95:64] ;\nW2 := SRC1[63: 32] ;\nW3 := SRC1[31: 0] ;\nW4 := SRC2[127:96] ;\nW5 := SRC2[95:64] ;\nDEST[127:96] := W2 XOR W0;\nDEST[95:64] := W3 XOR W1;\nDEST[63:32] := W4 XOR W2;\nDEST[31:0] := W5 XOR W3;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmxon",
    "category": "VMX Instructions",
    "instructionName": "VMXON\n\t\t— Enter VMX Operation",
    "detailsTable": [
      {
        "Description": "Enter VMX root operation.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 0F C7 /6 VMXON m64"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "M",
        "column_2": "ModRM:r/m (r)",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Puts the logical processor in VMX operation with no current VMCS, blocks INIT signals, disables A20M, and clears any address-range monitoring established by the MONITOR instruction.1\nThe operand of this instruction is a 4KB-aligned physical address (the VMXON pointer) that references the VMXON region, which the logical processor may use to support VMX operation. This operand is always 64 bits and is always in memory.",
    "operationText": "IF (register operand) or (CR0.PE = 0) or (CR4.VMXE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF not in VMX operation\n    THEN\n        IF (CPL > 0) or (in A20M mode) or\n        (the values of CR0 and CR4 are not supported in VMX operation; see Section 24.8) or\n        (bit 0 (lock bit) of IA32_FEATURE_CONTROL MSR is clear) or\n        (in SMX operation2 and bit 1 of IA32_FEATURE_CONTROL MSR is clear) or\n        (outside SMX operation and bit 2 of IA32_FEATURE_CONTROL MSR is clear)\n            THEN #GP(0);\n            ELSE\n                addr := contents of 64-bit in-memory source operand;\n                IF addr is not 4KB-aligned or\n                addr sets any bits beyond the physical-address width3\n                    THEN VMfailInvalid;\n                    ELSE\n                        rev := 32 bits located at physical address addr;\n                        IF rev[30:0] ≠ VMCS revision identifier supported by processor OR rev[31] = 1\n                            THEN VMfailInvalid;\n                            ELSE\n                                current-VMCS pointer := FFFFFFFF_FFFFFFFFH;\n                                enter VMX operation;\n                                block INIT signals;\n                                block and disable A20M;\nclear address-range monitoring;\n                    IF the processor supports Intel PT but does not allow it to be used in VMX operation1\n                        THEN IA32_RTIT_CTL.TraceEn := 0;\n                    FI;\n                    VMsucceed;\n                FI;\n            FI;\n        FI;\nELSIF in VMX non-root operation\n    THEN VMexit;\nELSIF CPL > 0\n    THEN #GP(0);\n    ELSE VMfail(“VMXON executed in VMX root operation”);\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: If executed in A20M mode.; \ncolumn_1: If the source operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.;",
        "If the value of the IA32_FEATURE_CONTROL MSR does not support entry to VMX operation in the current processor mode.",
        "column_2: If the source operand is in the SS segment and the memory address is in a non-canonical form.; column_1: #SS(0); \ncolumn_1: #UD; column_2: If operand is a register.; \ncolumn_1: If executed with CR4.VMXE = 0.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: If executed in A20M mode.; \ncolumn_1: If the memory source operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the source operand is located in an execute-only code segment.; \ncolumn_1: If the value of the IA32_FEATURE_CONTROL MSR does not support entry to VMX operation in the current processor mode.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory source operand.; \ncolumn_1: #SS(0); column_2: If the memory source operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_1: #UD; column_2: If operand is a register.; \ncolumn_1: If executed with CR4.VMXE = 0.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/nop",
    "category": "Core Instructions",
    "instructionName": "NOP\n\t\t— No Operation",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "One byte no-operation instruction.",
        "Instruction": "NOP",
        "Op/En": "ZO",
        "Opcode": "NP 90"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multi-byte no-operation instruction.",
        "Instruction": "NOP r/m16",
        "Op/En": "M",
        "Opcode": "NP 0F 1F /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Multi-byte no-operation instruction.",
        "Instruction": "NOP r/m32",
        "Op/En": "M",
        "Opcode": "NP 0F 1F /0"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "This instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction stream but does not impact machine context, except for the EIP register.\nThe multi-byte form of NOP is available on processors with model encoding:\nThe multi-byte NOP instruction does not alter the content of a register and will not issue a memory operation. The instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "The one-byte NOP instruction is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.\nThe multi-byte NOP instruction performs no operation on supported processors and generates undefined opcode\nexception on processors that do not support the multi-byte NOP instruction.\nThe memory operand form of the instruction allows software to create a byte sequence of “no operation” as one\ninstruction. For situations where multiple-byte NOPs are needed, the recommended operations (32-bit mode and\n64-bit mode) are:",
    "flagsAffectedText": "None.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/jmp",
    "category": "Core Instructions",
    "instructionName": "JMP\n\t\t— Jump",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits.",
        "Instruction": "JMP rel8",
        "Op/En": "D",
        "Opcode": "EB cb"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode.",
        "Instruction": "JMP rel16",
        "Op/En": "D",
        "Opcode": "E9 cw"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits.",
        "Instruction": "JMP rel32",
        "Op/En": "D",
        "Opcode": "E9 cd"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near, absolute indirect, address = zero-extended r/m16. Not supported in 64-bit mode.",
        "Instruction": "JMP r/m16",
        "Op/En": "M",
        "Opcode": "FF /4"
      },
      {
        "64-Bit Mode": "N.S.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode.",
        "Instruction": "JMP r/m32",
        "Op/En": "M",
        "Opcode": "FF /4"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Jump near, absolute indirect, RIP = 64-Bit offset from register or memory.",
        "Instruction": "JMP r/m64",
        "Op/En": "M",
        "Opcode": "FF /4"
      },
      {
        "64-Bit Mode": "Inv.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump far, absolute, address given in operand.",
        "Instruction": "JMP ptr16:16",
        "Op/En": "S",
        "Opcode": "EA cd"
      },
      {
        "64-Bit Mode": "Inv.",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump far, absolute, address given in operand.",
        "Instruction": "JMP ptr16:32",
        "Op/En": "S",
        "Opcode": "EA cp"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump far, absolute indirect, address given in m16:16.",
        "Instruction": "JMP m16:16",
        "Op/En": "M",
        "Opcode": "FF /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Jump far, absolute indirect, address given in m16:32.",
        "Instruction": "JMP m16:32",
        "Op/En": "M",
        "Opcode": "FF /5"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Jump far, absolute indirect, address given in m16:64.",
        "Instruction": "JMP m16:64",
        "Op/En": "M",
        "Opcode": "REX.W FF /5"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "S",
        "Operand 1": "Segment + Absolute Address",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "Offset",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.\nThis instruction can be used to execute four different types of jumps:\nA task switch can only be executed in protected mode (see Chapter 8, in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on performing task switches with the JMP instruction).\nNear and Short Jumps. When executing a near jump, the processor jumps to the address (within the current code segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current\nvalue of the instruction pointer in the EIP register). A near jump to a relative offset of 8-bits (rel8) is referred to as a short jump. The CS register is not changed on near and short jumps.\nAn absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16 or r/m32). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the EIP register. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.\nA relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed 8-, 16-, or 32-bit immediate value. This value is added to the value in the EIP register. (Here, the EIP register contains the address of the instruction following the JMP instruction). When using relative offsets, the opcode (for short vs. near jumps) and the operand-size attribute (for near relative jumps) determines the size of the target operand (8, 16, or 32 bits).\nFar Jumps in Real-Address or Virtual-8086 Mode. When executing a far jump in real-address or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand. Here the target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the segment and address of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.\nFar Jumps in Protected Mode. When the processor is operating in protected mode, the JMP instruction can be used to perform the following three types of far jumps:\n(The JMP instruction cannot be used to perform inter-privilege-level far jumps.)\nIn protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of jump to be performed.\nIf the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded into the EIP register. Note that a call gate (described in the next paragraph) can also be used to perform far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making jumps between 16-bit and 32-bit code segments.\nWhen executing a far jump through a call gate, the segment selector specified by the target operand identifies the call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment specified in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32).\nExecuting a task switch with the JMP instruction is somewhat similar to executing a jump through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset part of the target operand is ignored). The task gate in turn points to the TSS for the task, which contains the segment selectors for the task’s code and stack segments. The TSS also contains the EIP value for the next instruction that was to be executed before the task was suspended. This instruction pointer value is loaded into the EIP register so that the task begins executing again at this next instruction.\nThe JMP instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 8 in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for detailed information on the mechanics of a task switch.\nNote that when you execute at task switch with a JMP instruction, the nested task flag (NT) is not set in the EFLAGS register and the new TSS’s previous task link field is not loaded with the old task’s TSS selector. A return to the previous task can thus not be carried out by executing the IRET instruction. Switching tasks with the JMP instruction differs in this regard from the CALL instruction which does set the NT flag and save the previous task link information, allowing a return to the calling task with an IRET instruction.\nRefer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions” and Chapter 17, “Control-flow Enforcement Technology (CET)” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for CET details.\nIn 64-Bit Mode. The instruction’s operation size is fixed at 64 bits. If a selector points to a gate, then RIP equals the 64-bit displacement taken from gate; else RIP equals the zero-extended offset from the far pointer referenced in the instruction.\nSee the summary chart at the beginning of this section for encoding data and limits.\nInstruction ordering. Instructions following a far jump may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far jump have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).\nInstructions sequentially following a near indirect JMP instruction (i.e., those not at the target) may be executed speculatively. If software needs to prevent this (e.g., in order to prevent a speculative execution side channel), then an INT3 or LFENCE instruction opcode can be placed after the near indirect JMP in order to block speculative execution.",
    "operationText": "IF near jump\n    IF 64-bit Mode\n            THEN\n                    IF near relative jump\n                        THEN\n                            tempRIP := RIP + DEST; (* RIP is instruction following JMP instruction*)\n                        ELSE (* Near absolute jump *)\n                            tempRIP := DEST;\n                    FI;\n            ELSE\n                    IF near relative jump\n                        THEN\n                            tempEIP := EIP + DEST; (* EIP is instruction following JMP instruction*)\n                        ELSE (* Near absolute jump *)\n                            tempEIP := DEST;\n                    FI;\n    FI;\n    IF (IA32_EFER.LMA = 0 or target mode = Compatibility mode)\n    and tempEIP outside code segment limit\n            THEN #GP(0); FI\n    IF 64-bit mode and tempRIP is not canonical\n            THEN #GP(0);\n    FI;\n    IF OperandSize = 32\n                THEN\n                    EIP := tempEIP;\n                ELSE\n                    IF OperandSize = 16\n                            THEN (* OperandSize = 16 *)\n                                    EIP := tempEIP AND 0000FFFFH;\n                                ELSE (* OperandSize = 64)\n                                    RIP := tempRIP;\n                    FI;\n        FI;\n    IF (JMP near indirect, absolute indirect)\n            IF EndbranchEnabledAndNotSuppressed(CPL)\n                    IF CPL = 3\n                            THEN\n                                    IF ( no 3EH prefix OR IA32_U_CET.NO_TRACK_EN == 0 )\n                                        THEN\n                                            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                                    FI;\n                            ELSE\n                                    IF ( no 3EH prefix OR IA32_S_CET.NO_TRACK_EN == 0 )\n                                        THEN\n                                            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                                    FI;\n                    FI;\n            FI;\n    FI;\nFI;\nIF far jump and (PE = 0 or (PE = 1 AND VM = 1)) (* Real-address or virtual-8086 mode *)\n        THEN\n                tempEIP := DEST(Offset); (* DEST is ptr16:32 or [m16:32] *)\n                IF tempEIP is beyond code segment limit\n                    THEN #GP(0); FI;\n                CS := DEST(segment selector); (* DEST is ptr16:32 or [m16:32] *)\n                IF OperandSize = 32\n                        THEN\n                            EIP := tempEIP; (* DEST is ptr16:32 or [m16:32] *)\n                        ELSE (* OperandSize = 16 *)\n                            EIP := tempEIP AND 0000FFFFH; (* Clear upper 16 bits *)\n                FI;\nFI;\nIF far jump and (PE = 1 and VM = 0)\n(* IA-32e mode or protected mode, not virtual-8086 mode *)\n        THEN\n                IF effective address in the CS, DS, ES, FS, GS, or SS segment is illegal\n            or segment selector in target operand NULL\n                            THEN #GP(0); FI;\n                IF segment selector index not within descriptor table limits\n                    THEN #GP(new selector); FI;\n            Read type and access rights of segment descriptor;\n            IF (IA32_EFER.LMA = 0)\n                    THEN\n                            IF segment type is not a conforming or nonconforming code\n                            segment, call gate, task gate, or TSS\n                                    THEN #GP(segment selector); FI;\n                    ELSE\n                            IF segment type is not a conforming or nonconforming code segment\n                            call gate\n                                    THEN #GP(segment selector); FI;\n            FI;\n            Depending on type and access rights:\n                    GO TO CONFORMING-CODE-SEGMENT;\n                    GO TO NONCONFORMING-CODE-SEGMENT;\n                    GO TO CALL-GATE;\n                    GO TO TASK-GATE;\n                    GO TO TASK-STATE-SEGMENT;\n        ELSE\n                #GP(segment selector);\nFI;\nCONFORMING-CODE-SEGMENT:\n    IF L-Bit = 1 and D-BIT = 1 and IA32_EFER.LMA = 1\n            THEN GP(new code segment selector); FI;\n        IF DPL > CPL\n            THEN #GP(segment selector); FI;\n        IF segment not present\n            THEN #NP(segment selector); FI;\n    tempEIP := DEST(Offset);\n    IF OperandSize = 16\n                THEN tempEIP := tempEIP AND 0000FFFFH;\n    FI;\n    IF (IA32_EFER.LMA = 0 or target mode = Compatibility mode) and\n    tempEIP outside code segment limit\n            THEN #GP(0); FI\n    IF tempEIP is non-canonical\n            THEN #GP(0); FI;\n    IF ShadowStackEnabled(CPL)\n            IF (IA32_EFER.LMA and DEST(segment selector).L) = 0\n                    (* If target is legacy or compatibility mode then the SSP must be in low 4GB *)\n                    IF (SSP & 0xFFFFFFFF00000000 != 0)\n                            THEN #GP(0); FI;\n            FI;\n    FI;\n    CS := DEST[segment selector]; (* Segment descriptor information also loaded *)\n    CS(RPL) := CPL\n    EIP := tempEIP;\n    IF EndbranchEnabled(CPL)\n            IF CPL = 3\n                    THEN\n                            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                            IA32_U_CET.SUPPRESS = 0\n                    ELSE\n                            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                            IA32_S_CET.SUPPRESS = 0\n            FI;\n    FI;\nEND;\nNONCONFORMING-CODE-SEGMENT:\n    IF L-Bit = 1 and D-BIT = 1 and IA32_EFER.LMA = 1\n            THEN GP(new code segment selector); FI;\n    IF (RPL > CPL) OR (DPL ≠ CPL)\n            THEN #GP(code segment selector); FI;\n    IF segment not present\n            THEN #NP(segment selector); FI;\n    tempEIP := DEST(Offset);\n    IF OperandSize = 16\n                THEN tempEIP := tempEIP AND 0000FFFFH; FI;\n    IF (IA32_EFER.LMA = 0 OR target mode = Compatibility mode)\n    and tempEIP outside code segment limit\n            THEN #GP(0); FI\n    IF tempEIP is non-canonical THEN #GP(0); FI;\n    IF ShadowStackEnabled(CPL)\n            IF (IA32_EFER.LMA and DEST(segment selector).L) = 0\n                    (* If target is legacy or compatibility mode then the SSP must be in low 4GB *)\n                    IF (SSP & 0xFFFFFFFF00000000 != 0)\n                            THEN #GP(0); FI;\n            FI;\n    FI;\n    CS := DEST[segment selector]; (* Segment descriptor information also loaded *)\n    CS(RPL) := CPL;\n    EIP := tempEIP;\n    IF EndbranchEnabled(CPL)\n            IF CPL = 3\n                    THEN\n                            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                            IA32_U_CET.SUPPRESS = 0\n                    ELSE\n                            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH\n                            IA32_S_CET.SUPPRESS = 0\n            FI;\n    FI;\nEND;\nCALL-GATE:\n    IF call gate DPL < CPL\n    or call gate DPL < call gate segment-selector RPL\n                    THEN #GP(call gate selector); FI;\n    IF call gate not present\n            THEN #NP(call gate selector); FI;\n    IF call gate code-segment selector is NULL\n            THEN #GP(0); FI;\n    IF call gate code-segment selector index outside descriptor table limits\n            THEN #GP(code segment selector); FI;\n    Read code segment descriptor;\n    IF code-segment segment descriptor does not indicate a code segment\n    or code-segment segment descriptor is conforming and DPL > CPL\n    or code-segment segment descriptor is non-conforming and DPL ≠ CPL\n                    THEN #GP(code segment selector); FI;\n    IF IA32_EFER.LMA = 1 and (code-segment descriptor is not a 64-bit code segment\n    or code-segment segment descriptor has both L-Bit and D-bit set)\n                    THEN #GP(code segment selector); FI;\n    IF code segment is not present\n            THEN #NP(code-segment selector); FI;\n        tempEIP := DEST(Offset);\n        IF GateSize = 16\n                THEN tempEIP := tempEIP AND 0000FFFFH; FI;\n    IF (IA32_EFER.LMA = 0 OR target mode = Compatibility mode) AND tempEIP\n    outside code segment limit\n            THEN #GP(0); FI\n    CS := DEST[SegmentSelector]; (* Segment descriptor information also loaded *)\n    CS(RPL) := CPL;\n    EIP := tempEIP;\n    IF EndbranchEnabled(CPL)\n            IF CPL = 3\n                    THEN\n                            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;\n                            IA32_U_CET.SUPPRESS = 0\n                    ELSE\n                            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;\n                            IA32_S_CET.SUPPRESS = 0\n            FI;\n    FI;\nEND;\nTASK-GATE:\n    IF task gate DPL < CPL\n    or task gate DPL < task gate segment-selector RPL\n            THEN #GP(task gate selector); FI;\n    IF task gate not present\n            THEN #NP(gate selector); FI;\n    Read the TSS segment selector in the task-gate descriptor;\n    IF TSS segment selector local/global bit is set to local\n    or index not within GDT limits\n    or descriptor is not a TSS segment\n    or TSS descriptor specifies that the TSS is busy\n            THEN #GP(TSS selector); FI;\n        IF TSS not present\n            THEN #NP(TSS selector); FI;\n        SWITCH-TASKS to TSS;\n        IF EIP not within code segment limit\n            THEN #GP(0); FI;\nEND;\nTASK-STATE-SEGMENT:\n    IF TSS DPL < CPL\n    or TSS DPL < TSS segment-selector RPL\n    or TSS descriptor indicates TSS not available\n            THEN #GP(TSS selector); FI;\n    IF TSS is not present\n            THEN #NP(TSS selector); FI;\n    SWITCH-TASKS to TSS;\n    IF EIP not within code segment limit\n            THEN #GP(0); FI;\nEND;",
    "flagsAffectedText": "All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.",
    "exceptions": {
      "64BitMode": [
        "column_1: If target offset in destination operand is non-canonical.; \ncolumn_1: If target offset in destination operand is beyond the new code segment limit.; \ncolumn_1: If the segment selector in the destination operand is NULL.; \ncolumn_1: If the code segment selector in the 64-bit gate is NULL.; \ncolumn_1: If transitioning to compatibility mode and the SSP is beyond 4GB.; \ncolumn_2: If the code segment or 64-bit call gate is outside descriptor table limits.; column_1: #GP(selector); \ncolumn_1: If the code segment or 64-bit call gate overlaps non-canonical space.; \ncolumn_1: If the segment descriptor from a 64-bit call gate is in non-canonical space.; \ncolumn_1: If the segment descriptor pointed to by the segment selector in the destination operand is not for a conforming-code segment, nonconforming-code segment, 64-bit call gate.; \ncolumn_1: If the segment descriptor pointed to by the segment selector in the destination operand is a code segment, and has both the D-bit and the L-bit set.; \ncolumn_1: If the DPL for a nonconforming-code segment is not equal to the CPL, or the RPL for the segment’s segment selector is greater than the CPL.; \ncolumn_1: If the DPL for a conforming-code segment is greater than the CPL.; \ncolumn_1: If the DPL from a 64-bit call-gate is less than the CPL or than the RPL of the 64-bit call-gate.; \ncolumn_1: If the upper type field of a 64-bit call gate is not 0x0.; \ncolumn_1: If the segment selector from a 64-bit call gate is beyond the descriptor table limits.; \ncolumn_1: If the code segment descriptor pointed to by the selector in the 64-bit gate doesn't have the L-bit set and the D-bit clear.; \ncolumn_1: If the segment descriptor for a segment selector from the 64-bit call gate does not indicate it is a code segment.; \ncolumn_1: If the code segment is non-conforming and CPL ≠ DPL.; \ncolumn_1: If the code segment is confirming and CPL < DPL.; \ncolumn_1: #NP(selector); column_2: If a code segment or 64-bit call gate is not present.; \ncolumn_1: #UD; column_2: (64-bit mode only) If a far jump is direct to an absolute address in memory.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "compatibilityMode": [
        "Same as 64-bit mode exceptions."
      ],
      "protectedMode": [
        "column_1: If the segment selector in the destination operand, call gate, task gate, or TSS is NULL.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If target mode is compatibility mode and SSP is not in low 4GB.; \ncolumn_1: #GP(selector); column_2: If the segment selector index is outside descriptor table limits.; \ncolumn_1: If the segment descriptor pointed to by the segment selector in the destination operand is not for a conforming-code segment, nonconforming-code segment, call gate, task gate, or task state segment.; \ncolumn_1: If the DPL for a nonconforming-code segment is not equal to the CPL; \ncolumn_1: (When not using a call gate.) If the RPL for the segment’s segment selector is greater than the CPL.; \ncolumn_1: If the DPL for a conforming-code segment is greater than the CPL.; \ncolumn_1: If the DPL from a call-gate, task-gate, or TSS segment descriptor is less than the CPL or than the RPL of the call-gate, task-gate, or TSS’s segment selector.; \ncolumn_1: If the segment descriptor for selector in a call gate does not indicate it is a code segment.; \ncolumn_1: If the segment descriptor for the segment selector in a task gate does not indicate an available TSS.; \ncolumn_1: If the segment selector for a TSS has its local/global bit set for local.; \ncolumn_1: If a TSS segment descriptor specifies that the TSS is busy or not available.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NP; column_2: (selector) If the code segment being accessed is not present.; \ncolumn_1: If call gate, task gate, or TSS not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3. (Only occurs when fetching target from memory.); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made. (Only occurs when fetching target from memory.); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmulld:pmullq",
    "category": "Core Instructions",
    "instructionName": "PMULLD/PMULLQ\n\t\t— Multiply Packed Integers and Store Low Result",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 40 /r PMULLD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 40 /r VPMULLD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 40 /r VPMULLD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply the packed dword signed integers in xmm2 and xmm3/m128/m32bcst and store the low 32 bits of each product in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 40 /r VPMULLD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply the packed dword signed integers in ymm2 and ymm3/m256/m32bcst and store the low 32 bits of each product in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 40 /r VPMULLD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply the packed dword signed integers in zmm2 and zmm3/m512/m32bcst and store the low 32 bits of each product in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 40 /r VPMULLD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Multiply the packed qword signed integers in xmm2 and xmm3/m128/m64bcst and store the low 64 bits of each product in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 40 /r VPMULLQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VLA VX512DQ",
        "Description": "Multiply the packed qword signed integers in ymm2 and ymm3/m256/m64bcst and store the low 64 bits of each product in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 40 /r VPMULLQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Multiply the packed qword signed integers in zmm2 and zmm3/m512/m64bcst and store the low 64 bits of each product in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 40 /r VPMULLQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD signed multiply of the packed signed dword/qword integers from each element of the first source operand with the corresponding element in the second source operand. The low 32/64 bits of each 64/128-bit intermediate results are stored to the destination operand.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN Temp[127:0] := SRC1[i+63:i] * SRC2[63:0]\n                ELSE Temp[127:0] := SRC1[i+63:i] * SRC2[i+63:i]\n            FI;\n            DEST[i+63:i] := Temp[63:0]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN Temp[63:0] := SRC1[i+31:i] * SRC2[31:0]\n                ELSE Temp[63:0] := SRC1[i+31:i] * SRC2[i+31:i]\n            FI;\n            DEST[i+31:i] := Temp[31:0]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                *DEST[i+31:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nTemp0[63:0] := SRC1[31:0] * SRC2[31:0]\nTemp1[63:0] := SRC1[63:32] * SRC2[63:32]\nTemp2[63:0] := SRC1[95:64] * SRC2[95:64]\nTemp3[63:0] := SRC1[127:96] * SRC2[127:96]\nTemp4[63:0] := SRC1[159:128] * SRC2[159:128]\nTemp5[63:0] := SRC1[191:160] * SRC2[191:160]\nTemp6[63:0] := SRC1[223:192] * SRC2[223:192]\nTemp7[63:0] := SRC1[255:224] * SRC2[255:224]\nDEST[31:0] := Temp0[31:0]\nDEST[63:32] := Temp1[31:0]\nDEST[95:64] := Temp2[31:0]\nDEST[127:96] := Temp3[31:0]\nDEST[159:128] := Temp4[31:0]\nDEST[191:160] := Temp5[31:0]\nDEST[223:192] := Temp6[31:0]\nDEST[255:224] := Temp7[31:0]\nDEST[MAXVL-1:256] := 0\nTemp0[63:0] := SRC1[31:0] * SRC2[31:0]\nTemp1[63:0] := SRC1[63:32] * SRC2[63:32]\nTemp2[63:0] := SRC1[95:64] * SRC2[95:64]\nTemp3[63:0] := SRC1[127:96] * SRC2[127:96]\nDEST[31:0] := Temp0[31:0]\nDEST[63:32] := Temp1[31:0]\nDEST[95:64] := Temp2[31:0]\nDEST[127:96] := Temp3[31:0]\nDEST[MAXVL-1:128] := 0\nTemp0[63:0] := DEST[31:0] * SRC[31:0]\nTemp1[63:0] := DEST[63:32] * SRC[63:32]\nTemp2[63:0] := DEST[95:64] * SRC[95:64]\nTemp3[63:0] := DEST[127:96] * SRC[127:96]\nDEST[31:0] := Temp0[31:0]\nDEST[63:32] := Temp1[31:0]\nDEST[95:64] := Temp2[31:0]\nDEST[127:96] := Temp3[31:0]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcp14ss",
    "category": "Core Instructions",
    "instructionName": "VRCP14SS\n\t\t— Compute Approximate Reciprocal of Scalar Float32 Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the results in xmm1 using writemask k1. Also, upper double precision floating-point value (bits[127:32]) from xmm2 is copied to xmm1[127:32].",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 4D /r VRCP14SS xmm1 {k1}{z}, xmm2, xmm3/m32"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgetexpps",
    "category": "Core Instructions",
    "instructionName": "VGETEXPPS\n\t\t— Convert Exponents of Packed Single Precision Floating-Point Values to SinglePrecision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert the exponent of packed single-precision floating-point values in the source operand to single-precision floating-point results representing unbiased integer exponents and stores the results in the destination register.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 42 /r VGETEXPPS xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert the exponent of packed single-precision floating-point values in the source operand to single-precision floating-point results representing unbiased integer exponents and stores the results in the destination register.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 42 /r VGETEXPPS ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert the exponent of packed single-precision floating-point values in the source operand to single-precision floating-point results representing unbiased integer exponents and stores the results in the destination register.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 42 /r VGETEXPPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/roundps",
    "category": "Core Instructions",
    "instructionName": "ROUNDPS\n\t\t— Round Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.",
        "Op/En": "RMI",
        "Opcode*/Instruction": "66 0F 3A 08 /r ib ROUNDPS xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.",
        "Op/En": "RMI",
        "Opcode*/Instruction": "VEX.128.66.0F3A.WIG 08 /r ib VROUNDPS xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Round packed single precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8.",
        "Op/En": "RMI",
        "Opcode*/Instruction": "VEX.256.66.0F3A.WIG 08 /r ib VROUNDPS ymm1, ymm2/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Round the 4 single precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single precision floating-point value.\nThe immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-18 lists the encoded values for rounding-mode field).\nThe Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "IF (imm[2] = ‘1)\n    THEN // rounding mode is determined by MXCSR.RC\n        DEST[31:0] := ConvertSPFPToInteger_M(SRC[31:0]);\n        DEST[63:32] := ConvertSPFPToInteger_M(SRC[63:32]);\n        DEST[95:64] := ConvertSPFPToInteger_M(SRC[95:64]);\n        DEST[127:96] := ConvertSPFPToInteger_M(SRC[127:96]);\n    ELSE // rounding mode is determined by IMM8.RC\n        DEST[31:0] := ConvertSPFPToInteger_Imm(SRC[31:0]);\n        DEST[63:32] := ConvertSPFPToInteger_Imm(SRC[63:32]);\n        DEST[95:64] := ConvertSPFPToInteger_Imm(SRC[95:64]);\n        DEST[127:96] := ConvertSPFPToInteger_Imm(SRC[127:96]);\nFI;\nDEST[31:0] := RoundToInteger(SRC[31:0], ROUND_CONTROL)\nDEST[63:32] := RoundToInteger(SRC[63:32], ROUND_CONTROL)\nDEST[95:64] := RoundToInteger(SRC[95:64]], ROUND_CONTROL)\nDEST[127:96] := RoundToInteger(SRC[127:96]], ROUND_CONTROL)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := RoundToInteger(SRC[31:0], ROUND_CONTROL)\nDEST[63:32] := RoundToInteger(SRC[63:32], ROUND_CONTROL)\nDEST[95:64] := RoundToInteger(SRC[95:64]], ROUND_CONTROL)\nDEST[127:96] := RoundToInteger(SRC[127:96]], ROUND_CONTROL)\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := RoundToInteger(SRC[31:0], ROUND_CONTROL)\nDEST[63:32] := RoundToInteger(SRC[63:32], ROUND_CONTROL)\nDEST[95:64] := RoundToInteger(SRC[95:64]], ROUND_CONTROL)\nDEST[127:96] := RoundToInteger(SRC[127:96]], ROUND_CONTROL)\nDEST[159:128] := RoundToInteger(SRC[159:128]], ROUND_CONTROL)\nDEST[191:160] := RoundToInteger(SRC[191:160]], ROUND_CONTROL)\nDEST[223:192] := RoundToInteger(SRC[223:192] ], ROUND_CONTROL)\nDEST[255:224] := RoundToInteger(SRC[255:224] ], ROUND_CONTROL)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid (signaled only if SRC = SNaN).",
        "Precision (signaled only if imm[3] = ‘0; if imm[3] = ‘1, then the Precision Mask in the MXSCSR is ignored and precision exception is not signaled.)",
        "Note that Denormal is not signaled by ROUNDPS."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrndscaless",
    "category": "Core Instructions",
    "instructionName": "VRNDSCALESS\n\t\t— Round Scalar Float32 Value to Include a Given Number of Fraction Bits",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rounds scalar single-precision floating-point value in xmm3/m32 to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W0 0A /r ib VRNDSCALESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpternlogd:vpternlogq",
    "category": "Core Instructions",
    "instructionName": "VPTERNLOGD/VPTERNLOGQ\n\t\t— Bitwise Ternary Logic",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise ternary logic taking xmm1, xmm2, and xmm3/m128/m32bcst as source operands and writing the result to xmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 25 /r ib VPTERNLOGD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise ternary logic taking ymm1, ymm2, and ymm3/m256/m32bcst as source operands and writing the result to ymm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 25 /r ib VPTERNLOGD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise ternary logic taking zmm1, zmm2, and zmm3/m512/m32bcst as source operands and writing the result to zmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 25 /r ib VPTERNLOGD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise ternary logic taking xmm1, xmm2, and xmm3/m128/m64bcst as source operands and writing the result to xmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 25 /r ib VPTERNLOGQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise ternary logic taking ymm1, ymm2, and ymm3/m256/m64bcst as source operands and writing the result to ymm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 25 /r ib VPTERNLOGQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise ternary logic taking zmm1, zmm2, and zmm3/m512/m64bcst as source operands and writing the result to zmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 25 /r ib VPTERNLOGQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmpxchg",
    "category": "Core Instructions",
    "instructionName": "CMPXCHG\n\t\t— Compare and Exchange",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid*",
        "Description": "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F B0/r CMPXCHG r/m8, r8"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.",
        "Op/En": "MR",
        "Opcode/Instruction": "REX + 0F B0/r CMPXCHG r/m8**,r8"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid*",
        "Description": "Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F B1/r CMPXCHG r/m16, r16"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid*",
        "Description": "Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F B1/r CMPXCHG r/m32, r32"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.",
        "Op/En": "MR",
        "Opcode/Instruction": "REX.W + 0F B1/r CMPXCHG r/m64, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "(* Accumulator = AL, AX, EAX, or RAX depending on whether a byte, word, doubleword, or quadword comparison is being performed *)\nTEMP := DEST\nIF accumulator = TEMP\n    THEN\n        ZF := 1;\n        DEST := SRC;\n    ELSE\n        ZF := 0;\n        accumulator := TEMP;\n        DEST := TEMP;\nFI;",
    "flagsAffectedText": "The ZF flag is set if the values in the destination operand and register AL, AX, or EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are set according to the results of the comparison operation.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/divps",
    "category": "Core Instructions",
    "instructionName": "DIVPS\n\t\t— Divide Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Divide packed single precision floating-point values in xmm1 by packed single precision floating-point values in xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 5E /r DIVPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Divide packed single precision floating-point values in xmm2 by packed single precision floating-point values in xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 5E /r VDIVPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Divide packed single precision floating-point values in ymm2 by packed single precision floating-point values in ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 5E /r VDIVPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Divide packed single precision floating-point values in xmm2 by packed single precision floating-point values in xmm3/m128/m32bcst and write results to xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 5E /r VDIVPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Divide packed single precision floating-point values in ymm2 by packed single precision floating-point values in ymm3/m256/m32bcst and write results to ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 5E /r VDIVPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Divide packed single precision floating-point values in zmm2 by packed single precision floating-point values in zmm3/m512/m32bcst and write results to zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 5E /r VDIVPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD divide of the four, eight or sixteen packed single precision floating-point values in the first source operand (the second operand) by the four, eight or sixteen packed single precision floating-point values in the second source operand (the third operand). Results are written to the destination operand (the first operand).\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nVEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF (VL = 512) AND (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+31:i] := SRC1[i+31:i] / SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] := SRC1[i+31:i] / SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC1[31:0] / SRC2[31:0]\nDEST[63:32] := SRC1[63:32] / SRC2[63:32]\nDEST[95:64] := SRC1[95:64] / SRC2[95:64]\nDEST[127:96] := SRC1[127:96] / SRC2[127:96]\nDEST[159:128] := SRC1[159:128] / SRC2[159:128]\nDEST[191:160] := SRC1[191:160] / SRC2[191:160]\nDEST[223:192] := SRC1[223:192] / SRC2[223:192]\nDEST[255:224] := SRC1[255:224] / SRC2[255:224].\nDEST[MAXVL-1:256] := 0;\nDEST[31:0] := SRC1[31:0] / SRC2[31:0]\nDEST[63:32] := SRC1[63:32] / SRC2[63:32]\nDEST[95:64] := SRC1[95:64] / SRC2[95:64]\nDEST[127:96] := SRC1[127:96] / SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] / SRC2[31:0]\nDEST[63:32] := SRC1[63:32] / SRC2[63:32]\nDEST[95:64] := SRC1[95:64] / SRC2[95:64]\nDEST[127:96] := SRC1[127:96] / SRC2[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vptestmb:vptestmw:vptestmd:vptestmq",
    "category": "Core Instructions",
    "instructionName": "VPTESTMB/VPTESTMW/VPTESTMD/VPTESTMQ\n\t\t— Logical AND and Set Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Bitwise AND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 26 /r VPTESTMB k2 {k1}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Bitwise AND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 26 /r VPTESTMB k2 {k1}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise AND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 26 /r VPTESTMB k2 {k1}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Bitwise AND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 26 /r VPTESTMW k2 {k1}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Bitwise AND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 26 /r VPTESTMW k2 {k1}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise AND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 26 /r VPTESTMW k2 {k1}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 27 /r VPTESTMD k2 {k1}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 27 /r VPTESTMD k2 {k1}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 27 /r VPTESTMD k2 {k1}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 27 /r VPTESTMQ k2 {k1}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 27 /r VPTESTMQ k2 {k1}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 27 /r VPTESTMQ k2 {k1}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesdeclast",
    "category": "Core Instructions",
    "instructionName": "AESDECLAST\n\t\t— Perform Last Round of an AES Decryption Flow",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES",
        "Description": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 DF /r AESDECLAST xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES AVX",
        "Description": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG DF /r VAESDECLAST xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES",
        "Description": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG DF /r VAESDECLAST ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512VL",
        "Description": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG DF /r VAESDECLAST xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512VL",
        "Description": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG DF /r VAESDECLAST ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512F",
        "Description": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using four128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG DF /r VAESDECLAST zmm1, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      }
    ],
    "descriptionText": "This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\nThe EVEX encoded form of this instruction does not support memory fault suppression.",
    "operationText": "STATE := SRC1;\nRoundKey := SRC2;\nSTATE := InvShiftRows( STATE );\nSTATE := InvSubBytes( STATE );\nDEST[127:0] := STATE XOR RoundKey;\nDEST[MAXVL-1:128] (Unmodified)\n(KL,VL) = (1,128), (2,256)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := InvShiftRows( STATE )\n    STATE := InvSubBytes( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n(KL,VL) = (1,128), (2,256), (4,512)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := InvShiftRows( STATE )\n    STATE := InvSubBytes( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded: See Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/hreset",
    "category": "Core Instructions",
    "instructionName": "HRESET\n\t\t— History Reset",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "HRESET",
        "Description": "Processor history reset request. Controlled by the EAX implicit operand.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 3A F0 C0 /ib HRESET imm8, <EAX>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_2: If CPUID.07H.01H:EAX.HRESET[bit 22] = 0.; column_1: #UD;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/bextr",
    "category": "Core Instructions",
    "instructionName": "BEXTR\n\t\t— Bit Field Extract",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI1",
        "Description": "Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.0F38.W0 F7 /r BEXTR r32a, r/m32, r32b"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI1",
        "Description": "Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.0F38.W1 F7 /r BEXTR r64a, r/m64, r64b"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMV",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "VEX.vvvv (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Extracts contiguous bits from the first source operand (the second operand) using an index value and length value specified in the second source operand (the third operand). Bit 7:0 of the second source operand specifies the starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the second source operand. Bit 15:8 of the second source operand specifies the maximum number of bits (LENGTH) beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are extracted. The extracted bits are written to the destination register, starting from the least significant bit. All higher order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is cleared if no bits are extracted.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "START := SRC2[7:0];\nLEN := SRC2[15:8];\nTEMP := ZERO_EXTEND_TO_512 (SRC1 );\nDEST := ZERO_EXTEND(TEMP[START+LEN -1: START]);\nZF := (DEST = 0);",
    "flagsAffectedText": "ZF is updated based on the result. AF, SF, and PF are undefined. All other flags are cleared.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/subps",
    "category": "Core Instructions",
    "instructionName": "SUBPS\n\t\t— Subtract Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Subtract packed single precision floating-point values in xmm2/mem from xmm1 and store result in xmm1.",
        "Op/E n": "A",
        "Opcode/Instruction": "NP 0F 5C /r SUBPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed single precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1.",
        "Op/E n": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 5C /r VSUBPS xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed single precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1.",
        "Op/E n": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 5C /r VSUBPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Subtract packed single precision floating-point values from xmm3/m128/m32bcst to xmm2 and stores result in xmm1 with writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 5C /r VSUBPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Subtract packed single precision floating-point values from ymm3/m256/m32bcst to ymm2 and stores result in ymm1 with writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 5C /r VSUBPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Subtract packed single precision floating-point values in zmm3/m512/m32bcst from zmm2 and stores result in zmm1 with writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 5C /r VSUBPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD subtract of the packed single precision floating-point values in the second Source operand from the First Source operand, and stores the packed single precision floating-point results in the destination operand.\nVEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\nEVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The first source operand and destination operands are ZMM registers. The destination operand is conditionally updated according to the writemask.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC1[i+31:i] - SRC2[i+31:i]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                DEST[31:0] := 0\n        FI;\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256),(16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1)\n                THEN DEST[i+31:i] := SRC1[i+31:i] - SRC2[31:0];\n                ELSE DEST[i+31:i] := SRC1[i+31:i] - SRC2[i+31:i];\n            FI;\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                DEST[31:0] := 0\n        FI;\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC1[31:0] - SRC2[31:0]\nDEST[63:32] := SRC1[63:32] - SRC2[63:32]\nDEST[95:64] := SRC1[95:64] - SRC2[95:64]\nDEST[127:96] := SRC1[127:96] - SRC2[127:96]\nDEST[159:128] := SRC1[159:128] - SRC2[159:128]\nDEST[191:160] := SRC1[191:160] - SRC2[191:160]\nDEST[223:192] := SRC1[223:192] - SRC2[223:192]\nDEST[255:224] := SRC1[255:224] - SRC2[255:224].\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := SRC1[31:0] - SRC2[31:0]\nDEST[63:32] := SRC1[63:32] - SRC2[63:32]\nDEST[95:64] := SRC1[95:64] - SRC2[95:64]\nDEST[127:96] := SRC1[127:96] - SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] - SRC2[31:0]\nDEST[63:32] := SRC1[63:32] - SRC2[63:32]\nDEST[95:64] := SRC1[95:64] - SRC2[95:64]\nDEST[127:96] := SRC1[127:96] - SRC2[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrangeps",
    "category": "Core Instructions",
    "instructionName": "VRANGEPS\n\t\t— Range Restriction Calculation for Packed Pairs of Float32 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Calculate four RANGE operation output value from 4 pairs of single-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 50 /r ib VRANGEPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Calculate eight RANGE operation output value from 8 pairs of single-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 50 /r ib VRANGEPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Calculate 16 RANGE operation output value from 16 pairs of single-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 50 /r ib VRANGEPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpsllvw:vpsllvd:vpsllvq",
    "category": "Core Instructions",
    "instructionName": "VPSLLVW/VPSLLVD/VPSLLVQ\n\t\t— Variable Bit Shift Left Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 47 /r VPSLLVD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 47 /r VPSLLVQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 47 /r VPSLLVD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 47 /r VPSLLVQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 12 /r VPSLLVW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 12 /r VPSLLVW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2 left by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 12 /r VPSLLVW zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 47 /r VPSLLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 47 /r VPSLLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 47 /r VPSLLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 47 /r VPSLLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 47 /r VPSLLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 47 /r VPSLLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermt2w:vpermt2d:vpermt2q:vpermt2ps:vpermt2pd",
    "category": "Core Instructions",
    "instructionName": "VPERMT2W/VPERMT2D/VPERMT2Q/VPERMT2PS/VPERMT2PD\n\t\t— Full Permute From Two Tables Overwriting One Table",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Permute word integers from two tables in xmm3/m128 and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 7D /r VPERMT2W xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Permute word integers from two tables in ymm3/m256 and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 7D /r VPERMT2W ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Permute word integers from two tables in zmm3/m512 and zmm1 using indexes in zmm2 and store the result in zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 7D /r VPERMT2W zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double-words from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 7E /r VPERMT2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double-words from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 7E /r VPERMT2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute double-words from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 7E /r VPERMT2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute quad-words from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 7E /r VPERMT2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute quad-words from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 7E /r VPERMT2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute quad-words from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 7E /r VPERMT2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point values from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 7F /r VPERMT2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute single-precision floating-point values from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 7F /r VPERMT2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute single-precision floating-point values from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 7F /r VPERMT2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point values from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 7F /r VPERMT2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Permute double precision floating-point values from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 7F /r VPERMT2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Permute double precision floating-point values from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 7F /r VPERMT2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r,w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cld",
    "category": "Core Instructions",
    "instructionName": "CLD\n\t\t— Clear Direction Flag",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Clear DF flag.",
        "Instruction": "CLD",
        "Op/En": "ZO",
        "Opcode": "FC"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI). Operation is the same in all modes.",
    "operationText": "DF := 0;",
    "flagsAffectedText": "The DF flag is set to 0. The CF, OF, ZF, SF, AF, and PF flags are unaffected.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfcmaddcph:vfmaddcph",
    "category": "Core Instructions",
    "instructionName": "VFCMADDCPH/VFMADDCPH\n\t\t— Complex Multiply and Accumulate FP16 Values",
    "detailsTable": [
      {
        "Description": "Complex multiply a pair of FP16 values from xmm2 and complex conjugate of xmm3/m128/m32bcst, add to xmm1 and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F2.MAP6.W0 56 /r VFCMADDCPH xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from ymm2 and complex conjugate of ymm3/m256/m32bcst, add to ymm1 and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F2.MAP6.W0 56 /r VFCMADDCPH ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from zmm2 and complex conjugate of zmm3/m512/m32bcst, add to zmm1 and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F2.MAP6.W0 56 /r VFCMADDCPH zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from xmm2 and xmm3/m128/m32bcst, add to xmm1 and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F3.MAP6.W0 56 /r VFMADDCPH xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from ymm2 and ymm3/m256/m32bcst, add to ymm1 and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F3.MAP6.W0 56 /r VFMADDCPH ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from zmm2 and zmm3/m512/m32bcst, add to zmm1 and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F3.MAP6.W0 56 /r VFMADDCPH zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/phsubw:phsubd",
    "category": "Core Instructions",
    "instructionName": "PHSUBW/PHSUBD\n\t\t— Packed Horizontal Subtract",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Subtract 16-bit signed integers horizontally, pack to mm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 05 /r1 PHSUBW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Subtract 16-bit signed integers horizontally, pack to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 05 /r PHSUBW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Subtract 32-bit signed integers horizontally, pack to mm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 06 /r PHSUBD mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Subtract 32-bit signed integers horizontally, pack to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 06 /r PHSUBD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract 16-bit signed integers horizontally, pack to xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 05 /r VPHSUBW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract 32-bit signed integers horizontally, pack to xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 06 /r VPHSUBD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract 16-bit signed integers horizontally, pack to ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 05 /r VPHSUBW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract 32-bit signed integers horizontally, pack to ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 06 /r VPHSUBD ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nIn 64-bit mode, use the REX prefix to access additional registers.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
    "operationText": "mm1[15-0] = mm1[15-0] - mm1[31-16];\nmm1[31-16] = mm1[47-32] - mm1[63-48];\nmm1[47-32] = mm2/m64[15-0] - mm2/m64[31-16];\nmm1[63-48] = mm2/m64[47-32] - mm2/m64[63-48];\nxmm1[15-0] = xmm1[15-0] - xmm1[31-16];\nxmm1[31-16] = xmm1[47-32] - xmm1[63-48];\nxmm1[47-32] = xmm1[79-64] - xmm1[95-80];\nxmm1[63-48] = xmm1[111-96] - xmm1[127-112];\nxmm1[79-64] = xmm2/m128[15-0] - xmm2/m128[31-16];\nxmm1[95-80] = xmm2/m128[47-32] - xmm2/m128[63-48];\nxmm1[111-96] = xmm2/m128[79-64] - xmm2/m128[95-80];\nxmm1[127-112] = xmm2/m128[111-96] - xmm2/m128[127-112];\nDEST[15:0] := SRC1[15:0] - SRC1[31:16]\nDEST[31:16] := SRC1[47:32] - SRC1[63:48]\nDEST[47:32] := SRC1[79:64] - SRC1[95:80]\nDEST[63:48] := SRC1[111:96] - SRC1[127:112]\nDEST[79:64] := SRC2[15:0] - SRC2[31:16]\nDEST[95:80] := SRC2[47:32] - SRC2[63:48]\nDEST[111:96] := SRC2[79:64] - SRC2[95:80]\nDEST[127:112] := SRC2[111:96] - SRC2[127:112]\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := SRC1[15:0] - SRC1[31:16]\nDEST[31:16] := SRC1[47:32] - SRC1[63:48]\nDEST[47:32] := SRC1[79:64] - SRC1[95:80]\nDEST[63:48] := SRC1[111:96] - SRC1[127:112]\nDEST[79:64] := SRC2[15:0] - SRC2[31:16]\nDEST[95:80] := SRC2[47:32] - SRC2[63:48]\nDEST[111:96] := SRC2[79:64] - SRC2[95:80]\nDEST[127:112] := SRC2[111:96] - SRC2[127:112]\nDEST[143:128] := SRC1[143:128] - SRC1[159:144]\nDEST[159:144] := SRC1[175:160] - SRC1[191:176]\nDEST[175:160] := SRC1[207:192] - SRC1[223:208]\nDEST[191:176] := SRC1[239:224] - SRC1[255:240]\nDEST[207:192] := SRC2[143:128] - SRC2[159:144]\nDEST[223:208] := SRC2[175:160] - SRC2[191:176]\nDEST[239:224] := SRC2[207:192] - SRC2[223:208]\nDEST[255:240] := SRC2[239:224] - SRC2[255:240]\nmm1[31-0] = mm1[31-0] - mm1[63-32];\nmm1[63-32] = mm2/m64[31-0] - mm2/m64[63-32];\nxmm1[31-0] = xmm1[31-0] - xmm1[63-32];\nxmm1[63-32] = xmm1[95-64] - xmm1[127-96];\nxmm1[95-64] = xmm2/m128[31-0] - xmm2/m128[63-32];\nxmm1[127-96] = xmm2/m128[95-64] - xmm2/m128[127-96];\nDEST[31-0] := SRC1[31-0] - SRC1[63-32]\nDEST[63-32] := SRC1[95-64] - SRC1[127-96]\nDEST[95-64] := SRC2[31-0] - SRC2[63-32]\nDEST[127-96] := SRC2[95-64] - SRC2[127-96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] - SRC1[63:32]\nDEST[63:32] := SRC1[95:64] - SRC1[127:96]\nDEST[95:64] := SRC2[31:0] - SRC2[63:32]\nDEST[127:96] := SRC2[95:64] - SRC2[127:96]\nDEST[159:128] := SRC1[159:128] - SRC1[191:160]\nDEST[191:160] := SRC1[223:192] - SRC1[255:224]\nDEST[223:192] := SRC2[159:128] - SRC2[191:160]\nDEST[255:224] := SRC2[223:192] - SRC2[255:224]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesdec128kl",
    "category": "Core Instructions",
    "instructionName": "AESDEC128KL\n\t\t— Perform Ten Rounds of AES Decryption Flow With Key Locker Using 128-BitKey",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLE",
        "Description": "Decrypt xmm using 128-bit AES key indicated by handle at m384 and store result in xmm.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 DD !(11):rrr:bbb AESDEC128KL xmm, m384"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The AESDEC128KL1 instruction performs 10 rounds of AES to decrypt the first operand using the 128-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).",
    "operationText": "Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL > 0)) ||\n                Handle [2] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128);\nIF (Illegal Handle) {\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    DEST := AES128Decrypt (DEST, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vperm2i128",
    "category": "Core Instructions",
    "instructionName": "VPERM2I128\n\t\t— Permute Integer Values",
    "detailsTable": [
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 46 /r ib VPERM2I128 ymm1, ymm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Permute 128 bit integer data from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.\nImm8[1:0] select the source for the first destination 128-bit field, imm8[5:4] select the source for the second destination field. If imm8[3] is set, the low 128-bit field is zeroed. If imm8[7] is set, the high 128-bit field is zeroed.\nVEX.L must be 1, otherwise the instruction will #UD.",
    "operationText": "CASE IMM8[1:0] of\n0: DEST[127:0] := SRC1[127:0]\n1: DEST[127:0] := SRC1[255:128]\n2: DEST[127:0] := SRC2[127:0]\n3: DEST[127:0] := SRC2[255:128]\nESAC\nCASE IMM8[5:4] of\n0: DEST[255:128] := SRC1[127:0]\n1: DEST[255:128] := SRC1[255:128]\n2: DEST[255:128] := SRC2[127:0]\n3: DEST[255:128] := SRC2[255:128]\nESAC\nIF (imm8[3])\nDEST[127:0] := 0\nFI\nIF (imm8[7])\nDEST[255:128] := 0\nFI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-23, “Type 6 Class Exception Conditions.”",
        "Additionally:",
        "column_1: If VEX.W = 1.;"
      ],
      "simdFloating-Point¶": [
        "None"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttph2uw",
    "category": "Core Instructions",
    "instructionName": "VCVTTPH2UW\n\t\t— Convert Packed FP16 Values to Unsigned Word Integers",
    "detailsTable": [
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight unsigned word integers, and store the result in xmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.MAP5.W0 7C /r VCVTTPH2UW xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen unsigned word integers, and store the result in ymm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.MAP5.W0 7C /r VCVTTPH2UW ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert thirty-two packed FP16 values in zmm2/m512/m16bcst to thirty-two unsigned word integers, and store the result in zmm1 using truncation subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.MAP5.W0 7C /r VCVTTPH2UW zmm1{k1}{z}, zmm2/m512/m16bcst {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpdpwssds",
    "category": "Core Instructions",
    "instructionName": "VPDPWSSDS\n\t\t— Multiply and Add Signed Word Integers With Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX-VNNI",
        "Description": "Multiply groups of 2 pairs of signed words in xmm3/m128 with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1, with signed saturation.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 53 /r VPDPWSSDS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX-VNNI",
        "Description": "Multiply groups of 2 pairs of signed words in ymm3/m256 with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1, with signed saturation.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 53 /r VPDPWSSDS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI AVX512VL",
        "Description": "Multiply groups of 2 pairs of signed words in xmm3/m128/m32bcst with corresponding signed words of xmm2, summing those products and adding them to doubleword result in xmm1, with signed saturation, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 53 /r VPDPWSSDS xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI AVX512VL",
        "Description": "Multiply groups of 2 pairs of signed words in ymm3/m256/m32bcst with corresponding signed words of ymm2, summing those products and adding them to doubleword result in ymm1, with signed saturation, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 53 /r VPDPWSSDS ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VNNI",
        "Description": "Multiply groups of 2 pairs of signed words in zmm3/m512/m32bcst with corresponding signed words of zmm2, summing those products and adding them to doubleword result in zmm1, with signed saturation, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 53 /r VPDPWSSDS zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/tilerelease",
    "category": "Core Instructions",
    "instructionName": "TILERELEASE\n\t\t— Release Tile",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "AMX-TILE",
        "Description": "Initialize TILECFG and TILEDATA.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.NP.0F38.W0 49 C0 TILERELEASE"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "This instruction returns TILECFG and TILEDATA to the INIT state.\nAny attempt to execute the TILERELEASE instruction inside an Intel TSX transaction will result in a transaction abort.",
    "operationText": "zero_all_tile_data()\ntilecfg := 0// equivalent to 64B of zeros\nTILES_CONFIGURED := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "exceptions¶": [
        "AMX-E6; see Section 2.10, “Intel® AMX Instruction Exception Classes,” for details."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pminub:pminuw",
    "category": "Core Instructions",
    "instructionName": "PMINUB/PMINUW\n\t\t— Minimum of Packed Unsigned Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F DA /r1 PMINUB mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F DA /r PMINUB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed unsigned word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 38 3A/r PMINUW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F DA /r VPMINUB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38 3A/r VPMINUW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F DA /r VPMINUB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38 3A/r VPMINUW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F DA /r VPMINUB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F DA /r VPMINUB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed unsigned byte integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F DA /r VPMINUB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38 3A/r VPMINUW xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38 3A/r VPMINUW ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed unsigned word integers in zmm3/m512 and zmm2 and return packed minimum values in zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38 3A/r VPMINUW zmm1{k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\nLegacy SSE version PMINUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "IF DEST[7:0] < SRC[17:0] THEN\n    DEST[7:0] := DEST[7:0];\nELSE\n    DEST[7:0] := SRC[7:0]; FI;\n(* Repeat operation for 2nd through 7th bytes in source and destination operands *)\nIF DEST[63:56] < SRC[63:56] THEN\n    DEST[63:56] := DEST[63:56];\nELSE\n    DEST[63:56] := SRC[63:56]; FI;\nIF DEST[7:0] < SRC[7:0] THEN\n        DEST[7:0] := DEST[7:0];\n    ELSE\n        DEST[15:0] := SRC[7:0]; FI;\n    (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n    IF DEST[127:120] < SRC[127:120] THEN\n        DEST[127:120] := DEST[127:120];\n    ELSE\n        DEST[127:120] := SRC[127:120]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[7:0] < SRC2[7:0] THEN\n        DEST[7:0] := SRC1[7:0];\n    ELSE\n        DEST[7:0] := SRC2[7:0]; FI;\n    (* Repeat operation for 2nd through 15th bytes in source and destination operands *)\n    IF SRC1[127:120] < SRC2[127:120] THEN\n        DEST[127:120] := SRC1[127:120];\n    ELSE\n        DEST[127:120] := SRC2[127:120]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[7:0] < SRC2[7:0] THEN\n        DEST[7:0] := SRC1[7:0];\n    ELSE\n        DEST[15:0] := SRC2[7:0]; FI;\n    (* Repeat operation for 2nd through 31st bytes in source and destination operands *)\n    IF SRC1[255:248] < SRC2[255:248] THEN\n        DEST[255:248] := SRC1[255:248];\n    ELSE\n        DEST[255:248] := SRC2[255:248]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask* THEN\n        IF SRC1[i+7:i] < SRC2[i+7:i]\n            THEN DEST[i+7:i] := SRC1[i+7:i];\n            ELSE DEST[i+7:i] := SRC2[i+7:i];\n        FI;\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nIF DEST[15:0] < SRC[15:0] THEN\n        DEST[15:0] := DEST[15:0];\n    ELSE\n        DEST[15:0] := SRC[15:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF DEST[127:112] < SRC[127:112] THEN\n        DEST[127:112] := DEST[127:112];\n    ELSE\n        DEST[127:112] := SRC[127:112]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nIF SRC1[15:0] < SRC2[15:0] THEN\n        DEST[15:0] := SRC1[15:0];\n    ELSE\n        DEST[15:0] := SRC2[15:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF SRC1[127:112] < SRC2[127:112] THEN\n        DEST[127:112] := SRC1[127:112];\n    ELSE\n        DEST[127:112] := SRC2[127:112]; FI;\nDEST[MAXVL-1:128] := 0\nIF SRC1[15:0] < SRC2[15:0] THEN\n        DEST[15:0] := SRC1[15:0];\n    ELSE\n        DEST[15:0] := SRC2[15:0]; FI;\n    (* Repeat operation for 2nd through 15th words in source and destination operands *)\n    IF SRC1[255:240] < SRC2[255:240] THEN\n        DEST[255:240] := SRC1[255:240];\n    ELSE\n        DEST[255:240] := SRC2[255:240]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask* THEN\n        IF SRC1[i+15:i] < SRC2[i+15:i]\n            THEN DEST[i+15:i] := SRC1[i+15:i];\n            ELSE DEST[i+15:i] := SRC2[i+15:i];\n        FI;\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgatherpf0dps:vgatherpf0qps:vgatherpf0dpd:vgatherpf0qpd",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VGATHERPF0DPS/VGATHERPF0QPS/VGATHERPF0DPD/VGATHERPF0QPD\n\t\t— Sparse PrefetchPacked SP/DP Data Values With Signed Dword, Signed Qword Indices Using T0 Hint",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed dword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T0 hint.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C6 /1 /vsib VGATHERPF0DPS vm32z {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed qword indices, prefetch sparse byte memory locations containing single-precision data using opmask k1 and T0 hint.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 C7 /1 /vsib VGATHERPF0QPS vm64z {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed dword indices, prefetch sparse byte memory locations containing double precision data using opmask k1 and T0 hint.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C6 /1 /vsib VGATHERPF0DPD vm32y {k1}"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512PF",
        "Description": "Using signed qword indices, prefetch sparse byte memory locations containing double precision data using opmask k1 and T0 hint.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 C7 /1 /vsib VGATHERPF0QPD vm64z {k1}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fbld",
    "category": "Core Instructions",
    "instructionName": "FBLD\n\t\t— Load Binary Coded Decimal",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Convert BCD value to floating-point and push onto the FPU stack.",
        "Instruction": "FBLD m80bcd",
        "Opcode": "DF /4"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved, including that of −0.\nThe packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits (AH through FH). Attempting to load an invalid encoding produces an undefined result.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "TOP := TOP − 1;\nST(0) := ConvertToDoubleExtendedPrecisionFP(SRC);",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; column_1: #NM; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        ""
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movntdq",
    "category": "Core Instructions",
    "instructionName": "MOVNTDQ\n\t\t— Store Packed Integers Using Non-Temporal Hint",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move packed integer values in xmm1 to m128 using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F E7 /r MOVNTDQ m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move packed integer values in xmm1 to m128 using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E7 /r VMOVNTDQ m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move packed integer values in ymm1 to m256 using non-temporal hint.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E7 /r VMOVNTDQ m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move packed integer values in xmm1 to m128 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 E7 /r VMOVNTDQ m128, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move packed integer values in zmm1 to m256 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 E7 /r VMOVNTDQ m256, ymm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move packed integer values in zmm1 to m512 using non-temporal hint.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 E7 /r VMOVNTDQ m512, zmm1"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Moves the packed integers in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain integer data (packed bytes, words, double-words, or quadwords). The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (512-bit version) boundary otherwise a general-protection exception (#GP) will be generated.\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with VMOVNTDQ instructions if multiple processors might use different memory types to read/write the destination memory locations.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD.",
    "operationText": "VL = 128, 256, 512\nDEST[VL-1:0] := SRC[VL-1:0]\nDEST[MAXVL-1:VL] := 0\nDEST := SRC",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Exceptions Type1.SSE2 in Table 2-18, “Type 1 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-45, “Type E1NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/adox",
    "category": "Core Instructions",
    "instructionName": "ADOX\n\t\t— Unsigned Integer Addition of Two Operands With Overflow Flag",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "ADX",
        "Description": "Unsigned addition of r32 with OF, r/m32 to r32, writes OF.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 0F 38 F6 /r ADOX r32, r/m32"
      },
      {
        "64/32bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "ADX",
        "Description": "Unsigned addition of r64 with OF, r/m64 to r64, writes OF.",
        "Op/En": "RM",
        "Opcode/Instruction": "F3 REX.w 0F 38 F6 /r ADOX r64, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands.\nThe ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).\nThis instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.\nIn 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.\nADOX executes normally either inside or outside a transaction region.\nNote: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.",
    "operationText": "IF OperandSize is 64-bit\n    THEN OF:DEST[63:0] := DEST[63:0] + SRC[63:0] + OF;\n    ELSE OF:DEST[31:0] := DEST[31:0] + SRC[31:0] + OF;\nFI;",
    "flagsAffectedText": "OF is updated based on result. CF, SF, ZF, AF, and PF flags are unmodified.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #GP(0); column_2: For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0);"
      ],
      "realAddressMode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #GP(0); column_2: If any part of the operand lies outside the effective address space from 0 to FFFFH.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ],
      "virtual8086Mode": [
        "column_1: If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #GP(0); column_2: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/egetkey",
    "category": "SGX Instructions",
    "instructionName": "EGETKEY\n\t\t— Retrieves a Cryptographic Key",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function retrieves a cryptographic key.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 01H ENCLU[EGETKEY]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EGETKEY (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Address to a KEYREQUEST (In)",
        "column_5": "Address of the OUTPUTDATA (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/idiv",
    "category": "Core Instructions",
    "instructionName": "IDIV\n\t\t— Signed Divide",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide AX by r/m8, with result stored in: AL := Quotient, AH := Remainder.",
        "Instruction": "IDIV r/m8",
        "Op/En": "M",
        "Opcode": "F6 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Signed divide AX by r/m8, with result stored in AL := Quotient, AH := Remainder.",
        "Instruction": "IDIV r/m81",
        "Op/En": "M",
        "Opcode": "REX + F6 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide DX:AX by r/m16, with result stored in AX := Quotient, DX := Remainder.",
        "Instruction": "IDIV r/m16",
        "Op/En": "M",
        "Opcode": "F7 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Signed divide EDX:EAX by r/m32, with result stored in EAX := Quotient, EDX := Remainder.",
        "Instruction": "IDIV r/m32",
        "Op/En": "M",
        "Opcode": "F7 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Signed divide RDX:RAX by r/m64, with result stored in RAX := Quotient, RDX := Remainder.",
        "Instruction": "IDIV r/m64",
        "Op/En": "M",
        "Opcode": "REX.W + F7 /7"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor).\nNon-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the signed value in RDX:RAX by the source operand. RAX contains a 64-bit quotient; RDX contains a 64-bit remainder.\nSee the summary chart at the beginning of this section for encoding data and limits. See Table 3-51.",
    "operationText": "IF SRC = 0\n    THEN #DE; (* Divide error *)\nFI;\nIF OperandSize = 8 (* Word/byte operation *)\n    THEN\n        temp := AX / SRC; (* Signed division *)\n        IF (temp > 7FH) or (temp < 80H)\n        (* If a positive result is greater than 7FH or a negative result is less than 80H *)\n            THEN #DE; (* Divide error *)\n            ELSE\n                AL := temp;\n                AH := AX SignedModulus SRC;\n        FI;\n    ELSE IF OperandSize = 16 (* Doubleword/word operation *)\n        THEN\n            temp := DX:AX / SRC; (* Signed division *)\n            IF (temp > 7FFFH) or (temp < 8000H)\n            (* If a positive result is greater than 7FFFH\n            or a negative result is less than 8000H *)\n                THEN\n                    #DE; (* Divide error *)\n                ELSE\n                    AX := temp;\n                    DX := DX:AX SignedModulus SRC;\n            FI;\n        FI;\n    ELSE IF OperandSize = 32 (* Quadword/doubleword operation *)\n            temp := EDX:EAX / SRC; (* Signed division *)\n            IF (temp > 7FFFFFFFH) or (temp < 80000000H)\n            (* If a positive result is greater than 7FFFFFFFH\n            or a negative result is less than 80000000H *)\n                THEN\n                    #DE; (* Divide error *)\n                ELSE\n                    EAX := temp;\n                    EDX := EDXE:AX SignedModulus SRC;\n            FI;\n        FI;\n    ELSE IF OperandSize = 64 (* Doublequadword/quadword operation *)\n            temp := RDX:RAX / SRC; (* Signed division *)\n            IF (temp > 7FFFFFFFFFFFFFFFH) or (temp < 8000000000000000H)\n            (* If a positive result is greater than 7FFFFFFFFFFFFFFFH\n            or a negative result is less than 8000000000000000H *)\n                THEN\n                    #DE; (* Divide error *)\n                ELSE\n                    RAX := temp;\n                    RDX := RDE:RAX SignedModulus SRC;\n            FI;\n        FI;\nFI;",
    "flagsAffectedText": "The CF, OF, SF, ZF, AF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_2: If the memory address is in a non-canonical form.; column_1: #GP(0); \ncolumn_1: #DE; column_2: If the source operand (divisor) is 0; \ncolumn_1: If the quotient is too large for the designated register.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: The signed result (quotient) is too large for the destination.; \ncolumn_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: The signed result (quotient) is too large for the destination.; \ncolumn_1: #GP; column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: The signed result (quotient) is too large for the destination.; \ncolumn_1: #GP(0); column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpermb",
    "category": "Core Instructions",
    "instructionName": "VPERMB\n\t\t— Permute Packed Bytes Elements",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VBMI",
        "Description": "Permute bytes in xmm3/m128 using byte indexes in xmm2 and store the result in xmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 8D /r VPERMB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VBMI",
        "Description": "Permute bytes in ymm3/m256 using byte indexes in ymm2 and store the result in ymm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 8D /r VPERMB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI",
        "Description": "Permute bytes in zmm3/m512 using byte indexes in zmm2 and store the result in zmm1 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 8D /r VPERMB zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/phsubsw",
    "category": "Core Instructions",
    "instructionName": "PHSUBSW\n\t\t— Packed Horizontal Subtract and Saturate",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Subtract 16-bit signed integer horizontally, pack saturated integers to mm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 38 07 /r1 PHSUBSW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 07 /r PHSUBSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 07 /r VPHSUBSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 07 /r VPHSUBSW ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed, saturated 16-bit results are packed to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nLegacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nIn 64-bit mode, use the REX prefix to access additional registers.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
    "operationText": "mm1[15-0] = SaturateToSignedWord(mm1[15-0] - mm1[31-16]);\nmm1[31-16] = SaturateToSignedWord(mm1[47-32] - mm1[63-48]);\nmm1[47-32] = SaturateToSignedWord(mm2/m64[15-0] - mm2/m64[31-16]);\nmm1[63-48] = SaturateToSignedWord(mm2/m64[47-32] - mm2/m64[63-48]);\nxmm1[15-0] = SaturateToSignedWord(xmm1[15-0] - xmm1[31-16]);\nxmm1[31-16] = SaturateToSignedWord(xmm1[47-32] - xmm1[63-48]);\nxmm1[47-32] = SaturateToSignedWord(xmm1[79-64] - xmm1[95-80]);\nxmm1[63-48] = SaturateToSignedWord(xmm1[111-96] - xmm1[127-112]);\nxmm1[79-64] = SaturateToSignedWord(xmm2/m128[15-0] - xmm2/m128[31-16]);\nxmm1[95-80] =SaturateToSignedWord(xmm2/m128[47-32] - xmm2/m128[63-48]);\nxmm1[111-96] =SaturateToSignedWord(xmm2/m128[79-64] - xmm2/m128[95-80]);\nxmm1[127-112]= SaturateToSignedWord(xmm2/m128[111-96] - xmm2/m128[127-112]);\nDEST[15:0]= SaturateToSignedWord(SRC1[15:0] - SRC1[31:16])\nDEST[31:16] = SaturateToSignedWord(SRC1[47:32] - SRC1[63:48])\nDEST[47:32] = SaturateToSignedWord(SRC1[79:64] - SRC1[95:80])\nDEST[63:48] = SaturateToSignedWord(SRC1[111:96] - SRC1[127:112])\nDEST[79:64] = SaturateToSignedWord(SRC2[15:0] - SRC2[31:16])\nDEST[95:80] = SaturateToSignedWord(SRC2[47:32] - SRC2[63:48])\nDEST[111:96] = SaturateToSignedWord(SRC2[79:64] - SRC2[95:80])\nDEST[127:112] = SaturateToSignedWord(SRC2[111:96] - SRC2[127:112])\nDEST[MAXVL-1:128] := 0\nDEST[15:0]= SaturateToSignedWord(SRC1[15:0] - SRC1[31:16])\nDEST[31:16] = SaturateToSignedWord(SRC1[47:32] - SRC1[63:48])\nDEST[47:32] = SaturateToSignedWord(SRC1[79:64] - SRC1[95:80])\nDEST[63:48] = SaturateToSignedWord(SRC1[111:96] - SRC1[127:112])\nDEST[79:64] = SaturateToSignedWord(SRC2[15:0] - SRC2[31:16])\nDEST[95:80] = SaturateToSignedWord(SRC2[47:32] - SRC2[63:48])\nDEST[111:96] = SaturateToSignedWord(SRC2[79:64] - SRC2[95:80])\nDEST[127:112] = SaturateToSignedWord(SRC2[111:96] - SRC2[127:112])\nDEST[143:128]= SaturateToSignedWord(SRC1[143:128] - SRC1[159:144])\nDEST[159:144] = SaturateToSignedWord(SRC1[175:160] - SRC1[191:176])\nDEST[175:160] = SaturateToSignedWord(SRC1[207:192] - SRC1[223:208])\nDEST[191:176] = SaturateToSignedWord(SRC1[239:224] - SRC1[255:240])\nDEST[207:192] = SaturateToSignedWord(SRC2[143:128] - SRC2[159:144])\nDEST[223:208] = SaturateToSignedWord(SRC2[175:160] - SRC2[191:176])\nDEST[239:224] = SaturateToSignedWord(SRC2[207:192] - SRC2[223:208])\nDEST[255:240] = SaturateToSignedWord(SRC2[239:224] - SRC2[255:240])",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/addss",
    "category": "Core Instructions",
    "instructionName": "ADDSS\n\t\t— Add Scalar Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Add the low single precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 58 /r ADDSS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add the low single precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 58 /r VADDSS xmm1,xmm2, xmm3/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Add the low single precision floating-point value from xmm3/m32 to xmm2 and store the result in xmm1with writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 58 /r VADDSS xmm1{k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Adds the low single precision floating-point values from the second source operand and the first source operand, and stores the double precision floating-point result in the destination operand.\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:32) of the corresponding the destination register remain unchanged.\nEVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX version: The low doubleword element of the destination is updated according to the writemask.\nSoftware should ensure VADDSS is encoded with VEX.L=0. Encoding VADDSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := SRC1[31:0] + SRC2[31:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := DEST[31:0] + SRC[31:0]\nDEST[MAXVL-1:32] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sarx:shlx:shrx",
    "category": "Core Instructions",
    "instructionName": "SARX/SHLX/SHRX\n\t\t— Shift Without Affecting Flags",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI2",
        "Description": "Shift r/m32 arithmetically right with count specified in r32b.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.F3.0F38.W0 F7 /r SARX r32a, r/m32, r32b"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI2",
        "Description": "Shift r/m32 logically left with count specified in r32b.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.66.0F38.W0 F7 /r SHLX r32a, r/m32, r32b"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI2",
        "Description": "Shift r/m32 logically right with count specified in r32b.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.F2.0F38.W0 F7 /r SHRX r32a, r/m32, r32b"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI2",
        "Description": "Shift r/m64 arithmetically right with count specified in r64b.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.F3.0F38.W1 F7 /r SARX r64a, r/m64, r64b"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI2",
        "Description": "Shift r/m64 logically left with count specified in r64b.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.66.0F38.W1 F7 /r SHLX r64a, r/m64, r64b"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI2",
        "Description": "Shift r/m64 logically right with count specified in r64b.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.LZ.F2.0F38.W1 F7 /r SHRX r64a, r/m64, r64b"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMV",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "VEX.vvvv (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).\nThe shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit) while shifting.\nThe logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\nIf the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.\nSARX,SHRX, and SHLX instructions do not update flags.",
    "operationText": "TEMP := SRC1;\nIF VEX.W1 and CS.L = 1\nTHEN\n    countMASK := 3FH;\nELSE\n    countMASK := 1FH;\nFI\nCOUNT := (SRC2 AND countMASK)\nDEST[OperandSize -1] = TEMP[OperandSize -1];\nDO WHILE (COUNT ≠ 0)\n    IF instruction is SHLX\n        THEN\n            DEST[] := DEST *2;\n        ELSE IF instruction is SHRX\n            THEN\n                DEST[] := DEST /2; //unsigned divide\n        ELSE // SARX\n                DEST[] := DEST /2; // signed divide, round toward negative infinity\n    FI;\n    COUNT := COUNT - 1;\nOD",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/paddusb:paddusw",
    "category": "Core Instructions",
    "instructionName": "PADDUSB/PADDUSW\n\t\t— Add Packed Unsigned Integers With Unsigned Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Add packed unsigned byte integers from mm/m64 and mm and saturate the results.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F DC /r1 PADDUSB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F DC /r PADDUSB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Add packed unsigned word integers from mm/m64 and mm and saturate the results.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F DD /r1 PADDUSW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F DD /r PADDUSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.660F.WIG DC /r VPADDUSB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG DD /r VPADDUSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG DC /r VPADDUSB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG DD /r VPADDUSW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed unsigned byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG DC /r VPADDUSB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG DC /r VPADDUSB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Add packed unsigned byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG DC /r VPADDUSB zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed unsigned word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG DD /r VPADDUSW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG DD /r VPADDUSW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Add packed unsigned word integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG DD /r VPADDUSW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.\n(V)PADDUSB performs a SIMD add of the packed unsigned integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.\n(V)PADDUSW performs a SIMD add of the packed unsigned word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.\nEVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is an ZMM/YMM/XMM register.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "DEST[7:0] := SaturateToUnsignedByte(DEST[7:0] + SRC (7:0] );\n(* Repeat add operation for 2nd through 7th bytes *)\nDEST[63:56] := SaturateToUnsignedByte(DEST[63:56] + SRC[63:56]\nDEST[7:0] := SaturateToUnsignedByte (DEST[7:0] + SRC[7:0]);\n(* Repeat add operation for 2nd through 14th bytes *)\nDEST[127:120] := SaturateToUnSignedByte (DEST[127:120] + SRC[127:120]);\nDEST[7:0] := SaturateToUnsignedByte (SRC1[7:0] + SRC2[7:0]);\n(* Repeat subtract operation for 2nd through 14th bytes *)\nDEST[127:120] := SaturateToUnsignedByte (SRC1[111:120] + SRC2[127:120]);\nDEST[MAXVL-1:128] := 0\nDEST[7:0] := SaturateToUnsignedByte (SRC1[7:0] + SRC2[7:0]);\n(* Repeat add operation for 2nd through 31st bytes *)\nDEST[255:248] := SaturateToUnsignedByte (SRC1[255:248] + SRC2[255:248]);\nDEST[15:0] := SaturateToUnsignedWord(DEST[15:0] + SRC[15:0] );\n(* Repeat add operation for 2nd and 3rd words *)\nDEST[63:48] := SaturateToUnsignedWord(DEST[63:48] + SRC[63:48] );\nDEST[15:0] := SaturateToUnsignedWord (DEST[15:0] + SRC[15:0]);\n(* Repeat add operation for 2nd through 7th words *)\nDEST[127:112] := SaturateToUnSignedWord (DEST[127:112] + SRC[127:112]);\nDEST[15:0] := SaturateToUnsignedWord (SRC1[15:0] + SRC2[15:0]);\n(* Repeat subtract operation for 2nd through 7th words *)\nDEST[127:112] := SaturateToUnsignedWord (SRC1[127:112] + SRC2[127:112]);\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := SaturateToUnsignedWord (SRC1[15:0] + SRC2[15:0]);\n(* Repeat add operation for 2nd through 15th words *)\nDEST[255:240] := SaturateToUnsignedWord (SRC1[255:240] + SRC2[255:240])\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+7:i] := SaturateToUnsignedByte (SRC1[i+7:i] + SRC2[i+7:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+7:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := SaturateToUnsignedWord (SRC1[i+15:i] + SRC2[i+15:i])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/mulss",
    "category": "Core Instructions",
    "instructionName": "MULSS\n\t\t— Multiply Scalar Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Multiply the low single precision floating-point value in xmm2/m32 by the low single precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 59 /r MULSS xmm1,xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply the low single precision floating-point value in xmm3/m32 by the low single precision floating-point value in xmm2.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 59 /r VMULSS xmm1,xmm2, xmm3/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply the low single precision floating-point value in xmm3/m32 by the low single precision floating-point value in xmm2.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 59 /r VMULSS xmm1 {k1}{z}, xmm2, xmm3/m32 {er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Multiplies the low single precision floating-point value from the second source operand by the low single precision floating-point value in the first source operand, and stores the single precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source operand and the destination operands are XMM registers.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.\nVEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the write-mask.\nSoftware should ensure VMULSS is encoded with VEX.L=0. Encoding VMULSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := SRC1[31:0] * SRC2[31:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n            FI\n    FI;\nENDFOR\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] * SRC2[31:0]\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := DEST[31:0] * SRC[31:0]\nDEST[MAXVL-1:32] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Underflow, Overflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcompresspd",
    "category": "Core Instructions",
    "instructionName": "VCOMPRESSPD\n\t\t— Store Sparse Packed Double Precision Floating-Point Values Into DenseMemory",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compress packed double precision floating-point values from xmm2 to xmm1/m128 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 8A /r VCOMPRESSPD xmm1/m128 {k1}{z}, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compress packed double precision floating-point values from ymm2 to ymm1/m256 using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 8A /r VCOMPRESSPD ymm1/m256 {k1}{z}, ymm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compress packed double precision floating-point values from zmm2 using control mask k1 to zmm1/m512.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 8A /r VCOMPRESSPD zmm1/m512 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpmovdb:vpmovsdb:vpmovusdb",
    "category": "Core Instructions",
    "instructionName": "VPMOVDB/VPMOVSDB/VPMOVUSDB\n\t\t— Down Convert DWord to Byte",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed double-word integers from xmm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 31 /r VPMOVDB xmm1/m32 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed signed double-word integers from xmm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 21 /r VPMOVSDB xmm1/m32 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 11 /r VPMOVUSDB xmm1/m32 {k1}{z}, xmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 8 packed double-word integers from ymm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 31 /r VPMOVDB xmm1/m64 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 8 packed signed double-word integers from ymm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 21 /r VPMOVSDB xmm1/m64 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 11 /r VPMOVUSDB xmm1/m64 {k1}{z}, ymm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 16 packed double-word integers from zmm2 into 16 packed byte integers in xmm1/m128 with truncation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 31 /r VPMOVDB xmm1/m128 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 16 packed signed double-word integers from zmm2 into 16 packed signed byte integers in xmm1/m128 using signed saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 21 /r VPMOVSDB xmm1/m128 {k1}{z}, zmm2"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned byte integers in xmm1/m128 using unsigned saturation under writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 11 /r VPMOVUSDB xmm1/m128 {k1}{z}, zmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Quarter Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vinserti128:vinserti32x4:vinserti64x2:vinserti32x8:vinserti64x4",
    "category": "Core Instructions",
    "instructionName": "VINSERTI128/VINSERTI32x4/VINSERTI64x2/VINSERTI32x8/VINSERTI64x4\n\t\t— Insert PackedInteger Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Insert 128 bits of integer data from xmm3/m128 and the remaining values from ymm2 into ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 38 /r ib VINSERTI128 ymm1, ymm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Insert 128 bits of packed doubleword integer values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 38 /r ib VINSERTI32X4 ymm1 {k1}{z}, ymm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Insert 128 bits of packed doubleword integer values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 38 /r ib VINSERTI32X4 zmm1 {k1}{z}, zmm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Insert 128 bits of packed quadword integer values from xmm3/m128 and the remaining values from ymm2 into ymm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 38 /r ib VINSERTI64X2 ymm1 {k1}{z}, ymm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Insert 128 bits of packed quadword integer values from xmm3/m128 and the remaining values from zmm2 into zmm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 38 /r ib VINSERTI64X2 zmm1 {k1}{z}, zmm2, xmm3/m128, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Insert 256 bits of packed doubleword integer values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 3A /r ib VINSERTI32X8 zmm1 {k1}{z}, zmm2, ymm3/m256, imm8"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Insert 256 bits of packed quadword integer values from ymm3/m256 and the remaining values from zmm2 into zmm1 under writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 3A /r ib VINSERTI64X4 zmm1 {k1}{z}, zmm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple2"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple4"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple8"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/edbgrd",
    "category": "SGX Instructions",
    "instructionName": "EDBGRD\n\t\t— Read From a Debug Enclave",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function reads a dword/quadword from a debug enclave.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 04H ENCLS[EDBGRD]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EDBGRD (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Data read from a debug enclave (Out)",
        "column_5": "Address of source memory in the EPC (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttss2usi",
    "category": "Core Instructions",
    "instructionName": "VCVTTSS2USI\n\t\t— Convert With Truncation Scalar Single Precision Floating-Point Value toUnsigned Integer",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32 using truncation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 78 /r VCVTTSS2USI r32, xmm1/m32{sae}"
      },
      {
        "64/32 Bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64 using truncation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W1 78 /r VCVTTSS2USI r64, xmm1/m32{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Fixed"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmuldq",
    "category": "Core Instructions",
    "instructionName": "PMULDQ\n\t\t— Multiply Packed Doubleword Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Multiply packed signed doubleword integers in xmm1 by packed signed doubleword integers in xmm2/m128, and store the quadword results in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 38 28 /r PMULDQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 28 /r VPMULDQ xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 28 /r VPMULDQ ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 28 /r VPMULDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 28 /r VPMULDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed signed doubleword integers in zmm2 by packed signed doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 using writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 28 /r VPMULDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+63:i] := SignExtend64( SRC1[i+31:i]) * SignExtend64( SRC2[31:0])\n                ELSE DEST[i+63:i] := SignExtend64( SRC1[i+31:i]) * SignExtend64( SRC2[i+31:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SignExtend64( SRC1[31:0]) * SignExtend64( SRC2[31:0])\nDEST[127:64] := SignExtend64( SRC1[95:64]) * SignExtend64( SRC2[95:64])\nDEST[191:128] := SignExtend64( SRC1[159:128]) * SignExtend64( SRC2[159:128])\nDEST[255:192] := SignExtend64( SRC1[223:192]) * SignExtend64( SRC2[223:192])\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := SignExtend64( SRC1[31:0]) * SignExtend64( SRC2[31:0])\nDEST[127:64] := SignExtend64( SRC1[95:64]) * SignExtend64( SRC2[95:64])\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SignExtend64( DEST[31:0]) * SignExtend64( SRC[31:0])\nDEST[127:64] := SignExtend64( DEST[95:64]) * SignExtend64( SRC[95:64])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pmulhrsw",
    "category": "Core Instructions",
    "instructionName": "PMULHRSW\n\t\t— Packed Multiply High With Round and Scale",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to mm1.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 38 0B /r1 PMULHRSW mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 0B /r PMULHRSW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 0B /r VPMULHRSW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 0B /r VPMULHRSW ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 0B /r VPMULHRSW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 0B /r VPMULHRSW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to zmm1 under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 0B /r VPMULHRSW zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "PMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32-bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by selecting the 16 bits immediately to the right of the most significant bit of each 18-bit intermediate result and packed to the destination operand.\nWhen the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nIn 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.\nLegacy SSE version 64-bit operand: Both operands can be MMX registers. The second source operand is an MMX register or a 64-bit memory location.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
    "operationText": "temp0[31:0] = INT32 ((DEST[15:0] * SRC[15:0]) >>14) + 1;\ntemp1[31:0] = INT32 ((DEST[31:16] * SRC[31:16]) >>14) + 1;\ntemp2[31:0] = INT32 ((DEST[47:32] * SRC[47:32]) >> 14) + 1;\ntemp3[31:0] = INT32 ((DEST[63:48] * SRc[63:48]) >> 14) + 1;\nDEST[15:0] = temp0[16:1];\nDEST[31:16] = temp1[16:1];\nDEST[47:32] = temp2[16:1];\nDEST[63:48] = temp3[16:1];\ntemp0[31:0] = INT32 ((DEST[15:0] * SRC[15:0]) >>14) + 1;\ntemp1[31:0] = INT32 ((DEST[31:16] * SRC[31:16]) >>14) + 1;\ntemp2[31:0] = INT32 ((DEST[47:32] * SRC[47:32]) >>14) + 1;\ntemp3[31:0] = INT32 ((DEST[63:48] * SRC[63:48]) >>14) + 1;\ntemp4[31:0] = INT32 ((DEST[79:64] * SRC[79:64]) >>14) + 1;\ntemp5[31:0] = INT32 ((DEST[95:80] * SRC[95:80]) >>14) + 1;\ntemp6[31:0] = INT32 ((DEST[111:96] * SRC[111:96]) >>14) + 1;\ntemp7[31:0] = INT32 ((DEST[127:112] * SRC[127:112) >>14) + 1;\nDEST[15:0] = temp0[16:1];\nDEST[31:16] = temp1[16:1];\nDEST[47:32] = temp2[16:1];\nDEST[63:48] = temp3[16:1];\nDEST[79:64] = temp4[16:1];\nDEST[95:80] = temp5[16:1];\nDEST[111:96] = temp6[16:1];\nDEST[127:112] = temp7[16:1];\ntemp0[31:0] := INT32 ((SRC1[15:0] * SRC2[15:0]) >>14) + 1\ntemp1[31:0] := INT32 ((SRC1[31:16] * SRC2[31:16]) >>14) + 1\ntemp2[31:0] := INT32 ((SRC1[47:32] * SRC2[47:32]) >>14) + 1\ntemp3[31:0] := INT32 ((SRC1[63:48] * SRC2[63:48]) >>14) + 1\ntemp4[31:0] := INT32 ((SRC1[79:64] * SRC2[79:64]) >>14) + 1\ntemp5[31:0] := INT32 ((SRC1[95:80] * SRC2[95:80]) >>14) + 1\ntemp6[31:0] := INT32 ((SRC1[111:96] * SRC2[111:96]) >>14) + 1\ntemp7[31:0] := INT32 ((SRC1[127:112] * SRC2[127:112) >>14) + 1\nDEST[15:0] := temp0[16:1]\nDEST[31:16] := temp1[16:1]\nDEST[47:32] := temp2[16:1]\nDEST[63:48] := temp3[16:1]\nDEST[79:64] := temp4[16:1]\nDEST[95:80] := temp5[16:1]\nDEST[111:96] := temp6[16:1]\nDEST[127:112] := temp7[16:1]\nDEST[MAXVL-1:128] := 0\ntemp0[31:0] := INT32 ((SRC1[15:0] * SRC2[15:0]) >>14) + 1\ntemp1[31:0] := INT32 ((SRC1[31:16] * SRC2[31:16]) >>14) + 1\ntemp2[31:0] := INT32 ((SRC1[47:32] * SRC2[47:32]) >>14) + 1\ntemp3[31:0] := INT32 ((SRC1[63:48] * SRC2[63:48]) >>14) + 1\ntemp4[31:0] := INT32 ((SRC1[79:64] * SRC2[79:64]) >>14) + 1\ntemp5[31:0] := INT32 ((SRC1[95:80] * SRC2[95:80]) >>14) + 1\ntemp6[31:0] := INT32 ((SRC1[111:96] * SRC2[111:96]) >>14) + 1\ntemp7[31:0] := INT32 ((SRC1[127:112] * SRC2[127:112) >>14) + 1\ntemp8[31:0] := INT32 ((SRC1[143:128] * SRC2[143:128]) >>14) + 1\ntemp9[31:0] := INT32 ((SRC1[159:144] * SRC2[159:144]) >>14) + 1\ntemp10[31:0] := INT32 ((SRC1[75:160] * SRC2[175:160]) >>14) + 1\ntemp11[31:0] := INT32 ((SRC1[191:176] * SRC2[191:176]) >>14) + 1\ntemp12[31:0] := INT32 ((SRC1[207:192] * SRC2[207:192]) >>14) + 1\ntemp13[31:0] := INT32 ((SRC1[223:208] * SRC2[223:208]) >>14) + 1\ntemp14[31:0] := INT32 ((SRC1[239:224] * SRC2[239:224]) >>14) + 1\ntemp15[31:0] := INT32 ((SRC1[255:240] * SRC2[255:240) >>14) + 1\nDEST[15:0] := temp0[16:1]\nDEST[31:16] := temp1[16:1]\nDEST[47:32] := temp2[16:1]\nDEST[63:48] := temp3[16:1]\nDEST[79:64] := temp4[16:1]\nDEST[95:80] := temp5[16:1]\nDEST[111:96] := temp6[16:1]\nDEST[127:112] := temp7[16:1]\nDEST[143:128] := temp8[16:1]\nDEST[159:144] := temp9[16:1]\nDEST[175:160] := temp10[16:1]\nDEST[191:176] := temp11[16:1]\nDEST[207:192] := temp12[16:1]\nDEST[223:208] := temp13[16:1]\nDEST[239:224] := temp14[16:1]\nDEST[255:240] := temp15[16:1]\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN\n            temp[31:0] := ((SRC1[i+15:i] * SRC2[i+15:i]) >>14) + 1\n            DEST[i+15:i] := tmp[16:1]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4.nb in Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/wrfsbase:wrgsbase",
    "category": "Core Instructions",
    "instructionName": "WRFSBASE/WRGSBASE\n\t\t— Write FS/GS Segment Base",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/I",
        "CPUID Feature Flag": "FSGSBASE",
        "Description": "Load the FS base address with the 32-bit value in the source register.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 0F AE /2 WRFSBASE r32"
      },
      {
        "64/32-bit Mode": "V/I",
        "CPUID Feature Flag": "FSGSBASE",
        "Description": "Load the FS base address with the 64-bit value in the source register.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 REX.W 0F AE /2 WRFSBASE r64"
      },
      {
        "64/32-bit Mode": "V/I",
        "CPUID Feature Flag": "FSGSBASE",
        "Description": "Load the GS base address with the 32-bit value in the source register.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 0F AE /3 WRGSBASE r32"
      },
      {
        "64/32-bit Mode": "V/I",
        "CPUID Feature Flag": "FSGSBASE",
        "Description": "Load the GS base address with the 64-bit value in the source register.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 REX.W 0F AE /3 WRGSBASE r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Loads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.\nThe source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.\nThis instruction is supported only in 64-bit mode.",
    "operationText": "FS/GS segment base address := SRC;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CR4.FSGSBASE[bit 16] = 0.; \ncolumn_1: If CPUID.07H.0H:EBX.FSGSBASE[bit 0] = 0; \ncolumn_1: #GP(0); column_2: If the source register contains a non-canonical address.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/korw:korb:korq:kord",
    "category": "Core Instructions",
    "instructionName": "KORW/KORB/KORQ/KORD\n\t\t— Bitwise Logical OR Masks",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise OR 16 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W0 45 /r KORW k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Bitwise OR 8 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W0 45 /r KORB k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise OR 64 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.0F.W1 45 /r KORQ k1, k2, k3"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Bitwise OR 32 bits masks k2 and k3 and place result in k1.",
        "Op/En": "RVR",
        "Opcode/Instruction": "VEX.L1.66.0F.W1 45 /r KORD k1, k2, k3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.1vvv (r)",
        "Operand 3": "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
      }
    ],
    "descriptionText": "Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
    "operationText": "DEST[15:0] := SRC1[15:0] BITWISE OR SRC2[15:0]\nDEST[MAX_KL-1:16] := 0\nDEST[7:0] := SRC1[7:0] BITWISE OR SRC2[7:0]\nDEST[MAX_KL-1:8] := 0\nDEST[63:0] := SRC1[63:0] BITWISE OR SRC2[63:0]\nDEST[MAX_KL-1:64] := 0\nDEST[31:0] := SRC1[31:0] BITWISE OR SRC2[31:0]\nDEST[MAX_KL-1:32] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/subpd",
    "category": "Core Instructions",
    "instructionName": "SUBPD\n\t\t— Subtract Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Subtract packed double precision floating-point values in xmm2/mem from xmm1 and store result in xmm1.",
        "Op/E n": "A",
        "Opcode/Instruction": "66 0F 5C /r SUBPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed double precision floating-point values in xmm3/mem from xmm2 and store result in xmm1.",
        "Op/E n": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 5C /r VSUBPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Subtract packed double precision floating-point values in ymm3/mem from ymm2 and store result in ymm1.",
        "Op/E n": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 5C /r VSUBPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Subtract packed double precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 5C /r VSUBPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Subtract packed double precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 5C /r VSUBPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Subtract packed double precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 5C /r VSUBPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD subtract of the two, four or eight packed double precision floating-point values of the second Source operand from the first Source operand, and stores the packed double precision floating-point results in the destination operand.\nVEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\nEVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The first source operand and destination operands are ZMM registers. The destination operand is conditionally updated according to the writemask.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC1[i+63:i] - SRC2[i+63:i]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                DEST[63:0] := 0\n        FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1)\n                THEN DEST[i+63:i] := SRC1[i+63:i] - SRC2[63:0];\n                ELSE EST[i+63:i] := SRC1[i+63:i] - SRC2[i+63:i];\n            FI;\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                DEST[63:0] := 0\n        FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC1[63:0] - SRC2[63:0]\nDEST[127:64] := SRC1[127:64] - SRC2[127:64]\nDEST[191:128] := SRC1[191:128] - SRC2[191:128]\nDEST[255:192] := SRC1[255:192] - SRC2[255:192]\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := SRC1[63:0] - SRC2[63:0]\nDEST[127:64] := SRC1[127:64] - SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] - SRC[63:0]\nDEST[127:64] := DEST[127:64] - SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfpclasssd",
    "category": "Core Instructions",
    "instructionName": "VFPCLASSSD\n\t\t— Tests Type of a Scalar Float64 Value",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W1 67 /r ib VFPCLASSSD k2 {k1}, xmm2/m64, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrtsh",
    "category": "Core Instructions",
    "instructionName": "VRSQRTSH\n\t\t— Compute Approximate Reciprocal of Square Root of Scalar FP16 Value",
    "detailsTable": [
      {
        "Description": "Compute the approximate reciprocal square root of the FP16 value in xmm3/m16 and store the result in the low word element of xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 4F /r VRSQRTSH xmm1{k1}{z}, xmm2, xmm3/m16",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pshufw",
    "category": "Core Instructions",
    "instructionName": "PSHUFW\n\t\t— Shuffle Packed Words",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "NP 0F 70 /r ib PSHUFW mm1, mm2/m64, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies words from the source operand (second operand) and inserts them in the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the operation used by the PSHUFD instruction, which is illustrated in Figure 4-16. For the PSHUFW instruction, each 2-bit field in the order operand selects the contents of one word location in the destination operand. The encodings of the order operand fields select words from the source operand to be copied to the destination operand.\nThe source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register. The order operand is an 8-bit immediate. Note that this instruction permits a word in the source operand to be copied to more than one word location in the destination operand.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST[15:0] := (SRC >> (ORDER[1:0] * 16))[15:0];\nDEST[31:16] := (SRC >> (ORDER[3:2] * 16))[15:0];\nDEST[47:32] := (SRC >> (ORDER[5:4] * 16))[15:0];\nDEST[63:48] := (SRC >> (ORDER[7:6] * 16))[15:0];",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": [
        "See Table 23-7, “Exception Conditions for SIMD/MMX Instructions with Memory Reference,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vperm2f128",
    "category": "Core Instructions",
    "instructionName": "VPERM2F128\n\t\t— Permute Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.",
        "Op/En": "RV MI",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 06 /r ib VPERM2F128 ymm1, ymm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8"
      }
    ],
    "descriptionText": "Permute 128 bit floating-point-containing fields from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.\nImm8[1:0] select the source for the first destination 128-bit field, imm8[5:4] select the source for the second destination field. If imm8[3] is set, the low 128-bit field is zeroed. If imm8[7] is set, the high 128-bit field is zeroed.\nVEX.L must be 1, otherwise the instruction will #UD.",
    "operationText": "CASE IMM8[1:0] of\n0: DEST[127:0] := SRC1[127:0]\n1: DEST[127:0] := SRC1[255:128]\n2: DEST[127:0] := SRC2[127:0]\n3: DEST[127:0] := SRC2[255:128]\nESAC\nCASE IMM8[5:4] of\n0: DEST[255:128] := SRC1[127:0]\n1: DEST[255:128] := SRC1[255:128]\n2: DEST[255:128] := SRC2[127:0]\n3: DEST[255:128] := SRC2[255:128]\nESAC\nIF (imm8[3])\nDEST[127:0] := 0\nFI\nIF (imm8[7])\nDEST[MAXVL-1:128] := 0\nFI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-23, “Type 6 Class Exception Conditions.”",
        "Additionally:",
        "column_1: If VEX.W = 1.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sldt",
    "category": "Core Instructions",
    "instructionName": "SLDT\n\t\t— Store Local Descriptor Table Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Stores segment selector from LDTR in r/m16.",
        "Instruction": "SLDT r/m16",
        "Op/En": "M",
        "Opcode*": "0F 00 /0"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be executed in protected mode.\nOutside IA-32e mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared for the Pentium 4, Intel Xeon, and P6 family processors. They are undefined for Pentium, Intel486, and Intel386 processors. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.\nIn compatibility mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). The behavior of SLDT with a 64-bit register is to zero-extend the 16-bit selector and store it in the register. If the destination is memory and operand size is 64, SLDT will write the 16-bit selector to memory as a 16-bit quantity, regardless of the operand size.",
    "operationText": "DEST := LDTR(SegmentSelector);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL = 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL = 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vsubsh",
    "category": "Core Instructions",
    "instructionName": "VSUBSH\n\t\t— Subtract Scalar FP16 Value",
    "detailsTable": [
      {
        "Description": "Subtract the low FP16 value in xmm3/m16 from xmm2 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 5C /r VSUBSH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/addpd",
    "category": "Core Instructions",
    "instructionName": "ADDPD\n\t\t— Add Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Add packed double precision floating-point values from xmm2/mem to xmm1 and store result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 58 /r ADDPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed double precision floating-point values from xmm3/mem to xmm2 and store result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 58 /r VADDPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed double precision floating-point values from ymm3/mem to ymm2 and store result in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 58 /r VADDPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Add packed double precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 58 /r VADDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Add packed double precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 58 /r VADDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Add packed double precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 58 /r VADDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Adds two, four or eight packed double precision floating-point values from the first source operand to the second source operand, and stores the packed double precision floating-point result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC1[i+63:i] + SRC2[i+63:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+63:i] := SRC1[i+63:i] + SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := SRC1[i+63:i] + SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC1[63:0] + SRC2[63:0]\nDEST[127:64] := SRC1[127:64] + SRC2[127:64]\nDEST[191:128] := SRC1[191:128] + SRC2[191:128]\nDEST[255:192] := SRC1[255:192] + SRC2[255:192]\nDEST[MAXVL-1:256] := 0\n.\nDEST[63:0] := SRC1[63:0] + SRC2[63:0]\nDEST[127:64] := SRC1[127:64] + SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] + SRC[63:0]\nDEST[127:64] := DEST[127:64] + SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/shrd",
    "category": "Core Instructions",
    "instructionName": "SHRD\n\t\t— Double Precision Shift Right",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.",
        "Instruction": "SHRD r/m16, r16, imm8",
        "Op/En": "MRI",
        "Opcode*": "0F AC /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shift r/m16 to right CL places while shifting bits from r16 in from the left.",
        "Instruction": "SHRD r/m16, r16, CL",
        "Op/En": "MRC",
        "Opcode*": "0F AD /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.",
        "Instruction": "SHRD r/m32, r32, imm8",
        "Op/En": "MRI",
        "Opcode*": "0F AC /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.",
        "Instruction": "SHRD r/m64, r64, imm8",
        "Op/En": "MRI",
        "Opcode*": "REX.W + 0F AC /r ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Shift r/m32 to right CL places while shifting bits from r32 in from the left.",
        "Instruction": "SHRD r/m32, r32, CL",
        "Op/En": "MRC",
        "Opcode*": "0F AD /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Shift r/m64 to right CL places while shifting bits from r64 in from the left.",
        "Instruction": "SHRD r/m64, r64, CL",
        "Op/En": "MRC",
        "Opcode*": "REX.W + 0F AD /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MRI",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MRC",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "CL",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The SHRD instruction is useful for multi-precision shifts of 64 bits or more.\nThe instruction shifts the first operand (destination operand) to the right the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with the most significant bit of the destination operand).\nThe destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an immediate byte or the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode, the width of the count mask is 5 bits. Only bits 0 through 4 of the count register are used (masking the count to a value between 0 and 31). If the count is greater than the operand size, the result is undefined.\nIf the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits). See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF (In 64-Bit Mode and REX.W = 1)\n    THEN COUNT := COUNT MOD 64;\n    ELSE COUNT := COUNT MOD 32;\nFI\nSIZE := OperandSize;\nIF COUNT = 0\n    THEN\n        No operation;\n    ELSE\n        IF COUNT > SIZE\n            THEN (* Bad parameters *)\n                DEST is undefined;\n                CF, OF, SF, ZF, AF, PF are undefined;\n            ELSE (* Perform the shift *)\n                CF := BIT[DEST, COUNT – 1]; (* Last bit shifted out on exit *)\n                FOR i := 0 TO SIZE – 1 – COUNT\n                    DO\n                        BIT[DEST, i] := BIT[DEST, i + COUNT];\n                    OD;\n                FOR i := SIZE – COUNT TO SIZE – 1\n                    DO\n                        BIT[DEST,i] := BIT[SRC, i + COUNT – SIZE];\n                    OD;\n        FI;\nFI;",
    "flagsAffectedText": "If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/kshiftrw:kshiftrb:kshiftrq:kshiftrd",
    "category": "Core Instructions",
    "instructionName": "KSHIFTRW/KSHIFTRB/KSHIFTRQ/KSHIFTRD\n\t\t— Shift Right Mask Registers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift right 16 bits in k2 by immediate and write result in k1.",
        "Op/En": "RRI",
        "Opcode/Instruction": "VEX.L0.66.0F3A.W1 30 /r KSHIFTRW k1, k2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Shift right 8 bits in k2 by immediate and write result in k1.",
        "Op/En": "RRI",
        "Opcode/Instruction": "VEX.L0.66.0F3A.W0 30 /r KSHIFTRB k1, k2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift right 64 bits in k2 by immediate and write result in k1.",
        "Op/En": "RRI",
        "Opcode/Instruction": "VEX.L0.66.0F3A.W1 31 /r KSHIFTRQ k1, k2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift right 32 bits in k2 by immediate and write result in k1.",
        "Op/En": "RRI",
        "Opcode/Instruction": "VEX.L0.66.0F3A.W0 31 /r KSHIFTRD k1, k2, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RRI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
        "Operand 3": "imm8"
      }
    ],
    "descriptionText": "Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
    "operationText": "COUNT := imm8[7:0]\nDEST[MAX_KL-1:0] := 0\nIF COUNT <=15\n    THEN DEST[15:0] := SRC1[15:0] >> COUNT;\nFI;\nCOUNT := imm8[7:0]\nDEST[MAX_KL-1:0] := 0\nIF COUNT <=7\n    THEN DEST[7:0] := SRC1[7:0] >> COUNT;\nFI;\nCOUNT := imm8[7:0]\nDEST[MAX_KL-1:0] := 0\nIF COUNT <=63\n    THEN DEST[63:0] := SRC1[63:0] >> COUNT;\nFI;\nCOUNT := imm8[7:0]\nDEST[MAX_KL-1:0] := 0\nIF COUNT <=31\n    THEN DEST[31:0] := SRC1[31:0] >> COUNT;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-63, “TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg).”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/crc32",
    "category": "Core Instructions",
    "instructionName": "CRC32\n\t\t— Accumulate CRC32 Value",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Accumulate CRC32 on r/m8.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 38 F0 /r CRC32 r32, r/m8"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Accumulate CRC32 on r/m8.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 REX 0F 38 F0 /r CRC32 r32, r/m81"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Accumulate CRC32 on r/m16.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 38 F1 /r CRC32 r32, r/m16"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Accumulate CRC32 on r/m32.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 38 F1 /r CRC32 r32, r/m32"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Accumulate CRC32 on r/m8.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 REX.W 0F 38 F0 /r CRC32 r64, r/m8"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Accumulate CRC32 on r/m64.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 REX.W 0F 38 F1 /r CRC32 r64, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Starting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial 11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. The source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If the destination is an r64 register, then the 32-bit result is stored in the least significant double word and 00000000H is stored in the most significant double word of the r64 register.\nThe initial value supplied in the destination operand is a double word integer stored in the r32 register or the least significant double word of the r64 register. To incrementally accumulate a CRC32 value, software retains the result of the previous CRC32 operation in the destination operand, then executes the CRC32 instruction again with new input data in the source operand. Data contained in the source operand is processed in reflected bit order. This means that the most significant bit of the source operand is treated as the least significant bit of the quotient, and so on, for all the bits of the source operand. Likewise, the result of the CRC operation is stored in the destination operand in reflected bit order. This means that the most significant bit of the resulting CRC (bit 31) is stored in the least significant bit of the destination operand (bit 0), and so on, for all the bits of the CRC.",
    "operationText": "CRC32 instruction for 64-bit source operand and 64-bit destination operand:\n    TEMP1[63-0] := BIT_REFLECT64 (SRC[63-0])\n    TEMP2[31-0] := BIT_REFLECT32 (DEST[31-0])\n    TEMP3[95-0] := TEMP1[63-0] « 32\n    TEMP4[95-0] := TEMP2[31-0] « 64\n    TEMP5[95-0] := TEMP3[95-0] XOR TEMP4[95-0]\n    TEMP6[31-0] := TEMP5[95-0] MOD2 11EDC6F41H\n    DEST[31-0] := BIT_REFLECT (TEMP6[31-0])\n    DEST[63-32] := 00000000H\nCRC32 instruction for 32-bit source operand and 32-bit destination operand:\n    TEMP1[31-0] := BIT_REFLECT32 (SRC[31-0])\n    TEMP2[31-0] := BIT_REFLECT32 (DEST[31-0])\n    TEMP3[63-0] := TEMP1[31-0] « 32\n    TEMP4[63-0] := TEMP2[31-0] « 32\n    TEMP5[63-0] := TEMP3[63-0] XOR TEMP4[63-0]\n    TEMP6[31-0] := TEMP5[63-0] MOD2 11EDC6F41H\n    DEST[31-0] := BIT_REFLECT (TEMP6[31-0])\nCRC32 instruction for 16-bit source operand and 32-bit destination operand:\n    TEMP1[15-0] := BIT_REFLECT16 (SRC[15-0])\n    TEMP2[31-0] := BIT_REFLECT32 (DEST[31-0])\n    TEMP3[47-0] := TEMP1[15-0] « 32\n    TEMP4[47-0] := TEMP2[31-0] « 16\n    TEMP5[47-0] := TEMP3[47-0] XOR TEMP4[47-0]\n    TEMP6[31-0] := TEMP5[47-0] MOD2 11EDC6F41H\n    DEST[31-0] := BIT_REFLECT (TEMP6[31-0])\nCRC32 instruction for 8-bit source operand and 64-bit destination operand:\n    TEMP1[7-0] := BIT_REFLECT8(SRC[7-0])\n    TEMP2[31-0] := BIT_REFLECT32 (DEST[31-0])\n    TEMP3[39-0] := TEMP1[7-0] « 32\n    TEMP4[39-0] := TEMP2[31-0] « 8\n    TEMP5[39-0] := TEMP3[39-0] XOR TEMP4[39-0]\n    TEMP6[31-0] := TEMP5[39-0] MOD2 11EDC6F41H\n    DEST[31-0] := BIT_REFLECT (TEMP6[31-0])\n    DEST[63-32] := 00000000H\nCRC32 instruction for 8-bit source operand and 32-bit destination operand:\n    TEMP1[7-0] := BIT_REFLECT8(SRC[7-0])\n    TEMP2[31-0] := BIT_REFLECT32 (DEST[31-0])\n    TEMP3[39-0] := TEMP1[7-0] « 32\n    TEMP4[39-0] := TEMP2[31-0] « 8\n    TEMP5[39-0] := TEMP3[39-0] XOR TEMP4[39-0]\n    TEMP6[31-0] := TEMP5[39-0] MOD2 11EDC6F41H\n    DEST[31-0] := BIT_REFLECT (TEMP6[31-0])",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.SSE4_2[Bit 20] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in Protected Mode."
      ],
      "protectedMode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: (fault-code) For a page fault.; column_1: #PF; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.SSE4_2[Bit 20] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.SSE4_2[Bit 20] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ],
      "virtual8086Mode¶": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.SSE4_2[Bit 20] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/divpd",
    "category": "Core Instructions",
    "instructionName": "DIVPD\n\t\t— Divide Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Divide packed double precision floating-point values in xmm1 by packed double precision floating-point values in xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 5E /r DIVPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Divide packed double precision floating-point values in xmm2 by packed double precision floating-point values in xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 5E /r VDIVPD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Divide packed double precision floating-point values in ymm2 by packed double precision floating-point values in ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 5E /r VDIVPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Divide packed double precision floating-point values in xmm2 by packed double precision floating-point values in xmm3/m128/m64bcst and write results to xmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 5E /r VDIVPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Divide packed double precision floating-point values in ymm2 by packed double precision floating-point values in ymm3/m256/m64bcst and write results to ymm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 5E /r VDIVPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Divide packed double precision floating-point values in zmm2 by packed double precision floating-point values in zmm3/m512/m64bcst and write results to zmm1 subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 5E /r VDIVPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD divide of the double precision floating-point values in the first source operand by the floating-point values in the second source operand (the third operand). Results are written to the destination operand (the first operand).\nEVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand (the second operand) is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.\nVEX.128 encoded version: The first source operand (the second operand) is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination are zeroed.\n128-bit Legacy SSE version: The second source operand (the second operand) can be an XMM register or an 128-bit memory location. The destination is the same as the first source operand. The upper bits (MAXVL-1:128) of the corresponding destination are unmodified.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF (VL = 512) AND (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC); ; refer to Table 15-4 in the Intel® 64 and IA-32 Architectures\nSoftware Developer’s Manual, Volume 1\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := SRC1[i+63:i] / SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := SRC1[i+63:i] / SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC1[63:0] / SRC2[63:0]\nDEST[127:64] := SRC1[127:64] / SRC2[127:64]\nDEST[191:128] := SRC1[191:128] / SRC2[191:128]\nDEST[255:192] := SRC1[255:192] / SRC2[255:192]\nDEST[MAXVL-1:256] := 0;\nDEST[63:0] := SRC1[63:0] / SRC2[63:0]\nDEST[127:64] := SRC1[127:64] / SRC2[127:64]\nDEST[MAXVL-1:128] := 0;\nDEST[63:0] := SRC1[63:0] / SRC2[63:0]\nDEST[127:64] := SRC1[127:64] / SRC2[127:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/eacceptcopy",
    "category": "SGX Instructions",
    "instructionName": "EACCEPTCOPY\n\t\t— Initialize a Pending Page",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX2",
        "Description": "This leaf function initializes a dynamically allocated EPC page from another page in the EPC.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 07H ENCLU[EACCEPTCOPY]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EACCEPTCOPY (In)",
        "column_3": "Return Error Code (Out)",
        "column_4": "Address of a SECINFO (In)",
        "column_5": "Address of the destination EPC page (In)",
        "column_6": "Address of the source EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pdep",
    "category": "Core Instructions",
    "instructionName": "PDEP\n\t\t— Parallel Bits Deposit",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI2",
        "Description": "Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.LZ.F2.0F38.W0 F5 /r PDEP r32a, r32b, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI2",
        "Description": "Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.LZ.F2.0F38.W1 F5 /r PDEP r64a, r64b, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "PDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits from the first source operand and deposit them in the destination operand at the corresponding bit locations that are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero.\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
    "operationText": "TEMP := SRC1;\nMASK := SRC2;\nDEST := 0 ;\nm := 0, k := 0;\nDO WHILE m < OperandSize\n    IF MASK[ m] = 1 THEN\n        DEST[ m] := TEMP[ k];\n        k := k+ 1;\n    FI\n    m := m+ 1;\nOD",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-29, “Type 13 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/uiret",
    "category": "Core Instructions",
    "instructionName": "UIRET\n\t\t— User-Interrupt Return",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/I",
        "CPUID Feature Flag": "UINTR",
        "Description": "Return from handling a user interrupt.",
        "Op/En": "ZO",
        "Opcode/Instruction": "F3 0F 01 EC UIRET"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "UIRET returns from the handling of a user interrupt. It can be executed regardless of CPL.\nExecution of UIRET inside a transactional region causes a transactional abort; the abort loads EAX as it would have had it been due to an execution of IRET.\nUIRET can be tracked by Architectural Last Branch Records (LBRs), Intel Processor Trace (Intel PT), and Performance Monitoring. For both Intel PT and LBRs, UIRET is recorded in precisely the same manner as IRET. Hence for LBRs, UIRETs fall into the OTHER_BRANCH category, which implies that IA32_LBR_CTL.OTHER_BRANCH[bit 22] must be set to record user-interrupt delivery, and that the IA32_LBR_x_INFO.BR_TYPE field will indicate OTHER_BRANCH for any recorded user interrupt. For Intel PT, control flow tracing must be enabled by setting IA32_RTIT_CTL.BranchEn[bit 13].\nUIRET will also increment performance counters for which counting BR_INST_RETIRED.FAR_BRANCH is enabled.",
    "operationText": "Pop tempRIP;\nPop tempRFLAGS; // see below for how this is used to load RFLAGS\nPop tempRSP;\nIF tempRIP is not canonical in current paging mode\n    THEN #GP(0);\nFI;\nIF ShadowStackEnabled(CPL)\n    THEN\n        PopShadowStack SSRIP;\n        IF SSRIP ≠ tempRIP\n            THEN #CP (FAR-RET/IRET);\n        FI;\nFI;\nRIP := tempRIP;\n// update in RFLAGS only CF, PF, AF, ZF, SF, TF, DF, OF, NT, RF, AC, and ID\nRFLAGS := (RFLAGS & ~254DD5H) | (tempRFLAGS & 254DD5H);\nRSP := tempRSP;\nUIF := 1;\nClear any cache-line monitoring established by MONITOR or UMONITOR;",
    "flagsAffectedText": "See the Operation section.",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If an attempt to pop a value off the stack causes a non-canonical address to be referenced.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #CP; column_2: If return instruction pointer from stack and shadow stack do not match.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If executed inside an enclave.; \ncolumn_1: If CR4.UINTR = 0.; \ncolumn_1: If CPUID.07H.0H:EDX.UINTR[bit 5] = 0.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/invvpid",
    "category": "VMX Instructions",
    "instructionName": "INVVPID\n\t\t— Invalidate Translations Based on VPID",
    "detailsTable": [
      {
        "Description": "Invalidates entries in the TLBs and paging-structure caches based on VPID (in 64-bit mode).",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 81 INVVPID r64, m128"
      },
      {
        "Description": "Invalidates entries in the TLBs and paging-structure caches based on VPID (outside 64-bit mode).",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 81 INVVPID r32, m128"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "RM",
        "column_2": "ModRM:reg (r)",
        "column_3": "ModRM:r/m (r)",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on virtualprocessor identifier (VPID). (See Chapter 29, “VMX Support for Address Translation.”) Invalidation is based on the INVVPID type specified in the register operand and the INVVPID descriptor specified in the memory operand.\nOutside IA-32e mode, the register operand is always 32 bits, regardless of the value of CS.D; in 64-bit mode, the register operand has 64 bits (the instruction cannot be executed in compatibility mode).\nThe INVVPID types supported by a logical processors are reported in the IA32_VMX_EPT_VPID_CAP MSR (see Appendix A, “VMX Capability Reporting Facility”). There are four INVVPID types currently defined:\nIf an unsupported INVVPID type is specified, the instruction fails.\nINVVPID invalidates all the specified mappings for the indicated VPID(s) regardless of the EPTP and PCID values with which those mappings may be associated.\nThe INVVPID descriptor comprises 128 bits and consists of a VPID and a linear address as shown in Figure 31-2.",
    "operationText": "IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation\n    THEN VM exit;\nELSIF CPL > 0\n    THEN #GP(0);\n    ELSE\n        INVVPID_TYPE := value of register operand;\n        IF IA32_VMX_EPT_VPID_CAP MSR indicates that processor does not support\n        INVVPID_TYPE\n            THEN VMfail(Invalid operand to INVEPT/INVVPID);\n            ELSE // INVVPID_TYPE must be in the range 0–3\n                INVVPID_DESC := value of memory operand;\n                IF INVVPID_DESC[63:16] ≠ 0\n                    THEN VMfail(Invalid operand to INVEPT/INVVPID);\n                    ELSE\n                        CASE INVVPID_TYPE OF\n                            0:\n                                            // individual-address invalidation\n                                VPID := INVVPID_DESC[15:0];\n                                IF VPID = 0\n                                    THEN VMfail(Invalid operand to INVEPT/INVVPID);\n                                    ELSE\n                                        GL_ADDR := INVVPID_DESC[127:64];\n                                        IF (GL_ADDR is not in a canonical form)\n                                            THEN\n                                                VMfail(Invalid operand to INVEPT/INVVPID);\n                                            ELSE\n                                                Invalidate mappings for GL_ADDR tagged with VPID;\n                                                VMsucceed;\n                                        FI;\n                                FI;\n                                BREAK;\n                            1:\n                                            // single-context invalidation\n                                VPID := INVVPID_DESC[15:0];\n                                IF VPID = 0\n                                    THEN VMfail(Invalid operand to INVEPT/INVVPID);\n                                    ELSE\n                                        Invalidate all mappings tagged with VPID;\n                                        VMsucceed;\n                                FI;\n                                BREAK;\n                            2:\n                                            // all-context invalidation\n                                Invalidate all mappings tagged with all non-zero VPIDs;\n                                VMsucceed;\n                                BREAK;\n                            3:\n                                            // single-context invalidation retaining globals\n                                VPID := INVVPID_DESC[15:0];\n                                IF VPID = 0\n                                    THEN VMfail(Invalid operand to INVEPT/INVVPID);\n                                    ELSE\n                                        Invalidate all mappings tagged with VPID except global translations;\n                                        VMsucceed;\n                                FI;\n                                BREAK;\n                        ESAC;\n                FI;\n        FI;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the memory operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory operand.; \ncolumn_1: #SS(0); column_2: If the memory destination operand is in the SS segment and the memory address is in a non-canonical form.; \ncolumn_1: #UD; column_2: If not in VMX operation.; \ncolumn_1: If the logical processor does not support VPIDs (IA32_VMX_PROCBASED_CTLS2[37]=0).; \ncolumn_1: If the logical processor supports VPIDs (IA32_VMX_PROCBASED_CTLS2[37]=1) but does not support the INVVPID instruction (IA32_VMX_EPT_VPID_CAP[32]=0).;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the source operand is located in an execute-only code segment.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory operand.; \ncolumn_1: #SS(0); column_2: If the memory operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_2: If not in VMX operation.; column_1: #UD; \ncolumn_1: If the logical processor does not support VPIDs (IA32_VMX_PROCBASED_CTLS2[37]=0).; \ncolumn_1: If the logical processor supports VPIDs (IA32_VMX_PROCBASED_CTLS2[37]=1) but does not support the INVVPID instruction (IA32_VMX_EPT_VPID_CAP[32]=0).;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/por",
    "category": "Core Instructions",
    "instructionName": "POR\n\t\t— Bitwise Logical OR",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Bitwise OR of mm/m64 and mm.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F EB /r1 POR mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Bitwise OR of xmm2/m128 and xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F EB /r POR xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Bitwise OR of xmm2/m128 and xmm3.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Bitwise OR of ymm2/m256 and ymm3.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG EB /r VPOR ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise OR of packed doubleword integers in xmm2 and xmm3/m128/m32bcst using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 EB /r VPORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise OR of packed doubleword integers in ymm2 and ymm3/m256/m32bcst using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 EB /r VPORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise OR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 EB /r VPORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise OR of packed quadword integers in xmm2 and xmm3/m128/m64bcst using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 EB /r VPORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Bitwise OR of packed quadword integers in ymm2 and ymm3/m256/m64bcst using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 EB /r VPORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Bitwise OR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 EB /r VPORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.\n128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source and destination operands can be YMM registers.\nEVEX encoded version: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1 at 32/64-bit granularity.",
    "operationText": "DEST := DEST OR SRC\nDEST := DEST OR SRC\nDEST[MAXVL-1:128] (Unmodified)\nDEST := SRC1 OR SRC2\nDEST[MAXVL-1:128] := 0\nDEST := SRC1 OR SRC2\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC2 *is memory*)\n                THEN DEST[i+31:i] := SRC1[i+31:i] BITWISE OR SRC2[31:0]\n                ELSE DEST[i+31:i] := SRC1[i+31:i] BITWISE OR SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                *DEST[i+31:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI;\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aeskeygenassist",
    "category": "Core Instructions",
    "instructionName": "AESKEYGENASSIST\n\t\t— AES Round Key Generation Assist",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES",
        "Description": "Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A DF /r ib AESKEYGENASSIST xmm1, xmm2/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "Both AES and AVX flags",
        "Description": "Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG DF /r ib VAESKEYGENASSIST xmm1, xmm2/m128, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using 128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the result in the destination operand.\nThe destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "X3[31:0] := SRC [127: 96];\nX2[31:0] := SRC [95: 64];\nX1[31:0] := SRC [63: 32];\nX0[31:0] := SRC [31: 0];\nRCON[31:0] := ZeroExtend(imm8[7:0]);\nDEST[31:0] := SubWord(X1);\nDEST[63:32 ] := RotWord( SubWord(X1) ) XOR RCON;\nDEST[95:64] := SubWord(X3);\nDEST[127:96] := RotWord( SubWord(X3) ) XOR RCON;\nDEST[MAXVL-1:128] (Unmodified)\nX3[31:0] := SRC [127: 96];\nX2[31:0] := SRC [95: 64];\nX1[31:0] := SRC [63: 32];\nX0[31:0] := SRC [31: 0];\nRCON[31:0] := ZeroExtend(imm8[7:0]);\nDEST[31:0] := SubWord(X1);\nDEST[63:32 ] := RotWord( SubWord(X1) ) XOR RCON;\nDEST[95:64] := SubWord(X3);\nDEST[127:96] := RotWord( SubWord(X3) ) XOR RCON;\nDEST[MAXVL-1:128] := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/orpd",
    "category": "Core Instructions",
    "instructionName": "ORPD\n\t\t— Bitwise Logical OR of Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Return the bitwise logical OR of packed double precision floating-point values in xmm1 and xmm2/mem.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 56/r ORPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical OR of packed double precision floating-point values in xmm2 and xmm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F 56 /r VORPD xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the bitwise logical OR of packed double precision floating-point values in ymm2 and ymm3/mem.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.66.0F 56 /r VORPD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical OR of packed double precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 56 /r VORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Return the bitwise logical OR of packed double precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 56 /r VORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Return the bitwise logical OR of packed double precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 56 /r VORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a bitwise logical OR of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with write-mask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := SRC1[i+63:i] BITWISE OR SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := SRC1[i+63:i] BITWISE OR SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC1[63:0] BITWISE OR SRC2[63:0]\nDEST[127:64] := SRC1[127:64] BITWISE OR SRC2[127:64]\nDEST[191:128] := SRC1[191:128] BITWISE OR SRC2[191:128]\nDEST[255:192] := SRC1[255:192] BITWISE OR SRC2[255:192]\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := SRC1[63:0] BITWISE OR SRC2[63:0]\nDEST[127:64] := SRC1[127:64] BITWISE OR SRC2[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] BITWISE OR SRC[63:0]\nDEST[127:64] := DEST[127:64] BITWISE OR SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfcmulcph:vfmulcph",
    "category": "Core Instructions",
    "instructionName": "VFCMULCPH/VFMULCPH\n\t\t— Complex Multiply FP16 Values",
    "detailsTable": [
      {
        "Description": "Complex multiply a pair of FP16 values from xmm2 and complex conjugate of xmm3/m128/m32bcst, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F2.MAP6.W0 D6 /r VFCMULCPH xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from ymm2 and complex conjugate of ymm3/m256/m32bcst, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F2.MAP6.W0 D6 /r VFCMULCPH ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from zmm2 and complex conjugate of zmm3/m512/m32bcst, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F2.MAP6.W0 D6 /r VFCMULCPH zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from xmm2 and xmm3/m128/m32bcst, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.F3.MAP6.W0 D6 /r VFMULCPH xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from ymm2 and ymm3/m256/m32bcst, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.F3.MAP6.W0 D6 /r VFMULCPH ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from zmm2 and zmm3/m512/m32bcst, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.F3.MAP6.W0 D6 /r VFMULCPH zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpgatherqd:vpgatherqq",
    "category": "Core Instructions",
    "instructionName": "VPGATHERQD/VPGATHERQQ\n\t\t— Gather Packed Dword, Packed Qword with Signed Qword Indices",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 91 /vsib VPGATHERQD xmm1 {k1}, vm64x"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 91 /vsib VPGATHERQD xmm1 {k1}, vm64y"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 91 /vsib VPGATHERQD ymm1 {k1}, vm64z"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 91 /vsib VPGATHERQQ xmm1 {k1}, vm64x"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 91 /vsib VPGATHERQQ ymm1 {k1}, vm64y"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 91 /vsib VPGATHERQQ zmm1 {k1}, vm64z"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/setcc",
    "category": "Core Instructions",
    "instructionName": "SETcc\n\t\t— Set Byte on Condition",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if above (CF=0 and ZF=0).",
        "Instruction": "SETA r/m8",
        "Op/En": "M",
        "Opcode": "0F 97"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if above (CF=0 and ZF=0).",
        "Instruction": "SETA r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 97"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if above or equal (CF=0).",
        "Instruction": "SETAE r/m8",
        "Op/En": "M",
        "Opcode": "0F 93"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if above or equal (CF=0).",
        "Instruction": "SETAE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 93"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if below (CF=1).",
        "Instruction": "SETB r/m8",
        "Op/En": "M",
        "Opcode": "0F 92"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if below (CF=1).",
        "Instruction": "SETB r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 92"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if below or equal (CF=1 or ZF=1).",
        "Instruction": "SETBE r/m8",
        "Op/En": "M",
        "Opcode": "0F 96"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if below or equal (CF=1 or ZF=1).",
        "Instruction": "SETBE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 96"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if carry (CF=1).",
        "Instruction": "SETC r/m8",
        "Op/En": "M",
        "Opcode": "0F 92"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if carry (CF=1).",
        "Instruction": "SETC r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 92"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if equal (ZF=1).",
        "Instruction": "SETE r/m8",
        "Op/En": "M",
        "Opcode": "0F 94"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if equal (ZF=1).",
        "Instruction": "SETE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 94"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if greater (ZF=0 and SF=OF).",
        "Instruction": "SETG r/m8",
        "Op/En": "M",
        "Opcode": "0F 9F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if greater (ZF=0 and SF=OF).",
        "Instruction": "SETG r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if greater or equal (SF=OF).",
        "Instruction": "SETGE r/m8",
        "Op/En": "M",
        "Opcode": "0F 9D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if greater or equal (SF=OF).",
        "Instruction": "SETGE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if less (SF≠ OF).",
        "Instruction": "SETL r/m8",
        "Op/En": "M",
        "Opcode": "0F 9C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if less (SF≠ OF).",
        "Instruction": "SETL r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if less or equal (ZF=1 or SF≠ OF).",
        "Instruction": "SETLE r/m8",
        "Op/En": "M",
        "Opcode": "0F 9E"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if less or equal (ZF=1 or SF≠ OF).",
        "Instruction": "SETLE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9E"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not above (CF=1 or ZF=1).",
        "Instruction": "SETNA r/m8",
        "Op/En": "M",
        "Opcode": "0F 96"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not above (CF=1 or ZF=1).",
        "Instruction": "SETNA r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 96"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not above or equal (CF=1).",
        "Instruction": "SETNAE r/m8",
        "Op/En": "M",
        "Opcode": "0F 92"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not above or equal (CF=1).",
        "Instruction": "SETNAE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 92"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not below (CF=0).",
        "Instruction": "SETNB r/m8",
        "Op/En": "M",
        "Opcode": "0F 93"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not below (CF=0).",
        "Instruction": "SETNB r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 93"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not below or equal (CF=0 and ZF=0).",
        "Instruction": "SETNBE r/m8",
        "Op/En": "M",
        "Opcode": "0F 97"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not below or equal (CF=0 and ZF=0).",
        "Instruction": "SETNBE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 97"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not carry (CF=0).",
        "Instruction": "SETNC r/m8",
        "Op/En": "M",
        "Opcode": "0F 93"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not carry (CF=0).",
        "Instruction": "SETNC r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 93"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not equal (ZF=0).",
        "Instruction": "SETNE r/m8",
        "Op/En": "M",
        "Opcode": "0F 95"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not equal (ZF=0).",
        "Instruction": "SETNE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 95"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not greater (ZF=1 or SF≠ OF)",
        "Instruction": "SETNG r/m8",
        "Op/En": "M",
        "Opcode": "0F 9E"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not greater (ZF=1 or SF≠ OF).",
        "Instruction": "SETNG r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9E"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not greater or equal (SF≠ OF).",
        "Instruction": "SETNGE r/m8",
        "Op/En": "M",
        "Opcode": "0F 9C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not greater or equal (SF≠ OF).",
        "Instruction": "SETNGE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not less (SF=OF).",
        "Instruction": "SETNL r/m8",
        "Op/En": "M",
        "Opcode": "0F 9D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not less (SF=OF).",
        "Instruction": "SETNL r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9D"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not less or equal (ZF=0 and SF=OF).",
        "Instruction": "SETNLE r/m8",
        "Op/En": "M",
        "Opcode": "0F 9F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not less or equal (ZF=0 and SF=OF).",
        "Instruction": "SETNLE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9F"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not overflow (OF=0).",
        "Instruction": "SETNO r/m8",
        "Op/En": "M",
        "Opcode": "0F 91"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not overflow (OF=0).",
        "Instruction": "SETNO r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 91"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not parity (PF=0).",
        "Instruction": "SETNP r/m8",
        "Op/En": "M",
        "Opcode": "0F 9B"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not parity (PF=0).",
        "Instruction": "SETNP r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9B"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not sign (SF=0).",
        "Instruction": "SETNS r/m8",
        "Op/En": "M",
        "Opcode": "0F 99"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not sign (SF=0).",
        "Instruction": "SETNS r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 99"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if not zero (ZF=0).",
        "Instruction": "SETNZ r/m8",
        "Op/En": "M",
        "Opcode": "0F 95"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if not zero (ZF=0).",
        "Instruction": "SETNZ r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 95"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if overflow (OF=1)",
        "Instruction": "SETO r/m8",
        "Op/En": "M",
        "Opcode": "0F 90"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if overflow (OF=1).",
        "Instruction": "SETO r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 90"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if parity (PF=1).",
        "Instruction": "SETP r/m8",
        "Op/En": "M",
        "Opcode": "0F 9A"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if parity (PF=1).",
        "Instruction": "SETP r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9A"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if parity even (PF=1).",
        "Instruction": "SETPE r/m8",
        "Op/En": "M",
        "Opcode": "0F 9A"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if parity even (PF=1).",
        "Instruction": "SETPE r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9A"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if parity odd (PF=0).",
        "Instruction": "SETPO r/m8",
        "Op/En": "M",
        "Opcode": "0F 9B"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if parity odd (PF=0).",
        "Instruction": "SETPO r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 9B"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if sign (SF=1).",
        "Instruction": "SETS r/m8",
        "Op/En": "M",
        "Opcode": "0F 98"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if sign (SF=1).",
        "Instruction": "SETS r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 98"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set byte if zero (ZF=1).",
        "Instruction": "SETZ r/m8",
        "Op/En": "M",
        "Opcode": "0F 94"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Set byte if zero (ZF=1).",
        "Instruction": "SETZ r/m81",
        "Op/En": "M",
        "Opcode": "REX + 0F 94"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.\nThe terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.\nMany of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.\nSome languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.\nThe reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.\nIn IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
    "operationText": "IF condition\n    THEN DEST := 1;\n    ELSE DEST := 0;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ptest",
    "category": "Core Instructions",
    "instructionName": "PTEST\n\t\t— Logical Compare",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 17 /r PTEST xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Set ZF and CF depending on bitwise AND and ANDN of sources.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 17 /r VPTEST xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Set ZF and CF depending on bitwise AND and ANDN of sources.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 17 /r VPTEST ymm1, ymm2/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "PTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.\nThe first source register is specified by the ModR/M reg field.\n128-bit versions: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.\nVEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "IF (SRC[127:0] BITWISE AND DEST[127:0] = 0)\n    THEN ZF := 1;\n    ELSE ZF := 0;\nIF (SRC[127:0] BITWISE AND NOT DEST[127:0] = 0)\n    THEN CF := 1;\n    ELSE CF := 0;\nDEST (unmodified)\nAF := OF := PF := SF := 0;\nIF (SRC[255:0] BITWISE AND DEST[255:0] = 0) THEN ZF := 1;\n    ELSE ZF := 0;\nIF (SRC[255:0] BITWISE AND NOT DEST[255:0] = 0) THEN CF := 1;\n    ELSE CF := 0;\nDEST (unmodified)\nAF := OF := PF := SF := 0;",
    "flagsAffectedText": "The OF, AF, PF, SF flags are cleared and the ZF, CF flags are set according to the operation.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/loop:loopcc",
    "category": "Core Instructions",
    "instructionName": "LOOP/LOOPcc\n\t\t— Loop According to ECX Counter",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Decrement count; jump short if count ≠ 0.",
        "Instruction": "LOOP rel8",
        "Op/En": "D",
        "Opcode": "E2 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Decrement count; jump short if count ≠ 0 and ZF = 1.",
        "Instruction": "LOOPE rel8",
        "Op/En": "D",
        "Opcode": "E1 cb"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Decrement count; jump short if count ≠ 0 and ZF = 0.",
        "Instruction": "LOOPNE rel8",
        "Op/En": "D",
        "Opcode": "E0 cb"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Operand 1 Operand 2 Operand 3": "D Offset N/A N/A",
        "Operand 4": "N/A",
        "column_2": "",
        "column_3": "",
        "column_4": ""
      }
    ],
    "descriptionText": "Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.\nEach time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.\nThe target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of –128 to +127 are allowed with this instruction.\nSome forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.",
    "operationText": "IF (AddressSize = 32)\n    THEN Count is ECX;\nELSE IF (AddressSize = 64)\n    Count is RCX;\nELSE Count is CX;\nFI;\nCount := Count – 1;\nIF Instruction is not LOOP\n    THEN\n        IF (Instruction := LOOPE) or (Instruction := LOOPZ)\n            THEN IF (ZF = 1) and (Count ≠ 0)\n                    THEN BranchCond := 1;\n                    ELSE BranchCond := 0;\n                FI;\n            ELSE (Instruction = LOOPNE) or (Instruction = LOOPNZ)\n                IF (ZF = 0 ) and (Count ≠ 0)\n                    THEN BranchCond := 1;\n                    ELSE BranchCond := 0;\n        FI;\n    ELSE (* Instruction = LOOP *)\n        IF (Count ≠ 0)\n            THEN BranchCond := 1;\n            ELSE BranchCond := 0;\n        FI;\nFI;\nIF BranchCond = 1\n    THEN\n        IF in 64-bit mode (* OperandSize = 64 *)\n            THEN\n                tempRIP := RIP + SignExtend(DEST);\n                IF tempRIP is not canonical\n                    THEN #GP(0);\n                ELSE RIP := tempRIP;\n                FI;\n            ELSE\n                tempEIP := EIP SignExtend(DEST);\n                IF OperandSize 16\n                    THEN tempEIP := tempEIP AND 0000FFFFH;\n                FI;\n                IF tempEIP is not within code segment limit\n                    THEN #GP(0);\n                    ELSE EIP := tempEIP;\n                FI;\n        FI;\n    ELSE\n        Terminate loop and continue program execution at (R/E)IP;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtpd2uqq",
    "category": "Core Instructions",
    "instructionName": "VCVTPD2UQQ\n\t\t— Convert Packed Double Precision Floating-Point Values to Packed UnsignedQuadword Integers",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed double precision floating-point values from xmm2/mem to two packed unsigned quadword integers in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 79 /r VCVTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert fourth packed double precision floating-point values from ymm2/mem to four packed unsigned quadword integers in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 79 /r VCVTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed double precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 79 /r VCVTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/mwait",
    "category": "Core Instructions",
    "instructionName": "MWAIT\n\t\t— Monitor Wait",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.",
        "Instruction": "MWAIT",
        "Op/En": "ZO",
        "Opcode": "0F 01 C9"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "MWAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state. There are two principal targeted usages: address-range monitor and advanced power management. Both usages of MWAIT require the use of the MONITOR instruction.\nCPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set, MWAIT may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling MWAIT clears the CPUID feature flag and causes execution to generate an invalid-opcode exception.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.\nECX specifies optional extensions for the MWAIT instruction. EAX may contain hints such as the preferred optimized state the processor should enter. The first processors to implement MWAIT supported only the zero value for EAX and ECX. Later processors allowed setting ECX[0] to enable masked interrupts as break events for MWAIT (see below). Software can use the CPUID instruction to determine the extensions and hints supported by the processor.",
    "operationText": "(* MWAIT takes the argument in EAX as a hint extension and is architected to take the argument in ECX as an instruction extension\nMWAIT EAX, ECX *)\n{\nWHILE ( (“Monitor Hardware is in armed state”)) {\n    implementation_dependent_optimized_state(EAX, ECX); }\nSet the state of Monitor Hardware as triggered;\n}",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: If RCX[0] = 1 and CPUID.05H:ECX[bit 1] = 0.; \ncolumn_1: #UD; column_2: If the current privilege level is not 0.; \ncolumn_1: If CPUID.01H:ECX.MONITOR[bit 3] = 0.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "numeric¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: If ECX[0] = 1 and CPUID.05H:ECX[bit 1] = 0.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.MONITOR[bit 3] = 0.; \ncolumn_1: If current privilege level is not 0.;"
      ],
      "realAddressMode¶": [
        "column_1: If ECX[0] = 1 and CPUID.05H:ECX[bit 1] = 0.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.MONITOR[bit 3] = 0.;"
      ],
      "virtual8086Mode¶": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmadd132sh:vfnmadd132sh:vfmadd213sh:vfnmadd213sh:vfmadd231sh:vfnmadd231sh",
    "category": "Core Instructions",
    "instructionName": "VFMADD132SH/VFNMADD132SH/VFMADD213SH/VFNMADD213SH/VFMADD231SH/VFNMADD231SH\n\t\t— Fused Multiply-Add of Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Multiply FP16 values from xmm1 and xmm3/m16, add to xmm2, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 99 /r VFMADD132SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm1 and xmm2, add to xmm3/m16, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 A9 /r VFMADD213SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm2 and xmm3/m16, add to xmm1, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 B9 /r VFMADD231SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm1 and xmm3/m16, and negate the value. Add this value to xmm2, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 9D /r VFNMADD132SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm1 and xmm2, and negate the value. Add this value to xmm3/m16, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 AD /r VFNMADD213SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Multiply FP16 values from xmm2 and xmm3/m16, and negate the value. Add this value to xmm1, and store the result in xmm1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 BD /r VFNMADD231SH xmm1{k1}{z}, xmm2, xmm3/m16 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xrstors",
    "category": "Core Instructions",
    "instructionName": "XRSTORS\n\t\t— Restore Processor Extended States Supervisor",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "XSS",
        "Description": "Restore state components specified by EDX:EAX from mem.",
        "Op/En": "M",
        "Opcode / Instruction": "NP 0F C7 /3 XRSTORS mem"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "XSS",
        "Description": "Restore state components specified by EDX:EAX from mem.",
        "Op/En": "M",
        "Opcode / Instruction": "NP REX.W + 0F C7 /3 XRSTORS64 mem"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if CPL = 0.\nThe format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nSection 13.12, “Operation of XRSTORS,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a high-level outline:\nUse of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.\nSee Section 13.6, “Processor Tracking of XSAVE-Managed State,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for discussion of the bitmaps XINUSE and XMODIFIED and of the quantity XRSTOR_INFO.",
    "operationText": "RFBM := (XCR0 OR IA32_XSS) AND EDX:EAX;\n                            /* bitwise logical OR and AND */\nCOMPMASK := XCOMP_BV field from XSAVE header;\nRSTORMASK := XSTATE_BV field from XSAVE header;\nFORMAT = COMPMASK AND 7FFFFFFF_FFFFFFFFH;\nRESTORE_FEATURES = FORMAT AND RFBM;\nTO_BE_RESTORED := RESTORE_FEATURES AND RSTORMASK;\nFORCE_INIT := RFBM AND NOT FORMAT;\nTO_BE_INITIALIZED = (RFBM AND NOT RSTORMASK) OR FORCE_INIT;\nIF TO_BE_RESTORED[0] = 1\n    THEN\n        XINUSE[0] := 1;\n        load x87 state from legacy region of XSAVE area;\nELSIF TO_BE_INITIALIZED[0] = 1\n    THEN\n        XINUSE[0] := 0;\n        initialize x87 state;\nFI;\nIF TO_BE_RESTORED[1] = 1\n    THEN\n        XINUSE[1] := 1;\n        load SSE state from legacy region of XSAVE area; // this step loads the XMM registers and MXCSR\nELSIF TO_BE_INITIALIZED[1] = 1\n    THEN\n        set all XMM registers to 0;\n        XINUSE[1] := 0;\n        MXCSR := 1F80H;\nFI;\nNEXT_FEATURE_OFFSET = 576;\n                        // Legacy area and XSAVE header consume 576 bytes\nFOR i := 2 TO 62\n    IF FORMAT[i] = 1\n        THEN\n            IF TO_BE_RESTORED[i] = 1\n                THEN\n                    XINUSE[i] := 1;\n                    load XSAVE state component i at offset NEXT_FEATURE_OFFSET from base of XSAVE area;\n            FI;\n            NEXT_FEATURE_OFFSET = NEXT_FEATURE_OFFSET + n (n enumerated by CPUID(EAX=0DH,ECX=i):EAX);\n    FI;\n    IF TO_BE_INITIALIZED[i] = 1\n        THEN\n            XINUSE[i] := 0;\n            initialize XSAVE state component i;\n    FI;\nENDFOR;\nXMODIFIED := NOT RFBM;\nIF in VMX non-root operation\n    THEN VMXNR := 1;\n    ELSE VMXNR := 0;\nFI;\nLAXA := linear address of XSAVE area;\nXRSTOR_INFO := CPL,VMXNR,LAXA,COMPMASK;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: If a memory address is in a non-canonical form.; \ncolumn_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: If bit 63 of the XCOMP_BV field of the XSAVE header is 0.; \ncolumn_1: If a bit in XCR0|IA32_XSS is 0 and the corresponding bit in the XCOMP_BV field of the XSAVE header is 1.; \ncolumn_1: If a bit in the XCOMP_BV field in the XSAVE header is 0 and the corresponding bit in the XSTATE_BV field is 1.; \ncolumn_1: If bytes 63:16 of the XSAVE header are not all zero.; \ncolumn_1: If attempting to write any reserved bits of the MXCSR register with 1.; \ncolumn_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0.; column_1: #UD; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If a memory operand is not aligned on a 64-byte boundary, regardless of segment.; \ncolumn_1: If bit 63 of the XCOMP_BV field of the XSAVE header is 0.; \ncolumn_1: If a bit in XCR0|IA32_XSS is 0 and the corresponding bit in the XCOMP_BV field of the XSAVE header is 1.; \ncolumn_1: If a bit in the XCOMP_BV field in the XSAVE header is 0 and the corresponding bit in the XSTATE_BV field is 1.; \ncolumn_1: If bytes 63:16 of the XSAVE header are not all zero.; \ncolumn_1: If attempting to write any reserved bits of the MXCSR register with 1.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If any part of the operand lies outside the effective address space from 0 to FFFFH.; \ncolumn_1: If bit 63 of the XCOMP_BV field of the XSAVE header is 0.; \ncolumn_1: If a bit in XCR0|IA32_XSS is 0 and the corresponding bit in the XCOMP_BV field of the XSAVE header is 1.; \ncolumn_1: If a bit in the XCOMP_BV field in the XSAVE header is 0 and the corresponding bit in the XSTATE_BV field is 1.; \ncolumn_1: If bytes 63:16 of the XSAVE header are not all zero.; \ncolumn_1: If attempting to write any reserved bits of the MXCSR register with 1.; \ncolumn_1: #NM; column_2: If CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0.; \ncolumn_1: If CR4.OSXSAVE[bit 18] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/in",
    "category": "Core Instructions",
    "instructionName": "IN\n\t\t— Input From Port",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input byte from imm8 I/O port address into AL.",
        "Instruction": "IN AL, imm8",
        "Op/En": "I",
        "Opcode": "E4 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input word from imm8 I/O port address into AX.",
        "Instruction": "IN AX, imm8",
        "Op/En": "I",
        "Opcode": "E5 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input dword from imm8 I/O port address into EAX.",
        "Instruction": "IN EAX, imm8",
        "Op/En": "I",
        "Opcode": "E5 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input byte from I/O port in DX into AL.",
        "Instruction": "IN AL,DX",
        "Op/En": "ZO",
        "Opcode": "EC"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input word from I/O port in DX into AX.",
        "Instruction": "IN AX,DX",
        "Op/En": "ZO",
        "Opcode": "ED"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Input doubleword from I/O port in DX into EAX.",
        "Instruction": "IN EAX,DX",
        "Op/En": "ZO",
        "Opcode": "ED"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "I",
        "Operand 1": "imm8",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Copies the value from the I/O port specified with the second operand (source operand) to the destination operand (first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte immediate allows I/O port addresses 0 to 255 to be accessed.\nWhen accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port, the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.\nThis instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 19, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF ((PE = 1) and ((CPL > IOPL) or (VM = 1)))\n    THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)\n        IF (Any I/O Permission Bit for I/O port being accessed = 1)\n            THEN (* I/O operation is not allowed *)\n                #GP(0);\n            ELSE ( * I/O operation is allowed *)\n                DEST := SRC; (* Read from selected I/O port *)\n        FI;\n    ELSE (Real Mode or Protected Mode with CPL ≤ IOPL *)\n        DEST := SRC; (* Read from selected I/O port *)\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgatherqps:vgatherqpd",
    "category": "Core Instructions",
    "instructionName": "VGATHERQPS/VGATHERQPD\n\t\t— Gather Packed Single, Packed Double with Signed Qword Indices",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 93 /vsib VGATHERQPS xmm1 {k1}, vm64x"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 93 /vsib VGATHERQPS xmm1 {k1}, vm64y"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 93 /vsib VGATHERQPS ymm1 {k1}, vm64z"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 93 /vsib VGATHERQPD xmm1 {k1}, vm64x"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Using signed qword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 93 /vsib VGATHERQPD ymm1 {k1}, vm64y"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Using signed qword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 93 /vsib VGATHERQPD zmm1 {k1}, vm64z"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpshld",
    "category": "Core Instructions",
    "instructionName": "VPSHLD\n\t\t— Concatenate and Shift Packed Data Left Logical",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 70 /r /ib VPSHLDW xmm1{k1}{z}, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 70 /r /ib VPSHLDW ymm1{k1}{z}, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 70 /r /ib VPSHLDW zmm1{k1}{z}, zmm2, zmm3/m512, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 71 /r /ib VPSHLDD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 71 /r /ib VPSHLDD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 71 /r /ib VPSHLDD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 71 /r /ib VPSHLDQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2 AVX512VL",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 71 /r /ib VPSHLDQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_VBMI2",
        "Description": "Concatenate destination and source operands, extract result shifted to the left by constant value in imm8 into zmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 71 /r /ib VPSHLDQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/esetcontext",
    "category": "SGX Instructions",
    "instructionName": "ESETCONTEXT\n\t\t— Set the ENCLAVECONTEXT Field in SECS",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "EAX[5]",
        "Description": "This leaf function sets the ENCLAVECONTEXT field in SECS.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 02H ENCLV[ESETCONTEXT]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "ESETCONTEXT (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Address of the destination EPC page (In, EA)",
        "column_5": "Context Value (In, EA)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/mulsd",
    "category": "Core Instructions",
    "instructionName": "MULSD\n\t\t— Multiply Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Multiply the low double precision floating-point value in xmm2/m64 by low double precision floating-point value in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 59 /r MULSD xmm1,xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Multiply the low double precision floating-point value in xmm3/m64 by low double precision floating-point value in xmm2.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 59 /r VMULSD xmm1,xmm2, xmm3/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply the low double precision floating-point value in xmm3/m64 by low double precision floating-point value in xmm2.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 59 /r VMULSD xmm1 {k1}{z}, xmm2, xmm3/m64 {er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Multiplies the low double precision floating-point value in the second source operand by the low double precision floating-point value in the first source operand, and stores the double precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source operand and the destination operands are XMM registers.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded version: The quadword at bits 127:64 of the destination operand is copied from the same bits of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: The low quadword element of the destination operand is updated according to the write-mask.\nSoftware should ensure VMULSD is encoded with VEX.L=0. Encoding VMULSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := SRC1[63:0] * SRC2[63:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n            FI\n    FI;\nENDFOR\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0] * SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] * SRC[63:0]\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rstorssp",
    "category": "Core Instructions",
    "instructionName": "RSTORSSP\n\t\t— Restore Saved Shadow Stack Pointer",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "CET_SS",
        "Description": "Restore SSP.",
        "Op/En": "M",
        "Opcode/Instruction": "F3 0F 01 /5 (mod!=11, /5, memory only) RSTORSSP m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Restores SSP from the shadow-stack-restore token pointed to by m64. If the SSP restore was successful then the instruction replaces the shadow-stack-restore token with a previous-ssp token. The instruction sets the CF flag to indicate whether the SSP address recorded in the shadow-stack-restore token that was processed was 4 byte aligned, i.e., whether an alignment hole was created when the restore-shadow-stack token was pushed on this shadow stack.\nFollowing RSTORSSP if a restore-shadow-stack token needs to be saved on the previous shadow stack, use the SAVEPREVSSP instruction.\nIf pushing a restore-shadow-stack token on the previous shadow stack is not required, the previous-ssp token can be popped using the INCSSPQ instruction. If the CF flag was set to indicate presence of an alignment hole, an additional INCSSPD instruction is needed to advance the SSP past the alignment hole.",
    "operationText": "IF CPL = 3\n        IF (CR4.CET & IA32_U_CET.SH_STK_EN) = 0\n            THEN #UD; FI;\nELSE\n        IF (CR4.CET & IA32_S_CET.SH_STK_EN) = 0\n            THEN #UD; FI;\nFI;\nSSP_LA = Linear_Address(mem operand)\nIF SSP_LA not aligned to 8 bytes\n        THEN #GP(0); FI;\nprevious_ssp_token = SSP | (IA32_EFER.LMA AND CS.L) | 0x02\nStart Atomic Execution\nrestore_ssp_token = Locked shadow_stack_load 8 bytes from SSP_LA\nfault = 0\nIF ((restore_ssp_token & 0x03) != (IA32_EFER.LMA & CS.L))\n        THEN fault = 1; FI; (* If L flag in token does not match IA32_EFER.LMA & CS.L or bit 1 is not 0 *)\nIF ((IA32_EFER.LMA AND CS.L) = 0 AND restore_ssp_token[63:32] != 0)\n        THEN fault = 1; FI; (* If compatibility/legacy mode and SSP to be restored not below 4G *)\nTMP = restore_ssp_token & ~0x01\nTMP = (TMP - 8)\nTMP = TMP & ~0x07\nIF TMP != SSP_LA\n        THEN fault = 1; FI; (* If address in token does not match the requested top of stack *)\nTMP = (fault == 0) ? previous_ssp_token : restore_ssp_token\nshadow_stack_store 8 bytes of TMP to SSP_LA and release lock\nEnd Atomic Execution\nIF fault == 1\n    THEN #CP(RSTORSSP); FI;\nSSP = SSP_LA\n// Set the CF if the SSP in the restore token was 4 byte aligned, i.e., there is an alignment hole\nRFLAGS.CF = (restore_ssp_token & 0x04) ? 1 : 0;\nRFLAGS.ZF,PF,AF,OF,SF := 0;",
    "flagsAffectedText": "CF is set to indicate if the shadow stack pointer in the restore token was 4 byte aligned, else it is cleared. ZF, PF, AF, OF, and SF are cleared.",
    "exceptions": {
      "64BitMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: If CPL = 3 and IA32_U_CET.SH_STK_EN = 0.; \ncolumn_1: If CPL < 3 and IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: #GP(0); column_2: If linear address of memory operand not 8 byte aligned.; \ncolumn_1: If a memory address is in a non-canonical form.; \ncolumn_2: If a memory address referencing the SS segment is in a non-canonical form.; column_1: #SS(0); \ncolumn_1: #CP(rstorssp); column_2: If L bit in token does not match (IA32_EFER.LMA & CS.L).; \ncolumn_1: If address in token does not match linear address of memory operand.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code);"
      ],
      "compatibilityMode": [
        "Same as protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: If CR4.CET = 0.; \ncolumn_1: IF CPL = 3 and IA32_U_CET.SH_STK_EN = 0.; \ncolumn_1: IF CPL < 3 and IA32_S_CET.SH_STK_EN = 0.; \ncolumn_1: #GP(0); column_2: If linear address of memory operand not 8 byte aligned.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If destination is located in a non-writeable segment.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #CP(rstorssp); column_2: If L bit in token does not match (IA32_EFER.LMA & CS.L).; \ncolumn_1: If address in token does not match linear address of memory operand.; \ncolumn_1: If in 32-bit or compatibility mode and the address in token is not below 4G.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/adc",
    "category": "Core Instructions",
    "instructionName": "ADC\n\t\t— Add With Carry",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry imm8 to AL.",
        "Instruction": "ADC AL, imm8",
        "Op/En": "I",
        "Opcode": "14 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry imm16 to AX.",
        "Instruction": "ADC AX, imm16",
        "Op/En": "I",
        "Opcode": "15 iw"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry imm32 to EAX.",
        "Instruction": "ADC EAX, imm32",
        "Op/En": "I",
        "Opcode": "15 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add with carry imm32 sign extended to 64-bits to RAX.",
        "Instruction": "ADC RAX, imm32",
        "Op/En": "I",
        "Opcode": "REX.W + 15 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry imm8 to r/m8.",
        "Instruction": "ADC r/m8, imm8",
        "Op/En": "MI",
        "Opcode": "80 /2 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add with carry imm8 to r/m8.",
        "Instruction": "ADC r/m8*, imm8",
        "Op/En": "MI",
        "Opcode": "REX + 80 /2 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry imm16 to r/m16.",
        "Instruction": "ADC r/m16, imm16",
        "Op/En": "MI",
        "Opcode": "81 /2 iw"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with CF imm32 to r/m32.",
        "Instruction": "ADC r/m32, imm32",
        "Op/En": "MI",
        "Opcode": "81 /2 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add with CF imm32 sign extended to 64-bits to r/m64.",
        "Instruction": "ADC r/m64, imm32",
        "Op/En": "MI",
        "Opcode": "REX.W + 81 /2 id"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with CF sign-extended imm8 to r/m16.",
        "Instruction": "ADC r/m16, imm8",
        "Op/En": "MI",
        "Opcode": "83 /2 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with CF sign-extended imm8 into r/m32.",
        "Instruction": "ADC r/m32, imm8",
        "Op/En": "MI",
        "Opcode": "83 /2 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add with CF sign-extended imm8 into r/m64.",
        "Instruction": "ADC r/m64, imm8",
        "Op/En": "MI",
        "Opcode": "REX.W + 83 /2 ib"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry byte register to r/m8.",
        "Instruction": "ADC r/m8, r8",
        "Op/En": "MR",
        "Opcode": "10 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add with carry byte register to r/m64.",
        "Instruction": "ADC r/m8*, r8*",
        "Op/En": "MR",
        "Opcode": "REX + 10 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry r16 to r/m16.",
        "Instruction": "ADC r/m16, r16",
        "Op/En": "MR",
        "Opcode": "11 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with CF r32 to r/m32.",
        "Instruction": "ADC r/m32, r32",
        "Op/En": "MR",
        "Opcode": "11 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add with CF r64 to r/m64.",
        "Instruction": "ADC r/m64, r64",
        "Op/En": "MR",
        "Opcode": "REX.W + 11 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry r/m8 to byte register.",
        "Instruction": "ADC r8, r/m8",
        "Op/En": "RM",
        "Opcode": "12 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add with carry r/m64 to byte register.",
        "Instruction": "ADC r8*, r/m8*",
        "Op/En": "RM",
        "Opcode": "REX + 12 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with carry r/m16 to r16.",
        "Instruction": "ADC r16, r/m16",
        "Op/En": "RM",
        "Opcode": "13 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Add with CF r/m32 to r32.",
        "Instruction": "ADC r32, r/m32",
        "Op/En": "RM",
        "Opcode": "13 /r"
      },
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Add with CF r/m64 to r64.",
        "Instruction": "ADC r64, r/m64",
        "Op/En": "RM",
        "Opcode": "REX.W + 13 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "I",
        "Operand 1": "AL/AX/EAX/RAX",
        "Operand 2": "imm8/16/32",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.\nThe ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.\nThe ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := DEST + SRC + CF;",
    "flagsAffectedText": "The OF, SF, ZF, AF, CF, and PF flags are set according to the result.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vplzcntd:vplzcntq",
    "category": "Core Instructions",
    "instructionName": "VPLZCNTD/VPLZCNTQ\n\t\t— Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Count the number of leading zero bits in each dword element of xmm2/m128/m32bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 44 /r VPLZCNTD xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Count the number of leading zero bits in each dword element of ymm2/m256/m32bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 44 /r VPLZCNTD ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512CD",
        "Description": "Count the number of leading zero bits in each dword element of zmm2/m512/m32bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 44 /r VPLZCNTD zmm1 {k1}{z}, zmm2/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Count the number of leading zero bits in each qword element of xmm2/m128/m64bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 44 /r VPLZCNTQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512CD",
        "Description": "Count the number of leading zero bits in each qword element of ymm2/m256/m64bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 44 /r VPLZCNTQ ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512CD",
        "Description": "Count the number of leading zero bits in each qword element of zmm2/m512/m64bcst using writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 44 /r VPLZCNTQ zmm1 {k1}{z}, zmm2/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/neg",
    "category": "Core Instructions",
    "instructionName": "NEG\n\t\t— Two's Complement Negation",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Two's complement negate r/m8.",
        "Instruction": "NEG r/m8",
        "Op/En": "M",
        "Opcode": "F6 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Two's complement negate r/m8.",
        "Instruction": "NEG r/m81",
        "Op/En": "M",
        "Opcode": "REX + F6 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Two's complement negate r/m16.",
        "Instruction": "NEG r/m16",
        "Op/En": "M",
        "Opcode": "F7 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Two's complement negate r/m32.",
        "Instruction": "NEG r/m32",
        "Op/En": "M",
        "Opcode": "F7 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Two's complement negate r/m64.",
        "Instruction": "NEG r/m64",
        "Op/En": "M",
        "Opcode": "REX.W + F7 /3"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.\nThis instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "IF DEST = 0\n    THEN CF := 0;\n    ELSE CF := 1;\nFI;\nDEST := [– (DEST)]",
    "flagsAffectedText": "The CF flag set to 0 if the source operand is 0; otherwise it is set to 1. The OF, SF, ZF, AF, and PF flags are set according to the result.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "compatibilityMode": [
        "Same as for protected mode exceptions."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used but the destination is not a memory operand.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vptestnmb:vptestnmw:vptestnmd:vptestnmq",
    "category": "Core Instructions",
    "instructionName": "VPTESTNMB/VPTESTNMW/VPTESTNMD/VPTESTNMQ\n\t\t— Logical NAND and Set",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512VL AVX512BW",
        "Description": "Bitwise NAND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 26 /r VPTESTNMB k2 {k1}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512VL AVX512BW",
        "Description": "Bitwise NAND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 26 /r VPTESTNMB k2 {k1}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512F AVX512BW",
        "Description": "Bitwise NAND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 26 /r VPTESTNMB k2 {k1}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512VL AVX512BW",
        "Description": "Bitwise NAND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W1 26 /r VPTESTNMW k2 {k1}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512VL AVX512BW",
        "Description": "Bitwise NAND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W1 26 /r VPTESTNMW k2 {k1}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512F AVX512BW",
        "Description": "Bitwise NAND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W1 26 /r VPTESTNMW k2 {k1}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512VL AVX512F",
        "Description": "Bitwise NAND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W0 27 /r VPTESTNMD k2 {k1}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512VL AVX512F",
        "Description": "Bitwise NAND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W0 27 /r VPTESTNMD k2 {k1}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512F",
        "Description": "Bitwise NAND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W0 27 /r VPTESTNMD k2 {k1}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512VL AVX512F",
        "Description": "Bitwise NAND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.F3.0F38.W1 27 /r VPTESTNMQ k2 {k1}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512VL AVX512F",
        "Description": "Bitwise NAND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.F3.0F38.W1 27 /r VPTESTNMQ k2 {k1}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID": "AVX512F",
        "Description": "Bitwise NAND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.F3.0F38.W1 27 /r VPTESTNMQ k2 {k1}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pblendvb",
    "category": "Core Instructions",
    "instructionName": "PBLENDVB\n\t\t— Variable Blend Packed Bytes",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 10 /r PBLENDVB xmm1, xmm2/m128, <XMM0>"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1.",
        "Op/En": "RVMR",
        "Opcode/Instruction": "VEX.128.66.0F3A.W0 4C /r /is4 VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1.",
        "Op/En": "RVMR",
        "Opcode/Instruction": "VEX.256.66.0F3A.W0 4C /r /is4 VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "<XMM0>",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMR",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8[7:4]"
      }
    ],
    "descriptionText": "Conditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the most significant bit in each byte element of the XMM0 register.\nIf a mask bit is “1\", then the corresponding byte element in the source operand is copied to the destination, else the byte element in the destination operand is left unchanged.\nThe register assignment of the implicit third operand is defined to be the architectural register XMM0.\n128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute PBLENDVB with a VEX prefix will cause #UD.\nVEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.L must be 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction will #UD.\nVEX.256 encoded version: The first source operand and the destination operand are YMM registers. The second source operand is an YMM register or 256-bit memory location. The third source register is an YMM register and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored.\nVPBLENDVB permits the mask to be any XMM or YMM register. In contrast, PBLENDVB treats XMM0 implicitly as the mask and do not support non-destructive destination operation. An attempt to execute PBLENDVB encoded with a VEX prefix will cause a #UD exception.",
    "operationText": "MASK := XMM0\nIF (MASK[7] = 1) THEN DEST[7:0] := SRC[7:0];\nELSE DEST[7:0] := DEST[7:0];\nIF (MASK[15] = 1) THEN DEST[15:8] := SRC[15:8];\nELSE DEST[15:8] := DEST[15:8];\nIF (MASK[23] = 1) THEN DEST[23:16] := SRC[23:16]\nELSE DEST[23:16] := DEST[23:16];\nIF (MASK[31] = 1) THEN DEST[31:24] := SRC[31:24]\nELSE DEST[31:24] := DEST[31:24];\nIF (MASK[39] = 1) THEN DEST[39:32] := SRC[39:32]\nELSE DEST[39:32] := DEST[39:32];\nIF (MASK[47] = 1) THEN DEST[47:40] := SRC[47:40]\nELSE DEST[47:40] := DEST[47:40];\nIF (MASK[55] = 1) THEN DEST[55:48] := SRC[55:48]\nELSE DEST[55:48] := DEST[55:48];\nIF (MASK[63] = 1) THEN DEST[63:56] := SRC[63:56]\nELSE DEST[63:56] := DEST[63:56];\nIF (MASK[71] = 1) THEN DEST[71:64] := SRC[71:64]\nELSE DEST[71:64] := DEST[71:64];\nIF (MASK[79] = 1) THEN DEST[79:72] := SRC[79:72]\nELSE DEST[79:72] := DEST[79:72];\nIF (MASK[87] = 1) THEN DEST[87:80] := SRC[87:80]\nELSE DEST[87:80] := DEST[87:80];\nIF (MASK[95] = 1) THEN DEST[95:88] := SRC[95:88]\nELSE DEST[95:88] := DEST[95:88];\nIF (MASK[103] = 1) THEN DEST[103:96] := SRC[103:96]\nELSE DEST[103:96] := DEST[103:96];\nIF (MASK[111] = 1) THEN DEST[111:104] := SRC[111:104]\nELSE DEST[111:104] := DEST[111:104];\nIF (MASK[119] = 1) THEN DEST[119:112] := SRC[119:112]\nELSE DEST[119:112] := DEST[119:112];\nIF (MASK[127] = 1) THEN DEST[127:120] := SRC[127:120]\nELSE DEST[127:120] := DEST[127:120])\nDEST[MAXVL-1:128] (Unmodified)\nMASK := SRC3\nIF (MASK[7] = 1) THEN DEST[7:0] := SRC2[7:0];\nELSE DEST[7:0] := SRC1[7:0];\nIF (MASK[15] = 1) THEN DEST[15:8] := SRC2[15:8];\nELSE DEST[15:8] := SRC1[15:8];\nIF (MASK[23] = 1) THEN DEST[23:16] := SRC2[23:16]\nELSE DEST[23:16] := SRC1[23:16];\nIF (MASK[31] = 1) THEN DEST[31:24] := SRC2[31:24]\nELSE DEST[31:24] := SRC1[31:24];\nIF (MASK[39] = 1) THEN DEST[39:32] := SRC2[39:32]\nELSE DEST[39:32] := SRC1[39:32];\nIF (MASK[47] = 1) THEN DEST[47:40] := SRC2[47:40]\nELSE DEST[47:40] := SRC1[47:40];\nIF (MASK[55] = 1) THEN DEST[55:48] := SRC2[55:48]\nELSE DEST[55:48] := SRC1[55:48];\nIF (MASK[63] = 1) THEN DEST[63:56] := SRC2[63:56]\nELSE DEST[63:56] := SRC1[63:56];\nIF (MASK[71] = 1) THEN DEST[71:64] := SRC2[71:64]\nELSE DEST[71:64] := SRC1[71:64];\nIF (MASK[79] = 1) THEN DEST[79:72] := SRC2[79:72]\nELSE DEST[79:72] := SRC1[79:72];\nIF (MASK[87] = 1) THEN DEST[87:80] := SRC2[87:80]\nELSE DEST[87:80] := SRC1[87:80];\nIF (MASK[95] = 1) THEN DEST[95:88] := SRC2[95:88]\nELSE DEST[95:88] := SRC1[95:88];\nIF (MASK[103] = 1) THEN DEST[103:96] := SRC2[103:96]\nELSE DEST[103:96] := SRC1[103:96];\nIF (MASK[111] = 1) THEN DEST[111:104] := SRC2[111:104]\nELSE DEST[111:104] := SRC1[111:104];\nIF (MASK[119] = 1) THEN DEST[119:112] := SRC2[119:112]\nELSE DEST[119:112] := SRC1[119:112];\nIF (MASK[127] = 1) THEN DEST[127:120] := SRC2[127:120]\nELSE DEST[127:120] := SRC1[127:120])\nDEST[MAXVL-1:128] := 0\nMASK := SRC3\nIF (MASK[7] == 1) THEN DEST[7:0] := SRC2[7:0];\nELSE DEST[7:0] := SRC1[7:0];\nIF (MASK[15] == 1) THEN DEST[15:8] := SRC2[15:8];\nELSE DEST[15:8] := SRC1[15:8];\nIF (MASK[23] == 1) THEN DEST[23:16] := SRC2[23:16]\nELSE DEST[23:16] := SRC1[23:16];\nIF (MASK[31] == 1) THEN DEST[31:24] := SRC2[31:24]\nELSE DEST[31:24] := SRC1[31:24];\nIF (MASK[39] == 1) THEN DEST[39:32] := SRC2[39:32]\nELSE DEST[39:32] := SRC1[39:32];\nIF (MASK[47] == 1) THEN DEST[47:40] := SRC2[47:40]\nELSE DEST[47:40] := SRC1[47:40];\nIF (MASK[55] == 1) THEN DEST[55:48] := SRC2[55:48]\nELSE DEST[55:48] := SRC1[55:48];\nIF (MASK[63] == 1) THEN DEST[63:56] := SRC2[63:56]\nELSE DEST[63:56] := SRC1[63:56];\nIF (MASK[71] == 1) THEN DEST[71:64] := SRC2[71:64]\nELSE DEST[71:64] := SRC1[71:64];\nIF (MASK[79] == 1) THEN DEST[79:72] := SRC2[79:72]\nELSE DEST[79:72] := SRC1[79:72];\nIF (MASK[87] == 1) THEN DEST[87:80] := SRC2[87:80]\nELSE DEST[87:80] := SRC1[87:80];\nIF (MASK[95] == 1) THEN DEST[95:88] := SRC2[95:88]\nELSE DEST[95:88] := SRC1[95:88];\nIF (MASK[103] == 1) THEN DEST[103:96] := SRC2[103:96]\nELSE DEST[103:96] := SRC1[103:96];\nIF (MASK[111] == 1) THEN DEST[111:104] := SRC2[111:104]\nELSE DEST[111:104] := SRC1[111:104];\nIF (MASK[119] == 1) THEN DEST[119:112] := SRC2[119:112]\nELSE DEST[119:112] := SRC1[119:112];\nIF (MASK[127] == 1) THEN DEST[127:120] := SRC2[127:120]\nELSE DEST[127:120] := SRC1[127:120])\nIF (MASK[135] == 1) THEN DEST[135:128] := SRC2[135:128];\nELSE DEST[135:128] := SRC1[135:128];\nIF (MASK[143] == 1) THEN DEST[143:136] := SRC2[143:136];\nELSE DEST[[143:136] := SRC1[143:136];\nIF (MASK[151] == 1) THEN DEST[151:144] := SRC2[151:144]\nELSE DEST[151:144] := SRC1[151:144];\nIF (MASK[159] == 1) THEN DEST[159:152] := SRC2[159:152]\nELSE DEST[159:152] := SRC1[159:152];\nIF (MASK[167] == 1) THEN DEST[167:160] := SRC2[167:160]\nELSE DEST[167:160] := SRC1[167:160];\nIF (MASK[175] == 1) THEN DEST[175:168] := SRC2[175:168]\nELSE DEST[175:168] := SRC1[175:168];\nIF (MASK[183] == 1) THEN DEST[183:176] := SRC2[183:176]\nELSE DEST[183:176] := SRC1[183:176];\nIF (MASK[191] == 1) THEN DEST[191:184] := SRC2[191:184]\nELSE DEST[191:184] := SRC1[191:184];\nIF (MASK[199] == 1) THEN DEST[199:192] := SRC2[199:192]\nELSE DEST[199:192] := SRC1[199:192];\nIF (MASK[207] == 1) THEN DEST[207:200] := SRC2[207:200]\nELSE DEST[207:200] := SRC1[207:200]\nIF (MASK[215] == 1) THEN DEST[215:208] := SRC2[215:208]\nELSE DEST[215:208] := SRC1[215:208];\nIF (MASK[223] == 1) THEN DEST[223:216] := SRC2[223:216]\nELSE DEST[223:216] := SRC1[223:216];\nIF (MASK[231] == 1) THEN DEST[231:224] := SRC2[231:224]\nELSE DEST[231:224] := SRC1[231:224];\nIF (MASK[239] == 1) THEN DEST[239:232] := SRC2[239:232]\nELSE DEST[239:232] := SRC1[239:232];\nIF (MASK[247] == 1) THEN DEST[247:240] := SRC2[247:240]\nELSE DEST[247:240] := SRC1[247:240];\nIF (MASK[255] == 1) THEN DEST[255:248] := SRC2[255:248]\nELSE DEST[255:248] := SRC1[255:248]",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/blendpd",
    "category": "Core Instructions",
    "instructionName": "BLENDPD\n\t\t— Blend Packed Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Select packed double precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
        "Op/En": "RMI",
        "Opcode/Instruction": "66 0F 3A 0D /r ib BLENDPD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Select packed double precision floating-point Values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 0D /r ib VBLENDPD xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Select packed double precision floating-point Values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.",
        "Op/En": "RVMI",
        "Opcode/Instruction": "VEX.256.66.0F3A.WIG 0D /r ib VBLENDPD ymm1, ymm2, ymm3/m256, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMI",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVMI",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8[3:0]"
      }
    ],
    "descriptionText": "Double-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [3:0] determine whether the corresponding double precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is ”1”, then the double precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "IF (IMM8[0] = 0)THEN DEST[63:0] := DEST[63:0]\n    ELSE DEST [63:0] := SRC[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] := DEST[127:64]\n    ELSE DEST [127:64] := SRC[127:64] FI\nDEST[MAXVL-1:128] (Unmodified)\nIF (IMM8[0] = 0)THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST [63:0] := SRC2[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] := SRC1[127:64]\n    ELSE DEST [127:64] := SRC2[127:64] FI\nDEST[MAXVL-1:128] := 0\nIF (IMM8[0] = 0)THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST [63:0] := SRC2[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] := SRC1[127:64]\n    ELSE DEST [127:64] := SRC2[127:64] FI\nIF (IMM8[2] = 0) THEN DEST[191:128] := SRC1[191:128]\n    ELSE DEST [191:128] := SRC2[191:128] FI\nIF (IMM8[3] = 0) THEN DEST[255:192] := SRC1[255:192]\n    ELSE DEST [255:192] := SRC2[255:192] FI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrndscalesd",
    "category": "Core Instructions",
    "instructionName": "VRNDSCALESD\n\t\t— Round Scalar Float64 Value to Include a Given Number of Fraction Bits",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rounds scalar double precision floating-point value in xmm3/m64 to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W1 0B /r ib VRNDSCALESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/umonitor",
    "category": "Core Instructions",
    "instructionName": "UMONITOR\n\t\t— User Level Set Up Monitor Address",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "WAITPKG",
        "Description": "Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is contained in r16/r32/r64.",
        "Op/En": "A",
        "Opcode / Instruction": "F3 0F AE /6 UMONITOR r16/r32/r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The UMONITOR instruction arms address monitoring hardware using an address specified in the source register (the address range that the monitoring hardware checks for store operations can be determined by using the CPUID monitor leaf function, EAX=05H). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by UMWAIT.\nThe content of the source register is an effective address. By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used. The address range must use memory of the write-back type. Only write-back memory is guaranteed to correctly trigger the monitoring hardware. Additional information on determining what address range to use in order to prevent false wake-ups is described in Chapter 9, “MultipleProcessor Management‚” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\nThe UMONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, UMONITOR sets the A-bit but not the D-bit in page tables.\nUMONITOR and UMWAIT are available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. UMONITOR and UMWAIT may be executed at any privilege level. Except for the width of the source register, the instruction’s operation is the same in non-64-bit modes and in 64-bit mode.\nUMONITOR does not interoperate with the legacy MWAIT instruction. If UMONITOR was executed prior to executing MWAIT and following the most recent execution of the legacy MONITOR instruction, MWAIT will not enter an optimized state. Execution will continue to the instruction following MWAIT.\nThe UMONITOR instruction causes a transactional abort when used inside a transactional region.\nThe width of the source register (16b, 32b or 64b) is determined by the effective addressing width, which is affected in the standard way by the machine mode settings and 67 prefix.",
    "operationText": "UMONITOR sets up an address range for the monitor hardware using the content of source register as an effective\naddress and puts the monitor hardware in armed state. A store to the specified address range will trigger the\nmonitor hardware.",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If the specified segment is SS and the source register is in non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.7.0:ECX.WAITPKG[bit 5]=0.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "numeric¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: If the specified segment register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If the specified segment is SS and the source register is outside the SS segment limit.; \ncolumn_2: For a page fault.; column_1: #PF(fault-code); \ncolumn_1: #UD; column_2: If CPUID.7.0:ECX.WAITPKG[bit 5]=0.;"
      ],
      "realAddressMode¶": [
        "column_1: #SS; column_2: If the specified segment is SS and the source register is outside of the effective address space from 0 to FFFFH.; \ncolumn_1: #UD; column_2: If CPUID.7.0:ECX.WAITPKG[bit 5]=0.;"
      ],
      "virtual8086Mode¶": [
        "Same exceptions as in real address mode; additionally:",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtps2phx",
    "category": "Core Instructions",
    "instructionName": "VCVTPS2PHX\n\t\t— Convert Packed Single Precision Floating-Point Values to Packed FP16 Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512-FP16 AVX512VL",
        "Description": "Convert four packed single precision floating-point values in xmm2/m128/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.66.MAP5.W0 1D /r VCVTPS2PHX xmm1{k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512-FP16 AVX512VL",
        "Description": "Convert eight packed single precision floating-point values in ymm2/m256/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.66.MAP5.W0 1D /r VCVTPS2PHX xmm1{k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512-FP16",
        "Description": "Convert sixteen packed single precision floating-point values in zmm2 /m512/m32bcst to packed FP16 values, and store the result in ymm1 subject to writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.66.MAP5.W0 1D /r VCVTPS2PHX ymm1{k1}{z}, zmm2/m512/m32bcst {er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/xabort",
    "category": "Core Instructions",
    "instructionName": "XABORT\n\t\t— Transactional Abort",
    "detailsTable": [
      {
        "64/32bit Mode Support": "V/V",
        "CPUID Feature Flag": "RTM",
        "Description": "Causes an RTM abort if in RTM execution.",
        "Op/En": "A",
        "Opcode/Instruction": "C6 F8 ib XABORT imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "imm8",
        "Operand2": "N/A",
        "Operand3": "N/A",
        "Operand4": "N/A"
      }
    ],
    "descriptionText": "XABORT forces an RTM abort. Following an RTM abort, the logical processor resumes execution at the fallback address computed through the outermost XBEGIN instruction. The EAX register is updated to reflect an XABORT instruction caused the abort, and the imm8 argument will be provided in bits 31:24 of EAX.",
    "operationText": "IF RTM_ACTIVE = 0\n    THEN\n        Treat as NOP;\n    ELSE\n        GOTO RTM_ABORT_PROCESSING;\nFI;\n(* For any RTM abort condition encountered during RTM execution *)\nRTM_ABORT_PROCESSING:\n    Restore architectural register state;\n    Discard memory updates performed in transaction;\n    Update EAX with status and XABORT argument;\n    RTM_NEST_COUNT:= 0;\n    RTM_ACTIVE:= 0;\n    SUSLDTRK_ACTIVE := 0;\n    IF 64-bit Mode\n        THEN\n            RIP:= fallbackRIP;\n        ELSE\n            EIP := fallbackEIP;\n    FI;\nEND",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "column_1: If LOCK prefix is used.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmwrite",
    "category": "VMX Instructions",
    "instructionName": "VMWRITE\n\t\t— Write Field to Virtual-Machine Control Structure",
    "detailsTable": [
      {
        "Description": "Writes a specified VMCS field (in 64-bit mode).",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 79 VMWRITE r64, r/m64"
      },
      {
        "Description": "Writes a specified VMCS field (outside 64-bit mode).",
        "Op/En": "RM",
        "Opcode/Instruction": "NP 0F 79 VMWRITE r32, r/m32"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "RM",
        "column_2": "ModRM:reg (r)",
        "column_3": "ModRM:r/m (r)",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Writes the contents of a primary source operand (register or memory) to a specified field in a VMCS. In VMX root operation, the instruction writes to the current VMCS. If executed in VMX non-root operation, the instruction writes to the VMCS referenced by the VMCS link pointer field in the current VMCS.\nThe VMCS field is specified by the VMCS-field encoding contained in the register secondary source operand. Outside IA-32e mode, the secondary source operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode, the secondary source operand has 64 bits.\nThe effective size of the primary source operand, which may be a register or in memory, is always 32 bits outside IA-32e mode (the setting of CS.D is ignored with respect to operand size) and 64 bits in 64-bit mode. If the VMCS field specified by the secondary source operand is shorter than this effective operand size, the high bits of the primary source operand are ignored. If the VMCS field is longer, then the high bits of the field are cleared to 0.\nNote that any faults resulting from accessing a memory source operand occur after determining, in the operation section below, that the relevant VMCS pointer is valid but before determining if the destination VMCS field is supported.",
    "operationText": "IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation AND (“VMCS shadowing” is 0 OR secondary source operand sets bits in range 63:15 OR\nVMWRITE bit corresponding to bits 14:0 of secondary source operand is 1)1\n    THEN VMexit;\nELSIF CPL > 0\n    THEN #GP(0);\nELSIF (in VMX root operation AND current-VMCS pointer is not valid) OR\n(in VMX non-root operation AND VMCS-link pointer is not valid)\n    THEN VMfailInvalid;\nELSIF secondary source operand does not correspond to any VMCS field\n    THEN VMfailValid(VMREAD/VMWRITE from/to unsupported VMCS component);\nELSIF VMCS field indexed by secondary source operand is a VM-exit information field AND\nprocessor does not support writing to such fields2\n    THEN VMfailValid(VMWRITE to read-only VMCS component);\n    ELSE\nIF in VMX root operation\n            THEN field indexed by secondary source operand in current VMCS := primary source operand;\n            ELSE field indexed by secondary source operand in VMCS referenced by VMCS link pointer := primary source operand;\n    FI;\n    VMsucceed;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the memory source operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing a memory source operand.; \ncolumn_1: #SS(0); column_2: If the memory source operand is in the SS segment and the memory address is in a non-canonical form.; \ncolumn_1: #UD; column_2: If not in VMX operation.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: If a memory source operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the source operand is located in an execute-only code segment.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing a memory source operand.; \ncolumn_1: #SS(0); column_2: If a memory source operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_1: #UD; column_2: If not in VMX operation.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fldcw",
    "category": "Core Instructions",
    "instructionName": "FLDCW\n\t\t— Load x87 FPU Control Word",
    "detailsTable": [
      {
        "Description": "Load FPU control word from m2byte.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 /5",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruction is typically used to establish or change the FPU’s mode of operation.\nIf one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled “Software Exception Handling” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using the FCLEX or FNCLEX instruction) before loading the new control word.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "FPUControlWord := SRC;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_2: If the memory address is in a non-canonical form.; column_1: #GP(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None; however, this operation might unmask a pending exception in the FPU status word. That exception is then generated upon execution of the next “waiting” floating-point instruction."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pcmpistri",
    "category": "Core Instructions",
    "instructionName": "PCMPISTRI\n\t\t— Packed Compare Implicit Length Strings, Return Index",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_2",
        "Description": "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 3A 63 /r imm8 PCMPISTRI xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.",
        "Op/En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 63 /r ib VPCMPISTRI xmm1, xmm2/m128, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction compares data from two strings based on the encoded value in the imm8 control byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to ECX.\nEach string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)\nThe comparison and aggregation operations are performed according to the encoded value of imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).\nNote that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:\nCFlag – Reset if IntRes2 is equal to zero, set otherwise\nZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise\nSFlag – Set if any byte/word of xmm1 is null, reset otherwise\nOFlag –IntRes2[0]\nAFlag – Reset\nPFlag – Reset\nNote: In VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally, this instruction does not cause #GP if the memory operand is not aligned to 16 Byte boundary, and:",
        "column_1: If VEX.vvvv ≠ 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vprord:vprorvd:vprorq:vprorvq",
    "category": "Core Instructions",
    "instructionName": "VPRORD/VPRORVD/VPRORQ/VPRORVQ\n\t\t— Bit Rotate Right",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate doublewords in xmm2 right by count in the corresponding element of xmm3/m128/m32bcst, store result using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 14 /r VPRORVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate doublewords in xmm2/m128/m32bcst right by imm8, store result using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 72 /0 ib VPRORD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate quadwords in xmm2 right by count in the corresponding element of xmm3/m128/m64bcst, store result using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 14 /r VPRORVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate quadwords in xmm2/m128/m64bcst right by imm8, store result using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 72 /0 ib VPRORQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate doublewords in ymm2 right by count in the corresponding element of ymm3/m256/m32bcst, store using result writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 14 /r VPRORVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate doublewords in ymm2/m256/m32bcst right by imm8, store result using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 72 /0 ib VPRORD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate quadwords in ymm2 right by count in the corresponding element of ymm3/m256/m64bcst, store result using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 14 /r VPRORVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate quadwords in ymm2/m256/m64bcst right by imm8, store result using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 72 /0 ib VPRORQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rotate doublewords in zmm2 right by count in the corresponding element of zmm3/m512/m32bcst, store result using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 14 /r VPRORVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rotate doublewords in zmm2/m512/m32bcst right by imm8, store result using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 72 /0 ib VPRORD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rotate quadwords in zmm2 right by count in the corresponding element of zmm3/m512/m64bcst, store result using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 14 /r VPRORVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rotate quadwords in zmm2/m512/m64bcst right by imm8, store result using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 72 /0 ib VPRORQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (R)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cmpsd",
    "category": "Core Instructions",
    "instructionName": "CMPSD\n\t\t— Compare Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Compare low double precision floating-point value in xmm2/m64 and xmm1 using bits 2:0 of imm8 as comparison predicate.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F C2 /r ib CMPSD xmm1, xmm2/m64, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare low double precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG C2 /r ib VCMPSD xmm1, xmm2, xmm3/m64, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare low double precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 C2 /r ib VCMPSD k1 {k2}, xmm2, xmm3/m64{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the low double precision floating-point values in the second source operand and the first source operand and returns the result of the comparison to the destination operand. The comparison predicate operand (immediate operand) specifies the type of comparison performed.\n128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 64-bit memory location. Bits (MAXVL-1:64) of the corresponding YMM destination register remain unchanged. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\nVEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 64-bit memory location. The result is stored in the low quadword of the destination operand; the high quadword is filled with the contents of the high quadword of the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false).\nEVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 64-bit memory location. The destination operand (first operand) is an opmask register. The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.\nThe comparison predicate operand is an 8-bit immediate:\nThe unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.\nA subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.\nNote that processors with “CPUID.1H:ECX.AVX =0” do not implement the “greater-than”, “greater-than-or-equal”, “not-greater than”, and “not-greater-than-or-equal relations” predicates. These comparisons can be made either\nby using the inverse relationship (that is, use the “not-less-than-or-equal” to make a “greater-than” comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the first 8 rows of Table 3-7 (Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A) under the heading Emulation.\nCompilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPSD instruction, for processors with “CPUID.1H:ECX.AVX =0”. See Table 3-6. The compiler should treat reserved imm8 values as illegal syntax.\nThe greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)\nProcessors with “CPUID.1H:ECX.AVX =1” implement the full complement of 32 predicates shown in Table 3-7, software emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSD instruction. See Table 3-7, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. The compiler should treat reserved imm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface. Compilers and assemblers may implement three-operand pseudo-ops for EVEX encoded VCMPSD instructions in a similar fashion by extending the syntax listed in Table 3-7.\nSoftware should ensure VCMPSD is encoded with VEX.L=0. Encoding VCMPSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "CASE (COMPARISON PREDICATE) OF\n    0: OP3 := EQ_OQ; OP5 := EQ_OQ;\n    1: OP3 := LT_OS; OP5 := LT_OS;\n    2: OP3 := LE_OS; OP5 := LE_OS;\n    3: OP3 := UNORD_Q; OP5 := UNORD_Q;\n    4: OP3 := NEQ_UQ; OP5 := NEQ_UQ;\n    5: OP3 := NLT_US; OP5 := NLT_US;\n    6: OP3 := NLE_US; OP5 := NLE_US;\n    7: OP3 := ORD_Q; OP5 := ORD_Q;\n    8: OP5 := EQ_UQ;\n    9: OP5 := NGE_US;\n    10: OP5 := NGT_US;\n    11: OP5 := FALSE_OQ;\n    12: OP5 := NEQ_OQ;\n    13: OP5 := GE_OS;\n    14: OP5 := GT_OS;\n    15: OP5 := TRUE_UQ;\n    16: OP5 := EQ_OS;\n    17: OP5 := LT_OQ;\n    18: OP5 := LE_OQ;\n    19: OP5 := UNORD_S;\n    20: OP5 := NEQ_US;\n    21: OP5 := NLT_UQ;\n    22: OP5 := NLE_UQ;\n    23: OP5 := ORD_S;\n    24: OP5 := EQ_US;\n    25: OP5 := NGE_UQ;\n    26: OP5 := NGT_UQ;\n    27: OP5 := FALSE_OS;\n    28: OP5 := NEQ_OS;\n    29: OP5 := GE_OQ;\n    30: OP5 := GT_OQ;\n    31: OP5 := TRUE_US;\n    DEFAULT: Reserved\nESAC;\nCMP0 := SRC1[63:0] OP5 SRC2[63:0];\nIF k2[0] or *no writemask*\n    THEN IF CMP0 = TRUE\n        THEN DEST[0] := 1;\n        ELSE DEST[0] := 0; FI;\n    ELSE DEST[0] := 0\n            ; zeroing-masking only\nFI;\nDEST[MAX_KL-1:1] := 0\nCMP0 := DEST[63:0] OP3 SRC[63:0];\nIF CMP0 = TRUE\nTHEN DEST[63:0] := FFFFFFFFFFFFFFFFH;\nELSE DEST[63:0] := 0000000000000000H; FI;\nDEST[MAXVL-1:64] (Unmodified)\nCMP0 := SRC1[63:0] OP5 SRC2[63:0];\nIF CMP0 = TRUE\nTHEN DEST[63:0] := FFFFFFFFFFFFFFFFH;\nELSE DEST[63:0] := 0000000000000000H; FI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid if SNaN operand, Invalid if QNaN and predicate as listed in Table 3-1, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/packuswb",
    "category": "Core Instructions",
    "instructionName": "PACKUSWB\n\t\t— Pack With Unsigned Saturation",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 67 /r1 PACKUSWB mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 67 /r PACKUSWB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 67 /r VPACKUSWB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Converts 16 signed word integers from ymm2 and 16signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 67 /r VPACKUSWB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts signed word integers from xmm2 and signed word integers from xmm3/m128 into unsigned byte integers in xmm1 using unsigned saturation under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 67 /r VPACKUSWB xmm1{k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Converts signed word integers from ymm2 and signed word integers from ymm3/m256 into unsigned byte integers in ymm1 using unsigned saturation under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 67 /r VPACKUSWB ymm1{k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Converts signed word integers from zmm2 and signed word integers from zmm3/m512 into unsigned byte integers in zmm1 using unsigned saturation under writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 67 /r VPACKUSWB zmm1{k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Converts 4, 8, 16, or 32 signed word integers from the destination operand (first operand) and 4, 8, 16, or 32 signed word integers from the source operand (second operand) into 8, 16, 32 or 64 unsigned byte integers and stores the result in the destination operand. (See Figure 4-6 for an example of the packing operation.) If a signed word integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.\nEVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.\nVEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.\n128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
    "operationText": "DEST[7:0] := SaturateSignedWordToUnsignedByte DEST[15:0];\nDEST[15:8] := SaturateSignedWordToUnsignedByte DEST[31:16];\nDEST[23:16] := SaturateSignedWordToUnsignedByte DEST[47:32];\nDEST[31:24] := SaturateSignedWordToUnsignedByte DEST[63:48];\nDEST[39:32] := SaturateSignedWordToUnsignedByte SRC[15:0];\nDEST[47:40] := SaturateSignedWordToUnsignedByte SRC[31:16];\nDEST[55:48] := SaturateSignedWordToUnsignedByte SRC[47:32];\nDEST[63:56] := SaturateSignedWordToUnsignedByte SRC[63:48];\nDEST[7:0] := SaturateSignedWordToUnsignedByte (DEST[15:0]);\nDEST[15:8] := SaturateSignedWordToUnsignedByte (DEST[31:16]);\nDEST[23:16] := SaturateSignedWordToUnsignedByte (DEST[47:32]);\nDEST[31:24] := SaturateSignedWordToUnsignedByte (DEST[63:48]);\nDEST[39:32] := SaturateSignedWordToUnsignedByte (DEST[79:64]);\nDEST[47:40] := SaturateSignedWordToUnsignedByte (DEST[95:80]);\nDEST[55:48] := SaturateSignedWordToUnsignedByte (DEST[111:96]);\nDEST[63:56] := SaturateSignedWordToUnsignedByte (DEST[127:112]);\nDEST[71:64] := SaturateSignedWordToUnsignedByte (SRC[15:0]);\nDEST[79:72] := SaturateSignedWordToUnsignedByte (SRC[31:16]);\nDEST[87:80] := SaturateSignedWordToUnsignedByte (SRC[47:32]);\nDEST[95:88] := SaturateSignedWordToUnsignedByte (SRC[63:48]);\nDEST[103:96] := SaturateSignedWordToUnsignedByte (SRC[79:64]);\nDEST[111:104] := SaturateSignedWordToUnsignedByte (SRC[95:80]);\nDEST[119:112] := SaturateSignedWordToUnsignedByte (SRC[111:96]);\nDEST[127:120] := SaturateSignedWordToUnsignedByte (SRC[127:112]);\nDEST[7:0] := SaturateSignedWordToUnsignedByte (SRC1[15:0]);\nDEST[15:8] := SaturateSignedWordToUnsignedByte (SRC1[31:16]);\nDEST[23:16] := SaturateSignedWordToUnsignedByte (SRC1[47:32]);\nDEST[31:24] := SaturateSignedWordToUnsignedByte (SRC1[63:48]);\nDEST[39:32] := SaturateSignedWordToUnsignedByte (SRC1[79:64]);\nDEST[47:40] := SaturateSignedWordToUnsignedByte (SRC1[95:80]);\nDEST[55:48] := SaturateSignedWordToUnsignedByte (SRC1[111:96]);\nDEST[63:56] := SaturateSignedWordToUnsignedByte (SRC1[127:112]);\nDEST[71:64] := SaturateSignedWordToUnsignedByte (SRC2[15:0]);\nDEST[79:72] := SaturateSignedWordToUnsignedByte (SRC2[31:16]);\nDEST[87:80] := SaturateSignedWordToUnsignedByte (SRC2[47:32]);\nDEST[95:88] := SaturateSignedWordToUnsignedByte (SRC2[63:48]);\nDEST[103:96] := SaturateSignedWordToUnsignedByte (SRC2[79:64]);\nDEST[111:104] := SaturateSignedWordToUnsignedByte (SRC2[95:80]);\nDEST[119:112] := SaturateSignedWordToUnsignedByte (SRC2[111:96]);\nDEST[127:120] := SaturateSignedWordToUnsignedByte (SRC2[127:112]);\nDEST[MAXVL-1:128] := 0;\nDEST[7:0] := SaturateSignedWordToUnsignedByte (SRC1[15:0]);\nDEST[15:8] := SaturateSignedWordToUnsignedByte (SRC1[31:16]);\nDEST[23:16] := SaturateSignedWordToUnsignedByte (SRC1[47:32]);\nDEST[31:24] := SaturateSignedWordToUnsignedByte (SRC1[63:48]);\nDEST[39:32] := SaturateSignedWordToUnsignedByte (SRC1[79:64]);\nDEST[47:40] := SaturateSignedWordToUnsignedByte (SRC1[95:80]);\nDEST[55:48] := SaturateSignedWordToUnsignedByte (SRC1[111:96]);\nDEST[63:56] := SaturateSignedWordToUnsignedByte (SRC1[127:112]);\nDEST[71:64] := SaturateSignedWordToUnsignedByte (SRC2[15:0]);\nDEST[79:72] := SaturateSignedWordToUnsignedByte (SRC2[31:16]);\nDEST[87:80] := SaturateSignedWordToUnsignedByte (SRC2[47:32]);\nDEST[95:88] := SaturateSignedWordToUnsignedByte (SRC2[63:48]);\nDEST[103:96] := SaturateSignedWordToUnsignedByte (SRC2[79:64]);\nDEST[111:104] := SaturateSignedWordToUnsignedByte (SRC2[95:80]);\nDEST[119:112] := SaturateSignedWordToUnsignedByte (SRC2[111:96]);\nDEST[127:120] := SaturateSignedWordToUnsignedByte (SRC2[127:112]);\nDEST[135:128] := SaturateSignedWordToUnsignedByte (SRC1[143:128]);\nDEST[143:136] := SaturateSignedWordToUnsignedByte (SRC1[159:144]);\nDEST[151:144] := SaturateSignedWordToUnsignedByte (SRC1[175:160]);\nDEST[159:152] := SaturateSignedWordToUnsignedByte (SRC1[191:176]);\nDEST[167:160] := SaturateSignedWordToUnsignedByte (SRC1[207:192]);\nDEST[175:168] := SaturateSignedWordToUnsignedByte (SRC1[223:208]);\nDEST[183:176] := SaturateSignedWordToUnsignedByte (SRC1[239:224]);\nDEST[191:184] := SaturateSignedWordToUnsignedByte (SRC1[255:240]);\nDEST[199:192] := SaturateSignedWordToUnsignedByte (SRC2[143:128]);\nDEST[207:200] := SaturateSignedWordToUnsignedByte (SRC2[159:144]);\nDEST[215:208] := SaturateSignedWordToUnsignedByte (SRC2[175:160]);\nDEST[223:216] := SaturateSignedWordToUnsignedByte (SRC2[191:176]);\nDEST[231:224] := SaturateSignedWordToUnsignedByte (SRC2[207:192]);\nDEST[239:232] := SaturateSignedWordToUnsignedByte (SRC2[223:208]);\nDEST[247:240] := SaturateSignedWordToUnsignedByte (SRC2[239:224]);\nDEST[255:248] := SaturateSignedWordToUnsignedByte (SRC2[255:240]);\n(KL, VL) = (16, 128), (32, 256), (64, 512)\nTMP_DEST[7:0] := SaturateSignedWordToUnsignedByte (SRC1[15:0]);\nTMP_DEST[15:8] := SaturateSignedWordToUnsignedByte (SRC1[31:16]);\nTMP_DEST[23:16] := SaturateSignedWordToUnsignedByte (SRC1[47:32]);\nTMP_DEST[31:24] := SaturateSignedWordToUnsignedByte (SRC1[63:48]);\nTMP_DEST[39:32] := SaturateSignedWordToUnsignedByte (SRC1[79:64]);\nTMP_DEST[47:40] := SaturateSignedWordToUnsignedByte (SRC1[95:80]);\nTMP_DEST[55:48] := SaturateSignedWordToUnsignedByte (SRC1[111:96]);\nTMP_DEST[63:56] := SaturateSignedWordToUnsignedByte (SRC1[127:112]);\nTMP_DEST[71:64] := SaturateSignedWordToUnsignedByte (SRC2[15:0]);\nTMP_DEST[79:72] := SaturateSignedWordToUnsignedByte (SRC2[31:16]);\nTMP_DEST[87:80] := SaturateSignedWordToUnsignedByte (SRC2[47:32]);\nTMP_DEST[95:88] := SaturateSignedWordToUnsignedByte (SRC2[63:48]);\nTMP_DEST[103:96] := SaturateSignedWordToUnsignedByte (SRC2[79:64]);\nTMP_DEST[111:104] := SaturateSignedWordToUnsignedByte (SRC2[95:80]);\nTMP_DEST[119:112] := SaturateSignedWordToUnsignedByte (SRC2[111:96]);\nTMP_DEST[127:120] := SaturateSignedWordToUnsignedByte (SRC2[127:112]);\nIF VL >= 256\n    TMP_DEST[135:128] := SaturateSignedWordToUnsignedByte (SRC1[143:128]);\n    TMP_DEST[143:136] := SaturateSignedWordToUnsignedByte (SRC1[159:144]);\n    TMP_DEST[151:144] := SaturateSignedWordToUnsignedByte (SRC1[175:160]);\n    TMP_DEST[159:152] := SaturateSignedWordToUnsignedByte (SRC1[191:176]);\n    TMP_DEST[167:160] := SaturateSignedWordToUnsignedByte (SRC1[207:192]);\n    TMP_DEST[175:168] := SaturateSignedWordToUnsignedByte (SRC1[223:208]);\n    TMP_DEST[183:176] := SaturateSignedWordToUnsignedByte (SRC1[239:224]);\n    TMP_DEST[191:184] := SaturateSignedWordToUnsignedByte (SRC1[255:240]);\n    TMP_DEST[199:192] := SaturateSignedWordToUnsignedByte (SRC2[143:128]);\n    TMP_DEST[207:200] := SaturateSignedWordToUnsignedByte (SRC2[159:144]);\n    TMP_DEST[215:208] := SaturateSignedWordToUnsignedByte (SRC2[175:160]);\n    TMP_DEST[223:216] := SaturateSignedWordToUnsignedByte (SRC2[191:176]);\n    TMP_DEST[231:224] := SaturateSignedWordToUnsignedByte (SRC2[207:192]);\n    TMP_DEST[239:232] := SaturateSignedWordToUnsignedByte (SRC2[223:208]);\n    TMP_DEST[247:240] := SaturateSignedWordToUnsignedByte (SRC2[239:224]);\n    TMP_DEST[255:248] := SaturateSignedWordToUnsignedByte (SRC2[255:240]);\nFI;\nIF VL >= 512\n    TMP_DEST[263:256] := SaturateSignedWordToUnsignedByte (SRC1[271:256]);\n    TMP_DEST[271:264] := SaturateSignedWordToUnsignedByte (SRC1[287:272]);\n    TMP_DEST[279:272] := SaturateSignedWordToUnsignedByte (SRC1[303:288]);\n    TMP_DEST[287:280] := SaturateSignedWordToUnsignedByte (SRC1[319:304]);\n    TMP_DEST[295:288] := SaturateSignedWordToUnsignedByte (SRC1[335:320]);\n    TMP_DEST[303:296] := SaturateSignedWordToUnsignedByte (SRC1[351:336]);\n    TMP_DEST[311:304] := SaturateSignedWordToUnsignedByte (SRC1[367:352]);\n    TMP_DEST[319:312] := SaturateSignedWordToUnsignedByte (SRC1[383:368]);\n    TMP_DEST[327:320] := SaturateSignedWordToUnsignedByte (SRC2[271:256]);\n    TMP_DEST[335:328] := SaturateSignedWordToUnsignedByte (SRC2[287:272]);\n    TMP_DEST[343:336] := SaturateSignedWordToUnsignedByte (SRC2[303:288]);\n    TMP_DEST[351:344] := SaturateSignedWordToUnsignedByte (SRC2[319:304]);\n    TMP_DEST[359:352] := SaturateSignedWordToUnsignedByte (SRC2[335:320]);\n    TMP_DEST[367:360] := SaturateSignedWordToUnsignedByte (SRC2[351:336]);\n    TMP_DEST[375:368] := SaturateSignedWordToUnsignedByte (SRC2[367:352]);\n    TMP_DEST[383:376] := SaturateSignedWordToUnsignedByte (SRC2[383:368]);\n    TMP_DEST[391:384] := SaturateSignedWordToUnsignedByte (SRC1[399:384]);\n    TMP_DEST[399:392] := SaturateSignedWordToUnsignedByte (SRC1[415:400]);\n    TMP_DEST[407:400] := SaturateSignedWordToUnsignedByte (SRC1[431:416]);\n    TMP_DEST[415:408] := SaturateSignedWordToUnsignedByte (SRC1[447:432]);\n    TMP_DEST[423:416] := SaturateSignedWordToUnsignedByte (SRC1[463:448]);\n    TMP_DEST[431:424] := SaturateSignedWordToUnsignedByte (SRC1[479:464]);\n    TMP_DEST[439:432] := SaturateSignedWordToUnsignedByte (SRC1[495:480]);\n    TMP_DEST[447:440] := SaturateSignedWordToUnsignedByte (SRC1[511:496]);\n    TMP_DEST[455:448] := SaturateSignedWordToUnsignedByte (SRC2[399:384]);\n    TMP_DEST[463:456] := SaturateSignedWordToUnsignedByte (SRC2[415:400]);\n    TMP_DEST[471:464] := SaturateSignedWordToUnsignedByte (SRC2[431:416]);\n    TMP_DEST[479:472] := SaturateSignedWordToUnsignedByte (SRC2[447:432]);\n    TMP_DEST[487:480] := SaturateSignedWordToUnsignedByte (SRC2[463:448]);\n    TMP_DEST[495:488] := SaturateSignedWordToUnsignedByte (SRC2[479:464]);\n    TMP_DEST[503:496] := SaturateSignedWordToUnsignedByte (SRC2[495:480]);\n    TMP_DEST[511:504] := SaturateSignedWordToUnsignedByte (SRC2[511:496]);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 8\n    IF k1[j] OR *no writemask*\n        THEN\n            DEST[i+7:i] := TMP_DEST[i+7:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+7:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+7:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/minss",
    "category": "Core Instructions",
    "instructionName": "MINSS\n\t\t— Return Minimum Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Return the minimum scalar single precision floating-point value between xmm2/m32 and xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 5D /r MINSS xmm1,xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the minimum scalar single precision floating-point value between xmm3/m32 and xmm2.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 5D /r VMINSS xmm1,xmm2, xmm3/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Return the minimum scalar single precision floating-point value between xmm3/m32 and xmm2.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 5D /r VMINSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the low single precision floating-point values in the first source operand and the second source operand and returns the minimum value to the low doubleword of the destination operand.\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN in either source operand be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\nThe second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by (E)VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.\nSoftware should ensure VMINSS is encoded with VEX.L=0. Encoding VMINSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "MIN(SRC1, SRC2)\n{\n    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;\n        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC1 < SRC2) THEN DEST := SRC1;\n        ELSE DEST := SRC2;\n    FI;\n}\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (Including QNaN Source Operand), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtps2udq",
    "category": "Core Instructions",
    "instructionName": "VCVTPS2UDQ\n\t\t— Convert Packed Single Precision Floating-Point Values to Packed UnsignedDoubleword Integer Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.0F.W0 79 /r VCVTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.0F.W0 79 /r VCVTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert sixteen packed single precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.0F.W0 79 /r VCVTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pshuflw",
    "category": "Core Instructions",
    "instructionName": "PSHUFLW\n\t\t— Shuffle Packed Low Words",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "F2 0F 70 /r ib PSHUFLW xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.F2.0F.WIG 70 /r ib VPSHUFLW xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.F2.0F.WIG 70 /r ib VPSHUFLW ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1 under write mask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.F2.0F.WIG 70 /r ib VPSHUFLW xmm1 {k1}{z}, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1 under write mask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.F2.0F.WIG 70 /r ib VPSHUFLW ymm1 {k1}{z}, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shuffle the low words in zmm2/m512 based on the encoding in imm8 and store the result in zmm1 under write mask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.F2.0F.WIG 70 /r ib VPSHUFLW zmm1 {k1}{z}, zmm2/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Copies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. The 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword of the destination operand, for each 128-bit lane.\nNote that this instruction permits a word in the low quadword of the source operand to be copied to more than one word location in the low quadword of the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.\nEVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the write-mask.\nNote: In VEX encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "DEST[15:0] := (SRC >> (imm[1:0] *16))[15:0]\nDEST[31:16] := (SRC >> (imm[3:2] * 16))[15:0]\nDEST[47:32] := (SRC >> (imm[5:4] * 16))[15:0]\nDEST[63:48] := (SRC >> (imm[7:6] * 16))[15:0]\nDEST[127:64] := SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[15:0] := (SRC1 >> (imm[1:0] *16))[15:0]\nDEST[31:16] := (SRC1 >> (imm[3:2] * 16))[15:0]\nDEST[47:32] := (SRC1 >> (imm[5:4] * 16))[15:0]\nDEST[63:48] := (SRC1 >> (imm[7:6] * 16))[15:0]\nDEST[127:64] := SRC[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[15:0] := (SRC1 >> (imm[1:0] *16))[15:0]\nDEST[31:16] := (SRC1 >> (imm[3:2] * 16))[15:0]\nDEST[47:32] := (SRC1 >> (imm[5:4] * 16))[15:0]\nDEST[63:48] := (SRC1 >> (imm[7:6] * 16))[15:0]\nDEST[127:64] := SRC1[127:64]\nDEST[143:128] := (SRC1 >> (imm[1:0] *16))[143:128]\nDEST[159:144] := (SRC1 >> (imm[3:2] * 16))[143:128]\nDEST[175:160] := (SRC1 >> (imm[5:4] * 16))[143:128]\nDEST[191:176] := (SRC1 >> (imm[7:6] * 16))[143:128]\nDEST[255:192] := SRC1[255:192]\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL >= 128\n    TMP_DEST[15:0] := (SRC1 >> (imm[1:0] *16))[15:0]\n    TMP_DEST[31:16] := (SRC1 >> (imm[3:2] * 16))[15:0]\n    TMP_DEST[47:32] := (SRC1 >> (imm[5:4] * 16))[15:0]\n    TMP_DEST[63:48] := (SRC1 >> (imm[7:6] * 16))[15:0]\n    TMP_DEST[127:64] := SRC1[127:64]\nFI;\nIF VL >= 256\n    TMP_DEST[143:128] := (SRC1 >> (imm[1:0] *16))[143:128]\n    TMP_DEST[159:144] := (SRC1 >> (imm[3:2] * 16))[143:128]\n    TMP_DEST[175:160] := (SRC1 >> (imm[5:4] * 16))[143:128]\n    TMP_DEST[191:176] := (SRC1 >> (imm[7:6] * 16))[143:128]\n    TMP_DEST[255:192] := SRC1[255:192]\nFI;\nIF VL >= 512\n    TMP_DEST[271:256] := (SRC1 >> (imm[1:0] *16))[271:256]\n    TMP_DEST[287:272] := (SRC1 >> (imm[3:2] * 16))[271:256]\n    TMP_DEST[303:288] := (SRC1 >> (imm[5:4] * 16))[271:256]\n    TMP_DEST[319:304] := (SRC1 >> (imm[7:6] * 16))[271:256]\n    TMP_DEST[383:320] := SRC1[383:320]\n    TMP_DEST[399:384] := (SRC1 >> (imm[1:0] *16))[399:384]\n    TMP_DEST[415:400] := (SRC1 >> (imm[3:2] * 16))[399:384]\n    TMP_DEST[431:416] := (SRC1 >> (imm[5:4] * 16))[399:384]\n    TMP_DEST[447:432] := (SRC1 >> (imm[7:6] * 16))[399:384]\n    TMP_DEST[511:448] := SRC1[511:448]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i];\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fst:fstp",
    "category": "Core Instructions",
    "instructionName": "FST/FSTP\n\t\t— Store Floating-Point Value",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Copy ST(0) to m32fp.",
        "Instruction": "FST m32fp",
        "Opcode": "D9 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Copy ST(0) to m64fp.",
        "Instruction": "FST m64fp",
        "Opcode": "DD /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Copy ST(0) to ST(i).",
        "Instruction": "FST ST(i)",
        "Opcode": "DD D0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Copy ST(0) to m32fp and pop register stack.",
        "Instruction": "FSTP m32fp",
        "Opcode": "D9 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Copy ST(0) to m64fp and pop register stack.",
        "Instruction": "FSTP m64fp",
        "Opcode": "DD /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Copy ST(0) to m80fp and pop register stack.",
        "Instruction": "FSTP m80fp",
        "Opcode": "DB /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Copy ST(0) to ST(i) and pop register stack.",
        "Instruction": "FSTP ST(i)",
        "Opcode": "DD D8+i"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location or another register in the FPU register stack. When storing the value in memory, the value is converted to single precision or double precision floating-point format.\nThe FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FSTP instruction can also store values in memory in double extended-precision floating-point format.\nIf the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.\nIf the destination size is single precision or double precision, the significand of the value being stored is rounded to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception (#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.\nIf the value being stored is ±0, ±∞, or a NaN, the least-significant bits of the significand and the exponent are truncated to fit the destination format. This operation preserves the value’s identity as a 0, ∞, or NaN.\nIf the destination operand is a non-empty register, the invalid-operation exception is not generated.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "DEST := ST(0);\nIF Instruction = FSTP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_2: If destination result is an SNaN value or unsupported format, except when the destination format is in double extended-precision floating-point format.; column_1: #IA; \ncolumn_1: #U; column_2: Result is too small for the destination format.; \ncolumn_1: #O; column_2: Result is too large for the destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fcom:fcomp:fcompp",
    "category": "Core Instructions",
    "instructionName": "FCOM/FCOMP/FCOMPP\n\t\t— Compare Floating-Point Values",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with m32fp.",
        "Instruction": "FCOM m32fp",
        "Opcode": "D8 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with m64fp.",
        "Instruction": "FCOM m64fp",
        "Opcode": "DC /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(i).",
        "Instruction": "FCOM ST(i)",
        "Opcode": "D8 D0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(1).",
        "Instruction": "FCOM",
        "Opcode": "D8 D1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with m32fp and pop register stack.",
        "Instruction": "FCOMP m32fp",
        "Opcode": "D8 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with m64fp and pop register stack.",
        "Instruction": "FCOMP m64fp",
        "Opcode": "DC /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(i) and pop register stack.",
        "Instruction": "FCOMP ST(i)",
        "Opcode": "D8 D8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(1) and pop register stack.",
        "Instruction": "FCOMP",
        "Opcode": "D8 D9"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Compare ST(0) with ST(1) and pop register stack twice.",
        "Instruction": "FCOMPP",
        "Opcode": "DE D9"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0.\nThis instruction checks the class of the numbers being compared (see “FXAM—Examine Floating-Point” in this chapter). If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised and, if the exception is masked, the condition flags are set to “unordered.” If the invalid-arithmetic-operand exception is unmasked, the condition code flags are not set.\nThe FCOMP instruction pops the register stack following the comparison operation and the FCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThe FCOM instructions perform the same operation as the FUCOM instructions. The only difference is how they handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or both of the operands is a NaN value or is in an unsupported format. The FUCOM instructions perform the same operation as the FCOM instructions, except that they do not generate an invalid-arithmetic-operand exception for QNaNs.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "CASE (relation of operands) OF\n    ST > SRC:\n                    C3, C2, C0 := 000;\n    ST < SRC:\n                    C3, C2, C0 := 001;\n    ST = SRC:\n                    C3, C2, C0 := 100;\nESAC;\nIF ST(0) or SRC = NaN or unsupported format\n    THEN\n        #IA\n        IF FPUControlWord.IM = 1\n            THEN\n                C3, C2, C0 := 111;\n        FI;\nFI;\nIF Instruction = FCOMP\n    THEN\n        PopRegisterStack;\nFI;\nIF Instruction = FCOMPP\n    THEN\n        PopRegisterStack;\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_2: One or both operands are NaN values or have unsupported formats.; column_1: #IA; \ncolumn_1: Register is marked empty.; \ncolumn_1: #D; column_2: One or both operands are denormal values.;"
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/enqcmds",
    "category": "Core Instructions",
    "instructionName": "ENQCMDS\n\t\t— Enqueue Command Supervisor",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "ENQCMD",
        "Description": "Atomically enqueue 64-byte command with PASID from source memory operand to destination offset in ES segment specified in register operand as offset in ES segment.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 F8 !(11):rrr:bbb ENQCMDS r32/r64, m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpcmpb:vpcmpub",
    "category": "Core Instructions",
    "instructionName": "VPCMPB/VPCMPUB\n\t\t— Compare Packed Byte Values Into Mask",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed byte values in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 3F /r ib VPCMPB k1 {k2}, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed signed byte values in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 3F /r ib VPCMPB k1 {k2}, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed signed byte values in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 3F /r ib VPCMPB k1 {k2}, zmm2, zmm3/m512, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned byte values in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W0 3E /r ib VPCMPUB k1 {k2}, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Compare packed unsigned byte values in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W0 3E /r ib VPCMPUB k1 {k2}, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Compare packed unsigned byte values in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W0 3E /r ib VPCMPUB k1 {k2}, zmm2, zmm3/m512, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/wbnoinvd",
    "category": "Core Instructions",
    "instructionName": "WBNOINVD\n\t\t— Write Back and Do Not Invalidate Cache",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "WBNOINVD",
        "Description": "Write back and do not flush internal caches; initiate writing-back without flushing of external caches.",
        "Op/En": "ZO",
        "Opcode / Instruction": "F3 0F 09 WBNOINVD"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The WBNOINVD instruction writes back all modified cache lines in the processor’s internal cache to main memory but does not invalidate (flush) the internal caches.\nAfter executing this instruction, the processor does not wait for the external caches to complete their write-back operation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back signal. The amount of time or cycles for WBNOINVD to complete will vary due to size and other factors of different cache hierarchies. As a consequence, the use of the WBNOINVD instruction can have an impact on logical processor interrupt/event response time.\nThe WBNOINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see “Serializing Instructions” in Chapter 9 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A).\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "WriteBack(InternalCaches);\nContinue; (* Continue execution *)\nWBNOINVD void _wbnoinvd(void);",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmaskmov",
    "category": "Core Instructions",
    "instructionName": "VMASKMOV\n\t\t— Conditional SIMD Packed Loads and Stores",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1.",
        "Op/En": "RV M",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 2C /r VMASKMOVPS xmm1, xmm2, m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1.",
        "Op/En": "RV M",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 2C /r VMASKMOVPS ymm1, ymm2, m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally load packed double precision values from m128 using mask in xmm2 and store in xmm1.",
        "Op/En": "RV M",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 2D /r VMASKMOVPD xmm1, xmm2, m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally load packed double precision values from m256 using mask in ymm2 and store in ymm1.",
        "Op/En": "RV M",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 2D /r VMASKMOVPD ymm1, ymm2, m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally store packed single-precision values from xmm2 using mask in xmm1.",
        "Op/En": "MV R",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 2E /r VMASKMOVPS m128, xmm1, xmm2"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally store packed single-precision values from ymm2 using mask in ymm1.",
        "Op/En": "MV R",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 2E /r VMASKMOVPS m256, ymm1, ymm2"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally store packed double precision values from xmm2 using mask in xmm1.",
        "Op/En": "MV R",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 2F /r VMASKMOVPD m128, xmm1, xmm2"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Conditionally store packed double precision values from ymm2 using mask in ymm1.",
        "Op/En": "MV R",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 2F /r VMASKMOVPD m256, ymm1, ymm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MVR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:reg (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.\nThe mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.\nThe second source operand is a memory address for the load form of these instruction. The destination operand is a memory address for the store form of these instructions. The other operands are both XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).\nFaults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.\nUnlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.\nInstruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.\nVMASKMOV should not be used to access memory mapped I/O and un-cached memory as the access and the ordering of the individual loads or stores it does is implementation specific.\nIn cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.\nNote: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.\nNote: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field.",
    "operationText": "DEST[31:0] := IF (SRC1[31]) Load_32(mem) ELSE 0\nDEST[63:32] := IF (SRC1[63]) Load_32(mem + 4) ELSE 0\nDEST[95:64] := IF (SRC1[95]) Load_32(mem + 8) ELSE 0\nDEST[127:97] := IF (SRC1[127]) Load_32(mem + 12) ELSE 0\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := IF (SRC1[31]) Load_32(mem) ELSE 0\nDEST[63:32] := IF (SRC1[63]) Load_32(mem + 4) ELSE 0\nDEST[95:64] := IF (SRC1[95]) Load_32(mem + 8) ELSE 0\nDEST[127:96] := IF (SRC1[127]) Load_32(mem + 12) ELSE 0\nDEST[159:128] := IF (SRC1[159]) Load_32(mem + 16) ELSE 0\nDEST[191:160] := IF (SRC1[191]) Load_32(mem + 20) ELSE 0\nDEST[223:192] := IF (SRC1[223]) Load_32(mem + 24) ELSE 0\nDEST[255:224] := IF (SRC1[255]) Load_32(mem + 28) ELSE 0\nDEST[63:0] := IF (SRC1[63]) Load_64(mem) ELSE 0\nDEST[127:64] := IF (SRC1[127]) Load_64(mem + 16) ELSE 0\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := IF (SRC1[63]) Load_64(mem) ELSE 0\nDEST[127:64] := IF (SRC1[127]) Load_64(mem + 8) ELSE 0\nDEST[195:128] := IF (SRC1[191]) Load_64(mem + 16) ELSE 0\nDEST[255:196] := IF (SRC1[255]) Load_64(mem + 24) ELSE 0\nIF (SRC1[31]) DEST[31:0] := SRC2[31:0]\nIF (SRC1[63]) DEST[63:32] := SRC2[63:32]\nIF (SRC1[95]) DEST[95:64] := SRC2[95:64]\nIF (SRC1[127]) DEST[127:96] := SRC2[127:96]\nIF (SRC1[31]) DEST[31:0] := SRC2[31:0]\nIF (SRC1[63]) DEST[63:32] := SRC2[63:32]\nIF (SRC1[95]) DEST[95:64] := SRC2[95:64]\nIF (SRC1[127]) DEST[127:96] := SRC2[127:96]\nIF (SRC1[159]) DEST[159:128] :=SRC2[159:128]\nIF (SRC1[191]) DEST[191:160] := SRC2[191:160]\nIF (SRC1[223]) DEST[223:192] := SRC2[223:192]\nIF (SRC1[255]) DEST[255:224] := SRC2[255:224]\nIF (SRC1[63]) DEST[63:0] := SRC2[63:0]\nIF (SRC1[127]) DEST[127:64] := SRC2[127:64]\nIF (SRC1[63]) DEST[63:0] := SRC2[63:0]\nIF (SRC1[127]) DEST[127:64] := SRC2[127:64]\nIF (SRC1[191]) DEST[191:128] := SRC2[191:128]\nIF (SRC1[255]) DEST[255:192] := SRC2[255:192]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-23, “Type 6 Class Exception Conditions” (No AC# reported for any mask bit combinations).",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvttss2si",
    "category": "Core Instructions",
    "instructionName": "CVTTSS2SI\n\t\t— Convert With Truncation Scalar Single Precision Floating-Point Value to Integer",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 2C /r CVTTSS2SI r32, xmm1/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "SSE",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 REX.W 0F 2C /r CVTTSS2SI r64, xmm1/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.F3.0F.W0 2C /r 1 VCVTTSS2SI r32, xmm1/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.LIG.F3.0F.W1 2C /r 1 VCVTTSS2SI r64, xmm1/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 2C /r VCVTTSS2SI r32, xmm1/m32{sae}"
      },
      {
        "64/32 bit Mode Support": "V/N.E.2",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W1 2C /r VCVTTSS2SI r64, xmm1/m32{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Fixed"
      }
    ],
    "descriptionText": "Converts a single precision floating-point value in the source operand (the second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the single precision floating-point value is contained in the low doubleword of the register.\nWhen a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked, the indefinite integer value (80000000H or 80000000_00000000H if operand size is 64 bits) is returned.\nLegacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.\nVEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.\nSoftware should ensure VCVTTSS2SI is encoded with VEX.L=0. Encoding VCVTTSS2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF 64-Bit Mode and OperandSize = 64\nTHEN\n    DEST[63:0] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0]);\nELSE\n    DEST[31:0] := Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31:0]);\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-20, “Type 3 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instructions, see Table 2-48, “Type E3NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/eremove",
    "category": "SGX Instructions",
    "instructionName": "EREMOVE\n\t\t— Remove a page from the EPC",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function removes a page from the EPC.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 03H ENCLS[EREMOVE]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EREMOVE (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Effective address of the EPC page (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttps2uqq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPS2UQQ\n\t\t— Convert With Truncation Packed Single Precision Floating-Point Values toPacked Unsigned Quadword Integer Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed unsigned quadword values in xmm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 78 /r VCVTTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 78 /r VCVTTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 using truncation subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 78 /r VCVTTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/finit:fninit",
    "category": "Core Instructions",
    "instructionName": "FINIT/FNINIT\n\t\t— Initialize Floating-Point Unit",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Initialize FPU after checking for pending unmasked floating-point exceptions.",
        "Instruction": "FINIT",
        "Opcode": "9B DB E3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Initialize FPU without checking for pending unmasked floating-point exceptions.",
        "Instruction": "FNINIT1",
        "Opcode": "DB E3"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared.\nThe FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.\nThe assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "FPUControlWord := 037FH;\nFPUStatusWord := 0;\nFPUTagWord := FFFFH;\nFPUDataPointer := 0;\nFPUInstructionPointer := 0;\nFPULastInstructionOpcode := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "None."
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/lea",
    "category": "Core Instructions",
    "instructionName": "LEA\n\t\t— Load Effective Address",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store effective address for m in register r16.",
        "Instruction": "LEA r16,m",
        "Op/En": "RM",
        "Opcode": "8D /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store effective address for m in register r32.",
        "Instruction": "LEA r32,m",
        "Op/En": "RM",
        "Opcode": "8D /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Store effective address for m in register r64.",
        "Instruction": "LEA r64,m",
        "Op/En": "RM",
        "Opcode": "REX.W + 8D /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment.\nDifferent assemblers may use different algorithms based on the size attribute and symbolic reference of the source operand.\nIn 64-bit mode, the instruction’s destination operand is governed by operand size attribute, the default operand size is 32 bits. Address calculation is governed by address size attribute, the default address size is 64-bits. In 64-bit mode, address size of 16 bits is not encodable. See Table 3-55.",
    "operationText": "IF OperandSize = 16 and AddressSize = 16\n    THEN\n        DEST := EffectiveAddress(SRC); (* 16-bit address *)\n    ELSE IF OperandSize = 16 and AddressSize = 32\n        THEN\n            temp := EffectiveAddress(SRC); (* 32-bit address *)\n            DEST := temp[0:15]; (* 16-bit address *)\n        FI;\n    ELSE IF OperandSize = 32 and AddressSize = 16\n        THEN\n            temp := EffectiveAddress(SRC); (* 16-bit address *)\n            DEST := ZeroExtend(temp); (* 32-bit address *)\n        FI;\n    ELSE IF OperandSize = 32 and AddressSize = 32\n        THEN\n            DEST := EffectiveAddress(SRC); (* 32-bit address *)\n        FI;\n    ELSE IF OperandSize = 16 and AddressSize = 64\n        THEN\n            temp := EffectiveAddress(SRC); (* 64-bit address *)\n            DEST := temp[0:15]; (* 16-bit address *)\n        FI;\n    ELSE IF OperandSize = 32 and AddressSize = 64\n        THEN\n            temp := EffectiveAddress(SRC); (* 64-bit address *)\n            DEST := temp[0:31]; (* 16-bit address *)\n        FI;\n    ELSE IF OperandSize = 64 and AddressSize = 64\n        THEN\n            DEST := EffectiveAddress(SRC); (* 64-bit address *)\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfnmadd132ss:vfnmadd213ss:vfnmadd231ss",
    "category": "Core Instructions",
    "instructionName": "VFNMADD132SS/VFNMADD213SS/VFNMADD231SS\n\t\t— Fused Negative Multiply-Add of ScalarSingle Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and add to xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 9D /r VFNMADD132SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 AD /r VFNMADD213SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W0 BD /r VFNMADD231SS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and add to xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 9D /r VFNMADD132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 AD /r VFNMADD213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W0 BD /r VFNMADD231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vreduceph",
    "category": "Core Instructions",
    "instructionName": "VREDUCEPH\n\t\t— Perform Reduction Transformation on Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Perform reduction transformation on packed FP16 values in xmm2/m128/m16bcst by subtracting a number of fraction bits specified by the imm8 field. Store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.0F3A.W0 56 /r /ib VREDUCEPH xmm1{k1}{z}, xmm2/m128/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Perform reduction transformation on packed FP16 values in ymm2/m256/m16bcst by subtracting a number of fraction bits specified by the imm8 field. Store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.0F3A.W0 56 /r /ib VREDUCEPH ymm1{k1}{z}, ymm2/m256/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Perform reduction transformation on packed FP16 values in zmm2/m512/m16bcst by subtracting a number of fraction bits specified by the imm8 field. Store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.0F3A.W0 56 /r /ib VREDUCEPH zmm1{k1}{z}, zmm2/m512/m16bcst {sae}, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8 (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtqq2ps",
    "category": "Core Instructions",
    "instructionName": "VCVTQQ2PS\n\t\t— Convert Packed Quadword Integers to Packed Single Precision Floating-PointValues",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed quadword integers from xmm2/mem to packed single precision floating-point values in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.0F.W1 5B /r VCVTQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed quadword integers from ymm2/mem to packed single precision floating-point values in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.0F.W1 5B /r VCVTQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed quadword integers from zmm2/mem to eight packed single precision floating-point values in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.0F.W1 5B /r VCVTQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttsh2si",
    "category": "Core Instructions",
    "instructionName": "VCVTTSH2SI\n\t\t— Convert with Truncation Low FP16 Value to a Signed Integer",
    "detailsTable": [
      {
        "Description": "Convert FP16 value in the low element of xmm1/m16 to a signed integer and store the result in r32 using truncation.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 2C /r VCVTTSH2SI r32, xmm1/m16 {sae}",
        "Support": "V/V1",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Convert FP16 value in the low element of xmm1/m16 to a signed integer and store the result in r64 using truncation.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W1 2C /r VCVTTSH2SI r64, xmm1/m16 {sae}",
        "Support": "V/N.E.",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/extractps",
    "category": "Core Instructions",
    "instructionName": "EXTRACTPS\n\t\t— Extract Packed Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "VV",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Extract one single precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 3A 17 /r ib EXTRACTPS reg/m32, xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Extract one single precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F3A.WIG 17 /r ib VEXTRACTPS reg/m32, xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Extract one single precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F3A.WIG 17 /r ib VEXTRACTPS reg/m32, xmm1, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Extracts a single precision floating-point value from the source operand (second operand) at the 32-bit offset specified from imm8. Immediate bits higher than the most significant offset for the vector length are ignored.\nThe extracted single precision floating-point value is stored in the low 32-bits of the destination operand\nIn 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register are filled with zero. REX.W is ignored.\nVEX.128 and EVEX encoded version: When VEX.W1 or EVEX.W1 form is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.\nVEX.vvvv/EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\n128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.\nThe source register is an XMM register. Imm8[1:0] determine the starting DWORD offset from which to extract the 32-bit floating-point value.\nIf VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
    "operationText": "SRC_OFFSET := IMM8[1:0]\nIF (64-Bit Mode and DEST is register)\n    DEST[31:0] := (SRC[127:0] >> (SRC_OFFSET*32)) AND 0FFFFFFFFh\n    DEST[63:32] := 0\nELSE\n    DEST[31:0] := (SRC[127:0] >> (SRC_OFFSET*32)) AND 0FFFFFFFFh\nFI\nSRC_OFFSET := IMM8[1:0]\nIF (64-Bit Mode and DEST is register)\n    DEST[31:0] := (SRC[127:0] >> (SRC_OFFSET*32)) AND 0FFFFFFFFh\n    DEST[63:32] := 0\nELSE\n    DEST[31:0] := (SRC[127:0] >> (SRC_OFFSET*32)) AND 0FFFFFFFFh\nFI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-57, “Type E9NF Class Exception Conditions.”",
        "Additionally:",
        "column_1: #UD; column_2: If VEX.vvvv != 1111B or EVEX.vvvv != 1111B.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fdivr:fdivrp:fidivr",
    "category": "Core Instructions",
    "instructionName": "FDIVR/FDIVRP/FIDIVR\n\t\t— Reverse Divide",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide m32fp by ST(0) and store result in ST(0).",
        "Instruction": "FDIVR m32fp",
        "Opcode": "D8 /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide m64fp by ST(0) and store result in ST(0).",
        "Instruction": "FDIVR m64fp",
        "Opcode": "DC /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(i) by ST(0) and store result in ST(0).",
        "Instruction": "FDIVR ST(0), ST(i)",
        "Opcode": "D8 F8+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(0) by ST(i) and store result in ST(i).",
        "Instruction": "FDIVR ST(i), ST(0)",
        "Opcode": "DC F0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(0) by ST(i), store result in ST(i), and pop the register stack.",
        "Instruction": "FDIVRP ST(i), ST(0)",
        "Opcode": "DE F0+i"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide ST(0) by ST(1), store result in ST(1), and pop the register stack.",
        "Instruction": "FDIVRP",
        "Opcode": "DE F1"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide m32int by ST(0) and store result in ST(0).",
        "Instruction": "FIDIVR m32int",
        "Opcode": "DA /7"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Divide m16int by ST(0) and store result in ST(0).",
        "Instruction": "FIDIVR m16int",
        "Opcode": "DE /7"
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Divides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single precision or double precision floating-point format, word or doubleword integer format.\nThese instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.\nThe no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.\nThe FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.\nThe FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.\nIf an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.\nThe following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs.\nWhen the source operand is an integer 0, it is treated as a +0. This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "IF DEST = 0\n    THEN\n        #Z;\n    ELSE\n        IF Instruction = FIDIVR\n            THEN\n                DEST := ConvertToDoubleExtendedPrecisionFP(SRC) / DEST;\n            ELSE (* Source operand is floating-point value *)\n                DEST := SRC / DEST;\n        FI;\nFI;\nIF Instruction = FDIVRP\n    THEN\n        PopRegisterStack;\nFI;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Operand is an SNaN value or unsupported format.; \ncolumn_1: ±∞ / ±∞; ±0 / ±0; \ncolumn_1: #D; column_2: Source is a denormal value.; \ncolumn_1: #Z; column_2: SRC / ±0, where SRC is not equal to ±0.; \ncolumn_1: #U; column_2: Result is too small for destination format.; \ncolumn_1: #O; column_2: Result is too large for destination format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aaa",
    "category": "Core Instructions",
    "instructionName": "AAA\n\t\t— ASCII Adjust After Addition",
    "detailsTable": [
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "ASCII adjust AL after addition.",
        "Instruction": "AAA",
        "Op/En": "ZO",
        "Opcode": "37"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.\nIf the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4 through 7 of the AL register are set to 0.\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        #UD;\n    ELSE\n        IF ((AL AND 0FH) > 9) or (AF = 1)\n            THEN\n                AX := AX + 106H;\n                AF := 1;\n                CF := 1;\n            ELSE\n                AF := 0;\n                CF := 0;\n        FI;\n        AL := AL AND 0FH;\nFI;",
    "flagsAffectedText": "The AF and CF flags are set to 1 if the adjustment results in a decimal carry; otherwise they are set to 0. The OF, SF, ZF, and PF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        "Same exceptions as protected mode."
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        "Same exceptions as protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/ftst",
    "category": "Core Instructions",
    "instructionName": "FTST\n\t\t— TEST",
    "detailsTable": [
      {
        "Description": "Compare ST(0) with 0.0.",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 E4",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below).\nThis instruction performs an “unordered comparison.” An unordered comparison also checks the class of the numbers being compared (see “FXAM—Examine Floating-Point” in this chapter). If the value in register ST(0) is a NaN or is in an undefined format, the condition flags are set to “unordered” and the invalid operation exception is generated.\nThe sign of zero is ignored, so that (– 0.0 := +0.0).\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "CASE (relation of operands) OF\n    Not comparable:\n        C3, C2, C0 := 111;\n    ST(0) > 0.0:\n        C3, C2, C0 := 000;\n    ST(0) < 0.0:\n        C3, C2, C0 := 001;\n    ST(0) = 0.0:\n        C3, C2, C0 := 100;\nESAC;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: The source operand is a NaN value or is in an unsupported format.; \ncolumn_1: #D; column_2: The source operand is a denormal value.;"
      ],
      "protectedMode": [
        "column_2: If there is a pending x87 FPU exception.; column_1: #MF; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/divsd",
    "category": "Core Instructions",
    "instructionName": "DIVSD\n\t\t— Divide Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Divide low double precision floating-point value in xmm1 by low double precision floating-point value in xmm2/m64.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 5E /r DIVSD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Divide low double precision floating-point value in xmm2 by low double precision floating-point value in xmm3/m64.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 5E /r VDIVSD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Divide low double precision floating-point value in xmm2 by low double precision floating-point value in xmm3/m64.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 5E /r VDIVSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Divides the low double precision floating-point value in the first source operand by the low double precision floating-point value in the second source operand, and stores the double precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination are XMM registers.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding ZMM destination register remain unchanged.\nVEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The quadword at bits 127:64 of the destination operand is copied from the corresponding quadword of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The quadword element of the destination operand at bits 127:64 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX version: The low quadword element of the destination is updated according to the writemask.\nSoftware should ensure VDIVSD is encoded with VEX.L=0. Encoding VDIVSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "IF (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := SRC1[63:0] / SRC2[63:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC1[63:0] / SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := DEST[63:0] / SRC[63:0]\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rcl:rcr:rol:ror",
    "category": "Core Instructions",
    "instructionName": "RCL/RCR/ROL/ROR\n\t\t— Rotate",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 9 bits (CF, r/m8) left once.",
        "Instruction": "RCL r/m8, 1",
        "Op/En": "M1",
        "column_1": "D0 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 9 bits (CF, r/m8) left once.",
        "Instruction": "RCL r/m82, 1",
        "Op/En": "M1",
        "column_1": "REX + D0 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 9 bits (CF, r/m8) left CL times.",
        "Instruction": "RCL r/m8, CL",
        "Op/En": "MC",
        "column_1": "D2 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 9 bits (CF, r/m8) left CL times.",
        "Instruction": "RCL r/m82, CL",
        "Op/En": "MC",
        "column_1": "REX + D2 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 9 bits (CF, r/m8) left imm8 times.",
        "Instruction": "RCL r/m8, imm8",
        "Op/En": "MI",
        "column_1": "C0 /2 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 9 bits (CF, r/m8) left imm8 times.",
        "Instruction": "RCL r/m82, imm8",
        "Op/En": "MI",
        "column_1": "REX + C0 /2 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 17 bits (CF, r/m16) left once.",
        "Instruction": "RCL r/m16, 1",
        "Op/En": "M1",
        "column_1": "D1 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 17 bits (CF, r/m16) left CL times.",
        "Instruction": "RCL r/m16, CL",
        "Op/En": "MC",
        "column_1": "D3 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 17 bits (CF, r/m16) left imm8 times.",
        "Instruction": "RCL r/m16, imm8",
        "Op/En": "MI",
        "column_1": "C1 /2 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 33 bits (CF, r/m32) left once.",
        "Instruction": "RCL r/m32, 1",
        "Op/En": "M1",
        "column_1": "D1 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.",
        "Instruction": "RCL r/m64, 1",
        "Op/En": "M1",
        "column_1": "REX.W + D1 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 33 bits (CF, r/m32) left CL times.",
        "Instruction": "RCL r/m32, CL",
        "Op/En": "MC",
        "column_1": "D3 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.",
        "Instruction": "RCL r/m64, CL",
        "Op/En": "MC",
        "column_1": "REX.W + D3 /2"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 33 bits (CF, r/m32) left imm8 times.",
        "Instruction": "RCL r/m32, imm8",
        "Op/En": "MI",
        "column_1": "C1 /2 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.",
        "Instruction": "RCL r/m64, imm8",
        "Op/En": "MI",
        "column_1": "REX.W + C1 /2 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 9 bits (CF, r/m8) right once.",
        "Instruction": "RCR r/m8, 1",
        "Op/En": "M1",
        "column_1": "D0 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 9 bits (CF, r/m8) right once.",
        "Instruction": "RCR r/m82, 1",
        "Op/En": "M1",
        "column_1": "REX + D0 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 9 bits (CF, r/m8) right CL times.",
        "Instruction": "RCR r/m8, CL",
        "Op/En": "MC",
        "column_1": "D2 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 9 bits (CF, r/m8) right CL times.",
        "Instruction": "RCR r/m82, CL",
        "Op/En": "MC",
        "column_1": "REX + D2 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 9 bits (CF, r/m8) right imm8 times.",
        "Instruction": "RCR r/m8, imm8",
        "Op/En": "MI",
        "column_1": "C0 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 9 bits (CF, r/m8) right imm8 times.",
        "Instruction": "RCR r/m82, imm8",
        "Op/En": "MI",
        "column_1": "REX + C0 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 17 bits (CF, r/m16) right once.",
        "Instruction": "RCR r/m16, 1",
        "Op/En": "M1",
        "column_1": "D1 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 17 bits (CF, r/m16) right CL times.",
        "Instruction": "RCR r/m16, CL",
        "Op/En": "MC",
        "column_1": "D3 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 17 bits (CF, r/m16) right imm8 times.",
        "Instruction": "RCR r/m16, imm8",
        "Op/En": "MI",
        "column_1": "C1 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.",
        "Instruction": "RCR r/m32, 1",
        "Op/En": "M1",
        "column_1": "D1 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.",
        "Instruction": "RCR r/m64, 1",
        "Op/En": "M1",
        "column_1": "REX.W + D1 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 33 bits (CF, r/m32) right CL times.",
        "Instruction": "RCR r/m32, CL",
        "Op/En": "MC",
        "column_1": "D3 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.",
        "Instruction": "RCR r/m64, CL",
        "Op/En": "MC",
        "column_1": "REX.W + D3 /3"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 33 bits (CF, r/m32) right imm8 times.",
        "Instruction": "RCR r/m32, imm8",
        "Op/En": "MI",
        "column_1": "C1 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.",
        "Instruction": "RCR r/m64, imm8",
        "Op/En": "MI",
        "column_1": "REX.W + C1 /3 ib"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 8 bits r/m8 left once.",
        "Instruction": "ROL r/m8, 1",
        "Op/En": "M1",
        "column_1": "D0 /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 8 bits r/m8 left once",
        "Instruction": "ROL r/m82, 1",
        "Op/En": "M1",
        "column_1": "REX + D0 /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 8 bits r/m8 left CL times.",
        "Instruction": "ROL r/m8, CL",
        "Op/En": "MC",
        "column_1": "D2 /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Rotate 8 bits r/m8 left CL times.",
        "Instruction": "ROL r/m82, CL",
        "Op/En": "MC",
        "column_1": "REX + D2 /0"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Rotate 8 bits r/m8 left imm8 times.",
        "Instruction": "ROL r/m8, imm8",
        "Op/En": "MI",
        "column_1": "C0 /0 ib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M1",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "1",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MC",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "CL",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MI",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).\nThe rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.\nThe RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.\nThe OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.",
    "operationText": "SIZE := OperandSize;\nCASE (determine count) OF\n    SIZE := 8:\n        tempCOUNT := (COUNT AND 1FH) MOD 9;\n    SIZE := 16:\n        tempCOUNT := (COUNT AND 1FH) MOD 17;\n    SIZE := 32:\n        tempCOUNT := COUNT AND 1FH;\n    SIZE := 64:\n        tempCOUNT := COUNT AND 3FH;\nESAC;\nIF OperandSize = 64\n    THEN COUNTMASK = 3FH;\n    ELSE COUNTMASK = 1FH;\nFI;\nWHILE (tempCOUNT ≠ 0)\n    DO\n        tempCF := MSB(DEST);\n        DEST := (DEST ∗ 2) + CF;\n        CF := tempCF;\n        tempCOUNT := tempCOUNT – 1;\n    OD;\nELIHW;\nIF (COUNT & COUNTMASK) = 1\n    THEN OF := MSB(DEST) XOR CF;\n    ELSE OF is undefined;\nFI;\nIF (COUNT & COUNTMASK) = 1\n    THEN OF := MSB(DEST) XOR CF;\n    ELSE OF is undefined;\nFI;\nWHILE (tempCOUNT ≠ 0)\n    DO\n        tempCF := LSB(SRC);\n        DEST := (DEST / 2) + (CF * 2SIZE);\n        CF := tempCF;\n        tempCOUNT := tempCOUNT – 1;\n    OD;\ntempCOUNT := (COUNT & COUNTMASK) MOD SIZE\nWHILE (tempCOUNT ≠ 0)\n    DO\n        tempCF := MSB(DEST);\n        DEST := (DEST ∗ 2) + tempCF;\n        tempCOUNT := tempCOUNT – 1;\n    OD;\nELIHW;\nIF (COUNT & COUNTMASK) ≠ 0\n    THEN CF := LSB(DEST);\nFI;\nIF (COUNT & COUNTMASK) = 1\n    THEN OF := MSB(DEST) XOR CF;\n    ELSE OF is undefined;\nFI;\ntempCOUNT := (COUNT & COUNTMASK) MOD SIZE\nWHILE (tempCOUNT ≠ 0)\n    DO\n        tempCF := LSB(SRC);\n        DEST := (DEST / 2) + (tempCF ∗ 2SIZE);\n        tempCOUNT := tempCOUNT – 1;\n    OD;\nELIHW;\nIF (COUNT & COUNTMASK) ≠ 0\n    THEN CF := MSB(DEST);\nFI;\nIF (COUNT & COUNTMASK) = 1\n    THEN OF := MSB(DEST) XOR MSB − 1(DEST);\n    ELSE OF is undefined;\nFI;",
    "flagsAffectedText": "For RCL and RCR instructions, a zero-bit rotate does nothing, i.e., affects no flags. For ROL and ROR instructions, if the masked count is 0, the flags are not affected. If the masked count is 1, then the OF flag is affected, otherwise (masked count is greater than 1) the OF flag is undefined.\nFor all instructions, the CF flag is affected when the masked count is non-zero. The SF, ZF, AF, and PF flags are always unaffected.",
    "exceptions": {
      "64BitMode": [
        "column_2: If the source operand is located in a nonwritable segment.; column_1: #GP(0); \ncolumn_1: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vtestpd:vtestps",
    "category": "Core Instructions",
    "instructionName": "VTESTPD/VTESTPS\n\t\t— Packed Bit Test",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources.",
        "Op /En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 0E /r VTESTPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources.",
        "Op /En": "RM",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 0E /r VTESTPS ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Set ZF and CF depending on sign bit AND and ANDN of packed double precision floating-point sources.",
        "Op /En": "RM",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 0F /r VTESTPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Set ZF and CF depending on sign bit AND and ANDN of packed double precision floating-point sources.",
        "Op /En": "RM",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 0F /r VTESTPD ymm1, ymm2/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.\nVTESTPD performs a bitwise comparison of all the sign bits of the double precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.\nThe first source register is specified by the ModR/M reg field.\n128-bit version: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.\nVEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "TEMP[127:0] := SRC[127:0] AND DEST[127:0]\nIF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127] = 0)\n    THEN ZF := 1;\n    ELSE ZF := 0;\nTEMP[127:0] := SRC[127:0] AND NOT DEST[127:0]\nIF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127] = 0)\n    THEN CF := 1;\n    ELSE CF := 0;\nDEST (unmodified)\nAF := OF := PF := SF := 0;\nTEMP[255:0] := SRC[255:0] AND DEST[255:0]\nIF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127]= TEMP[160] =TEMP[191] = TEMP[224] = TEMP[255] = 0)\n    THEN ZF := 1;\n    ELSE ZF := 0;\nTEMP[255:0] := SRC[255:0] AND NOT DEST[255:0]\nIF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127]= TEMP[160] =TEMP[191] = TEMP[224] = TEMP[255] = 0)\n    THEN CF := 1;\n    ELSE CF := 0;\nDEST (unmodified)\nAF := OF := PF := SF := 0;\nTEMP[127:0] := SRC[127:0] AND DEST[127:0]\nIF ( TEMP[63] = TEMP[127] = 0)\n    THEN ZF := 1;\n    ELSE ZF := 0;\nTEMP[127:0] := SRC[127:0] AND NOT DEST[127:0]\nIF ( TEMP[63] = TEMP[127] = 0)\n    THEN CF := 1;\n    ELSE CF := 0;\nDEST (unmodified)\nAF := OF := PF := SF := 0;\nTEMP[255:0] := SRC[255:0] AND DEST[255:0]\nIF (TEMP[63] = TEMP[127] = TEMP[191] = TEMP[255] = 0)\n    THEN ZF := 1;\n    ELSE ZF := 0;\nTEMP[255:0] := SRC[255:0] AND NOT DEST[255:0]\nIF (TEMP[63] = TEMP[127] = TEMP[191] = TEMP[255] = 0)\n    THEN CF := 1;\n    ELSE CF := 0;\nDEST (unmodified)\nAF := OF := PF := SF := 0;",
    "flagsAffectedText": "The OF, AF, PF, SF flags are cleared and the ZF, CF flags are set according to the operation.",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”",
        "Additionally:",
        "column_1: If VEX.W = 1 for VTESTPS or VTESTPD.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movhpd",
    "category": "Core Instructions",
    "instructionName": "MOVHPD\n\t\t— Move High Packed Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move double precision floating-point value from m64 to high quadword of xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 16 /r MOVHPD xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Merge double precision floating-point value from m64 and the low quadword of xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 16 /r VMOVHPD xmm2, xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Merge double precision floating-point value from m64 and the low quadword of xmm1.",
        "Op / En": "D",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 16 /r VMOVHPD xmm2, xmm1, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move double precision floating-point value from high quadword of xmm1 to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "66 0F 17 /r MOVHPD m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move double precision floating-point value from high quadword of xmm1 to m64.",
        "Op / En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 17 /r VMOVHPD m64, xmm1"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move double precision floating-point value from high quadword of xmm1 to m64.",
        "Op / En": "E",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 17 /r VMOVHPD m64, xmm1"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      },
      {
        "Op/En": "E",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "This instruction cannot be used for register to register or memory to memory moves.\n128-bit Legacy SSE load:\nMoves a double precision floating-point value from the source 64-bit memory operand and stores it in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.\nVEX.128 & EVEX encoded load:\nLoads a double precision floating-point value from the source 64-bit memory operand (the third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source operand (second operand) are copied to the low 64-bits of the destination. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\n128-bit store:\nStores a double precision floating-point value from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).\nNote: VMOVHPD (store) (VEX.128.66.0F 17 /r) is legal and has the same behavior as the existing 66 0F 17 store. For VMOVHPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.\nIf VMOVHPD is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception.",
    "operationText": "DEST[63:0] (Unmodified)\nDEST[127:64] := SRC[63:0]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[63:0] := SRC1[63:0]\nDEST[127:64] := SRC2[63:0]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC[127:64]",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-57, “Type E9NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pushf:pushfd:pushfq",
    "category": "Core Instructions",
    "instructionName": "PUSHF/PUSHFD/PUSHFQ\n\t\t— Push EFLAGS Register Onto the Stack",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Push lower 16 bits of EFLAGS.",
        "Instruction": "PUSHF",
        "Op/En": "ZO",
        "Opcode": "9C"
      },
      {
        "64-Bit Mode": "N.E.",
        "Compat/Leg Mode": "Valid",
        "Description": "Push EFLAGS.",
        "Instruction": "PUSHFD",
        "Op/En": "ZO",
        "Opcode": "9C"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Push RFLAGS.",
        "Instruction": "PUSHFQ",
        "Op/En": "ZO",
        "Opcode": "9C"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions reverse the operation of the POPF/POPFD instructions.\nWhen copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, the values for these flags are cleared in the EFLAGS image stored on the stack. See Chapter 3 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information about the EFLAGS register.\nThe PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32 when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.\nIn 64-bit mode, the instruction’s default operation is to decrement the stack pointer (RSP) by 8 and pushes RFLAGS on the stack. 16-bit operation is supported using the operand size override prefix 66H. 32-bit operand size cannot be encoded in this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, values for these flags are cleared in the RFLAGS image stored on the stack.\nWhen operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0), the PUSHF/PUSHFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs. If the virtual-8086 mode extensions are enabled (CR4.VME = 1), PUSHF (but not PUSHFD) can be executed in virtual-8086 mode with IOPL < 3.\n(The protected-mode virtual-interrupt feature — enabled by setting CR4.PVI — affects the CLI and STI instructions in the same manner as the virtual-8086 mode extensions. PUSHF, however, is not affected by CR4.PVI.)\nIn the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction executes: an #SS exception is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
    "operationText": "IF (PE = 0) or (PE = 1 and ((VM = 0) or (VM = 1 and IOPL = 3)))\n(* Real-Address Mode, Protected mode, or Virtual-8086 mode with IOPL equal to 3 *)\n    THEN\n        IF OperandSize = 32\n            THEN\n                push (EFLAGS AND 00FCFFFFH);\n                (* VM and RF bits are cleared in image stored on the stack *)\n            ELSE\n                push (EFLAGS); (* Lower 16 bits only *)\n        FI;\n    ELSE IF 64-bit MODE (* In 64-bit Mode *)\n        IF OperandSize = 64\n            THEN\n                push (RFLAGS AND 00000000_00FCFFFFH);\n                (* VM and RF bits are cleared in image stored on the stack; *)\n            ELSE\n                push (EFLAGS); (* Lower 16 bits only *)\n        FI;\n    ELSE (* In Virtual-8086 Mode with IOPL less than 3 *)\n        IF (CR4.VME = 0) OR (OperandSize = 32)\n            THEN #GP(0); (* Trap to virtual-8086 monitor *)\n            ELSE\n                tempFLAGS = EFLAGS[15:0];\n                tempFLAGS[9] = tempFLAGS[19]; (* VIF replaces IF *)\n                tempFlags[13:12]=3; (*IOPLissetto3inimagestoredonthestack*)\n                push (tempFLAGS);\n        FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while CPL = 3 and alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while CPL = 3 and alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        "column_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pshufb",
    "category": "Core Instructions",
    "instructionName": "PSHUFB\n\t\t— Packed Shuffle Bytes",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Shuffle bytes in mm1 according to contents of mm2/m64.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 38 00 /r1 PSHUFB mm1, mm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSSE3",
        "Description": "Shuffle bytes in xmm1 according to contents of xmm2/m128.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 00 /r PSHUFB xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shuffle bytes in xmm2 according to contents of xmm3/m128.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 00 /r VPSHUFB xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shuffle bytes in ymm2 according to contents of ymm3/m256.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 00 /r VPSHUFB ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shuffle bytes in xmm2 according to contents of xmm3/m128 under write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG 00 /r VPSHUFB xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shuffle bytes in ymm2 according to contents of ymm3/m256 under write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG 00 /r VPSHUFB ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shuffle bytes in zmm2 according to contents of zmm3/m512 under write mask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG 00 /r VPSHUFB zmm1 {k1}{z}, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "PSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle control mask in the source operand (the second operand). The instruction permutes the data in the destination operand, leaving the shuffle mask unaffected. If the most significant bit (bit[7]) of each byte of the shuffle control mask is set, then constant zero is written in the result byte. Each byte in the shuffle control mask forms an index to permute the corresponding byte in the destination operand. The value of each index is the least significant 4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.\nIn 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.\nLegacy SSE version 64-bit operand: Both operands can be MMX registers.\n128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The destination operand is the first operand, the first source operand is the second operand, the second source operand is the third operand. Bits (MAXVL-1:128) of the destination YMM register are zeroed.\nVEX.256 encoded version: Bits (255:128) of the destination YMM register stores the 16-byte shuffle result of the upper 16 bytes of the first source operand, using the upper 16-bytes of the second source operand as control mask.\nThe value of each index is for the high 128-bit lane is the least significant 4 bits of the respective shuffle control byte. The index value selects a source data element within each 128-bit lane.\nEVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.\nEVEX and VEX encoded version: Four/two in-lane 128-bit shuffles.",
    "operationText": "TEMP := DEST\nfor i = 0 to 7 {\n    if (SRC[(i * 8)+7] = 1 ) then\n            DEST[(i*8)+7...(i*8)+0] := 0;\n    else\n            index[2..0] := SRC[(i*8)+2 .. (i*8)+0];\n            DEST[(i*8)+7...(i*8)+0] := TEMP[(index*8+7)..(index*8+0)];\n    endif;\n}\nPSHUFB (with 128 bit operands)\nTEMP := DEST\nfor i = 0 to 15 {\n    if (SRC[(i * 8)+7] = 1 ) then\n            DEST[(i*8)+7..(i*8)+0] := 0;\n        else\n            index[3..0] := SRC[(i*8)+3 .. (i*8)+0];\n            DEST[(i*8)+7..(i*8)+0] := TEMP[(index*8+7)..(index*8+0)];\n    endif\n}\nfor i = 0 to 15 {\n    if (SRC2[(i * 8)+7] = 1) then\n        DEST[(i*8)+7..(i*8)+0] := 0;\n        else\n        index[3..0] := SRC2[(i*8)+3 .. (i*8)+0];\n        DEST[(i*8)+7..(i*8)+0] := SRC1[(index*8+7)..(index*8+0)];\n    endif\n}\nDEST[MAXVL-1:128] := 0\nfor i = 0 to 15 {\n    if (SRC2[(i * 8)+7] == 1 ) then\n        DEST[(i*8)+7..(i*8)+0] := 0;\n        else\n        index[3..0] := SRC2[(i*8)+3 .. (i*8)+0];\n        DEST[(i*8)+7..(i*8)+0] := SRC1[(index*8+7)..(index*8+0)];\n    endif\n    if (SRC2[128 + (i * 8)+7] == 1 ) then\n        DEST[128 + (i*8)+7..(i*8)+0] := 0;\n        else\n        index[3..0] := SRC2[128 + (i*8)+3 .. (i*8)+0];\n        DEST[128 + (i*8)+7..(i*8)+0] := SRC1[128 + (index*8+7)..(index*8+0)];\n    endif\n}\n(KL, VL) = (16, 128), (32, 256), (64, 512)\njmask := (KL-1) & ~0xF\n                // 0x00, 0x10, 0x30 depending on the VL\nFOR j = 0 TO KL-1\n                // dest\n    IF kl[ i ] or no_masking\n        index := src.byte[ j ];\n        IF index & 0x80\n            Dest.byte[ j ] := 0;\n        ELSE\n            index := (index & 0xF) + (j & jmask);\n                // 16-element in-lane lookup\n            Dest.byte[ j ] := src.byte[ index ];\n    ELSE if zeroing\n        Dest.byte[ j ] := 0;\nDEST[MAXVL-1:VL] := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtss2usi",
    "category": "Core Instructions",
    "instructionName": "VCVTSS2USI\n\t\t— Convert Scalar Single Precision Floating-Point Value to Unsigned DoublewordInteger",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 79 /r VCVTSS2USI r32, xmm1/m32{er}"
      },
      {
        "64/32 Bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert one single precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W1 79 /r VCVTSS2USI r64, xmm1/m32{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Fixed"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pconfig",
    "category": "Core Instructions",
    "instructionName": "PCONFIG\n\t\t— Platform Configuration",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "PCONFIG",
        "Description": "This instruction is used to execute functions for configuring platform features.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F 01 C5 PCONFIG"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The PCONFIG instruction allows software to configure certain platform features. It supports these features with multiple leaf functions, selecting a leaf function using the value in EAX.\nDepending on the leaf function, the registers RBX, RCX, and RDX may be used to provide input information or for the instruction to report output information. Addresses and operands are 32 bits outside 64-bit mode and are 64 bits in 64-bit mode. The value of CS.D does not affect operand size or address size.\nExecutions of PCONFIG may fail for platform-specific reasons. An execution reports failure by setting the ZF flag and loading EAX with a non-zero failure reason; a successful execution clears ZF and EAX.\nEach PCONFIG leaf function applies to a specific hardware block called a PCONFIG target. The leaf function is supported only if the processor supports that target. Each target is associated with a numerical target identifier, and CPUID leaf 1BH (PCONFIG information) enumerates the identifiers of the supported targets. An attempt to execute an undefined leaf function, or a leaf function that applies to an unsupported target identifier, results in a general-protection exception (#GP).",
    "operationText": "(* #UD if PCONFIG is not enumerated or CPL > 0 *)\nIF CPUID.7.0:EDX[18] = 0 OR CPL > 0\n    THEN #UD; FI;\n(* #GP(0) for an unsupported leaf function *)\nIF EAX != 0\n    THEN #GP(0); FI;\nCASE (EAX) (* operation based on selected leaf function *)\n    0 (MKTME_KEY_PROGRAM):\n    (* Confirm that TME-MK is properly enabled by the IA32_TME_ACTIVATE MSR *)\n    (* The MSR must be locked, encryption enabled, and a non-zero number of KeyID bits specified *)\n    IF IA32_TME_ACTIVATE[0] = 0 OR IA32_TME_ACTIVATE[1] = 0 OR IA32_TME_ACTIVATE[35:32] = 0\n            THEN #GP(0); FI;\n    IF DS:RBX is not 256-byte aligned\n        THEN #GP(0); FI;\n    Load TMP_KEY_PROGRAM_STRUCT from 192 bytes at linear address DS:RBX;\n    IF TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL sets any reserved bits\n        THEN #GP(0); FI;\n    (* Check for a valid command *)\n    IF TMP_KEY_PROGRAM_STRUCT. KEYID_CTRL.COMMAND > 3\n        THEN #GP(0); FI;\n    (* Check that the KEYID being operated upon is a valid KEYID *)\n    IF TMP_KEY_PROGRAM_STRUCT.KEYID = 0 OR\n        TMP_KEY_PROGRAM_STRUCT.KEYID > 2^IA32_TME_ACTIVATE.MK_TME_KEYID_BITS – 1 OR\n        TMP_KEY_PROGRAM_STRUCT.KEYID > IA32_TME_CAPABILITY.MK_TME_MAX_KEYS\n            THEN #GP(0); FI;\n    (* Check that only one encryption algorithm is requested for the KeyID and it is one of the activated algorithms *)\n    IF TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.ENC_ALG does not set exactly one bit OR\n        (TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.ENC_ALG & IA32_TME_ACTIVATE[63:48]) = 0\n            THEN #GP(0); FI:\n    Attempt to acquire lock to gain exclusive access to platform key table;\n    IF attempt is unsuccessful\n        THEN (* PCONFIG failure *)\n            RFLAGS.ZF := 1;\n            RAX := DEVICE_BUSY;\n                    (* failure reason 5 *)\n            GOTO EXIT;\n    FI;\n    CASE (TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.COMMAND) OF\n        0 (KEYID_SET_KEY_DIRECT):\n        Update TME-MK table for TMP_KEY_PROGRAM_STRUCT.KEYID as follows:\n            Encrypt with the selected key\n            Use the encryption algorithm selected by TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.ENC_ALG\n            (* The number of bytes used by the next two lines depends on selected encryption algorithm *)\n            DATA_KEY is TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_1\n            TWEAK_KEY is TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_2\n        BREAK;\n        1 (KEYID_SET_KEY_RANDOM):\n        Load TMP_RND_DATA_KEY with a random key using hardware RNG; (* key size depends on selected encryption algorithm *)\n        IF there was insufficient entropy\n            THEN (* PCONFIG failure *)\n                RFLAGS.ZF := 1;\n                RAX := ENTROPY_ERROR; (* failure reason 2 *)\n                Release lock on platform key table;\n                GOTO EXIT;\n        FI;\n        Load TMP_RND_TWEAK_KEY with a random key using hardware RNG; (* key size depends on selected encryption algorithm *)\n        IF there was insufficient entropy\n            THEN (* PCONFIG failure *)\n                RFLAGS.ZF := 1;\n                RAX := ENTROPY_ERROR; (* failure reason 2 *)\n                Release lock on platform key table;\n                GOTO EXIT;\n        FI;\n        (* Combine software-supplied entropy to the data key and tweak key *)\n        (* The number of bytes used by the next two lines depends on selected encryption algorithm *)\n        TMP_RND_DATA_KEY := TMP_RND_KEY XOR TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_1;\n        TMP_RND_TWEAK_KEY := TMP_RND_TWEAK_KEY XOR TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_2;\n        Update TME-MK table for TMP_KEY_PROGRAM_STRUCT.KEYID as follows:\n            Encrypt with the selected key\n            Use the encryption algorithm selected by TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.ENC_ALG\n            (* The number of bytes used by the next two lines depends on selected encryption algorithm *)\n            DATA_KEY is TMP_RND_DATA_KEY\n            TWEAK_KEY is TMP_RND_TWEAK_KEY\n        BREAK;\n        2 (KEYID_CLEAR_KEY):\n        Update TME-MK table for TMP_KEY_PROGRAM_STRUCT.KEYID as follows:\n            Encrypt (or not) using the current configuration for TME\n            The specified encryption algorithm and key values are not used.\n        BREAK;\n        3 (KEYID_NO_ENCRYPT):\n        Update TME-MK table for TMP_KEY_PROGRAM_STRUCT.KEYID as follows:\n            Do not encrypt\n            The specified encryption algorithm and key values are not used.\n        BREAK;\n    ESAC;\n    Release lock on platform key table;\nESAC;\nRAX := 0;\nRFLAGS.ZF := 0;\nEXIT:\nRFLAGS.CF := 0;\nRFLAGS.PF := 0;\nRFLAGS.AF := 0;\nRFLAGS.OF := 0;\nRFLAGS.SF := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: If a memory operand is non-canonical form.; \ncolumn_1: MKTME_KEY_PROGRAM leaf function:; \ncolumn_1: If IA32_TME_ACTIVATE MSR is not locked.; \ncolumn_1: If hardware encryption and TME-MK capability are not enabled in IA32_TME_ACTIVATE MSR.; \ncolumn_1: If a memory operand is not 256B aligned.; \ncolumn_1: If any of the reserved bits in the KEYID_CTRL field of the MKTME_KEY_PROGRAM_STRUCT are set or that field indicates an unsupported KeyID, key-programming command, or encryption algorithm.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing memory operands.; \ncolumn_1: #UD; column_2: If any of the LOCK/REP/Operand Size/VEX prefixes are used.; \ncolumn_1: If the current privilege level is not 0.; \ncolumn_1: If CPUID.7.0:EDX.PCONFIG[bit 18] = 0.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the relevant segment limit.; \ncolumn_1: MKTME_KEY_PROGRAM leaf function:; \ncolumn_1: If IA32_TME_ACTIVATE MSR is not locked.; \ncolumn_1: If hardware encryption and TME-MK capability are not enabled in IA32_TME_ACTIVATE MSR.; \ncolumn_1: If the memory operand is not 256B aligned.; \ncolumn_1: If any of the reserved bits in the KEYID_CTRL field of the MKTME_KEY_PROGRAM_STRUCT are set or that field indicates an unsupported KeyID, key-programming command, or encryption algorithm.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing memory operands.; \ncolumn_1: #UD; column_2: If any of the LOCK/REP/Operand Size/VEX prefixes are used.; \ncolumn_1: If current privilege level is not 0.; \ncolumn_1: If CPUID.7.0:EDX[bit 18] = 0;"
      ],
      "realAddressMode": [
        "column_1: MKTME_KEY_PROGRAM leaf function:; \ncolumn_1: If IA32_TME_ACTIVATE MSR is not locked.; \ncolumn_1: If hardware encryption and TME-MK capability are not enabled in IA32_TME_ACTIVATE MSR.; \ncolumn_1: If a memory operand is not 256B aligned.; \ncolumn_1: If any of the reserved bits in the KEYID_CTRL field of the MKTME_KEY_PROGRAM_STRUCT are set or that field indicates an unsupported KeyID, key-programming command, or encryption algorithm.; \ncolumn_1: #UD; column_2: If any of the LOCK/REP/Operand Size/VEX prefixes are used.; \ncolumn_1: If current privilege level is not 0.; \ncolumn_1: If CPUID.7.0:EDX.PCONFIG[bit 18] = 0;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmaddrnd231pd",
    "category": "Core Instructions",
    "instructionName": "VFMADDRND231PD\n\t\t— Fused Multiply-Add of Packed Double-Precision Floating-Point Valueswith rounding control",
    "detailsTable": null,
    "operandEncodingTable": null,
    "descriptionText": "Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two or four packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).\nThe immediate byte defines several bit fields that control rounding, DAZ, FTZ, and exception suppression (SeeTable 5-3).The rounding mode specified in MXCSR.RC may be bypassed if the immediate bit called MS1 (MXCSR.RC Override) is set. Likewise, the MXCSR.FTZ and MXCSR.DAZ may also be bypassed if the immediate bit called MS2 (MXCSR.FTZ/DAZ Override) is set. In case SAE (Suppress All Exceptions) bit is set (i.e. imm8[3] = 1), the status flags in MXCSR are not updated and no SIMD floating-point exceptions are raised. When SAE bit is not set (i.e. imm8[3] = 0) then SIMD floating-point exceptions are signaled according to the MXCSR. If any result operand is an SNaN then it will be converted to a QNaN.\nVEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.\nVEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.\nCompiler tools may optionally support the complementary mnemonic VMADDRND321PD. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 2.3.1, “FMA Instruction Operand Order and Arithmetic Behavior”",
    "operationText": "In the operations below, “+” and “*” symbols represent multiplication and addition with infinite precision inputs and outputs (no rounding)\nIF (VEX.128) THEN\n    MAXVL =2\nELSEIF (VEX.256)\n    MAXVL = 4\nFI\nIF (imm8[3] = 1) THEN\n    Suppress_SIMD_Exception_Signaling_Reporting();\nFI\nFor i = 0 to MAXVL-1 {\n    n = 64*i;\n    DEST[n+63:n]←RoundFPControl_Imm((SRC2[n+63:n]*SRC3[n+63:n] + DEST[n+63:n]), imm8)\n}\nIF (VEX.128) THEN\nDEST[255:128] ← 0\nFI\nIF (imm8[3] = 1) THEN\n    Resume_SIMD_Exception_Signaling_Reporting();\nFI",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Exceptions Type 2"
      ],
      "simdFloating-Point¶": [
        "IF imm[3] = 1 Then",
        "None",
        "Else",
        "Overflow, Underflow, Invalid, Precision, Denormal",
        "FI"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfnmsub132sd:vfnmsub213sd:vfnmsub231sd",
    "category": "Core Instructions",
    "instructionName": "VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD\n\t\t— Fused Negative Multiply-Subtract ofScalar Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 9F /r VFNMSUB132SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 AF /r VFNMSUB213SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply scalar double precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.LIG.66.0F38.W1 BF /r VFNMSUB231SD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and subtract xmm2 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 9F /r VFNMSUB132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m64 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 AF /r VFNMSUB213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply scalar double precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and subtract xmm1 and put result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 BF /r VFNMSUB231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/iret:iretd:iretq",
    "category": "Core Instructions",
    "instructionName": "IRET/IRETD/IRETQ\n\t\t— Interrupt Return",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Interrupt return (16-bit operand size).",
        "Instruction": "IRET",
        "Op/En": "ZO",
        "Opcode": "CF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Interrupt return (32-bit operand size).",
        "Instruction": "IRETD",
        "Op/En": "ZO",
        "Opcode": "CF"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "Interrupt return (64-bit operand size).",
        "Instruction": "IRETQ",
        "Op/En": "ZO",
        "Opcode": "REX.W + CF"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled “Task Linking” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\nIRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.\nIn Real-Address Mode, the IRET instruction performs a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.\nIn Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs the following types of interrupt returns:\nIf the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure, without a task switch. The code segment being returned to must be equally or less privileged than the interrupt handler routine (as indicated by the RPL field of the code segment selector popped from the stack).\nAs with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is to virtual-8086 mode, the processor also pops the data segment registers from the stack.\nIf the NT flag is set, the IRET instruction performs a task switch (return) from a nested task (a task called with a CALL instruction, an interrupt, or an exception) back to the calling or interrupted task. The updated state of the task executing the IRET instruction is saved in its TSS. If the task is re-entered later, the code that follows the IRET instruction is executed.\nIf the NT flag is set and the processor is in IA-32e mode, the IRET instruction causes a general protection exception.\nIf nonmaskable interrupts (NMIs) are blocked (see Section 6.7.1, “Handling Multiple NMIs” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A), execution of the IRET instruction unblocks NMIs.\nThis unblocking occurs even if the instruction causes a fault. In such a case, NMIs are unmasked before the exception handler is invoked.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.W prefix promotes operation to 64 bits (IRETQ). See the summary chart at the beginning of this section for encoding data and limits.\nRefer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions” and Chapter 17, “Control-flow Enforcement Technology (CET)” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for CET details.\nInstruction ordering. IRET is a serializing instruction. See Section 9.3 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\nSee “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 26 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
    "operationText": "IF PE = 0\n    THEN GOTO REAL-ADDRESS-MODE;\nELSIF (IA32_EFER.LMA = 0)\n    THEN\n            IF (EFLAGS.VM = 1)\n                        THEN GOTO RETURN-FROM-VIRTUAL-8086-MODE;\n                        ELSE GOTO PROTECTED-MODE;\n            FI;\n    ELSE GOTO IA-32e-MODE;\nFI;\nREAL-ADDRESS-MODE;\n    IF OperandSize = 32\n            THEN\n                        EIP := Pop();\n                        CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n                        tempEFLAGS := Pop();\n                        EFLAGS := (tempEFLAGS AND 257FD5H) OR (EFLAGS AND 1A0000H);\n            ELSE (* OperandSize = 16 *)\n                        EIP := Pop(); (* 16-bit pop; clear upper 16 bits *)\n                        CS := Pop(); (* 16-bit pop *)\n                        EFLAGS[15:0] := Pop();\n    FI;\n    END;\nRETURN-FROM-VIRTUAL-8086-MODE:\n(* Processor is in virtual-8086 mode when IRET is executed and stays in virtual-8086 mode *)\n    IF IOPL = 3 (* Virtual mode: PE = 1, VM = 1, IOPL = 3 *)\n            THEN IF OperandSize = 32\n                        THEN\n                                EIP := Pop();\n                                CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n                                EFLAGS := Pop();\n                                (* VM, IOPL,VIP and VIF EFLAG bits not modified by pop *)\n                                IF EIP not within CS limit\n                                    THEN #GP(0); FI;\n                        ELSE (* OperandSize = 16 *)\n                                EIP := Pop(); (* 16-bit pop; clear upper 16 bits *)\n                                CS := Pop(); (* 16-bit pop *)\n                                EFLAGS[15:0] := Pop(); (* IOPL in EFLAGS not modified by pop *)\n                                IF EIP not within CS limit\n                                    THEN #GP(0); FI;\n                        FI;\n            ELSE\n                        #GP(0); (* Trap to virtual-8086 monitor: PE = 1, VM = 1, IOPL < 3 *)\n    FI;\nEND;\nPROTECTED-MODE:\n    IF NT = 1\n            THEN GOTO TASK-RETURN; (* PE = 1, VM = 0, NT = 1 *)\n    FI;\n    IF OperandSize = 32\n            THEN\n                        EIP := Pop();\n                        CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n                        tempEFLAGS := Pop();\n            ELSE (* OperandSize = 16 *)\n                        EIP := Pop(); (* 16-bit pop; clear upper bits *)\n                        CS := Pop(); (* 16-bit pop *)\n                        tempEFLAGS := Pop(); (* 16-bit pop; clear upper bits *)\n    FI;\n    IF tempEFLAGS(VM) = 1 and CPL = 0\n            THEN GOTO RETURN-TO-VIRTUAL-8086-MODE;\n            ELSE GOTO PROTECTED-MODE-RETURN;\n    FI;\nTASK-RETURN:(*PE=1,VM =0,NT =1*)\n    SWITCH-TASKS (without nesting) to TSS specified in link field of current TSS;\n    Mark the task just abandoned as NOT BUSY;\n    IF EIP is not within CS limit\n            THEN #GP(0); FI;\nEND;\nRETURN-TO-VIRTUAL-8086-MODE:\n    (* Interrupted procedure was in virtual-8086 mode: PE = 1, CPL=0, VM = 1 in flag image *)\n    (* If shadow stack or indirect branch tracking at CPL3 then #GP(0) *)\n    IF CR4.CET AND (IA32_U_CET.ENDBR_EN OR IA32_U_CET.SHSTK_EN)\n            THEN #GP(0); FI;\n    shadowStackEnabled = ShadowStackEnabled(CPL)\n    IF EIP not within CS limit\n            THEN #GP(0); FI;\n    EFLAGS := tempEFLAGS;\n    ESP := Pop();\n    SS := Pop(); (* Pop 2 words; throw away high-order word *)\n    ES := Pop(); (* Pop 2 words; throw away high-order word *)\n    DS := Pop(); (* Pop 2 words; throw away high-order word *)\n    FS := Pop(); (* Pop 2 words; throw away high-order word *)\n    GS := Pop(); (* Pop 2 words; throw away high-order word *)\n    IF shadowStackEnabled\n            (* check if 8 byte aligned *)\n            IF SSP AND 0x7 != 0\n                        THEN #CP(FAR-RET/IRET); FI;\n    FI;\n    CPL := 3;\n    (* Resume execution in Virtual-8086 mode *)\n    tempOldSSP = SSP;\n    (* Now past all faulting points; safe to free the token. The token free is done using the old SSP\n        * and using a supervisor override as old CPL was a supervisor privilege level *)\n    IF shadowStackEnabled\n            expected_token_value = tempOldSSP | BUSY_BIT (* busy bit - bit position 0 - must be set *)\n            new_token_value = tempOldSSP (* clear the busy bit *)\n            shadow_stack_lock_cmpxchg8b(tempOldSSP, new_token_value, expected_token_value)\n    FI;\nEND;\nPROTECTED-MODE-RETURN: (* PE = 1 *)\n    IF CS(RPL) > CPL\n            THEN GOTO RETURN-TO-OUTER-PRIVILEGE-LEVEL;\n            ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL; FI;\nEND;\nRETURN-TO-OUTER-PRIVILEGE-LEVEL:\n    IF OperandSize = 32\n            THEN\n                        tempESP := Pop();\n                        tempSS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n    ELSE IF OperandSize = 16\n            THEN\n                        tempESP := Pop(); (* 16-bit pop; clear upper bits *)\n                        tempSS := Pop(); (* 16-bit pop *)\n            ELSE (* OperandSize = 64 *)\n                        tempRSP := Pop();\n                        tempSS := Pop(); (* 64-bit pop, high-order 48 bits discarded *)\n    FI;\n    IF new mode ≠ 64-Bit Mode\n            THEN\n                        IF EIP is not within CS limit\n                                THEN #GP(0); FI;\n            ELSE (* new mode = 64-bit mode *)\n                        IF RIP is non-canonical\n                                    THEN #GP(0); FI;\n    FI;\n    EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) := tempEFLAGS;\n    IF OperandSize = 32 or OperandSize = 64\n            THEN EFLAGS(RF, AC, ID) := tempEFLAGS; FI;\n    IF CPL ≤ IOPL\n            THEN EFLAGS(IF) := tempEFLAGS; FI;\n    IF CPL = 0\n            THEN\n                        EFLAGS(IOPL) := tempEFLAGS;\n                        IF OperandSize = 32 or OperandSize = 64\n                                THEN EFLAGS(VIF, VIP) := tempEFLAGS; FI;\n    FI;\n    IF ShadowStackEnabled(CPL)\n            (* check if 8 byte aligned *)\n            IF SSP AND 0x7 != 0\n                        THEN #CP(FAR-RET/IRET); FI;\n            IF CS(RPL) != 3\n                        THEN\n                                tempSsCS = shadow_stack_load 8 bytes from SSP+16;\n                                tempSsLIP = shadow_stack_load 8 bytes from SSP+8;\n                                tempSSP = shadow_stack_load 8 bytes from SSP;\n                                SSP = SSP + 24;\n                                (* Do 64 bit compare to detect bits beyond 15 being set *)\n                                tempCS = CS; (* zero padded to 64 bit *)\n                                IF tempCS != tempSsCS\n                                    THEN #CP(FAR-RET/IRET); FI;\n                                (* Do 64 bit compare; pad CSBASE+RIP with 0 for 32 bit LIP *)\n                                IF CSBASE + RIP != tempSsEIP\n                                    THEN #CP(FAR-RET/IRET); FI;\n                                (* check if 4 byte aligned *)\n                                IF tempSSP AND 0x3 != 0\n                                    THEN #CP(FAR-RET/IRET); FI;\n            FI;\n    FI;\n    tempOldCPL = CPL;\n    CPL := CS(RPL);\n            IF OperandSize = 64\n                        THEN\n                                RSP := tempRSP;\n                                SS := tempSS;\n            ELSE\n                        ESP := tempESP;\n                        SS := tempSS;\n            FI;\n            IF new mode != 64-Bit Mode\n                        THEN\n                                IF EIP is not within CS limit\n                                    THEN #GP(0); FI;\n            ELSE (* new mode = 64-bit mode *)\n                        IF RIP is non-canonical\n                                THEN #GP(0); FI;\n            FI;\n            tempOldSSP = SSP;\n            IF ShadowStackEnabled(CPL)\n                        IF CPL = 3\n                                THEN tempSSP := IA32_PL3_SSP; FI;\n            IF ((IA32_EFER.LMA AND CS.L) = 0 AND tempSSP[63:32] != 0) OR\n                    ((IA32_EFER.LMA AND CS.L) = 1 AND tempSSP is not canonical relative to the current paging mode)\n                        THEN #GP(0); FI;\n            SSP := tempSSP\n            FI;\n            (* Now past all faulting points; safe to free the token. The token free is done using the old SSP\n                * and using a supervisor override as old CPL was a supervisor privilege level *)\n            IF ShadowStackEnabled(tempOldCPL)\n                        expected_token_value = tempOldSSP | BUSY_BIT (* busy bit - bit position 0 - must be set *)\n                        new_token_value = tempOldSSP (* clear the busy bit *)\n                        shadow_stack_lock_cmpxchg8b(tempOldSSP, new_token_value, expected_token_value)\n            FI;\n    FOR each SegReg in (ES, FS, GS, and DS)\n            DO\n                        tempDesc := descriptor cache for SegReg (* hidden part of segment register *)\n                        IF (SegmentSelector == NULL) OR (tempDesc(DPL) < CPL AND tempDesc(Type) is (data or non-conforming code)))\n                                THEN (* Segment register invalid *)\n                                    SegmentSelector := 0; (*Segment selector becomes null*)\n                        FI;\n            OD;\nEND;\nRETURN-TO-SAME-PRIVILEGE-LEVEL: (* PE = 1, RPL = CPL *)\n    IF new mode ≠ 64-Bit Mode\n            THEN\n                        IF EIP is not within CS limit\n                                THEN #GP(0); FI;\n            ELSE (* new mode = 64-bit mode *)\n                        IF RIP is non-canonical\n                                    THEN #GP(0); FI;\n    FI;\n    EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) := tempEFLAGS;\n    IF OperandSize = 32 or OperandSize = 64\n            THEN EFLAGS(RF, AC, ID) := tempEFLAGS; FI;\n    IF CPL ≤ IOPL\n            THEN EFLAGS(IF) := tempEFLAGS; FI;\n    IF CPL = 0\n                THEN\n                            EFLAGS(IOPL) := tempEFLAGS;\n                            IF OperandSize = 32 or OperandSize = 64\n                                THEN EFLAGS(VIF, VIP) := tempEFLAGS; FI;\n    FI;\n    IF ShadowStackEnabled(CPL)\n            IF SSP AND 0x7 != 0 (* check if aligned to 8 bytes *)\n                        THEN #CP(FAR-RET/IRET); FI;\n            tempSsCS = shadow_stack_load 8 bytes from SSP+16;\n            tempSsLIP = shadow_stack_load 8 bytes from SSP+8;\n            tempSSP = shadow_stack_load 8 bytes from SSP;\n            SSP = SSP + 24;\n            tempCS = CS; (* zero padded to 64 bit *)\n            IF tempCS != tempSsCS (* 64 bit compare; CS zero padded to 64 bits *)\n                        THEN #CP(FAR-RET/IRET); FI;\n            IF CSBASE + RIP != tempSsLIP (* 64 bit compare; CSBASE+RIP zero padded to 64 bit for 32 bit LIP *)\n                        THEN #CP(FAR-RET/IRET); FI;\n            IF tempSSP AND 0x3 != 0 (* check if aligned to 4 bytes *)\n                        THEN #CP(FAR-RET/IRET); FI;\n            IF ((IA32_EFER.LMA AND CS.L) = 0 AND tempSSP[63:32] != 0) OR\n                    ((IA32_EFER.LMA AND CS.L) = 1 AND tempSSP is not canonical relative to the current paging mode)\n                        THEN #GP(0); FI;\n    FI;\n    IF ShadowStackEnabled(CPL)\n            IF IA32_EFER.LMA = 1\n            (* In IA-32e-mode the IRET may be switching stacks if the interrupt/exception was delivered\n                through an IDT with a non-zero IST *)\n            (* In IA-32e mode for same CPL IRET there is always a stack switch. The below check verifies if the\n                stack switch was to self stack and if so, do not try to free the token on this shadow stack. If the\n                tempSSP was not to same stack then there was a stack switch so do attempt to free the token *)\n                        IF tempSSP != SSP\n                                THEN\n                                    expected_token_value = SSP | BUSY_BIT (* busy bit - bit position 0 - must be set *)\n                                    new_token_value = SSP (* clear the busy bit *)\n                                    shadow_stack_lock_cmpxchg8b(SSP, new_token_value, expected_token_value)\n                        FI;\n            FI;\n            SSP := tempSSP\n    FI;\nEND;\nIA-32e-MODE:\n    IF NT = 1\n            THEN #GP(0);\n    ELSE IF OperandSize = 32\n            THEN\n                        EIP := Pop();\n                        CS := Pop();\n                        tempEFLAGS := Pop();\n            ELSE IF OperandSize = 16\n                        THEN\n                                EIP := Pop(); (* 16-bit pop; clear upper bits *)\n                                CS := Pop(); (* 16-bit pop *)\n                                tempEFLAGS := Pop(); (* 16-bit pop; clear upper bits *)\n                        FI;\n            ELSE (* OperandSize = 64 *)\n                        THEN\n                                    RIP := Pop();\n                                    CS := Pop(); (* 64-bit pop, high-order 48 bits discarded *)\n                                    tempRFLAGS := Pop();\n    FI;\n    IF CS.RPL > CPL\n            THEN GOTO RETURN-TO-OUTER-PRIVILEGE-LEVEL;\n            ELSE\n                        IF instruction began in 64-Bit Mode\n                                THEN\n                                    IF OperandSize = 32\n                                        THEN\n                                            ESP := Pop();\n                                            SS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)\n                                    ELSE IF OperandSize = 16\n                                        THEN\n                                            ESP := Pop(); (* 16-bit pop; clear upper bits *)\n                                            SS := Pop(); (* 16-bit pop *)\n                                        ELSE (* OperandSize = 64 *)\n                                            RSP := Pop();\n                                            SS := Pop(); (* 64-bit pop, high-order 48 bits discarded *)\n                                    FI;\n                        FI;\n                        GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL; FI;\nEND;",
    "flagsAffectedText": "All the flags and fields in the EFLAGS register are potentially modified, depending on the mode of operation of the processor. If performing a return from a nested task to a previous task, the EFLAGS register will be modified according to the EFLAGS image stored in the previous task’s TSS.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the return code segment selector is NULL.; \ncolumn_1: If the stack segment selector is NULL going back to compatibility mode.; \ncolumn_1: If the stack segment selector is NULL going back to CPL3 64-bit mode.; \ncolumn_1: If a NULL stack segment selector RPL is not equal to CPL going back to non-CPL3 64-bit mode.; \ncolumn_1: If the return instruction pointer is not within the return code segment limit.; \ncolumn_1: If the return instruction pointer is non-canonical.; \ncolumn_2: If a segment selector index is outside its descriptor table limits.; column_1: #GP(Selector); \ncolumn_1: If a segment descriptor memory address is non-canonical.; \ncolumn_1: If the segment descriptor for a code segment does not indicate it is a code segment.; \ncolumn_1: If the proposed new code segment descriptor has both the D-bit and L-bit set.; \ncolumn_1: If the DPL for a nonconforming-code segment is not equal to the RPL of the code segment selector.; \ncolumn_1: If CPL is greater than the RPL of the code segment selector.; \ncolumn_1: If the DPL of a conforming-code segment is greater than the return code segment selector RPL.; \ncolumn_1: If the stack segment is not a writable data segment.; \ncolumn_1: If the stack segment descriptor DPL is not equal to the RPL of the return code segment selector.; \ncolumn_1: If the stack segment selector RPL is not equal to the RPL of the return code segment selector.; \ncolumn_1: #SS(0); column_2: If an attempt to pop a value off the stack violates the SS limit.; \ncolumn_1: If an attempt to pop a value off the stack causes a non-canonical address to be referenced.; \ncolumn_1: If the return stack segment is not present.; \ncolumn_2: (selector) If the return code segment is not present.; column_1: #NP; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If an unaligned memory reference occurs when the CPL is 3 and alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: #CP; column_2: (Far-RET/IRET) If the previous SSP from shadow stack (when returning to CPL <3) or from IA32_PL3_SSP (returning to CPL 3) is not 4 byte aligned.; \ncolumn_1: If returning to 32-bit or compatibility mode and the previous SSP from shadow stack (when returning to CPL <3) or from IA32_PL3_SSP (returning to CPL 3) is beyond 4GB.; \ncolumn_1: If return instruction pointer from stack and shadow stack do not match.;"
      ],
      "compatibilityMode": [
        "",
        "Other exceptions same as in Protected Mode."
      ],
      "protectedMode": [
        "column_1: If the return instruction pointer is not within the return code segment limit.; \ncolumn_1: #GP(selector); column_2: If a segment selector index is outside its descriptor table limits.; \ncolumn_1: If the return code segment selector RPL is less than the CPL.; \ncolumn_1: If the DPL of a conforming-code segment is greater than the return code segment selector RPL.; \ncolumn_1: If the DPL for a nonconforming-code segment is not equal to the RPL of the code segment selector.; \ncolumn_1: If the stack segment descriptor DPL is not equal to the RPL of the return code segment selector.; \ncolumn_1: If the stack segment is not a writable data segment.; \ncolumn_1: If the stack segment selector RPL is not equal to the RPL of the return code segment selector.; \ncolumn_1: If the segment descriptor for a code segment does not indicate it is a code segment.; \ncolumn_1: If the segment selector for a TSS has its local/global bit set for local.; \ncolumn_1: If a TSS segment descriptor specifies that the TSS is not busy.; \ncolumn_1: If a TSS segment descriptor specifies that the TSS is not available.; \ncolumn_1: #SS(0); column_2: If the top bytes of stack are not within stack limits.; \ncolumn_1: If the return stack segment is not present.; \ncolumn_1: #NP; column_2: (selector) If the return code segment is not present.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference occurs when the CPL is 3 and alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: #CP; column_2: (Far-RET/IRET) If the previous SSP from shadow stack (when returning to CPL <3) or from IA32_PL3_SSP (returning to CPL 3) is not 4 byte aligned.; \ncolumn_1: If returning to 32-bit or compatibility mode and the previous SSP from shadow stack (when returning to CPL <3) or from IA32_PL3_SSP (returning to CPL 3) is beyond 4GB.; \ncolumn_1: If return instruction pointer from stack and shadow stack do not match.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If the top bytes of stack are not within stack limits.;"
      ],
      "virtual8086Mode": [
        "column_1: IF IOPL not equal to 3.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #SS(0); column_2: If the top bytes of stack are not within stack limits.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference occurs and alignment checking is enabled.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtpd2ps",
    "category": "Core Instructions",
    "instructionName": "CVTPD2PS\n\t\t— Convert Packed Double Precision Floating-Point Values to Packed Single PrecisionFloating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert two packed double precision floating-point values in xmm2/mem to two single precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 5A /r CVTPD2PS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert two packed double precision floating-point values in xmm2/mem to two single precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 5A /r VCVTPD2PS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert four packed double precision floating-point values in ymm2/mem to four single precision floating-point values in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 5A /r VCVTPD2PS xmm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert two packed double precision floating-point values in xmm2/m128/m64bcst to two single precision floating-point values in xmm1with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 5A /r VCVTPD2PS xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed double precision floating-point values in ymm2/m256/m64bcst to four single precision floating-point values in xmm1with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 5A /r VCVTPD2PS xmm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert eight packed double precision floating-point values in zmm2/m512/m64bcst to eight single precision floating-point values in ymm1with writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 5A /r VCVTPD2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Converts two, four or eight packed double precision floating-point values in the source operand (second operand) to two, four or eight packed single precision floating-point values in the destination operand (first operand).\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64-bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    k := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            DEST[i+31:i] := Convert_Double_Precision_Floating_Point_To_Single_Precision_Floating_Point(SRC[k+63:k])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL/2] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    k := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+31:i] :=Convert_Double_Precision_Floating_Point_To_Single_Precision_Floating_Point(SRC[63:0])\n                ELSE\n                    DEST[i+31:i] := Convert_Double_Precision_Floating_Point_To_Single_Precision_Floating_Point(SRC[k+63:k])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL/2] := 0\nDEST[31:0] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[127:64])\nDEST[95:64] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[191:128])\nDEST[127:96] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[255:192)\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[127:64])\nDEST[MAXVL-1:64] := 0\nDEST[31:0] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[127:64])\nDEST[127:64] := 0\nDEST[MAXVL-1:128] (unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instructions, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision, Underflow, Overflow, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/wrmsr",
    "category": "Core Instructions",
    "instructionName": "WRMSR\n\t\t— Write to Model Specific Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Write the value in EDX:EAX to MSR specified by ECX.",
        "Instruction": "WRMSR",
        "Op/En": "ZO",
        "Opcode": "0F 30"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected MSR and the contents of the EAX register are copied to low-order 32 bits of the MSR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an MSR should be set to values previously read.\nThis instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to bits in a reserved MSR.\nWhen the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated. This includes global entries (see “Translation Lookaside Buffers (TLBs)” in Chapter 3 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A).\nMSRs control functions for testability, execution tracing, performance-monitoring and machine check errors. Chapter 2, “Model-Specific Registers (MSRs),” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4, lists all MSRs that can be written with this instruction and their addresses. Note that each processor family has its own set of MSRs.\nThe WRMSR instruction is a serializing instruction (see “Serializing Instructions” in Chapter 9 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A). Note that WRMSR to the IA32_TSC_DEADLINE MSR (MSR index 6E0H) and the X2APIC MSRs (MSR indices 802H to 83FH) are not serializing.\nThe CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction.",
    "operationText": "MSR[ECX] := EDX:EAX;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the value in ECX specifies a reserved or unimplemented MSR address.; \ncolumn_1: If the value in EDX:EAX sets bits that are reserved in the MSR specified by ECX.; \ncolumn_1: If the source register contains a non-canonical address and ECX specifies one of the following MSRs: IA32_DS_AREA, IA32_FS_BASE, IA32_GS_BASE, IA32_KERNEL_GS_BASE, IA32_L-STAR, IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If the value in EDX:EAX sets bits that are reserved in the MSR specified by ECX.; \ncolumn_1: If the source register contains a non-canonical address and ECX specifies one of the following MSRs: IA32_DS_AREA, IA32_FS_BASE, IA32_GS_BASE, IA32_KERNEL_GS_BASE, IA32_L-STAR, IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrangess",
    "category": "Core Instructions",
    "instructionName": "VRANGESS\n\t\t— Range Restriction Calculation From a Pair of Scalar Float32 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Calculate a RANGE operation output value from 2 single-precision floating-point values in xmm2 and xmm3/m32, store the output to xmm1 under writemask. Imm8 specifies the comparison and sign of the range operation.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F3A.W0 51 /r VRANGESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmptrst",
    "category": "VMX Instructions",
    "instructionName": "VMPTRST\n\t\t— Store Pointer to Virtual-Machine Control Structure",
    "detailsTable": [
      {
        "Description": "Stores the current VMCS pointer into memory.",
        "Op/En": "M",
        "Opcode/Instruction": "NP 0F C7 /7 VMPTRST m64"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "M",
        "column_2": "ModRM:r/m (w)",
        "column_3": "NA",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Stores the current-VMCS pointer into a specified memory address. The operand of this instruction is always 64 bits and is always in memory.",
    "operationText": "IF (register operand) or (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation\n    THEN VMexit;\nELSIF CPL > 0\n    THEN #GP(0);\n    ELSE\n        64-bit in-memory destination operand := current-VMCS pointer;\n        VMsucceed;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the destination operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.; \ncolumn_2: If a page fault occurs in accessing the memory destination operand.; column_1: #PF(fault-code); \ncolumn_1: #SS(0); column_2: If the destination operand is in the SS segment and the memory address is in a non-canonical form.; \ncolumn_1: #UD; column_2: If operand is a register.; \ncolumn_1: If not in VMX operation.;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: If the memory destination operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the destination operand is located in a read-only data segment or any code segment.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory destination operand.; \ncolumn_1: #SS(0); column_2: If the memory destination operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_1: #UD; column_2: If operand is a register.; \ncolumn_1: If not in VMX operation.;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/encodekey128",
    "category": "Core Instructions",
    "instructionName": "ENCODEKEY128\n\t\t— Encode 128-Bit Key With Key Locker",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLE",
        "Description": "Wrap a 128-bit AES key from XMM0 into a key handle and output handle in XMM0—2.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 FA 11:rrr:bbb ENCODEKEY128 r32, r32, <XMM0-2>, <XMM4-6>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "Implicit XMM0 (r, w)",
        "Operands 4—5": "Implicit XMM1—2 (w)",
        "Operands 6—7": "Implicit XMM4—6 (w)",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The ENCODEKEY1281 instruction wraps a 128-bit AES key from the implicit operand XMM0 into a key handle that is then stored in the implicit destination operands XMM0-2.\nThe explicit source operand specifies handle restrictions, if any.\nThe explicit destination operand is populated with information on the source of the key and its attributes. XMM4 through XMM6 are reserved for future usages and software should not rely upon them being zeroed.",
    "operationText": "#GP (0) if a reserved bit2 in SRC[31:0] is set\nInputKey[127:0] := XMM0;\nKeyMetadata[2:0] = SRC[2:0];\nKeyMetadata[23:3] = 0;\n    // Reserved for future usage\nKeyMetadata[27:24] = 0;\n    // KeyType is AES-128 (value of 0)\nKeyMetadata[127:28] = 0;\n    // Reserved for future usage\n// KeyMetadata is the AAD input and InputKey is the Plaintext input for WrapKey128\nHandle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0], IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]);\nDEST[0] := IWKey.NoBackup;\nDEST[4:1] := IWKey.KeySource[3:0];\nDEST[31:5] = 0;\nXMM0 := Handle[127:0]; // AAD\nXMM1 := Handle[255:128]; // Integrity Tag\nXMM2 := Handle[383:256]; // CipherText\n/\nXMM4 := 0;\n/\nXMM4 := 0;\nR\nXMM4 := 0;\ne\nXMM4 := 0;\ns\nXMM4 := 0;\ne\nXMM4 := 0;\nr\nXMM4 := 0;\nv\nXMM4 := 0;\ne\nXMM4 := 0;\nd\nXMM4 := 0;\nf\nXMM4 := 0;\no\nXMM4 := 0;\nr\nXMM4 := 0;\nf\nXMM4 := 0;\nu\nXMM4 := 0;\nt\nXMM4 := 0;\nu\nXMM4 := 0;\nr\nXMM4 := 0;\ne\nXMM4 := 0;\nXMM4 := 0;\n/\nXMM5 := 0;\n/\nXMM5 := 0;\nR\nXMM5 := 0;\ne\nXMM5 := 0;\ns\nXMM5 := 0;\ne\nXMM5 := 0;\nr\nXMM5 := 0;\nv\nXMM5 := 0;\ne\nXMM5 := 0;\nd\nXMM5 := 0;\nf\nXMM5 := 0;\no\nXMM5 := 0;\nr\nXMM5 := 0;\nf\nXMM5 := 0;\nu\nXMM5 := 0;\nt\nXMM5 := 0;\nu\nXMM5 := 0;\nr\nXMM5 := 0;\ne\nXMM5 := 0;\nXMM5 := 0;\n/\nXMM6 := 0;\n/\nXMM6 := 0;\nR\nXMM6 := 0;\ne\nXMM6 := 0;\ns\nXMM6 := 0;\ne\nXMM6 := 0;\nr\nXMM6 := 0;\nv\nXMM6 := 0;\ne\nXMM6 := 0;\nd\nXMM6 := 0;\nf\nXMM6 := 0;\no\nXMM6 := 0;\nr\nXMM6 := 0;\nf\nXMM6 := 0;\nu\nXMM6 := 0;\nt\nXMM6 := 0;\nu\nXMM6 := 0;\nr\nXMM6 := 0;\ne\nXMM6 := 0;\nXMM6 := 0;\nRFLAGS.OF, SF, ZF, AF, PF, CF := 0;",
    "flagsAffectedText": "All arithmetic flags (OF, SF, ZF, AF, PF, CF) are cleared to 0. Although they are cleared for the currently defined operations, future extensions may report information in the flags.\n1. Further details on Key Locker and usage of this instruction can be found here:",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtph2dq",
    "category": "Core Instructions",
    "instructionName": "VCVTPH2DQ\n\t\t— Convert Packed FP16 Values to Signed Doubleword Integers",
    "detailsTable": [
      {
        "Description": "Convert four packed FP16 values in xmm2/m64/m16bcst to four signed doubleword integers, and store the result in xmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP5.W0 5B /r VCVTPH2DQ xmm1{k1}{z}, xmm2/m64/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert eight packed FP16 values in xmm2/m128/m16bcst to eight signed doubleword integers, and store the result in ymm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP5.W0 5B /r VCVTPH2DQ ymm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Convert sixteen packed FP16 values in ymm2/m256/m16bcst to sixteen signed doubleword integers, and store the result in zmm1 subject to writemask k1.",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP5.W0 5B /r VCVTPH2DQ zmm1{k1}{z}, ymm2/m256/m16bcst {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Half"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtpd2udq",
    "category": "Core Instructions",
    "instructionName": "VCVTPD2UDQ\n\t\t— Convert Packed Double Precision Floating-Point Values to Packed UnsignedDoubleword Integers",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert two packed double precision floating-point values in xmm2/m128/m64bcst to two unsigned doubleword integers in xmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode Instruction": "EVEX.128.0F.W1 79 /r VCVTPD2UDQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed double precision floating-point values in ymm2/m256/m64bcst to four unsigned doubleword integers in xmm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode Instruction": "EVEX.256.0F.W1 79 /r VCVTPD2UDQ xmm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert eight packed double precision floating-point values in zmm2/m512/m64bcst to eight unsigned doubleword integers in ymm1 subject to writemask k1.",
        "Op/En": "A",
        "Opcode Instruction": "EVEX.512.0F.W1 79 /r VCVTPD2UDQ ymm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/fbstp",
    "category": "Core Instructions",
    "instructionName": "FBSTP\n\t\t— Store BCD Integer and Pop",
    "detailsTable": [
      {
        "Description": "Store ST(0) in m80bcd and pop ST(0).",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "DF /6",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value, according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.\nThe destination operand specifies the address where the first byte destination value is to be stored. The BCD value (including its sign bit) requires 10 bytes of space in memory.\nThe following table shows the results obtained when storing various classes of numbers in packed BCD format.\nIf the converted value is too large for the destination format, or if the source operand is an ∞, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "DEST := BCD(ST(0));\nPopRegisterStack;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Converted value that exceeds 18 BCD digits in length.; \ncolumn_1: Source operand is an SNaN, QNaN, ±∞, or in an unsupported format.; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #NM; column_2: CR0.EM[bit 2] or CR0.TS[bit 3] = 1.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/verr:verw",
    "category": "Core Instructions",
    "instructionName": "VERR/VERW\n\t\t— Verify a Segment for Reading or Writing",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set ZF=1 if segment specified with r/m16 can be read.",
        "Op/En": "M",
        "Opcode/Instruction": "0F 00 /4 VERR r/m16"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Set ZF=1 if segment specified with r/m16 can be written.",
        "Op/En": "M",
        "Opcode/Instruction": "0F 00 /5 VERW r/m16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (r)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.\nTo set the ZF flag, the following conditions must be met:\nThe validation performed is the same as is performed when a segment selector is loaded into the DS, ES, FS, or GS register, and the indicated access (read or write) is performed. The segment selector's value cannot result in a protection exception, enabling the software to anticipate possible segment access problems.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode. The operand size is fixed at 16 bits.",
    "operationText": "IF SRC(Offset) > (GDTR(Limit) or (LDTR(Limit))\n    THEN ZF := 0; FI;\nRead segment descriptor;\nIF SegmentDescriptor(DescriptorType) = 0 (* System segment *)\nor (SegmentDescriptor(Type) ≠ conforming code segment)\nand (CPL > DPL) or (RPL > DPL)\n    THEN\n        ZF := 0;\n    ELSE\n        IF ((Instruction = VERR) and (Segment readable))\n        or ((Instruction = VERW) and (Segment writable))\n            THEN\n                ZF := 1;\n            ELSE\n                ZF := 0;\n        FI;\nFI;",
    "flagsAffectedText": "The ZF flag is set to 1 if the segment is accessible and readable (VERR) or writable (VERW); otherwise, it is set to 0.",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "The only exceptions generated for these instructions are those related to illegal addressing of the source operand.",
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: If the LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfcmulcsh:vfmulcsh",
    "category": "Core Instructions",
    "instructionName": "VFCMULCSH/VFMULCSH\n\t\t— Complex Multiply Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Complex multiply a pair of FP16 values from xmm2 and complex conjugate of xmm3/m32, and store the result in xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F2.MAP6.W0 D7 /r VFCMULCSH xmm1{k1}{z}, xmm2, xmm3/m32 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      },
      {
        "Description": "Complex multiply a pair of FP16 values from xmm2 and xmm3/m32, and store the result in xmm1 subject to writemask k1. Bits 127:32 of xmm2 are copied to xmm1[127:32].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP6.W0 D7 /r VFMULCSH xmm1{k1}{z}, xmm2, xmm3/m32 {er}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/serialize",
    "category": "Core Instructions",
    "instructionName": "SERIALIZE\n\t\t— Serialize Instruction Execution",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SERIALIZE",
        "Description": "Serialize instruction fetch and execution.",
        "Op/En": "ZO",
        "Opcode/Instruction": "NP 0F 01 E8 SERIALIZE"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "Serializes instruction execution. Before the next instruction is fetched and executed, the SERIALIZE instruction ensures that all modifications to flags, registers, and memory by previous instructions are completed, draining all buffered writes to memory. This instruction is also a serializing instruction as defined in the section “Serializing Instructions” in Chapter 9 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\nSERIALIZE does not modify registers, arithmetic flags, or memory.",
    "operationText": "Wait_On_Fetch_And_Execution_Of_Next_Instruction_Until(preceding_instructions_complete_and_preceding_stores_globally_visible);",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "column_1: If CPUID.07H.0H:EDX.SERIALIZE[bit 14] = 0.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/encodekey256",
    "category": "Core Instructions",
    "instructionName": "ENCODEKEY256\n\t\t— Encode 256-Bit Key With Key Locker",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLE",
        "Description": "Wrap a 256-bit AES key from XMM1:XMM0 into a key handle and store it in XMM0—3.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 FB 11:rrr:bbb ENCODEKEY256 r32, r32 <XMM0-6>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operands 3—4": "Implicit XMM0—1 (r, w)",
        "Operands 5—9": "Implicit XMM2—6 (w)",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The ENCODEKEY2561 instruction wraps a 256-bit AES key from the implicit operand XMM1:XMM0 into a key handle that is then stored in the implicit destination operands XMM0-3.\nThe explicit source operand is a general-purpose register and specifies what handle restrictions should be built into the handle.\nThe explicit destination operand is populated with information on the source of the key and its attributes. XMM4 through XMM6 are reserved for future usages and software should not rely upon them being zeroed.",
    "operationText": "#GP (0) if a reserved bit2 in SRC[31:0] is set\nInputKey[255:0] := XMM1:XMM0;\nKeyMetadata[2:0] = SRC[2:0];\nKeyMetadata[23:3] = 0; // Reserved for future usage\nKeyMetadata[27:24] = 1; // KeyType is AES-256 (value of 1)\nKeyMetadata[127:28] = 0; // Reserved for future usage\n// KeyMetadata is the AAD input and InputKey is the Plaintext input for WrapKey256\nHandle[511:0] := WrapKey256(InputKey[255:0], KeyMetadata[127:0], IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]);\nDEST[0] := IWKey.NoBackup;\nDEST[4:1] := IWKey.KeySource[3:0];\nDEST[31:5] = 0;\nXMM0 := Handle[127:0]; // AAD\nXMM1 := Handle[255:128]; // Integrity Tag\nXMM2 := Handle[383:256]; // CipherText[127:0]\nXMM3 := Handle[511:384]; // CipherText[255:128]\nXMM4 := 0;\n    // Reserved for future usage\nXMM5 := 0;\n    // Reserved for future usage\nXMM6 := 0;\n    // Reserved for future usage\nRFLAGS.OF, SF, ZF, AF, PF, CF := 0;\n1. Further details on Key Locker and usage of this instruction can be found here:\n2. SRC[31:3] are currently reserved for future usages. SRC[2], which indicates a no-decrypt restriction, is reserved if CPUID.19H:EAX[2] is 0. SRC[1], which indicates a no-encrypt restriction, is reserved if CPUID.19H:EAX[1] is 0. SRC[0], which indicates a CPL0-only restriction, is reserved if CPUID.19H:EAX[0] is 0.",
    "flagsAffectedText": "All arithmetic flags (OF, SF, ZF, AF, PF, CF) are cleared to 0. Although they are cleared for the currently defined operations, future extensions may report information in the flags.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/pminud:pminuq",
    "category": "Core Instructions",
    "instructionName": "PMINUD/PMINUQ\n\t\t— Minimum of Packed Unsigned Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE4_1",
        "Description": "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
        "Op/E n": "A",
        "Opcode/Instruction": "66 0F 38 3B /r PMINUD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.",
        "Op/E n": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG 3B /r VPMINUD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.",
        "Op/E n": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG 3B /r VPMINUD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed minimum values in xmm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 3B /r VPMINUD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed minimum values in ymm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 3B /r VPMINUD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 3B /r VPMINUD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed minimum values in xmm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 3B /r VPMINUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed minimum values in ymm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 3B /r VPMINUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1.",
        "Op/E n": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 3B /r VPMINUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.\n128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.\nVEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
    "operationText": "PMINUD instruction for 128-bit operands:\n    IF DEST[31:0] < SRC[31:0] THEN\n        DEST[31:0] := DEST[31:0];\n    ELSE\n        DEST[31:0] := SRC[31:0]; FI;\n    (* Repeat operation for 2nd through 7th words in source and destination operands *)\n    IF DEST[127:96] < SRC[127:96] THEN\n        DEST[127:96] := DEST[127:96];\n    ELSE\n        DEST[127:96] := SRC[127:96]; FI;\nDEST[MAXVL-1:128] (Unmodified)\nVPMINUD instruction for 128-bit operands:\n    IF SRC1[31:0] < SRC2[31:0] THEN\n        DEST[31:0] := SRC1[31:0];\n    ELSE\n        DEST[31:0] := SRC2[31:0]; FI;\n    (* Repeat operation for 2nd through 3rd dwords in source and destination operands *)\n    IF SRC1[127:96] < SRC2[127:96] THEN\n        DEST[127:96] := SRC1[127:96];\n    ELSE\n        DEST[127:96] := SRC2[127:96]; FI;\nDEST[MAXVL-1:128] := 0\nVPMINUD instruction for 128-bit operands:\n    IF SRC1[31:0] < SRC2[31:0] THEN\n        DEST[31:0] := SRC1[31:0];\n    ELSE\n        DEST[31:0] := SRC2[31:0]; FI;\n    (* Repeat operation for 2nd through 7th dwords in source and destination operands *)\n    IF SRC1[255:224] < SRC2[255:224] THEN\n        DEST[255:224] := SRC1[255:224];\n    ELSE\n        DEST[255:224] := SRC2[255:224]; FI;\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n        IF (EVEX.b = 1) AND (SRC2 *is memory*)\n            THEN\n                IF SRC1[i+31:i] < SRC2[31:0]\n                    THEN DEST[i+31:i] := SRC1[i+31:i];\n                    ELSE DEST[i+31:i] := SRC2[31:0];\n                FI;\n            ELSE\n                IF SRC1[i+31:i] < SRC2[i+31:i]\n                    THEN DEST[i+31:i] := SRC1[i+31:i];\n                    ELSE DEST[i+31:i] := SRC2[i+31:i];\n            FI;\n        FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n        IF (EVEX.b = 1) AND (SRC2 *is memory*)\n            THEN\n                IF SRC1[i+63:i] < SRC2[63:0]\n                    THEN DEST[i+63:i] := SRC1[i+63:i];\n                    ELSE DEST[i+63:i] := SRC2[63:0];\n                FI;\n            ELSE\n                IF SRC1[i+63:i] < SRC2[i+63:i]\n                    THEN DEST[i+63:i] := SRC1[i+63:i];\n                    ELSE DEST[i+63:i] := SRC2[i+63:i];\n            FI;\n        FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-49, “Type E4 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpgatherdd:vpgatherqd",
    "category": "Core Instructions",
    "instructionName": "VPGATHERDD/VPGATHERQD\n\t\t— Gather Packed Dword Values Using Signed Dword/Qword Indices",
    "detailsTable": [
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using dword indices specified in vm32x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 90 /r VPGATHERDD xmm1, vm32x, xmm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using qword indices specified in vm64x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 91 /r VPGATHERQD xmm1, vm64x, xmm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using dword indices specified in vm32y, gather dword from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 90 /r VPGATHERDD ymm1, vm32y, ymm2"
      },
      {
        "64/32 -bit Mode": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using qword indices specified in vm64y, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 91 /r VPGATHERQD xmm1, vm64y, xmm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMV",
        "Operand 1": "ModRM:reg (r,w)",
        "Operand 2": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 3": "VEX.vvvv (r, w)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction conditionally loads up to 4 or 8 dword values from memory addresses specified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\nThe mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is specified by the most significant bit of each data element of the mask register. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.\nUsing qword indices, the instruction conditionally loads up to 2 or 4 qword values from the VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destination register are zero’ed with qword indices.\nThis instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.\nIf the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.\nVEX.128 version: For dword indices, the instruction will gather four dword values. For qword indices, the instruction will gather two values and zero the upper 64 bits of the destination.\nVEX.256 version: For dword indices, the instruction will gather eight dword values. For qword indices, the instruction will gather four values and zero the upper 128 bits of the destination.\nNote that:",
    "operationText": "DEST := SRC1;\nBASE_ADDR: base register encoded in VSIB addressing;\nVINDEX: the vector index register encoded by VSIB addressing;\nSCALE: scale factor encoded by SIB:[7:6];\nDISP: optional 1, 4 byte displacement;\nMASK := SRC3;\nMASK[MAXVL-1:128] := 0;\nFOR j := 0 to 3\n    i := j * 32;\n    IF MASK[31+i] THEN\n        MASK[i +31:i] := FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +31:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 3\n    i := j * 32;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX[i+31:i])*SCALE + DISP;\n    IF MASK[31+i] THEN\n        DEST[i +31:i] := FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +31:i] := 0;\nENDFOR\nDEST[MAXVL-1:128] := 0;\nMASK[MAXVL-1:64] := 0;\nFOR j := 0 to 3\n    i := j * 32;\n    IF MASK[31+i] THEN\n        MASK[i +31:i] := FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +31:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 1\n    k := j * 64;\n    i := j * 32;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[k+63:k])*SCALE + DISP;\n    IF MASK[31+i] THEN\n        DEST[i +31:i] := FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +31:i] := 0;\nENDFOR\nDEST[MAXVL-1:64] := 0;\nMASK[MAXVL-1:256] := 0;\nFOR j := 0 to 7\n    i := j * 32;\n    IF MASK[31+i] THEN\n        MASK[i +31:i] := FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +31:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 7\n    i := j * 32;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[i+31:i])*SCALE + DISP;\n    IF MASK[31+i] THEN\n        DEST[i +31:i] := FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +31:i] := 0;\nENDFOR\nDEST[MAXVL-1:256] := 0;\nMASK[MAXVL-1:128] := 0;\nFOR j := 0 to 7\n    i := j * 32;\n    IF MASK[31+i] THEN\n        MASK[i +31:i] := FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +31:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 3\n    k := j * 64;\n    i := j * 32;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[k+63:k])*SCALE + DISP;\n    IF MASK[31+i] THEN\n        DEST[i +31:i] := FETCH_32BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +31:i] := 0;\nENDFOR\nDEST[MAXVL-1:128] := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-27, “Type 12 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/gf2p8affineinvqb",
    "category": "Core Instructions",
    "instructionName": "GF2P8AFFINEINVQB\n\t\t— Galois Field Affine Transformation Inverse",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "GFNI",
        "Description": "Computes inverse affine transformation in the finite field GF(2^8).",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F3A CF /r /ib GF2P8AFFINEINVQB xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX GFNI",
        "Description": "Computes inverse affine transformation in the finite field GF(2^8).",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F3A.W1 CF /r /ib VGF2P8AFFINEINVQB xmm1, xmm2, xmm3/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX GFNI",
        "Description": "Computes inverse affine transformation in the finite field GF(2^8).",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F3A.W1 CF /r /ib VGF2P8AFFINEINVQB ymm1, ymm2, ymm3/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL GFNI",
        "Description": "Computes inverse affine transformation in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F3A.W1 CF /r /ib VGF2P8AFFINEINVQB xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL GFNI",
        "Description": "Computes inverse affine transformation in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F3A.W1 CF /r /ib VGF2P8AFFINEINVQB ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F GFNI",
        "Description": "Computes inverse affine transformation in the finite field GF(2^8).",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F3A.W1 CF /r /ib VGF2P8AFFINEINVQB zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8 (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/aad",
    "category": "Core Instructions",
    "instructionName": "AAD\n\t\t— ASCII Adjust AX Before Division",
    "detailsTable": [
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "ASCII adjust AX before division.",
        "Instruction": "AAD",
        "Op/En": "ZO",
        "Opcode": "D5 0A"
      },
      {
        "64-bit Mode": "Invalid",
        "Compat/Leg Mode": "Valid",
        "Description": "Adjust AX before division to number base imm8.",
        "Instruction": "AAD imm8",
        "Op/En": "ZO",
        "Opcode": "D5 ib"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value.\nThe AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H. The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10) number in registers AH and AL.\nThe generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the “Operation” section below), by setting the imm8 byte to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine code (D5 imm8).\nThis instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.",
    "operationText": "IF 64-Bit Mode\n    THEN\n        #UD;\n    ELSE\n        tempAL := AL;\n        tempAH := AH;\n        AL := (tempAL + (tempAH ∗ imm8)) AND FFH;\n        (* imm8 is set to 0AH for the AAD mnemonic.*)\n        AH := 0;\nFI;\nThe immediate value (imm8) is taken from the second byte of the instruction.",
    "flagsAffectedText": "The SF, ZF, and PF flags are set according to the resulting binary value in the AL register; the OF, AF, and CF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        ""
      ],
      "compatibilityMode": [
        "Same exceptions as protected mode."
      ],
      "protectedMode": [
        ""
      ],
      "realAddressMode": [
        "Same exceptions as protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/maxss",
    "category": "Core Instructions",
    "instructionName": "MAXSS\n\t\t— Return Maximum Scalar Single Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Return the maximum scalar single precision floating-point value between xmm2/m32 and xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 5F /r MAXSS xmm1, xmm2/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the maximum scalar single precision floating-point value between xmm3/m32 and xmm2.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F3.0F.WIG 5F /r VMAXSS xmm1, xmm2, xmm3/m32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Return the maximum scalar single precision floating-point value between xmm3/m32 and xmm2.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F3.0F.W0 5F /r VMAXSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the low single precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low doubleword of the destination operand.\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN from either source operand be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\nThe second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL:128) of the destination register are zeroed.\nEVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.\nSoftware should ensure VMAXSS is encoded with VEX.L=0. Encoding VMAXSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "MAX(SRC1, SRC2)\n{\n    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;\n        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC1 > SRC2) THEN DEST := SRC1;\n        ELSE DEST := SRC2;\n    FI;\n}\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := MAX(SRC1[31:0], SRC2[31:0])\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := MAX(SRC1[31:0], SRC2[31:0])\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := MAX(DEST[31:0], SRC[31:0])\nDEST[MAXVL-1:32] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (Including QNaN Source Operand), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/fsqrt",
    "category": "Core Instructions",
    "instructionName": "FSQRT\n\t\t— Square Root",
    "detailsTable": [
      {
        "Description": "Computes square root of ST(0) and stores the result in ST(0).",
        "Leg Mode": "",
        "Mode": "",
        "Opcode": "D9 FA",
        "column_2": ""
      }
    ],
    "operandEncodingTable": null,
    "descriptionText": "Computes the square root of the source value in the ST(0) register and stores the result in ST(0).\nThe following table shows the results obtained when taking the square root of various classes of numbers, assuming that neither overflow nor underflow occurs.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "ST(0) := SquareRoot(ST(0));",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "floating-point¶": [
        "column_1: #IA; column_2: Source operand is an SNaN value or unsupported format.; \ncolumn_1: Source operand is a negative value (except for −0).; \ncolumn_2: Source operand is a denormal value.; column_1: #D; \ncolumn_1: #P; column_2: Value cannot be represented exactly in destination format.;"
      ],
      "protectedMode": [
        "column_1: #MF; column_2: If there is a pending x87 FPU exception.; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "Same exceptions as in protected mode."
      ],
      "virtual8086Mode": [
        "Same exceptions as in protected mode."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vp2intersectd:vp2intersectq",
    "category": "Core Instructions",
    "instructionName": "VP2INTERSECTD/VP2INTERSECTQ\n\t\t— Compute Intersection Between DWORDS/QUADWORDS to aPair of Mask Registers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VP2INTERSECT",
        "Description": "Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between dwords in xmm3/m128/m32bcst and xmm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.NDS.128.F2.0F38.W0 68 /r VP2INTERSECTD k1+1, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VP2INTERSECT",
        "Description": "Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between dwords in ymm3/m256/m32bcst and ymm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.NDS.256.F2.0F38.W0 68 /r VP2INTERSECTD k1+1, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F AVX512_VP2INTERSECT",
        "Description": "Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between dwords in zmm3/m512/m32bcst and zmm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.NDS.512.F2.0F38.W0 68 /r VP2INTERSECTD k1+1, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VP2INTERSECT",
        "Description": "Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between quadwords in xmm3/m128/m64bcst and xmm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.NDS.128.F2.0F38.W1 68 /r VP2INTERSECTQ k1+1, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512_VP2INTERSECT",
        "Description": "Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between quadwords in ymm3/m256/m64bcst and ymm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.NDS.256.F2.0F38.W1 68 /r VP2INTERSECTQ k1+1, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F AVX512_VP2INTERSECT",
        "Description": "Store, in an even/odd pair of mask registers, the indicators of the locations of value matches between quadwords in zmm3/m512/m64bcst and zmm2.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.NDS.512.F2.0F38.W1 68 /r VP2INTERSECTQ k1+1, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtpd2pi",
    "category": "Core Instructions",
    "instructionName": "CVTPD2PI\n\t\t— Convert Packed Double Precision Floating-Point Values to Packed Dword Integers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert two packed double precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm.",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 2D /r CVTPD2PI mm, xmm/m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Converts two packed double precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).\nThe source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.\nThis instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.\nIn 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
    "operationText": "DEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer32(SRC[63:0]);\nDEST[63:32] := Convert_Double_Precision_Floating_Point_To_Integer32(SRC[127:64]);",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 23-4, “Exception Conditions for Legacy SIMD/MMX Instructions with FP Exception and 16-Byte Alignment” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B."
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movddup",
    "category": "Core Instructions",
    "instructionName": "MOVDDUP\n\t\t— Replicate Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Move double precision floating-point value from xmm2/m64 and duplicate into xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 12 /r MOVDDUP xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move double precision floating-point value from xmm2/m64 and duplicate into xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.F2.0F.WIG 12 /r VMOVDDUP xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move even index double precision floating-point values from ymm2/mem and duplicate each element into ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.F2.0F.WIG 12 /r VMOVDDUP ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move double precision floating-point value from xmm2/m64 and duplicate each element into xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.F2.0F.W1 12 /r VMOVDDUP xmm1 {k1}{z}, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move even index double precision floating-point values from ymm2/m256 and duplicate each element into ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.F2.0F.W1 12 /r VMOVDDUP ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move even index double precision floating-point values from zmm2/m512 and duplicate each element into zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.F2.0F.W1 12 /r VMOVDDUP zmm1 {k1}{z}, zmm2/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "MOVDDUP"
      }
    ],
    "descriptionText": "For 256-bit or higher versions: Duplicates even-indexed double precision floating-point values from the source operand (the second operand) and into adjacent pair and store to the destination operand (the first operand).\nFor 128-bit versions: Duplicates the low double precision floating-point value from the source operand (the second operand) and store to the destination operand (the first operand).\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register are unchanged. The source operand is XMM register or a 64-bit memory location.\nVEX.128 and EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. The source operand is XMM register or a 64-bit memory location. The destination is updated conditionally under the writemask for EVEX version.\nVEX.256 and EVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed. The source operand is YMM register or a 256-bit memory location. The destination is updated conditionally under the write-mask for EVEX version.\nEVEX.512 encoded version: The destination is updated according to the writemask. The source operand is ZMM register or a 512-bit memory location.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nTMP_SRC[63:0] := SRC[63:0]\nTMP_SRC[127:64] := SRC[63:0]\nIF VL >= 256\n    TMP_SRC[191:128] := SRC[191:128]\n    TMP_SRC[255:192] := SRC[191:128]\nFI;\nIF VL >= 512\n    TMP_SRC[319:256] := SRC[319:256]\n    TMP_SRC[383:320] := SRC[319:256]\n    TMP_SRC[477:384] := SRC[477:384]\n    TMP_SRC[511:484] := SRC[477:384]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_SRC[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n                        ; zeroing-masking\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SRC[63:0]\nDEST[127:64] := SRC[63:0]\nDEST[191:128] := SRC[191:128]\nDEST[255:192] := SRC[191:128]\nDEST[MAXVL-1:256] := 0\nDEST[63:0] := SRC[63:0]\nDEST[127:64] := SRC[63:0]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SRC[63:0]\nDEST[127:64] := SRC[63:0]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-22, “Type 5 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-52, “Type E5NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/sqrtpd",
    "category": "Core Instructions",
    "instructionName": "SQRTPD\n\t\t— Square Root of Double Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Computes Square Roots of the packed double precision floating-point values in xmm2/m128 and stores the result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "66 0F 51 /r SQRTPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes Square Roots of the packed double precision floating-point values in xmm2/m128 and stores the result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 51 /r VSQRTPD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes Square Roots of the packed double precision floating-point values in ymm2/m256 and stores the result in ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 51 /r VSQRTPD ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes Square Roots of the packed double precision floating-point values in xmm2/m128/m64bcst and stores the result in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 51 /r VSQRTPD xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes Square Roots of the packed double precision floating-point values in ymm2/m256/m64bcst and stores the result in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 51 /r VSQRTPD ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes Square Roots of the packed double precision floating-point values in zmm2/m512/m64bcst and stores the result in zmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 51 /r VSQRTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Performs a SIMD computation of the square roots of the two, four or eight packed double precision floating-point values in the source operand (the second operand) stores the packed double precision floating-point results in the destination operand (the first operand).\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nVEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF (VL = 512) AND (EVEX.b = 1) AND (SRC *is register*)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC *is memory*)\n                THEN DEST[i+63:i] := SQRT(SRC[63:0])\n                ELSE DEST[i+63:i] := SQRT(SRC[i+63:i])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[63:0] := SQRT(SRC[63:0])\nDEST[127:64] := SQRT(SRC[127:64])\nDEST[191:128] := SQRT(SRC[191:128])\nDEST[255:192] := SQRT(SRC[255:192])\nDEST[MAXVL-1:256] := 0\n.\nDEST[63:0] := SQRT(SRC[63:0])\nDEST[127:64] := SQRT(SRC[127:64])\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := SQRT(SRC[63:0])\nDEST[127:64] := SQRT(SRC[127:64])\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions,” additionally:",
        "",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vucomish",
    "category": "Core Instructions",
    "instructionName": "VUCOMISH\n\t\t— Unordered Compare Scalar FP16 Values and Set EFLAGS",
    "detailsTable": [
      {
        "column_1": "VUCOMISH xmm1, xmm2/m16 {sae}",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "Compare low FP16 values in xmm1 and xmm2/m16 and set the EFLAGS flags accordingly."
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpbroadcastb:vpbroadcastw:vpbroadcastd:vpbroadcastq",
    "category": "Core Instructions",
    "instructionName": "VPBROADCASTB/VPBROADCASTW/VPBROADCASTD/VPBROADCASTQ\n\t\t— Load With Broadcast Integer Data From General Purpose Register",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Broadcast an 8-bit value from a GPR to all bytes in the 128-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 7A /r VPBROADCASTB xmm1 {k1}{z}, reg"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Broadcast an 8-bit value from a GPR to all bytes in the 256-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 7A /r VPBROADCASTB ymm1 {k1}{z}, reg"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Broadcast an 8-bit value from a GPR to all bytes in the 512-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 7A /r VPBROADCASTB zmm1 {k1}{z}, reg"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Broadcast a 16-bit value from a GPR to all words in the 128-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 7B /r VPBROADCASTW xmm1 {k1}{z}, reg"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Broadcast a 16-bit value from a GPR to all words in the 256-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 7B /r VPBROADCASTW ymm1 {k1}{z}, reg"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Broadcast a 16-bit value from a GPR to all words in the 512-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 7B /r VPBROADCASTW zmm1 {k1}{z}, reg"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast a 32-bit value from a GPR to all doublewords in the 128-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 7C /r VPBROADCASTD xmm1 {k1}{z}, r32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast a 32-bit value from a GPR to all doublewords in the 256-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 7C /r VPBROADCASTD ymm1 {k1}{z}, r32"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast a 32-bit value from a GPR to all doublewords in the 512-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 7C /r VPBROADCASTD zmm1 {k1}{z}, r32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast a 64-bit value from a GPR to all quadwords in the 128-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 7C /r VPBROADCASTQ xmm1 {k1}{z}, r64"
      },
      {
        "64/32 bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Broadcast a 64-bit value from a GPR to all quadwords in the 256-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 7C /r VPBROADCASTQ ymm1 {k1}{z}, r64"
      },
      {
        "64/32 bit Mode Support": "V/N.E.1",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Broadcast a 64-bit value from a GPR to all quadwords in the 512-bit destination subject to writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 7C /r VPBROADCASTQ zmm1 {k1}{z}, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrndscaleph",
    "category": "Core Instructions",
    "instructionName": "VRNDSCALEPH\n\t\t— Round Packed FP16 Values to Include a Given Number of Fraction Bits",
    "detailsTable": [
      {
        "Description": "Round packed FP16 values in xmm2/m128/m16bcst to a number of fraction bits specified by the imm8 field. Store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.NP.0F3A.W0 08 /r /ib VRNDSCALEPH xmm1{k1}{z}, xmm2/m128/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Round packed FP16 values in ymm2/m256/m16bcst to a number of fraction bits specified by the imm8 field. Store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.NP.0F3A.W0 08 /r /ib VRNDSCALEPH ymm1{k1}{z}, ymm2/m256/m16bcst, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Round packed FP16 values in zmm2/m512/m16bcst to a number of fraction bits specified by the imm8 field. Store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.NP.0F3A.W0 08 /r /ib VRNDSCALEPH zmm1{k1}{z}, zmm2/m512/m16bcst {sae}, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8 (r)",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrt14pd",
    "category": "Core Instructions",
    "instructionName": "VRSQRT14PD\n\t\t— Compute Approximate Reciprocals of Square Roots of Packed Float64 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes the approximate reciprocal square roots of the packed double precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 4E /r VRSQRT14PD xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Computes the approximate reciprocal square roots of the packed double precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 4E /r VRSQRT14PD ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Computes the approximate reciprocal square roots of the packed double precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1 under writemask.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 4E /r VRSQRT14PD zmm1 {k1}{z}, zmm2/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movnti",
    "category": "Core Instructions",
    "instructionName": "MOVNTI\n\t\t— Store Doubleword Using Non-Temporal Hint",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move doubleword from r32 to m32 using non-temporal hint.",
        "Op/En": "MR",
        "Opcode / Instruction": "NP 0F C3 /r MOVNTI m32, r32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "SSE2",
        "Description": "Move quadword from r64 to m64 using non-temporal hint.",
        "Op/En": "MR",
        "Opcode / Instruction": "NP REX.W + 0F C3 /r MOVNTI m64, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a general-purpose register. The destination operand is a 32-bit memory location.\nThe non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\nBecause the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTI instructions if multiple processors might use different memory types to read/write the destination memory locations.\nIn 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "DEST := SRC;",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_2: If CPUID.01H:EDX.SSE2[bit 26] = 0.; column_1: #UD; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.01H:EDX.SSE2[bit 26] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If CPUID.01H:EDX.SSE2[bit 26] = 0.; \ncolumn_1: If the LOCK prefix is used.;"
      ],
      "simdFloating-Point¶": [
        "None."
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode.",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/addps",
    "category": "Core Instructions",
    "instructionName": "ADDPS\n\t\t— Add Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Add packed single precision floating-point values from xmm2/m128 to xmm1 and store result in xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "NP 0F 58 /r ADDPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed single precision floating-point values from xmm3/m128 to xmm2 and store result in xmm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.128.0F.WIG 58 /r VADDPS xmm1,xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add packed single precision floating-point values from ymm3/m256 to ymm2 and store result in ymm1.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.256.0F.WIG 58 /r VADDPS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Add packed single precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1 with writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.128.0F.W0 58 /r VADDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Add packed single precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1 with writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.256.0F.W0 58 /r VADDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Add packed single precision floating-point values from zmm3/m512/m32bcst to zmm2 and store result in zmm1 with writemask k1.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.512.0F.W0 58 /r VADDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst {er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Adds four, eight or sixteen packed single precision floating-point values from the first source operand with the second source operand, and stores the packed single precision floating-point result in the destination operand.\nEVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC1[i+31:i] + SRC2[i+31:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+31:i] :=\n                        SRC1[i+31:i] + SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] :=\n                        SRC1[i+31:i] + SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking*\n                            ; merging-masking\n                THEN *DEST[i+31:i]\n                        remains unchanged*\n                ELSE\n                            ; zeroing-masking\n                    DEST[i+31:i] :=\n                        0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] + SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[159:128] := SRC1[159:128] + SRC2[159:128]\nDEST[191:160]:= SRC1[191:160] + SRC2[191:160]\nDEST[223:192] := SRC1[223:192] + SRC2[223:192]\nDEST[255:224] := SRC1[255:224] + SRC2[255:224].\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] + SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] + SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "VEX-encoded instruction, see Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-46, “Type E2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vp4dpwssds",
    "category": "Xeon Phi™ Instructions",
    "instructionName": "VP4DPWSSDS\n\t\t— Dot Product of Signed Words With Dword Accumulation and Saturation(4-Iterations)",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512_4VNNIW",
        "Description": "Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate the resulting dword results with signed saturation in zmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F2.0F38.W0 53 /r VP4DPWSSDS zmm1{k1}{z}, zmm2+3, m128"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En Tuple Operand 1 Operand 2 Operand 3 Operand 4": "A Tuple1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) N/A",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "",
        "column_6": ""
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/movshdup",
    "category": "Core Instructions",
    "instructionName": "MOVSHDUP\n\t\t— Replicate Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Move odd index single precision floating-point values from xmm2/mem and duplicate each element into xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F3 0F 16 /r MOVSHDUP xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move odd index single precision floating-point values from xmm2/mem and duplicate each element into xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.128.F3.0F.WIG 16 /r VMOVSHDUP xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Move odd index single precision floating-point values from ymm2/mem and duplicate each element into ymm1.",
        "Op / En": "A",
        "Opcode/Instruction": "VEX.256.F3.0F.WIG 16 /r VMOVSHDUP ymm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move odd index single precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.F3.0F.W0 16 /r VMOVSHDUP xmm1 {k1}{z}, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Move odd index single precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.F3.0F.W0 16 /r VMOVSHDUP ymm1 {k1}{z}, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Move odd index single precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.F3.0F.W0 16 /r VMOVSHDUP zmm1 {k1}{z}, zmm2/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      }
    ],
    "descriptionText": "Duplicates odd-indexed single precision floating-point values from the source operand (the second operand) to adjacent element pair in the destination operand (the first operand). See Figure 4-3. The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.\nVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.\nVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed.\nEVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.\nNote: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (4, 128), (8, 256), (16, 512)\nTMP_SRC[31:0] := SRC[63:32]\nTMP_SRC[63:32] := SRC[63:32]\nTMP_SRC[95:64] := SRC[127:96]\nTMP_SRC[127:96] := SRC[127:96]\nIF VL >= 256\n    TMP_SRC[159:128] := SRC[191:160]\n    TMP_SRC[191:160] := SRC[191:160]\n    TMP_SRC[223:192] := SRC[255:224]\n    TMP_SRC[255:224] := SRC[255:224]\nFI;\nIF VL >= 512\n    TMP_SRC[287:256] := SRC[319:288]\n    TMP_SRC[319:288] := SRC[319:288]\n    TMP_SRC[351:320] := SRC[383:352]\n    TMP_SRC[383:352] := SRC[383:352]\n    TMP_SRC[415:384] := SRC[447:416]\n    TMP_SRC[447:416] := SRC[447:416]\n    TMP_SRC[479:448] := SRC[511:480]\n    TMP_SRC[511:480] := SRC[511:480]\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_SRC[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[31:0] := SRC[63:32]\nDEST[63:32] := SRC[63:32]\nDEST[95:64] := SRC[127:96]\nDEST[127:96] := SRC[127:96]\nDEST[159:128] := SRC[191:160]\nDEST[191:160] := SRC[191:160]\nDEST[223:192] := SRC[255:224]\nDEST[255:224] := SRC[255:224]\nDEST[MAXVL-1:256] := 0\nDEST[31:0] := SRC[63:32]\nDEST[63:32] := SRC[63:32]\nDEST[95:64] := SRC[127:96]\nDEST[127:96] := SRC[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC[63:32]\nDEST[63:32] := SRC[63:32]\nDEST[95:64] := SRC[127:96]\nDEST[127:96] := SRC[127:96]\nDEST[MAXVL-1:128] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Exceptions Type E4NF.nb in Table 2-50, “Type E4NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/maxsd",
    "category": "Core Instructions",
    "instructionName": "MAXSD\n\t\t— Return Maximum Scalar Double Precision Floating-Point Value",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Return the maximum scalar double precision floating-point value between xmm2/m64 and xmm1.",
        "Op / En": "A",
        "Opcode/Instruction": "F2 0F 5F /r MAXSD xmm1, xmm2/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Return the maximum scalar double precision floating-point value between xmm3/m64 and xmm2.",
        "Op / En": "B",
        "Opcode/Instruction": "VEX.LIG.F2.0F.WIG 5F /r VMAXSD xmm1, xmm2, xmm3/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Return the maximum scalar double precision floating-point value between xmm3/m64 and xmm2.",
        "Op / En": "C",
        "Opcode/Instruction": "EVEX.LLIG.F2.0F.W1 5F /r VMAXSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "Compares the low double precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low quadword of the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. When the second source operand is a memory operand, only 64 bits are accessed.\nIf the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).\nIf only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN of either source operand be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN, and OR.\n128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.\nVEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\nEVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.\nSoftware should ensure VMAXSD is encoded with VEX.L=0. Encoding VMAXSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.",
    "operationText": "MAX(SRC1, SRC2)\n{\n    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;\n        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;\n        ELSE IF (SRC1 > SRC2) THEN DEST := SRC1;\n        ELSE DEST := SRC2;\n    FI;\n}\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := MAX(SRC1[63:0], SRC2[63:0])\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                DEST[63:0] := 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := MAX(SRC1[63:0], SRC2[63:0])\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\nDEST[63:0] := MAX(DEST[63:0], SRC[63:0])\nDEST[MAXVL-1:64] (Unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-20, “Type 3 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-47, “Type E3 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Invalid (Including QNaN Source Operand), Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrndscalesh",
    "category": "Core Instructions",
    "instructionName": "VRNDSCALESH\n\t\t— Round Scalar FP16 Value to Include a Given Number of Fraction Bits",
    "detailsTable": [
      {
        "Description": "Round the low FP16 value in xmm3/m16 to a number of fraction bits specified by the imm8 field. Store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.NP.0F3A.W0 0A /r /ib VRNDSCALESH xmm1{k1}{z}, xmm2, xmm3/m16 {sae}, imm8",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "imm8 (r)",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/popcnt",
    "category": "Core Instructions",
    "instructionName": "POPCNT\n\t\t— Return the Count of Number of Bits Set to 1",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "POPCNT on r/m16",
        "Instruction": "POPCNT r16, r/m16",
        "Op/En": "RM",
        "Opcode": "F3 0F B8 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "POPCNT on r/m32",
        "Instruction": "POPCNT r32, r/m32",
        "Op/En": "RM",
        "Opcode": "F3 0F B8 /r"
      },
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "N.E.",
        "Description": "POPCNT on r/m64",
        "Instruction": "POPCNT r64, r/m64",
        "Op/En": "RM",
        "Opcode": "F3 REX.W 0F B8 /r"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "This instruction calculates the number of bits set to 1 in the second operand (source) and returns the count in the first operand (a destination register).",
    "operationText": "Count = 0;\nFor (i=0; i < OperandSize; i++)\n{ IF (SRC[ i] = 1) // i’th bit\n    THEN Count++; FI;\n}\nDEST := Count;",
    "flagsAffectedText": "OF, SF, ZF, AF, CF, PF are all cleared. ZF is set if SRC = 0, otherwise ZF is cleared.",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.POPCNT [Bit 23] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in Protected Mode."
      ],
      "protectedMode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.; \ncolumn_2: If CPUID.01H:ECX.POPCNT [Bit 23] = 0.; column_1: #UD; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_2: If a memory operand effective address is outside the SS segment limit.; column_1: #SS(0); \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.POPCNT [Bit 23] = 0.; \ncolumn_1: If LOCK prefix is used.;"
      ],
      "virtual8086Mode¶": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_2: (fault-code) For a page fault.; column_1: #PF; \ncolumn_1: #AC(0); column_2: If an unaligned memory reference is made while alignment checking is enabled.; \ncolumn_2: If CPUID.01H:ECX.POPCNT [Bit 23] = 0.; column_1: #UD; \ncolumn_1: If LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesenc256kl",
    "category": "Core Instructions",
    "instructionName": "AESENC256KL\n\t\t— Perform 14 Rounds of AES Encryption Flow With Key Locker Using 256-Bit Key",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AESKLE",
        "Description": "Encrypt xmm using 256-bit AES key indicated by handle at m512 and store result in xmm.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 DE !(11):rrr:bbb AESENC256KL xmm, m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The AESENC256KL1 instruction performs 14 rounds of AES to encrypt the first operand using the 256-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).",
    "operationText": "Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (\n                HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL > 0)) ||\n                Handle [1] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256\n                );\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    DEST := AES256Encrypt (DEST, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvttpd2uqq",
    "category": "Core Instructions",
    "instructionName": "VCVTTPD2UQQ\n\t\t— Convert With Truncation Packed Double Precision Floating-Point Values toPacked Unsigned Quadword Integers",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed double precision floating-point values from xmm2/m128/m64bcst to two packed unsigned quadword integers in xmm1 using truncation with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 78 /r VCVTTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed double precision floating-point values from ymm2/m256/m64bcst to four packed unsigned quadword integers in ymm1 using truncation with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 78 /r VCVTTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed double precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 using truncation with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 78 /r VCVTTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/sgdt",
    "category": "Core Instructions",
    "instructionName": "SGDT\n\t\t— Store Global Descriptor Table Register",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Store GDTR to m.",
        "Instruction": "",
        "Op/En": "",
        "column_1": "0F 01 /0"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination operand specifies a memory location.\nIn legacy or compatibility mode, the destination operand is a 6-byte memory location. If the operand-size attribute is 16 or 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.\nIn 64-bit mode, the operand size is fixed at 8+2 bytes. The instruction stores an 8-byte base and a 2-byte limit.\nSGDT is useful only by operating-system software. However, it can be used in application programs without causing an exception to be generated if CR4.UMIP = 0. See “LGDT/LIDT—Load Global/Interrupt Descriptor Table Register” in Chapter 3, Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A, for information on loading the GDTR and IDTR.",
    "operationText": "IF instruction is SGDT\n    IF OperandSize =16 or OperandSize = 32 (* Legacy or Compatibility Mode *)\n        THEN\n            DEST[0:15] := GDTR(Limit);\n            DEST[16:47] := GDTR(Base); (* Full 32-bit base address stored *)\n            FI;\n        ELSE (* 64-bit Mode *)\n            DEST[0:15] := GDTR(Limit);\n            DEST[16:79] := GDTR(Base); (* Full 64-bit base address stored *)\n    FI;\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while CPL = 3.; column_1: #AC(0);"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #GP(0); column_2: If the destination is located in a non-writable segment.; \ncolumn_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.; \ncolumn_1: If CR4.UMIP = 1 and CPL > 0.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while CPL = 3.;"
      ],
      "realAddressMode": [
        "column_1: #GP; column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.;"
      ],
      "virtual8086Mode": [
        "column_2: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; column_1: #GP(0); \ncolumn_1: If CR4.UMIP = 1.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/invd",
    "category": "Core Instructions",
    "instructionName": "INVD\n\t\t— Invalidate Internal Caches",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Flush internal caches; initiate flushing of external caches.",
        "Instruction": "INVD",
        "Op/En": "ZO",
        "column_1": "0F 08"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Invalidates (flushes) the processor’s internal caches and issues a special-function bus cycle that directs external caches to also flush themselves. Data held in internal caches is not written back to main memory.\nAfter executing this instruction, the processor does not wait for the external caches to complete their flushing operation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal.\nThe INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction.\nThe INVD instruction may be used when the cache is used as temporary memory and the cache contents need to be invalidated rather than written back to memory. When the cache is used as temporary memory, no external device should be actively writing data to main memory.\nUse this instruction with care. Data cached internally and not written back to main memory will be lost. Note that any data from an external device to main memory (for example, via a PCIWrite) can be temporarily stored in the caches; these data can be lost when an INVD instruction is executed. Unless there is a specific requirement or benefit to flushing caches without writing back modified cache lines (for example, temporary memory, testing, or fault recovery where cache coherency with main memory is not a concern), software should instead use the WBINVD instruction.\nOn processors that support processor reserved memory, the INVD instruction cannot be executed when processor reserved memory protections are activated. See Section 36.5, “EPC and Management of EPC Pages,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3D.\nSome processors prevent execution of INVD after BIOS execution is complete. They report this by enumerating CPUID.(EAX=07H,ECX=1H):EAX[bit 30] as 1. On such processors, INVD cannot be executed if bit 0 of SR_BIOS_DONE (MSR address 151H) is 1.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "Flush(InternalCaches);\nSignalFlush(ExternalCaches);\nContinue (* Continue execution *)",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If the processor reserved memory protections are activated.; \ncolumn_1: If CPUID.(EAX=07H, ECX=1H):EAX[30] = 1 and bit 0 is set in MSR_BIOS_DONE (MSR address 151H).; \ncolumn_2: If the LOCK prefix is used.; column_1: #UD;"
      ],
      "realAddressMode": [
        "column_1: If the processor reserved memory protections are activated.; \ncolumn_1: #UD; column_2: If the LOCK prefix is used.;"
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vmaxsh",
    "category": "Core Instructions",
    "instructionName": "VMAXSH\n\t\t— Return Maximum of Scalar FP16 Values",
    "detailsTable": [
      {
        "Description": "Return the maximum low FP16 value between xmm3/m16 and xmm2 and store the result in xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 5F /r VMAXSH xmm1{k1}{z}, xmm2, xmm3/m16 {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcomish",
    "category": "Core Instructions",
    "instructionName": "VCOMISH\n\t\t— Compare Scalar Ordered FP16 Values and Set EFLAGS",
    "detailsTable": [
      {
        "column_1": "VCOMISH xmm1, xmm2/m16 {sae}",
        "column_2": "",
        "column_3": "",
        "column_4": "",
        "column_5": "Compare low FP16 values in xmm1 and xmm2/m16, and set the EFLAGS flags accordingly."
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vgatherdpd:vgatherqpd",
    "category": "Core Instructions",
    "instructionName": "VGATHERDPD/VGATHERQPD\n\t\t— Gather Packed Double Precision Floating-Point Values UsingSigned Dword/Qword Indices",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using dword indices specified in vm32x, gather double precision floating-point values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 92 /r VGATHERDPD xmm1, vm32x, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using qword indices specified in vm64x, gather double precision floating-point values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.128.66.0F38.W1 93 /r VGATHERQPD xmm1, vm64x, xmm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using dword indices specified in vm32x, gather double precision floating-point values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 92 /r VGATHERDPD ymm1, vm32x, ymm2"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Using qword indices specified in vm64y, gather double precision floating-point values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.",
        "Op/En": "RMV",
        "Opcode/Instruction": "VEX.256.66.0F38.W1 93 /r VGATHERQPD ymm1, vm64y, ymm2"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RMV",
        "Operand 1": "ModRM:reg (r,w)",
        "Operand 2": "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
        "Operand 3": "VEX.vvvv (r, w)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "The instruction conditionally loads up to 2 or 4 double precision floating-point values from memory addresses specified by the memory operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.\nThe mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is specified by the most significant bit of each data element of the mask register. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.\nUsing dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 double precision floating-point values from the VSIB addressing memory operand, and updates the destination register.\nThis instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.\nIf the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.\nVEX.128 version: The instruction will gather two double precision floating-point values. For dword indices, only the lower two indices in the vector index register are used.\nVEX.256 version: The instruction will gather four double precision floating-point values. For dword indices, only the lower four indices in the vector index register are used.\nNote that:",
    "operationText": "DEST := SRC1;\nBASE_ADDR: base register encoded in VSIB addressing;\nVINDEX: the vector index register encoded by VSIB addressing;\nSCALE: scale factor encoded by SIB:[7:6];\nDISP: optional 1, 4 byte displacement;\nMASK := SRC3;\nMASK[MAXVL-1:128] := 0;\nFOR j := 0 to 1\n    i := j * 64;\n    IF MASK[63+i] THEN\n        MASK[i +63:i] := FFFFFFFF_FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +63:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 1\n    k := j * 32;\n    i := j * 64;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX[k+31:k])*SCALE + DISP;\n    IF MASK[63+i] THEN\n        DEST[i +63:i] := FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +63: i] := 0;\nENDFOR\nDEST[MAXVL-1:128] := 0;\nMASK[MAXVL-1:128] := 0;\nFOR j := 0 to 1\n    i := j * 64;\n    IF MASK[63+i] THEN\n        MASK[i +63:i] := FFFFFFFF_FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +63:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 1\n    i := j * 64;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[i+63:i])*SCALE + DISP;\n    IF MASK[63+i] THEN\n        DEST[i +63:i] := FETCH_64BITS(DATA_ADDR); // a fault exits this instruction\n    FI;\n    MASK[i +63: i] := 0;\nENDFOR\nDEST[MAXVL-1:128] := 0;\nMASK[MAXVL-1:256] := 0;\nFOR j := 0 to 3\n    i := j * 64;\n    IF MASK[63+i] THEN\n        MASK[i +63:i] := FFFFFFFF_FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +63:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 3\n    i := j * 64;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[i+63:i])*SCALE + DISP;\n    IF MASK[63+i] THEN\n        DEST[i +63:i] := FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +63: i] := 0;\nENDFOR\nDEST[MAXVL-1:256] := 0;\nMASK[MAXVL-1:256] := 0;\nFOR j := 0 to 3\n    i := j * 64;\n    IF MASK[63+i] THEN\n        MASK[i +63:i] := FFFFFFFF_FFFFFFFFH; // extend from most significant bit\n    ELSE\n        MASK[i +63:i] := 0;\n    FI;\nENDFOR\nFOR j := 0 to 3\n    k := j * 32;\n    i := j * 64;\n    DATA_ADDR := BASE_ADDR + (SignExtend(VINDEX1[k+31:k])*SCALE + DISP;\n    IF MASK[63+i] THEN\n        DEST[i +63:i] := FETCH_64BITS(DATA_ADDR); // a fault exits the instruction\n    FI;\n    MASK[i +63:i] := 0;\nENDFOR\nDEST[MAXVL-1:256] := 0;",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-27, “Type 12 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vfmaddsub132ps:vfmaddsub213ps:vfmaddsub231ps",
    "category": "Core Instructions",
    "instructionName": "VFMADDSUB132PS/VFMADDSUB213PS/VFMADDSUB231PS\n\t\t— Fused Multiply-AlternatingAdd/Subtract of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 96 /r VFMADDSUB132PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 A6 /r VFMADDSUB213PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 B6 /r VFMADDSUB231PS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 96 /r VFMADDSUB132PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 A6 /r VFMADDSUB213PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "FMA",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 B6 /r VFMADDSUB231PS ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 A6 /r VFMADDSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm2 and xmm3/m128/m32bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 B6 /r VFMADDSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from xmm1 and xmm3/m128/m32bcst, add/subtract elements in zmm2 and put result in xmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 96 /r VFMADDSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 A6 /r VFMADDSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm2 and ymm3/m256/m32bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 B6 /r VFMADDSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Multiply packed single precision floating-point values from ymm1 and ymm3/m256/m32bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 96 /r VFMADDSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm2, add/subtract elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 A6 /r VFMADDSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm2 and zmm3/m512/m32bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 B6 /r VFMADDSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Multiply packed single precision floating-point values from zmm1 and zmm3/m512/m32bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 96 /r VFMADDSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrcpsh",
    "category": "Core Instructions",
    "instructionName": "VRCPSH\n\t\t— Compute Reciprocal of Scalar FP16 Value",
    "detailsTable": [
      {
        "Description": "Compute the approximate reciprocal of the low FP16 value in xmm3/m16 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16].",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.66.MAP6.W0 4D /r VRCPSH xmm1{k1}{z}, xmm2, xmm3/m16",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/sfence",
    "category": "Core Instructions",
    "instructionName": "SFENCE\n\t\t— Store Fence",
    "detailsTable": [
      {
        "64-Bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Serializes store operations.",
        "Instruction": "SFENCE",
        "Op/En": "ZO",
        "Opcode*": "NP 0F AE F8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "ZO",
        "Operand 1": "N/A",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Orders processor execution relative to all memory stores prior to the SFENCE instruction. The processor ensures that every store prior to SFENCE is globally visible before any store after SFENCE becomes globally visible. The SFENCE instruction is ordered with respect to memory stores, other SFENCE instructions, MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to memory loads or the LFENCE instruction.\nWeakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The SFENCE instruction provides a performance-efficient way of ensuring store ordering between routines that produce weakly-ordered results and routines that consume this data.\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.\nSpecification of the instruction's opcode above indicates a ModR/M byte of F8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, SFENCE is encoded by any opcode of the form 0F AE Fx, where x is in the range 8-F.",
    "operationText": "Wait_On_Following_Stores_Until(preceding_stores_globally_visible);",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/psraw:psrad:psraq",
    "category": "Core Instructions",
    "instructionName": "PSRAW/PSRAD/PSRAQ\n\t\t— Shift Packed Data Right Arithmetic",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift words in mm right by mm/m64 while shifting in sign bits.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F E1 /r1 PSRAW mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F E1 /r PSRAW xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift words in mm right by imm8 while shifting in sign bits",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 71 /4 ib1 PSRAW mm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift words in xmm1 right by imm8 while shifting in sign bits",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 71 /4 ib PSRAW xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift doublewords in mm right by mm/m64 while shifting in sign bits.",
        "Op/En": "A",
        "Opcode/Instruction": "NP 0F E2 /r1 PSRAD mm, mm/m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F E2 /r PSRAD xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MMX",
        "Description": "Shift doublewords in mm right by imm8 while shifting in sign bits.",
        "Op/En": "B",
        "Opcode/Instruction": "NP 0F 72 /4 ib1 PSRAD mm, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shift doublewords in xmm1 right by imm8 while shifting in sign bits.",
        "Op/En": "B",
        "Opcode/Instruction": "66 0F 72 /4 ib PSRAD xmm1, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E1 /r VPSRAW xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift words in xmm2 right by imm8 while shifting in sign bits.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 71 /4 ib VPSRAW xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.128.66.0F.WIG E2 /r VPSRAD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shift doublewords in xmm2 right by imm8 while shifting in sign bits.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 72 /4 ib VPSRAD xmm1, xmm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E1 /r VPSRAW ymm1, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift words in ymm2 right by imm8 while shifting in sign bits.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 71 /4 ib VPSRAW ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.",
        "Op/En": "C",
        "Opcode/Instruction": "VEX.256.66.0F.WIG E2 /r VPSRAD ymm1, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 right by imm8 while shifting in sign bits.",
        "Op/En": "D",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 72 /4 ib VPSRAD ymm1, ymm2, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG E1 /r VPSRAW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG E1 /r VPSRAW ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG E1 /r VPSRAW zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2/m128 right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.128.66.0F.WIG 71 /4 ib VPSRAW xmm1 {k1}{z}, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2/m256 right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.256.66.0F.WIG 71 /4 ib VPSRAW ymm1 {k1}{z}, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2/m512 right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "E",
        "Opcode/Instruction": "EVEX.512.66.0F.WIG 71 /4 ib VPSRAW zmm1 {k1}{z}, zmm2/m512, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 E2 /r VPSRAD xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 E2 /r VPSRAD ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 E2 /r VPSRAD zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2/m128/m32bcst right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 72 /4 ib VPSRAD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2/m256/m32bcst right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 72 /4 ib VPSRAD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2/m512/m32bcst right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 72 /4 ib VPSRAD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 E2 /r VPSRAQ xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 E2 /r VPSRAQ ymm1 {k1}{z}, ymm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "G",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 E2 /r VPSRAQ zmm1 {k1}{z}, zmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2/m128/m64bcst right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 72 /4 ib VPSRAQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2/m256/m64bcst right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 72 /4 ib VPSRAQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2/m512/m64bcst right by imm8 while shifting in sign bits using writemask k1.",
        "Op/En": "F",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 72 /4 ib VPSRAQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:r/m (r, w)",
        "Operand 2": "imm8",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "D",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "E",
        "Operand 1": "EVEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "F",
        "Operand 1": "EVEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "G",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Mem128"
      }
    ],
    "descriptionText": "Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18 gives an example of shifting words in a 64-bit operand.)\nNote that only the first 64-bits of a 128-bit count operand are checked to compute the count. If the second source operand is a memory address, 128 bits are loaded.\nThe (V)PSRAW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand, and the (V)PSRAD instruction shifts each of the doublewords in the destination operand.\nIn 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\nLegacy SSE instructions 64-bit operand: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.\n128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.\nVEX.128 encoded version: The destination and first source operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.\nVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location. The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.\nEVEX encoded versions: The destination operand is a ZMM register updated according to the writemask. The count operand is either an 8-bit immediate (the immediate count version) or an 8-bit value from an XMM register or a memory location (the variable count version). For the immediate count version, the source operand (the second operand) can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. For the variable count version, the first source operand (the second operand) is a ZMM register, the second source operand (the third operand, 8-bit variable count) can be an XMM register or a memory location.\nNote: In VEX/EVEX encoded versions of shifts with an immediate count, vvvv of VEX/EVEX encode the destination register, and VEX.B/EVEX.B + ModRM.r/m encodes the source register.\nNote: For shifts with an immediate count (VEX.128.66.0F 71-73 /4, EVEX.128.66.0F 71-73 /4), VEX.vvvv/EVEX.vvvv encodes the destination register.",
    "operationText": "IF (COUNT > 15)\n        THEN COUNT := 16;\n    FI;\n    DEST[15:0] := SignExtend(DEST[15:0] >> COUNT);\n    (* Repeat shift operation for 2nd and 3rd words *)\n    DEST[63:48] := SignExtend(DEST[63:48] >> COUNT);\nPSRAD (with 64-bit operand)\n    IF (COUNT > 31)\n        THEN COUNT := 32;\n    FI;\n    DEST[31:0] := SignExtend(DEST[31:0] >> COUNT);\n    DEST[63:32] := SignExtend(DEST[63:32] >> COUNT);\nARITHMETIC_RIGHT_SHIFT_DWORDS1(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\nTHEN\n    DEST[31:0] := SignBit\nELSE\n    DEST[31:0] := SignExtend(SRC[31:0] >> COUNT);\nFI;\nARITHMETIC_RIGHT_SHIFT_QWORDS1(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 63)\nTHEN\n    DEST[63:0] := SignBit\nELSE\n    DEST[63:0] := SignExtend(SRC[63:0] >> COUNT);\nFI;\nARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 15)\n    THEN COUNT := 16;\nFI;\nDEST[15:0] := SignExtend(SRC[15:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 15th words *)\nDEST[255:240] := SignExtend(SRC[255:240] >> COUNT);\nARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\n    THEN COUNT := 32;\nFI;\nDEST[31:0] := SignExtend(SRC[31:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 7th words *)\nDEST[255:224] := SignExtend(SRC[255:224] >> COUNT);\nARITHMETIC_RIGHT_SHIFT_QWORDS(SRC, COUNT_SRC, VL) ; VL: 128b, 256b or 512b\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 63)\n    THEN COUNT := 64;\nFI;\nDEST[63:0] := SignExtend(SRC[63:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 7th words *)\nDEST[VL-1:VL-64] := SignExtend(SRC[VL-1:VL-64] >> COUNT);\nARITHMETIC_RIGHT_SHIFT_WORDS(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 15)\n    THEN COUNT := 16;\nFI;\nDEST[15:0] := SignExtend(SRC[15:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 7th words *)\nDEST[127:112] := SignExtend(SRC[127:112] >> COUNT);\nARITHMETIC_RIGHT_SHIFT_DWORDS(SRC, COUNT_SRC)\nCOUNT := COUNT_SRC[63:0];\nIF (COUNT > 31)\n    THEN COUNT := 32;\nFI;\nDEST[31:0] := SignExtend(SRC[31:0] >> COUNT);\n    (* Repeat shift operation for 2nd through 3rd words *)\nDEST[127:96] := SignExtend(SRC[127:96] >> COUNT);\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL = 128\n    TMP_DEST[127:0] := ARITHMETIC_RIGHT_SHIFT_WORDS_128b(SRC1[127:0], SRC2)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)\n    TMP_DEST[511:256] := ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1[511:256], SRC2)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (8, 128), (16, 256), (32, 512)\nIF VL = 128\n    TMP_DEST[127:0] := ARITHMETIC_RIGHT_SHIFT_WORDS_128b(SRC1[127:0], imm8)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], imm8)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], imm8)\n    TMP_DEST[511:256] := ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1[511:256], imm8)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 16\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+15:i] := TMP_DEST[i+15:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+15:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+15:i] = 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\nDEST[255:0] := ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1, imm8)\nDEST[MAXVL-1:256] := 0\nDEST[127:0] := ARITHMETIC_RIGHT_SHIFT_WORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := ARITHMETIC_RIGHT_SHIFT_WORDS(SRC1, imm8)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := ARITHMETIC_RIGHT_SHIFT_WORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := ARITHMETIC_RIGHT_SHIFT_WORDS(DEST, imm8)\nDEST[MAXVL-1:128] (Unmodified)\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC1 *is memory*)\n                THEN DEST[i+31:i] := ARITHMETIC_RIGHT_SHIFT_DWORDS1(SRC1[31:0], imm8)\n                ELSE DEST[i+31:i] := ARITHMETIC_RIGHT_SHIFT_DWORDS1(SRC1[i+31:i], imm8)\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF VL = 128\n    TMP_DEST[127:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS_128b(SRC1[127:0], SRC2)\nFI;\nIF VL = 256\n    TMP_DEST[255:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)\nFI;\nIF VL = 512\n    TMP_DEST[255:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)\n    TMP_DEST[511:256] := ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1[511:256], SRC2)\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                        ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                            ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\nDEST[255:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1, SRC2)\nDEST[MAXVL-1:256] := 0\nDEST[255:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1, imm8)\nDEST[MAXVL-1:256] := 0\nDEST[127:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS(SRC1, SRC2)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS(SRC1, imm8)\nDEST[MAXVL-1:128] := 0\nDEST[127:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS(DEST, SRC)\nDEST[MAXVL-1:128] (Unmodified)\nDEST[127:0] := ARITHMETIC_RIGHT_SHIFT_DWORDS(DEST, imm8)\nDEST[MAXVL-1:128] (Unmodified)\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask* THEN\n            IF (EVEX.b = 1) AND (SRC1 *is memory*)\n                THEN DEST[i+63:i] := ARITHMETIC_RIGHT_SHIFT_QWORDS1(SRC1[63:0], imm8)\n                ELSE DEST[i+63:i] := ARITHMETIC_RIGHT_SHIFT_QWORDS1(SRC1[i+63:i], imm8)\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nTMP_DEST[VL-1:0] := ARITHMETIC_RIGHT_SHIFT_QWORDS(SRC1[VL-1:0], SRC2, VL)\nFOR j := 0 TO 7\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := TMP_DEST[i+63:i]\n        ELSE\n            IF *merging-masking*\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE *zeroing-masking*\n                        ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "numeric¶": [
        "None."
      ],
      "other¶": null
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/rcpps",
    "category": "Core Instructions",
    "instructionName": "RCPPS\n\t\t— Compute Reciprocals of Packed Single Precision Floating-Point Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE",
        "Description": "Computes the approximate reciprocals of the packed single precision floating-point values in xmm2/m128 and stores the results in xmm1.",
        "Op/En": "RM",
        "Opcode*/Instruction": "NP 0F 53 /r RCPPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes the approximate reciprocals of packed single precision values in xmm2/mem and stores the results in xmm1.",
        "Op/En": "RM",
        "Opcode*/Instruction": "VEX.128.0F.WIG 53 /r VRCPPS xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Computes the approximate reciprocals of packed single precision values in ymm2/mem and stores the results in ymm1.",
        "Op/En": "RM",
        "Opcode*/Instruction": "VEX.256.0F.WIG 53 /r VRCPPS ymm1, ymm2/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a SIMD computation of the approximate reciprocals of the four packed single precision floating-point values in the source operand (second operand) stores the packed single precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD single precision floating-point operation.\nThe relative error for this approximation is:\n|Relative Error| ≤ 1.5 ∗ 2−12\nThe RCPPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results (see Section 4.9.1.5, “Numeric Underflow Exception (#U)” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1) are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B∗2125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.\nNote: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "DEST[31:0] := APPROXIMATE(1/SRC[31:0])\nDEST[63:32] := APPROXIMATE(1/SRC[63:32])\nDEST[95:64] := APPROXIMATE(1/SRC[95:64])\nDEST[127:96] := APPROXIMATE(1/SRC[127:96])\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := APPROXIMATE(1/SRC[31:0])\nDEST[63:32] := APPROXIMATE(1/SRC[63:32])\nDEST[95:64] := APPROXIMATE(1/SRC[95:64])\nDEST[127:96] := APPROXIMATE(1/SRC[127:96])\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := APPROXIMATE(1/SRC[31:0])\nDEST[63:32] := APPROXIMATE(1/SRC[63:32])\nDEST[95:64] := APPROXIMATE(1/SRC[95:64])\nDEST[127:96] := APPROXIMATE(1/SRC[127:96])\nDEST[159:128] := APPROXIMATE(1/SRC[159:128])\nDEST[191:160] := APPROXIMATE(1/SRC[191:160])\nDEST[223:192] := APPROXIMATE(1/SRC[223:192])\nDEST[255:224] := APPROXIMATE(1/SRC[255:224])",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions,” additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/movbe",
    "category": "Core Instructions",
    "instructionName": "MOVBE\n\t\t— Move Data After Swapping Bytes",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MOVBE",
        "Description": "Reverse byte order in m16 and move to r16.",
        "Op/En": "RM",
        "Opcode/Instruction": "0F 38 F0 /r MOVBE r16, m16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MOVBE",
        "Description": "Reverse byte order in m32 and move to r32.",
        "Op/En": "RM",
        "Opcode/Instruction": "0F 38 F0 /r MOVBE r32, m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MOVBE",
        "Description": "Reverse byte order in m64 and move to r64.",
        "Op/En": "RM",
        "Opcode/Instruction": "REX.W + 0F 38 F0 /r MOVBE r64, m64"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MOVBE",
        "Description": "Reverse byte order in r16 and move to m16.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F 38 F1 /r MOVBE m16, r16"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "MOVBE",
        "Description": "Reverse byte order in r32 and move to m32.",
        "Op/En": "MR",
        "Opcode/Instruction": "0F 38 F1 /r MOVBE m32, r32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MOVBE",
        "Description": "Reverse byte order in r64 and move to m64.",
        "Op/En": "MR",
        "Opcode/Instruction": "REX.W + 0F 38 F1 /r MOVBE m64, r64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "MR",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "ModRM:reg (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Performs a byte swap operation on the data copied from the second operand (source operand) and store the result in the first operand (destination operand). The source operand can be a general-purpose register, or memory location; the destination register can be a general-purpose register, or a memory location; however, both operands can not be registers, and only one operand can be a memory location. Both operands must be the same size, which can be a word, a doubleword or quadword.\nThe MOVBE instruction is provided for swapping the bytes on a read from memory or on a write to memory; thus providing support for converting little-endian values to big-endian format and vice versa.\nIn 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
    "operationText": "TEMP := SRC\nIF ( OperandSize = 16)\n    THEN\n        DEST[7:0] := TEMP[15:8];\n        DEST[15:8] := TEMP[7:0];\n    ELES IF ( OperandSize = 32)\n        DEST[7:0] := TEMP[31:24];\n        DEST[15:8] := TEMP[23:16];\n        DEST[23:16] := TEMP[15:8];\n        DEST[31:23] := TEMP[7:0];\n    ELSE IF ( OperandSize = 64)\n        DEST[7:0] := TEMP[63:56];\n        DEST[15:8] := TEMP[55:48];\n        DEST[23:16] := TEMP[47:40];\n        DEST[31:24] := TEMP[39:32];\n        DEST[39:32] := TEMP[31:24];\n        DEST[47:40] := TEMP[23:16];\n        DEST[55:48] := TEMP[15:8];\n        DEST[63:56] := TEMP[7:0];\nFI;",
    "flagsAffectedText": "None.",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If the stack address is in a non-canonical form.; \ncolumn_2: If a page fault occurs.; column_1: #PF(fault-code); \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_2: If CPUID.01H:ECX.MOVBE[bit 22] = 0.; column_1: #UD; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If REP (F3H) prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains a NULL segment selector.; \ncolumn_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.MOVBE[bit 22] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If REP (F3H) prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS; column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.MOVBE[bit 22] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If REP (F3H) prefix is used.;"
      ],
      "virtual8086Mode": [
        "column_1: #SS(0); column_2: If a memory operand effective address is outside the SS segment limit.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If CPUID.01H:ECX.MOVBE[bit 22] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If REP (F3H) prefix is used.; \ncolumn_1: If REPNE (F2H) prefix is used and CPUID.01H:ECX.SSE4_2[bit 20] = 0.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/edbgwr",
    "category": "SGX Instructions",
    "instructionName": "EDBGWR\n\t\t— Write to a Debug Enclave",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SGX1",
        "Description": "This leaf function writes a dword/quadword to a debug enclave.",
        "Op/En": "IR",
        "Opcode/Instruction": "EAX = 05H ENCLS[EDBGWR]"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "IR",
        "column_2": "EDBGWR (In)",
        "column_3": "Return error code (Out)",
        "column_4": "Data to be written to a debug enclave (In)",
        "column_5": "Address of Target memory in the EPC (In)"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/aesdec",
    "category": "Core Instructions",
    "instructionName": "AESDEC\n\t\t— Perform One Round of an AES Decryption Flow",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES",
        "Description": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 38 DE /r AESDEC xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AES AVX",
        "Description": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.128.66.0F38.WIG DE /r VAESDEC xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES",
        "Description": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.",
        "Op/En": "B",
        "Opcode/Instruction": "VEX.256.66.0F38.WIG DE /r VAESDEC ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512VL",
        "Description": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.WIG DE /r VAESDEC xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512VL",
        "Description": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.WIG DE /r VAESDEC ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "VAES AVX512F",
        "Description": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using four 128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.WIG DE /r VAESDEC zmm1, zmm2, zmm3/m512"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "N/A"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Full Mem"
      }
    ],
    "descriptionText": "This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\nUse the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDECLAST instruction.\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\nThe EVEX encoded form of this instruction does not support memory fault suppression.",
    "operationText": "STATE := SRC1;\nRoundKey := SRC2;\nSTATE := InvShiftRows( STATE );\nSTATE := InvSubBytes( STATE );\nSTATE := InvMixColumns( STATE );\nDEST[127:0] := STATE XOR RoundKey;\nDEST[MAXVL-1:128] (Unmodified)\n(KL,VL) = (1,128), (2,256)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := InvShiftRows( STATE )\n    STATE := InvSubBytes( STATE )\n    STATE := InvMixColumns( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n(KL,VL) = (1,128), (2,256), (4,512)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := InvShiftRows( STATE )\n    STATE := InvSubBytes( STATE )\n    STATE := InvMixColumns( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] :=0",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded: See Table 2-50, “Type E4NF Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vrsqrtph",
    "category": "Core Instructions",
    "instructionName": "VRSQRTPH\n\t\t— Compute Reciprocals of Square Roots of Packed FP16 Values",
    "detailsTable": [
      {
        "Description": "Compute the approximate reciprocals of the square roots of packed FP16 values in xmm2/m128/m16bcst and store the result in xmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.128.66.MAP6.W0 4E /r VRSQRTPH xmm1{k1}{z}, xmm2/m128/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Compute the approximate reciprocals of the square roots of packed FP16 values in ymm2/m256/m16bcst and store the result in ymm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.256.66.MAP6.W0 4E /r VRSQRTPH ymm1{k1}{z}, ymm2/m256/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16 AVX512VL"
      },
      {
        "Description": "Compute the approximate reciprocals of the square roots of packed FP16 values in zmm2/m512/m16bcst and store the result in zmm1 subject to writemask k1.",
        "Instruction En bit Mode Flag\nSupport  Instruction En bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.512.66.MAP6.W0 4E /r VRSQRTPH zmm1{k1}{z}, zmm2/m512/m16bcst",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/addsubps",
    "category": "Core Instructions",
    "instructionName": "ADDSUBPS\n\t\t— Packed Single Precision Floating-Point Add/Subtract",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "SSE3",
        "Description": "Add/subtract single precision floating-point values from xmm2/m128 to xmm1.",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F D0 /r ADDSUBPS xmm1, xmm2/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add/subtract single precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.128.F2.0F.WIG D0 /r VADDSUBPS xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Add / subtract single precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.",
        "Op/En": "RVM",
        "Opcode/Instruction": "VEX.256.F2.0F.WIG D0 /r VADDSUBPS ymm1, ymm2, ymm3/m256"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (r, w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      },
      {
        "Op/En": "RVM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Adds odd-numbered single precision floating-point values of the first source operand (second operand) with the corresponding single precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered single precision floating-point values from the second source operand from the corresponding single precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.\nIn 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).\n128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See Figure 3-4.\nVEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.\nVEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
    "operationText": "DEST[31:0] := DEST[31:0] - SRC[31:0]\nDEST[63:32] := DEST[63:32] + SRC[63:32]\nDEST[95:64] := DEST[95:64] - SRC[95:64]\nDEST[127:96] := DEST[127:96] + SRC[127:96]\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := SRC1[31:0] - SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] - SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := SRC1[31:0] - SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] - SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[159:128] := SRC1[159:128] - SRC2[159:128]\nDEST[191:160] := SRC1[191:160] + SRC2[191:160]\nDEST[223:192] := SRC1[223:192] - SRC2[223:192]\nDEST[255:224] := SRC1[255:224] + SRC2[255:224]",
    "flagsAffectedText": "",
    "exceptions": {
      "exceptions¶": [
        "When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."
      ],
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions.”"
      ],
      "simdFloating-Point¶": [
        "Overflow, Underflow, Invalid, Precision, Denormal."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/tzcnt",
    "category": "Core Instructions",
    "instructionName": "TZCNT\n\t\t— Count the Number of Trailing Zero Bits",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI1",
        "Description": "Count the number of trailing zero bits in r/m16, return result in r16.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F BC /r TZCNT r16, r/m16"
      },
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "BMI1",
        "Description": "Count the number of trailing zero bits in r/m32, return result in r32.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F BC /r TZCNT r32, r/m32"
      },
      {
        "64/32-bit Mode": "V/N.E.",
        "CPUID Feature Flag": "BMI1",
        "Description": "Count the number of trailing zero bits in r/m64, return result in r64.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 REX.W 0F BC /r TZCNT r64, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "TZCNT counts the number of trailing least significant zero bits in source operand (second operand) and returns the result in destination operand (first operand). TZCNT is an extension of the BSF instruction. The key difference between TZCNT and BSF instruction is that TZCNT provides operand size as output when source operand is zero while in the case of BSF instruction, if source operand is zero, the content of destination operand are undefined. On processors that do not support TZCNT, the instruction byte encoding is executed as BSF.",
    "operationText": "temp := 0\nDEST := 0\nDO WHILE ( (temp < OperandSize) and (SRC[ temp] = 0) )\n    temp := temp +1\n    DEST := DEST+ 1\nOD\nIF DEST = OperandSize\n    CF := 1\nELSE\n    CF := 0\nFI\nIF DEST = 0\n    ZF := 1\nELSE\n    ZF := 0\nFI",
    "flagsAffectedText": "ZF is set to 1 in case of zero output (least significant bit of the source is set), and to 0 otherwise, CF is set to 1 if the input was zero and cleared otherwise. OF, SF, PF, and AF flags are undefined.",
    "exceptions": {
      "64BitMode": [
        "column_1: #SS(0); column_2: If a memory address referencing the SS segment is in a non-canonical form.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If LOCK prefix is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in Protected Mode."
      ],
      "protectedMode": [
        "column_1: If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.; \ncolumn_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; column_1: #AC(0); \ncolumn_1: #UD; column_2: If LOCK prefix is used.;"
      ],
      "realAddressMode": [
        "column_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #UD; column_2: If LOCK prefix is used.;"
      ],
      "virtual8086Mode¶": [
        "column_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF; column_2: (fault-code) For a page fault.; \ncolumn_1: #AC(0); column_2: If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.; \ncolumn_1: #UD; column_2: If LOCK prefix is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/invept",
    "category": "VMX Instructions",
    "instructionName": "INVEPT\n\t\t— Invalidate Translations Derived from EPT",
    "detailsTable": [
      {
        "Description": "Invalidates EPT-derived entries in the TLBs and paging-structure caches (in 64-bit mode).",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 80 INVEPT r64, m128"
      },
      {
        "Description": "Invalidates EPT-derived entries in the TLBs and paging-structure caches (outside 64-bit mode).",
        "Op/En": "RM",
        "Opcode/Instruction": "66 0F 38 80 INVEPT r32, m128"
      }
    ],
    "operandEncodingTable": [
      {
        "column_1": "RM",
        "column_2": "ModRM:reg (r)",
        "column_3": "ModRM:r/m (r)",
        "column_4": "NA",
        "column_5": "NA"
      }
    ],
    "descriptionText": "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches that were derived from extended page tables (EPT). (See Chapter 29, “VMX Support for Address Translation.”) Invalidation is based on the INVEPT type specified in the register operand and the INVEPT descriptor specified in the memory operand.\nOutside IA-32e mode, the register operand is always 32 bits, regardless of the value of CS.D; in 64-bit mode, the register operand has 64 bits (the instruction cannot be executed in compatibility mode).\nThe INVEPT types supported by a logical processors are reported in the IA32_VMX_EPT_VPID_CAP MSR (see Appendix A, “VMX Capability Reporting Facility”). There are two INVEPT types currently defined:\nIf an unsupported INVEPT type is specified, the instruction fails.\nINVEPT invalidates all the specified mappings for the indicated EPTP(s) regardless of the VPID and PCID values with which those mappings may be associated.\nThe INVEPT descriptor comprises 128 bits and contains a 64-bit EPTP value in bits 63:0 (see Figure 31-1).",
    "operationText": "IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)\n    THEN #UD;\nELSIF in VMX non-root operation\n    THEN VM exit;\nELSIF CPL > 0\n    THEN #GP(0);\n    ELSE\n        INVEPT_TYPE := value of register operand;\n        IF IA32_VMX_EPT_VPID_CAP MSR indicates that processor does not support INVEPT_TYPE\n            THEN VMfail(Invalid operand to INVEPT/INVVPID);\n            ELSE // INVEPT_TYPE must be 1 or 2\n                INVEPT_DESC := value of memory operand;\n                EPTP := INVEPT_DESC[63:0];\n                CASE INVEPT_TYPE OF\n                    1:\n                                    // single-context invalidation\n                        IF VM entry with the “enable EPT“ VM execution control set to 1\n                        would fail due to the EPTP value\n                            THEN VMfail(Invalid operand to INVEPT/INVVPID);\n                            ELSE\n                                Invalidate mappings associated with EPTP[51:12];\n                                VMsucceed;\n                        FI;\n                        BREAK;\n                    2:\n                                    // global invalidation\n                        Invalidate mappings associated with all EPTPs;\n                        VMsucceed;\n                        BREAK;\n                ESAC;\n        FI;\nFI;",
    "flagsAffectedText": "See the operation section and Section 31.2.",
    "exceptions": {
      "64BitMode": [
        "column_1: If the memory operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory operand.; \ncolumn_1: #SS(0); column_2: If the memory operand is in the SS segment and the memory address is in a non-canonical form.; \ncolumn_1: #UD; column_2: If not in VMX operation.; \ncolumn_1: If the logical processor does not support EPT (IA32_VMX_PROCBASED_CTLS2[33]=0).; \ncolumn_1: If the logical processor supports EPT (IA32_VMX_PROCBASED_CTLS2[33]=1) but does not support the INVEPT instruction (IA32_VMX_EPT_VPID_CAP[20]=0).;"
      ],
      "compatibilityMode": [
        ""
      ],
      "protectedMode": [
        "column_1: If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.; \ncolumn_1: If the DS, ES, FS, or GS register contains an unusable segment.; \ncolumn_1: If the source operand is located in an execute-only code segment.; \ncolumn_1: #PF(fault-code); column_2: If a page fault occurs in accessing the memory operand.; \ncolumn_1: #SS(0); column_2: If the memory operand effective address is outside the SS segment limit.; \ncolumn_1: If the SS register contains an unusable segment.; \ncolumn_1: #UD; column_2: If not in VMX operation.; \ncolumn_1: If the logical processor does not support EPT (IA32_VMX_PROCBASED_CTLS2[33]=0).; \ncolumn_1: If the logical processor supports EPT (IA32_VMX_PROCBASED_CTLS2[33]=1) but does not support the INVEPT instruction (IA32_VMX_EPT_VPID_CAP[20]=0).;"
      ],
      "realAddressMode": [
        ""
      ],
      "virtual8086Mode": [
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/cvtpd2dq",
    "category": "Core Instructions",
    "instructionName": "CVTPD2DQ\n\t\t— Convert Packed Double Precision Floating-Point Values to Packed DoublewordIntegers",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Convert two packed double precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1.",
        "Op / En": "A",
        "Opcode Instruction": "F2 0F E6 /r CVTPD2DQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert two packed double precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1.",
        "Op / En": "A",
        "Opcode Instruction": "VEX.128.F2.0F.WIG E6 /r VCVTPD2DQ xmm1, xmm2/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Convert four packed double precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1.",
        "Op / En": "A",
        "Opcode Instruction": "VEX.256.F2.0F.WIG E6 /r VCVTPD2DQ xmm1, ymm2/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert two packed double precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode Instruction": "EVEX.128.F2.0F.W1 E6 /r VCVTPD2DQ xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Convert four packed double precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode Instruction": "EVEX.256.F2.0F.W1 E6 /r VCVTPD2DQ xmm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Convert eight packed double precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 subject to writemask k1.",
        "Op / En": "B",
        "Opcode Instruction": "EVEX.512.F2.0F.W1 E6 /r VCVTPD2DQ ymm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Converts packed double precision floating-point values in the source operand (second operand) to packed signed doubleword integers in the destination operand (first operand).\nWhen a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.\nEVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.\nVEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.\nVEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.\n128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.\nVEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
    "operationText": "(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    k := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] :=\n            Convert_Double_Precision_Floating_Point_To_Integer(SRC[k+63:k])\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE\n                        ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL/2] := 0\n(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    k := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+31:i] :=\n            Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0])\n                ELSE\n                    DEST[i+31:i] :=\n            Convert_Double_Precision_Floating_Point_To_Integer(SRC[k+63:k])\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL/2] := 0\nDEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[127:64])\nDEST[95:64] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[191:128])\nDEST[127:96] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[255:192)\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[127:64])\nDEST[MAXVL-1:64] := 0\nDEST[31:0] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[63:0])\nDEST[63:32] := Convert_Double_Precision_Floating_Point_To_Integer(SRC[127:64])\nDEST[127:64] := 0\nDEST[MAXVL-1:128] (unmodified)",
    "flagsAffectedText": "",
    "exceptions": {
      "other¶": [
        "See Table 2-19, “Type 2 Class Exception Conditions.”",
        "EVEX-encoded instructions, see Table 2-46, “Type E2 Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "Invalid, Precision."
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtsh2sd",
    "category": "Core Instructions",
    "instructionName": "VCVTSH2SD\n\t\t— Convert Low FP16 Value to an FP64 Value",
    "detailsTable": [
      {
        "Description": "Convert the low FP16 value in xmm3/m16 to an FP64 value and store the result in the low element of xmm1 subject to writemask k1. Bits 127:64 of xmm2 are copied to xmm1[127:64].",
        "Instruction En Bit Mode Flag\nSupport  Instruction En Bit Mode Flag\nSupport  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag  64/32 CPUID Feature Instruction En Bit Mode Flag  CPUID Feature Instruction En Bit Mode Flag  Op/ 64/32 CPUID Feature": "EVEX.LLIG.F3.MAP5.W0 5A /r VCVTSH2SD xmm1{k1}{z}, xmm2, xmm3/m16 {sae}",
        "Support": "V/V",
        "column_2": "A",
        "column_4": "AVX512-FP16"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple": "Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/loadiwkey",
    "category": "Core Instructions",
    "instructionName": "LOADIWKEY\n\t\t— Load Internal Wrapping Key With Key Locker",
    "detailsTable": [
      {
        "64/32-bit Mode": "V/V",
        "CPUID Feature Flag": "KL",
        "Description": "Load internal wrapping key from xmm1, xmm2, and XMM0.",
        "Op/En": "A",
        "Opcode/Instruction": "F3 0F 38 DC 11:rrr:bbb LOADIWKEY xmm1, xmm2, <EAX>, <XMM0>"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (r)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "Implicit EAX (r)",
        "Operand 4": "Implicit XMM0 (r)",
        "Tuple": "N/A"
      }
    ],
    "descriptionText": "The LOADIWKEY1 instruction writes the Key Locker internal wrapping key, which is called IWKey. This IWKey is used by the ENCODEKEY* instructions to wrap keys into handles. Conversely, the AESENC/DEC*KL instructions use IWKey to unwrap those keys from the handles and help verify the handle integrity. For security reasons, no instruction is designed to allow software to directly read the IWKey value.\nIWKey includes two cryptographic keys as well as metadata. The two cryptographic keys are loaded from register sources so that LOADIWKEY can be executed without the keys ever being in memory.\nThe key input operands are:\nThe implicit operand EAX specifies the KeySource and whether backing up the key is permitted:\n1. Further details on Key Locker and usage of this instruction can be found here:",
    "operationText": "IF CPL > 0\n                    // LOADKWKEY only allowed at ring 0 (supervisor mode)\n    THEN #GP (0); FI;\nIF EAX[4:1] > 1\n                    // Reserved KeySource encoding used\n    THEN #GP (0); FI;\nIF EAX[31:5] != 0\n                    // Reserved bit in EAX is set\n    THEN #GP (0); FI;\nIF EAX[0] AND (CPUID.19H.ECX[0] == 0)\n                        // NoBackup is not supported on this part\n    THEN #GP (0); FI;\nIF (EAX[4:1] == 1) AND (CPUID.19H.ECX[1] == 0)\n                        // KeySource of 1 is not supported on this part\n    THEN #GP (0); FI;\nIF (EAX[4:1] == 0) // KeySource of 0\n    THEN\n        IWKey.Encryption Key[127:0] := SRC2[127:0]:\n        IWKey.Encryption Key[255:128] := SRC1[127:0];\n        IWKey.IntegrityKey[127:0] := XMM0[127:0];\n        IWKey.NoBackup = EAX [0];\n        IWKey.KeySource = EAX [4:1];\n        RFLAGS.ZF := 0;\n    ELSE // KeySource of 1. See RDSEED definition for details of randomness\n        IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED hardware block was received\n            THEN\n                IWKey.Encryption Key[127:0] := SRC2[127:0] XOR HW_NRND_GEN.data[127:0];\n                IWKey.Encryption Key[255:128] := SRC1[127:0] XOR HW_NRND_GEN.data[255:128];\n                IWKey.IntegrityKey[127:0] := XMM0[127:0] XOR HW_NRND_GEN.data[383:256];\n                IWKey.NoBackup = EAX [0];\n                IWKey.KeySource = EAX [4:1];\n                RFLAGS.ZF := 0;\n            ELSE // Random data was not returned from RDSEED hardware block. IWKey was not loaded\n                RFLAGS.ZF := 1;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;",
    "flagsAffectedText": "ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to full-entropy random data not being received from RDSEED. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vpsravw:vpsravd:vpsravq",
    "category": "Core Instructions",
    "instructionName": "VPSRAVW/VPSRAVD/VPSRAVQ\n\t\t— Variable Bit Shift Right Arithmetic",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F38.W0 46 /r VPSRAVD xmm1, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F38.W0 46 /r VPSRAVD ymm1, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 11 /r VPSRAVW xmm1 {k1}{z}, xmm2, xmm3/m128"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512BW",
        "Description": "Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 11 /r VPSRAVW ymm1 {k1}{z}, ymm2, ymm3/m256"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512BW",
        "Description": "Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in sign bits using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 11 /r VPSRAVW zmm1 {k1}{z}, zmm2, zmm3/m512"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in sign bits using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 46 /r VPSRAVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in sign bits using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 46 /r VPSRAVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in sign bits using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 46 /r VPSRAVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in sign bits using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 46 /r VPSRAVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in sign bits using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 46 /r VPSRAVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in sign bits using writemask k1.",
        "Op/En": "C",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 46 /r VPSRAVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "VEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full Mem"
      },
      {
        "Op/En": "C",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vcvtuqq2pd",
    "category": "Core Instructions",
    "instructionName": "VCVTUQQ2PD\n\t\t— Convert Packed Unsigned Quadword Integers to Packed Double PrecisionFloating-Point Values",
    "detailsTable": [
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to two packed double precision floating-point values in xmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.128.F3.0F.W1 7A /r VCVTUQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512DQ",
        "Description": "Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed double precision floating-point values in ymm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.256.F3.0F.W1 7A /r VCVTUQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst"
      },
      {
        "64/32 Bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512DQ",
        "Description": "Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed double precision floating-point values in zmm1 with writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.512.F3.0F.W1 7A /r VCVTUQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vprold:vprolvd:vprolq:vprolvq",
    "category": "Core Instructions",
    "instructionName": "VPROLD/VPROLVD/VPROLQ/VPROLVQ\n\t\t— Bit Rotate Left",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate doublewords in xmm2 left by count in the corresponding element of xmm3/m128/m32bcst. Result written to xmm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W0 15 /r VPROLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate doublewords in xmm2/m128/m32bcst left by imm8. Result written to xmm1 using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 72 /1 ib VPROLD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate quadwords in xmm2 left by count in the corresponding element of xmm3/m128/m64bcst. Result written to xmm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F38.W1 15 /r VPROLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate quadwords in xmm2/m128/m64bcst left by imm8. Result written to xmm1 using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.128.66.0F.W1 72 /1 ib VPROLQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate doublewords in ymm2 left by count in the corresponding element of ymm3/m256/m32bcst. Result written to ymm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W0 15 /r VPROLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate doublewords in ymm2/m256/m32bcst left by imm8. Result written to ymm1 using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 72 /1 ib VPROLD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate quadwords in ymm2 left by count in the corresponding element of ymm3/m256/m64bcst. Result written to ymm1 under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F38.W1 15 /r VPROLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Rotate quadwords in ymm2/m256/m64bcst left by imm8. Result written to ymm1 using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.256.66.0F.W1 72 /1 ib VPROLQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rotate left of doublewords in zmm2 by count in the corresponding element of zmm3/m512/m32bcst. Result written to zmm1 using writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W0 15 /r VPROLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rotate left of doublewords in zmm3/m512/m32bcst by imm8. Result written to zmm1 using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 72 /1 ib VPROLD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rotate quadwords in zmm2 left by count in the corresponding element of zmm3/m512/m64bcst. Result written to zmm1under writemask k1.",
        "Op / En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F38.W1 15 /r VPROLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Rotate quadwords in zmm2/m512/m64bcst left by imm8. Result written to zmm1 using writemask k1.",
        "Op / En": "A",
        "Opcode/Instruction": "EVEX.512.66.0F.W1 72 /1 ib VPROLQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "VEX.vvvv (w)",
        "Operand 2": "ModRM:r/m (R)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/vscalefsd",
    "category": "Core Instructions",
    "instructionName": "VSCALEFSD\n\t\t— Scale Scalar Float64 Values With Float64 Values",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Scale the scalar double precision floating-point values in xmm2 using the value from xmm3/m64. Under writemask k1.",
        "Op/En": "A",
        "Opcode/Instruction": "EVEX.LLIG.66.0F38.W1 2D /r VSCALEFSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "EVEX.vvvv (r)",
        "Operand 3": "ModRM:r/m (r)",
        "Operand 4": "N/A",
        "Tuple Type": "Tuple1 Scalar"
      }
    ],
    "descriptionText": "",
    "operationText": "",
    "flagsAffectedText": "",
    "exceptions": {}
  },
  {
    "url": "https://www.felixcloutier.com/x86/clflushopt",
    "category": "Core Instructions",
    "instructionName": "CLFLUSHOPT\n\t\t— Flush Cache Line Optimized",
    "detailsTable": [
      {
        "64-bit Mode": "Valid",
        "Compat/Leg Mode": "Valid",
        "Description": "Flushes cache line containing m8.",
        "Op/En": "M",
        "Opcode / Instruction": "NFx 66 0F AE /7 CLFLUSHOPT m8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "M",
        "Operand 1": "ModRM:r/m (w)",
        "Operand 2": "N/A",
        "Operand 3": "N/A",
        "Operand 4": "N/A"
      }
    ],
    "descriptionText": "Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand. If that cache line contains modified data at any level of the cache hierarchy, that data is written back to memory. The source operand is a byte memory location.\nThe availability of CLFLUSHOPT is indicated by the presence of the CPUID feature flag CLFLUSHOPT (CPUID.(EAX=07H,ECX=0H):EBX[bit 23]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).\nThe memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references the cache line).\nExecutions of the CLFLUSHOPT instruction are ordered with respect to fence instructions and to locked read-modify-write instructions; they are also ordered with respect to older writes to the cache line being invalidated. They are not ordered with respect to other executions of CLFLUSHOPT, to executions of CLFLUSH and CLWB, or to younger writes to the cache line being invalidated. Software can use the SFENCE instruction to order an execution of CLFLUSHOPT relative to one of those operations.\nThe CLFLUSHOPT instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load (and in addition, a CLFLUSHOPT instruction is allowed to flush a linear address in an execute-only segment). Like a load, the CLFLUSHOPT instruction sets the A bit but not the D bit in the page tables.\nIn some implementations, the CLFLUSHOPT instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX). The CLFLUSHOPT instruction is not expected to be commonly used inside typical transactional regions. However, programmers must not rely on CLFLUSHOPT instruction to force a transactional abort, since whether they cause transactional abort is implementation dependent.\nCLFLUSHOPT operation is the same in non-64-bit modes and 64-bit mode.",
    "operationText": "Flush_Cache_Line_Optimized(SRC);",
    "flagsAffectedText": "",
    "exceptions": {
      "64BitMode": [
        "column_1: #GP(0); column_2: If the memory address is in a non-canonical form.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.(EAX=07H,ECX=0H):EBX.CLFLUSHOPT[bit 23] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If an instruction prefix F2H or F3H is used.;"
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #SS(0); column_2: For an illegal address in the SS segment.; \ncolumn_1: #PF(fault-code); column_2: For a page fault.; \ncolumn_1: #UD; column_2: If CPUID.(EAX=07H,ECX=0H):EBX.CLFLUSHOPT[bit 23] = 0.; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If an instruction prefix F2H or F3H is used.;"
      ],
      "realAddressMode": [
        "column_2: If CPUID.(EAX=07H,ECX=0H):EBX.CLFLUSHOPT[bit 23] = 0.; column_1: #UD; \ncolumn_1: If the LOCK prefix is used.; \ncolumn_1: If an instruction prefix F2H or F3H is used.;"
      ],
      "virtual8086Mode": [
        "Same exceptions as in real address mode.",
        ""
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/bndcu:bndcn",
    "category": "Core Instructions",
    "instructionName": "BNDCU/BNDCN\n\t\t— Check Upper Bound",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "N.E./V",
        "CPUID Feature Flag": "MPX",
        "Description": "Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form).",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 1A /r BNDCU bnd, r/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MPX",
        "Description": "Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form).",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 1A /r BNDCU bnd, r/m64"
      },
      {
        "64/32 bit Mode Support": "N.E./V",
        "CPUID Feature Flag": "MPX",
        "Description": "Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form).",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 1B /r BNDCN bnd, r/m32"
      },
      {
        "64/32 bit Mode Support": "V/N.E.",
        "CPUID Feature Flag": "MPX",
        "Description": "Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form).",
        "Op/En": "RM",
        "Opcode/Instruction": "F2 0F 1B /r BNDCN bnd, r/m64"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "RM",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "N/A"
      }
    ],
    "descriptionText": "Compare the address in the second operand with the upper bound in bnd. The second operand can be either a register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to 01H and signal a #BR exception.\nBNDCU perform 1’s complement operation on the upper bound of bnd first before proceeding with address comparison. BNDCN perform address comparison directly using the upper bound in bnd that is already reverted out of 1’s complement form.\nThis instruction does not cause any memory access, and does not read or write any flags.\nEffective address computation of m32/64 has identical behavior to LEA",
    "operationText": "IF reg > NOT(BND.UB) Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\nTEMP := LEA(mem);\nIF TEMP > NOT(BND.UB) Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\nIF reg > BND.UB Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\nTEMP := LEA(mem);\nIF TEMP > BND.UB Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;",
    "flagsAffectedText": "None",
    "exceptions": {
      "64BitMode": [
        "",
        "Same exceptions as in protected mode."
      ],
      "compatibilityMode": [
        "Same exceptions as in protected mode."
      ],
      "protectedMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 67H prefix is not used and CS.D=0.; \ncolumn_1: If 67H prefix is used and CS.D=1.;"
      ],
      "realAddressMode": [
        "column_1: #UD; column_2: If the LOCK prefix is used.; \ncolumn_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.;"
      ],
      "virtual8086Mode": [
        "column_2: If the LOCK prefix is used.; column_1: #UD; \ncolumn_1: If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.; \ncolumn_1: If 16-bit addressing is used.;"
      ]
    }
  },
  {
    "url": "https://www.felixcloutier.com/x86/pshufd",
    "category": "Core Instructions",
    "instructionName": "PSHUFD\n\t\t— Shuffle Packed Doublewords",
    "detailsTable": [
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "SSE2",
        "Description": "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "66 0F 70 /r ib PSHUFD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX",
        "Description": "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.128.66.0F.WIG 70 /r ib VPSHUFD xmm1, xmm2/m128, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX2",
        "Description": "Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.",
        "Op/En": "A",
        "Opcode/Instruction": "VEX.256.66.0F.WIG 70 /r ib VPSHUFD ymm1, ymm2/m256, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shuffle the doublewords in xmm2/m128/m32bcst based on the encoding in imm8 and store the result in xmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.128.66.0F.W0 70 /r ib VPSHUFD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512VL AVX512F",
        "Description": "Shuffle the doublewords in ymm2/m256/m32bcst based on the encoding in imm8 and store the result in ymm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.256.66.0F.W0 70 /r ib VPSHUFD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8"
      },
      {
        "64/32 bit Mode Support": "V/V",
        "CPUID Feature Flag": "AVX512F",
        "Description": "Shuffle the doublewords in zmm2/m512/m32bcst based on the encoding in imm8 and store the result in zmm1 using writemask k1.",
        "Op/En": "B",
        "Opcode/Instruction": "EVEX.512.66.0F.W0 70 /r ib VPSHUFD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8"
      }
    ],
    "operandEncodingTable": [
      {
        "Op/En": "A",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "N/A"
      },
      {
        "Op/En": "B",
        "Operand 1": "ModRM:reg (w)",
        "Operand 2": "ModRM:r/m (r)",
        "Operand 3": "imm8",
        "Operand 4": "N/A",
        "Tuple Type": "Full"
      }
    ],
    "descriptionText": "Copies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand). Figure 4-16 shows the operation of the 256-bit VPSHUFD instruction and the encoding of the order operand. Each 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and copy to the target element in the destination operand. For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high 128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand (see the field encoding in Figure 4-16) determines which doubleword element (from the respective 128-bit lane) of the source operand will be copied to doubleword 0 of the destination operand.\nFor 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.\n10B - X2 ORDER 11B - X7 7 6 5 4 3 2 1 0 Operand 11B - X3 Operand\nThe source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.\nIn 64-bit mode and not encoded in VEX/EVEX, using REX.R permits this instruction to access XMM8-XMM15.\n128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.\nVEX.128 encoded version: The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.\nVEX.256 encoded version: The source operand can be an YMM register or a 256-bit memory location. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. Bits (255-1:128) of the destination stores the shuffled results of the upper 16 bytes of the source operand using the immediate byte as the order operand.\nEVEX encoded version: The source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.\nEach 128-bit lane of the destination stores the shuffled results of the respective lane of the source operand using the immediate byte as the order operand.\nNote: EVEX.vvvv and VEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
    "operationText": "DEST[31:0] := (SRC >> (ORDER[1:0] * 32))[31:0];\nDEST[63:32] := (SRC >> (ORDER[3:2] * 32))[31:0];\nDEST[95:64] := (SRC >> (ORDER[5:4] * 32))[31:0];\nDEST[127:96] := (SRC >> (ORDER[7:6] * 32))[31:0];\nDEST[MAXVL-1:128] (Unmodified)\nDEST[31:0] := (SRC >> (ORDER[1:0] * 32))[31:0];\nDEST[63:32] := (SRC >> (ORDER[3:2] * 32))[31:0];\nDEST[95:64] := (SRC >> (ORDER[5:4] * 32))[31:0];\nDEST[127:96] := (SRC >> (ORDER[7:6] * 32))[31:0];\nDEST[MAXVL-1:128] := 0\nDEST[31:0] := (SRC[127:0] >> (ORDER[1:0] * 32))[31:0];\nDEST[63:32] := (SRC[127:0] >> (ORDER[3:2] * 32))[31:0];\nDEST[95:64] := (SRC[127:0] >> (ORDER[5:4] * 32))[31:0];\nDEST[127:96] := (SRC[127:0] >> (ORDER[7:6] * 32))[31:0];\nDEST[159:128] := (SRC[255:128] >> (ORDER[1:0] * 32))[31:0];\nDEST[191:160] := (SRC[255:128] >> (ORDER[3:2] * 32))[31:0];\nDEST[223:192] := (SRC[255:128] >> (ORDER[5:4] * 32))[31:0];\nDEST[255:224] := (SRC[255:128] >> (ORDER[7:6] * 32))[31:0];\nDEST[MAXVL-1:256] := 0\n(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF (EVEX.b = 1) AND (SRC *is memory*)\n        THEN TMP_SRC[i+31:i] := SRC[31:0]\n        ELSE TMP_SRC[i+31:i] := SRC[i+31:i]\n    FI;\nENDFOR;\nIF VL >= 128\n    TMP_DEST[31:0] := (TMP_SRC[127:0] >> (ORDER[1:0] * 32))[31:0];\n    TMP_DEST[63:32] := (TMP_SRC[127:0] >> (ORDER[3:2] * 32))[31:0];\n    TMP_DEST[95:64] := (TMP_SRC[127:0] >> (ORDER[5:4] * 32))[31:0];\n    TMP_DEST[127:96] := (TMP_SRC[127:0] >> (ORDER[7:6] * 32))[31:0];\nFI;\nIF VL >= 256\n    TMP_DEST[159:128] := (TMP_SRC[255:128]\n                        >> (ORDER[1:0] * 32))[31:0];\n    TMP_DEST[191:160] := (TMP_SRC[255:128]\n                        >> (ORDER[3:2] * 32))[31:0];\n    TMP_DEST[223:192] := (TMP_SRC[255:128]\n                        >> (ORDER[5:4] * 32))[31:0];\n    TMP_DEST[255:224] := (TMP_SRC[255:128]\n                        >> (ORDER[7:6] * 32))[31:0];\nFI;\nIF VL >= 512\n    TMP_DEST[287:256] := (TMP_SRC[383:256]\n                        >> (ORDER[1:0] * 32))[31:0];\n    TMP_DEST[319:288] := (TMP_SRC[383:256]\n                        >> (ORDER[3:2] * 32))[31:0];\n    TMP_DEST[351:320] := (TMP_SRC[383:256]\n                        >> (ORDER[5:4] * 32))[31:0];\n    TMP_DEST[383:352] := (TMP_SRC[383:256]\n                        >> (ORDER[7:6] * 32))[31:0];\n    TMP_DEST[415:384] := (TMP_SRC[511:384]\n                        >> (ORDER[1:0] * 32))[31:0];\n    TMP_DEST[447:416] := (TMP_SRC[511:384]\n                        >> (ORDER[3:2] * 32))[31:0];\n    TMP_DEST[479:448] := (TMP_SRC[511:384]\n                        >> (ORDER[5:4] * 32))[31:0];\n    TMP_DEST[511:480] := (TMP_SRC[511:384]\n                        >> (ORDER[7:6] * 32))[31:0];\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := TMP_DEST[i+31:i]\n        ELSE\n            IF *merging-masking*\n                            ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE *zeroing-masking*\n                                ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0",
    "flagsAffectedText": "None.",
    "exceptions": {
      "other¶": [
        "Non-EVEX-encoded instruction, see Table 2-21, “Type 4 Class Exception Conditions.”",
        "EVEX-encoded instruction, see Table 2-50, “Type E4NF Class Exception Conditions.”",
        "Additionally:",
        ""
      ],
      "simdFloating-Point¶": [
        "None."
      ]
    }
  }
]
